old_file path,new_file path,commit SHA,parent commit SHA,commit message,diff_myers,diff_hist,Discrepancy
,.gitignore,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,6 @@
+bin/*
+gin/*
+local.properties
+*.iml
+.idea/*
+proguard-project.txt
","1 bin/*
2 gin/*
3 local.properties
4 *.iml
5 .idea/*
6 proguard-project.txt",Yes
,AndroidManifest.xml,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,15 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<manifest xmlns:android=""http://schemas.android.com/apk/res/android""
+          package=""com.bumptech.photos""
+          android:versionCode=""1""
+          android:versionName=""1.0"">
+  <application android:label=""@string/app_name"">
+    <activity android:name=""ACTIVITY_ENTRY_NAME""
+              android:label=""@string/app_name"">
+      <intent-filter>
+        <action android:name=""android.intent.action.MAIN""/>
+        <category android:name=""android.intent.category.LAUNCHER""/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
3           package=""com.bumptech.photos""
4           android:versionCode=""1""
5           android:versionName=""1.0"">
6   <application android:label=""@string/app_name"">
7     <activity android:name=""ACTIVITY_ENTRY_NAME""
8               android:label=""@string/app_name"">
9       <intent-filter>
10         <action android:name=""android.intent.action.MAIN""/>
11         <category android:name=""android.intent.category.LAUNCHER""/>
12       </intent-filter>
13     </activity>
14   </application>
15 </manifest>",Yes
,ant.properties,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
","1 # This file is used to override default values used by the Ant build system.
2 #
3 # This file must be checked into Version Control Systems, as it is
4 # integral to the build system of your project.
5 
6 # This file is only used by the Ant script.
7 
8 # You can use this to override default values such as
9 #  'source.dir' for the location of your java source folder and
10 #  'out.dir' for the location of your output folder.
11 
12 # You can also use it define how the release builds are signed by declaring
13 # the following properties:
14 #  'key.store' for the location of your keystore and
15 #  'key.alias' for the name of the key to use.
16 # The password will be asked during the build when you use the 'release' target.
17 ",No
,build.xml,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,92 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project name=""photos"" default=""help"">
+
+  <!-- The local.properties file is created and updated by the 'android' tool.
+       It contains the path to the SDK. It should *NOT* be checked into
+       Version Control Systems. -->
+  <property file=""local.properties""/>
+
+  <!-- The ant.properties file can be created by you. It is only edited by the
+       'android' tool to add properties to it.
+       This is the place to change some Ant specific build properties.
+       Here are some properties you may want to change/update:
+
+       source.dir
+           The name of the source directory. Default is 'src'.
+       out.dir
+           The name of the output directory. Default is 'bin'.
+
+       For other overridable properties, look at the beginning of the rules
+       files in the SDK, at tools/ant/build.xml
+
+       Properties related to the SDK location or the project target should
+       be updated using the 'android' tool with the 'update' action.
+
+       This file is an integral part of the build system for your
+       application and should be checked into Version Control Systems.
+
+       -->
+  <property file=""ant.properties""/>
+
+  <!-- if sdk.dir was not set from one of the property file, then
+       get it from the ANDROID_HOME env var.
+       This must be done before we load project.properties since
+       the proguard config can use sdk.dir -->
+  <property environment=""env""/>
+  <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
+    <isset property=""env.ANDROID_HOME""/>
+  </condition>
+
+  <!-- The project.properties file is created and updated by the 'android'
+       tool, as well as ADT.
+
+       This contains project specific properties such as project target, and library
+       dependencies. Lower level build properties are stored in ant.properties
+       (or in .classpath for Eclipse projects).
+
+       This file is an integral part of the build system for your
+       application and should be checked into Version Control Systems. -->
+  <loadproperties srcFile=""project.properties""/>
+
+  <!-- quick check on sdk.dir -->
+  <fail
+    message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
+    unless=""sdk.dir""
+    />
+
+  <!--
+      Import per project custom build rules if present at the root of the project.
+      This is the place to put custom intermediary targets such as:
+          -pre-build
+          -pre-compile
+          -post-compile (This is typically used for code obfuscation.
+                         Compiled code location: ${out.classes.absolute.dir}
+                         If this is not done in place, override ${out.dex.input.absolute.dir})
+          -post-package
+          -post-build
+          -pre-clean
+  -->
+  <import file=""custom_rules.xml"" optional=""true""/>
+
+  <!-- Import the actual build file.
+
+       To customize existing targets, there are two options:
+       - Customize only one target:
+           - copy/paste the target into this file, *before* the
+             <import> task.
+           - customize it to your needs.
+       - Customize the whole content of build.xml
+           - copy/paste the content of the rules files (minus the top node)
+             into this file, replacing the <import> task.
+           - customize to your needs.
+
+       ***********************
+       ****** IMPORTANT ******
+       ***********************
+       In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+       in order to avoid having your file be overridden by tools such as ""android update project""
+  -->
+  <!-- version-tag: 1 -->
+  <import file=""${sdk.dir}/tools/ant/build.xml""/>
+
+</project>
","1 <?xml version=""1.0"" encoding=""UTF-8""?>
2 <project name=""photos"" default=""help"">
3 
4   <!-- The local.properties file is created and updated by the 'android' tool.
5        It contains the path to the SDK. It should *NOT* be checked into
6        Version Control Systems. -->
7   <property file=""local.properties""/>
8 
9   <!-- The ant.properties file can be created by you. It is only edited by the
10        'android' tool to add properties to it.
11        This is the place to change some Ant specific build properties.
12        Here are some properties you may want to change/update:
13 
14        source.dir
15            The name of the source directory. Default is 'src'.
16        out.dir
17            The name of the output directory. Default is 'bin'.
18 
19        For other overridable properties, look at the beginning of the rules
20        files in the SDK, at tools/ant/build.xml
21 
22        Properties related to the SDK location or the project target should
23        be updated using the 'android' tool with the 'update' action.
24 
25        This file is an integral part of the build system for your
26        application and should be checked into Version Control Systems.
27 
28        -->
29   <property file=""ant.properties""/>
30 
31   <!-- if sdk.dir was not set from one of the property file, then
32        get it from the ANDROID_HOME env var.
33        This must be done before we load project.properties since
34        the proguard config can use sdk.dir -->
35   <property environment=""env""/>
36   <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
37     <isset property=""env.ANDROID_HOME""/>
38   </condition>
39 
40   <!-- The project.properties file is created and updated by the 'android'
41        tool, as well as ADT.
42 
43        This contains project specific properties such as project target, and library
44        dependencies. Lower level build properties are stored in ant.properties
45        (or in .classpath for Eclipse projects).
46 
47        This file is an integral part of the build system for your
48        application and should be checked into Version Control Systems. -->
49   <loadproperties srcFile=""project.properties""/>
50 
51   <!-- quick check on sdk.dir -->
52   <fail
53     message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
54     unless=""sdk.dir""
55     />
56 
57   <!--
58       Import per project custom build rules if present at the root of the project.
59       This is the place to put custom intermediary targets such as:
60           -pre-build
61           -pre-compile
62           -post-compile (This is typically used for code obfuscation.
63                          Compiled code location: ${out.classes.absolute.dir}
64                          If this is not done in place, override ${out.dex.input.absolute.dir})
65           -post-package
66           -post-build
67           -pre-clean
68   -->
69   <import file=""custom_rules.xml"" optional=""true""/>
70 
71   <!-- Import the actual build file.
72 
73        To customize existing targets, there are two options:
74        - Customize only one target:
75            - copy/paste the target into this file, *before* the
76              <import> task.
77            - customize it to your needs.
78        - Customize the whole content of build.xml
79            - copy/paste the content of the rules files (minus the top node)
80              into this file, replacing the <import> task.
81            - customize to your needs.
82 
83        ***********************
84        ****** IMPORTANT ******
85        ***********************
86        In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
87        in order to avoid having your file be overridden by tools such as ""android update project""
88   -->
89   <!-- version-tag: 1 -->
90   <import file=""${sdk.dir}/tools/ant/build.xml""/>
91 
92 </project>",No
,project.properties,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# ""ant.properties"", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+android.library=true
+# Project target.
+target=android-10
","1 # This file is automatically generated by Android Tools.
2 # Do not modify this file -- YOUR CHANGES WILL BE ERASED!
3 #
4 # This file must be checked in Version Control Systems.
5 #
6 # To customize properties used by the Ant build system edit
7 # ""ant.properties"", and override values to adapt the script to your
8 # project structure.
9 #
10 # To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
11 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
12 
13 android.library=true
14 # Project target.
15 target=android-10",No
,res\layout\main.xml,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,13 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
+              android:orientation=""vertical""
+              android:layout_width=""fill_parent""
+              android:layout_height=""fill_parent""
+  >
+  <TextView
+    android:layout_width=""fill_parent""
+    android:layout_height=""wrap_content""
+    android:text=""Hello World, ACTIVITY_ENTRY_NAME""
+    />
+</LinearLayout>
+
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
3               android:orientation=""vertical""
4               android:layout_width=""fill_parent""
5               android:layout_height=""fill_parent""
6   >
7   <TextView
8     android:layout_width=""fill_parent""
9     android:layout_height=""wrap_content""
10     android:text=""Hello World, ACTIVITY_ENTRY_NAME""
11     />
12 </LinearLayout>
13 ",No
,res\values\strings.xml,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,,initial commit,"@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<resources>
+  <string name=""app_name"">ACTIVITY_ENTRY_NAME</string>
+</resources>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <string name=""app_name"">ACTIVITY_ENTRY_NAME</string>
4 </resources>",Yes
.gitignore,.gitignore,45bc62776a5312e0d5d40712e298247c9bdfed63,d4bacdf31b1ef95d1e192aa0aa3cf9651ed8f9d4,fix typo in .gitignore,"@@ -1,5 +1,5 @@
 bin/*
-gin/*
+gen/*
 local.properties
 *.iml
 .idea/*
","2 gen/*
2 gin/*",No
,.gitmodules,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,3 @@
+[submodule ""DiskLruCache""]
+	path = DiskLruCache
+	url = https://github.com/JakeWharton/DiskLruCache.git
","1 [submodule ""DiskLruCache""]
2 	path = DiskLruCache
3 	url = https://github.com/JakeWharton/DiskLruCache.git",Yes
,DiskLruCache,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1 @@
+Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc
",1 Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc,Yes
libs\android-support-v4.jar,libs\android-support-v4.jar,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"Binary files /dev/null and b/libs/android-support-v4.jar differ
",,No
,src\com\bumptech\photos\LoadedCallback.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: sam
+ * Date: 2/9/12
+ * Time: 7:04 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface LoadedCallback {
+    public void loadCompleted(Bitmap loaded);
+    public void onLoadFailed(Exception e);
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos;
6 
7 import android.graphics.Bitmap;
8 
9 /**
10  * Created by IntelliJ IDEA.
11  * User: sam
12  * Date: 2/9/12
13  * Time: 7:04 PM
14  * To change this template use File | Settings | File Templates.
15  */
16 public interface LoadedCallback {
17     public void loadCompleted(Bitmap loaded);
18     public void onLoadFailed(Exception e);
19 }",No
,src\com\bumptech\photos\PhotoManager.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos;
+
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.os.Handler;
+import com.bumptech.photos.cache.LruPhotoCache;
+import com.bumptech.photos.cache.PhotoDiskCache;
+import com.bumptech.photos.resize.PhotoStreamResizer;
+
+import java.io.File;
+import java.io.InputStream;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Future;
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: sam
+ * Date: 2/9/12
+ * Time: 5:02 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class PhotoManager {
+    private PhotoDiskCache diskCache;
+    private LruPhotoCache memoryCache;
+    private PhotoStreamResizer resizer;
+    private Map<Object, Future> taskManager = new HashMap<Object, Future>();
+    private Handler backgroundHandler;
+
+    public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
+        this.backgroundHandler = backgroundHandler;
+        if (Build.VERSION.SDK_INT < 11)
+            this.memoryCache = new LruPhotoCache(maxMemCacheSize);
+        this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
+        this.resizer = new PhotoStreamResizer(mainHandler, backgroundHandler);
+    }
+
+    public Object getImage(final String path, final LoadedCallback cb) {
+        return getImage(path, null, cb);
+    }
+
+    /**
+     * Loads the image for the given id
+     * @param path - the path id to the image
+     * @param recycled - a mutable bitmap of the same width and height as image at path to be reused
+     * @param cb - the callback called when the load completes
+     * @return A token tracking this request
+     */
+    public Object getImage(final String path, final Bitmap recycled, final LoadedCallback cb){
+        final Object token = cb;
+        final String key = getKey(path);
+        if (!returnFromCache(key, token, cb)) {
+            final Future task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
+            taskManager.put(token, task);
+        }
+        return token;
+    }
+
+    public Object getImage(String path, int width, int height, LoadedCallback cb) {
+        return getImage(path, width, height, null, cb);
+    }
+
+    /**
+     * Loads the image for the given id to nearly the given width and height maintaining the original proportions
+     * @param path - the id of the image
+     * @param width - the desired width in pixels
+     * @param height - the desired height of the slice
+     * @param recycled - a mutable bitmap of the same width and height to be reused
+     * @param cb - the callback called when the task finishes
+     * @return A token tracking this request
+     */
+    public Object getImage(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+        final Object token = cb;
+        final String key = getKey(path, width, height);
+        if (!returnFromCache(key, token, cb)) {
+            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+                @Override
+                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                    return resizer.loadApproximate(path, width, height, resizeCallback);
+                }
+            });
+        }
+        return token;
+    }
+
+
+    public Object centerSlice(String path, int width, int height, LoadedCallback cb) {
+        return centerSlice(path, width, height, null, cb);
+    }
+
+    /**
+     * Loads the image for the given id, resizes it to be exactly width pixels wide keeping proportions,
+     * and then returns a section from the center of image exactly height pixels tall
+     * @param path - the id of the image
+     * @param width - the desired width in pixels
+     * @param height - the desired height of the slice
+     * @param recycled - a mutable bitmap of the same width and height to be reused
+     * @param cb - the callback called when the task finishes
+     * @return A token tracking this request
+     */
+    public Object centerSlice(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+        final Object token = cb;
+        final String key = getKey(path, width, height);
+        if (!returnFromCache(key, token, cb)) {
+            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
+                @Override
+                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                    return resizer.resizeCenterCrop(path, width, height, resizeCallback);
+                }
+            });
+        }
+        return token;
+    }
+
+    public Object fitCenter(String path, int width, int height, LoadedCallback cb) {
+        return fitCenter(path, width, height, null, cb);
+    }
+
+    /**
+     * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
+     * an area of width*height.
+     * @param path - the id of the image
+     * @param width - the width of the space
+     * @param height - the height of the space
+     * @param recycled - a mutable bitmap of the same width and height to be reused
+     * @param cb - the callback called when the task finishes
+     * @return A token tracking this request
+     */
+    public Object fitCenter(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+        final Object token = cb;
+        final String key = getKey(path, width, height);
+        if (!returnFromCache(key, token, cb)) {
+            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+                @Override
+                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                    return resizer.fitInSpace(path, width, height, resizeCallback);
+                }
+            });
+        }
+        return token;
+    }
+
+    private boolean returnFromCache(String key, Object token, LoadedCallback cb) {
+        boolean found = false;
+        if (Build.VERSION.SDK_INT < 11) {
+            Bitmap inCache = memoryCache.get(key);
+            if (inCache != null) {
+                found = true;
+                cb.loadCompleted(inCache);
+            }
+        }
+        return found;
+    }
+
+    private abstract class DiskCacheCallback implements PhotoDiskCache.GetCallback {
+        private String key;
+        private Object token;
+        private Bitmap recycled;
+        private LoadedCallback cb;
+        private boolean useDiskCache;
+
+        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb, boolean useDiskCache) {
+            this.key = key;
+            this.token = token;
+            this.recycled = recycled;
+            this.cb = cb;
+            this.useDiskCache = useDiskCache;
+        }
+
+        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
+            this(key, token, recycled, cb, true);
+        }
+
+        @Override
+        public void onGet(InputStream is) {
+            final Future task;
+            final boolean inDiskCache = is != null;
+            final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, useDiskCache);
+            if (inDiskCache) {
+                task = resizer.loadAsIs(is, recycled, resizeCb);
+            } else {
+                task = resizeIfNotFound(resizeCb);
+            }
+            taskManager.put(token, task);
+        }
+
+        public abstract Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
+    }
+
+    private PhotoStreamResizer.ResizeCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache ) {
+        return new PhotoStreamResizer.ResizeCallback() {
+            @Override
+            public void onResizeComplete(Bitmap resized) {
+                if (Build.VERSION.SDK_INT < 11) {
+                    memoryCache.put(key, resized);
+                }
+                if (!inDiskCache && useDiskCache) {
+                    diskCache.put(key, resized);
+                }
+                taskManager.remove(token);
+                cb.loadCompleted(resized);
+            }
+
+            @Override
+            public void onResizeFailed(Exception e) {
+                cb.onLoadFailed(e);
+            }
+        };
+    }
+
+    public void cancelTask(Object token){
+        backgroundHandler.removeCallbacksAndMessages(token);
+        final Future task = taskManager.get(token);
+        if (task != null){
+            task.cancel(true);
+        }
+    }
+
+    private static String getKey(String path){
+        return getKey(path, 0, 0);
+    }
+
+    private static String getKey(String path, int width, int height){
+        return sha1Hash(path) + ""_"" + String.valueOf(width) + ""_"" + String.valueOf(height);
+    }
+
+    private static String sha1Hash(String toHash) {
+        String hash = null;
+        try {
+            byte[] bytes = toHash.getBytes();
+            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
+            digest.update(bytes, 0, bytes.length);
+            hash = new BigInteger(1, digest.digest()).toString(16);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        return hash;
+    }
+
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos;
6 
7 import android.graphics.Bitmap;
8 import android.os.Build;
9 import android.os.Handler;
10 import com.bumptech.photos.cache.LruPhotoCache;
11 import com.bumptech.photos.cache.PhotoDiskCache;
12 import com.bumptech.photos.resize.PhotoStreamResizer;
13 
14 import java.io.File;
15 import java.io.InputStream;
16 import java.math.BigInteger;
17 import java.security.MessageDigest;
18 import java.security.NoSuchAlgorithmException;
19 import java.util.HashMap;
20 import java.util.Map;
21 import java.util.concurrent.Future;
22 
23 /**
24  * Created by IntelliJ IDEA.
25  * User: sam
26  * Date: 2/9/12
27  * Time: 5:02 PM
28  * To change this template use File | Settings | File Templates.
29  */
30 public class PhotoManager {
31     private PhotoDiskCache diskCache;
32     private LruPhotoCache memoryCache;
33     private PhotoStreamResizer resizer;
34     private Map<Object, Future> taskManager = new HashMap<Object, Future>();
35     private Handler backgroundHandler;
36 
37     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
38         this.backgroundHandler = backgroundHandler;
39         if (Build.VERSION.SDK_INT < 11)
40             this.memoryCache = new LruPhotoCache(maxMemCacheSize);
41         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
42         this.resizer = new PhotoStreamResizer(mainHandler, backgroundHandler);
43     }
44 
45     public Object getImage(final String path, final LoadedCallback cb) {
46         return getImage(path, null, cb);
47     }
48 
49     /**
50      * Loads the image for the given id
51      * @param path - the path id to the image
52      * @param recycled - a mutable bitmap of the same width and height as image at path to be reused
53      * @param cb - the callback called when the load completes
54      * @return A token tracking this request
55      */
56     public Object getImage(final String path, final Bitmap recycled, final LoadedCallback cb){
57         final Object token = cb;
58         final String key = getKey(path);
59         if (!returnFromCache(key, token, cb)) {
60             final Future task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
61             taskManager.put(token, task);
62         }
63         return token;
64     }
65 
66     public Object getImage(String path, int width, int height, LoadedCallback cb) {
67         return getImage(path, width, height, null, cb);
68     }
69 
70     /**
71      * Loads the image for the given id to nearly the given width and height maintaining the original proportions
72      * @param path - the id of the image
73      * @param width - the desired width in pixels
74      * @param height - the desired height of the slice
75      * @param recycled - a mutable bitmap of the same width and height to be reused
76      * @param cb - the callback called when the task finishes
77      * @return A token tracking this request
78      */
79     public Object getImage(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
80         final Object token = cb;
81         final String key = getKey(path, width, height);
82         if (!returnFromCache(key, token, cb)) {
83             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
84                 @Override
85                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
86                     return resizer.loadApproximate(path, width, height, resizeCallback);
87                 }
88             });
89         }
90         return token;
91     }
92 
93 
94     public Object centerSlice(String path, int width, int height, LoadedCallback cb) {
95         return centerSlice(path, width, height, null, cb);
96     }
97 
98     /**
99      * Loads the image for the given id, resizes it to be exactly width pixels wide keeping proportions,
100      * and then returns a section from the center of image exactly height pixels tall
101      * @param path - the id of the image
102      * @param width - the desired width in pixels
103      * @param height - the desired height of the slice
104      * @param recycled - a mutable bitmap of the same width and height to be reused
105      * @param cb - the callback called when the task finishes
106      * @return A token tracking this request
107      */
108     public Object centerSlice(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
109         final Object token = cb;
110         final String key = getKey(path, width, height);
111         if (!returnFromCache(key, token, cb)) {
112             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
113                 @Override
114                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
115                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
116                 }
117             });
118         }
119         return token;
120     }
121 
122     public Object fitCenter(String path, int width, int height, LoadedCallback cb) {
123         return fitCenter(path, width, height, null, cb);
124     }
125 
126     /**
127      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
128      * an area of width*height.
129      * @param path - the id of the image
130      * @param width - the width of the space
131      * @param height - the height of the space
132      * @param recycled - a mutable bitmap of the same width and height to be reused
133      * @param cb - the callback called when the task finishes
134      * @return A token tracking this request
135      */
136     public Object fitCenter(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
137         final Object token = cb;
138         final String key = getKey(path, width, height);
139         if (!returnFromCache(key, token, cb)) {
140             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
141                 @Override
142                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
143                     return resizer.fitInSpace(path, width, height, resizeCallback);
144                 }
145             });
146         }
147         return token;
148     }
149 
150     private boolean returnFromCache(String key, Object token, LoadedCallback cb) {
151         boolean found = false;
152         if (Build.VERSION.SDK_INT < 11) {
153             Bitmap inCache = memoryCache.get(key);
154             if (inCache != null) {
155                 found = true;
156                 cb.loadCompleted(inCache);
157             }
158         }
159         return found;
160     }
161 
162     private abstract class DiskCacheCallback implements PhotoDiskCache.GetCallback {
163         private String key;
164         private Object token;
165         private Bitmap recycled;
166         private LoadedCallback cb;
167         private boolean useDiskCache;
168 
169         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb, boolean useDiskCache) {
170             this.key = key;
171             this.token = token;
172             this.recycled = recycled;
173             this.cb = cb;
174             this.useDiskCache = useDiskCache;
175         }
176 
177         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
178             this(key, token, recycled, cb, true);
179         }
180 
181         @Override
182         public void onGet(InputStream is) {
183             final Future task;
184             final boolean inDiskCache = is != null;
185             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, useDiskCache);
186             if (inDiskCache) {
187                 task = resizer.loadAsIs(is, recycled, resizeCb);
188             } else {
189                 task = resizeIfNotFound(resizeCb);
190             }
191             taskManager.put(token, task);
192         }
193 
194         public abstract Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
195     }
196 
197     private PhotoStreamResizer.ResizeCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache ) {
198         return new PhotoStreamResizer.ResizeCallback() {
199             @Override
200             public void onResizeComplete(Bitmap resized) {
201                 if (Build.VERSION.SDK_INT < 11) {
202                     memoryCache.put(key, resized);
203                 }
204                 if (!inDiskCache && useDiskCache) {
205                     diskCache.put(key, resized);
206                 }
207                 taskManager.remove(token);
208                 cb.loadCompleted(resized);
209             }
210 
211             @Override
212             public void onResizeFailed(Exception e) {
213                 cb.onLoadFailed(e);
214             }
215         };
216     }
217 
218     public void cancelTask(Object token){
219         backgroundHandler.removeCallbacksAndMessages(token);
220         final Future task = taskManager.get(token);
221         if (task != null){
222             task.cancel(true);
223         }
224     }
225 
226     private static String getKey(String path){
227         return getKey(path, 0, 0);
228     }
229 
230     private static String getKey(String path, int width, int height){
231         return sha1Hash(path) + ""_"" + String.valueOf(width) + ""_"" + String.valueOf(height);
232     }
233 
234     private static String sha1Hash(String toHash) {
235         String hash = null;
236         try {
237             byte[] bytes = toHash.getBytes();
238             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
239             digest.update(bytes, 0, bytes.length);
240             hash = new BigInteger(1, digest.digest()).toString(16);
241         } catch (NoSuchAlgorithmException e) {
242             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
243         }
244         return hash;
245     }
246 
247 }",No
,src\com\bumptech\photos\cache\LruPhotoCache.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.cache;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.v4.util.LruCache;
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: sam
+ * Date: 2/9/12
+ * Time: 5:57 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class LruPhotoCache{
+    private static final float SIZE_RATIO = 1f/8f;
+    private final PhotoCache photoCache;
+
+    /*
+    Can only call after context is created (ie in onCreate or later...)
+    */
+    public static int getMaxCacheSize(Context context){
+        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
+    }
+
+    private class PhotoCache extends LruCache<String, Bitmap> {
+
+        private PhotoCache(int maxSize) {
+            super(maxSize);
+        }
+
+
+        @Override
+        protected int sizeOf(String key, Bitmap value) {
+            //get the size, getByteCount() is API 12+...
+            return value.getHeight() * value.getRowBytes();
+        }
+    }
+
+    public LruPhotoCache(int size) {
+        photoCache = new PhotoCache(size);
+    }
+
+    public void put(String key, Bitmap bitmap) {
+        photoCache.put(key, bitmap);
+    }
+
+    public Bitmap get(String key) {
+        return photoCache.get(key);
+    }
+
+    public void remove(String key){
+        photoCache.remove(key);
+    }
+
+    public void evictAll(){
+        photoCache.evictAll();
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.cache;
6 
7 import android.app.ActivityManager;
8 import android.content.Context;
9 import android.graphics.Bitmap;
10 import android.support.v4.util.LruCache;
11 
12 /**
13  * Created by IntelliJ IDEA.
14  * User: sam
15  * Date: 2/9/12
16  * Time: 5:57 PM
17  * To change this template use File | Settings | File Templates.
18  */
19 public class LruPhotoCache{
20     private static final float SIZE_RATIO = 1f/8f;
21     private final PhotoCache photoCache;
22 
23     /*
24     Can only call after context is created (ie in onCreate or later...)
25     */
26     public static int getMaxCacheSize(Context context){
27         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
28         return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
29     }
30 
31     private class PhotoCache extends LruCache<String, Bitmap> {
32 
33         private PhotoCache(int maxSize) {
34             super(maxSize);
35         }
36 
37 
38         @Override
39         protected int sizeOf(String key, Bitmap value) {
40             //get the size, getByteCount() is API 12+...
41             return value.getHeight() * value.getRowBytes();
42         }
43     }
44 
45     public LruPhotoCache(int size) {
46         photoCache = new PhotoCache(size);
47     }
48 
49     public void put(String key, Bitmap bitmap) {
50         photoCache.put(key, bitmap);
51     }
52 
53     public Bitmap get(String key) {
54         return photoCache.get(key);
55     }
56 
57     public void remove(String key){
58         photoCache.remove(key);
59     }
60 
61     public void evictAll(){
62         photoCache.evictAll();
63     }
64 }",No
,src\com\bumptech\photos\cache\PhotoDiskCache.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,122 @@
+package com.bumptech.photos.cache;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import com.bumptech.photos.util.Log;
+import com.jakewharton.DiskLruCache;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: sam
+ * Date: 10/20/12
+ * Time: 1:25 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class PhotoDiskCache {
+    private static int APP_VERSION = 0;
+    private static int VALUE_COUNT = 1; //values per cache entry
+    private DiskLruCache cache;
+    private Handler mainHandler;
+    private Handler getHandler;
+    private Handler putHandler;
+
+    public interface GetCallback {
+        public void onGet(InputStream is);
+    };
+
+    public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
+        try {
+            cache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
+        } catch (IOException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        this.putHandler = loadHandler;
+        this.mainHandler = mainHandler;
+        this.getHandler = loadHandler;
+    }
+
+    public void put(final String key, final Bitmap bitmap) {
+        if (bitmap == null) return;
+
+        Log.d(""DLRU: doPut key="" + key);
+        putHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                Log.d(""DLRU: run put key="" + key);
+                DiskLruCache.Editor edit = null;
+                OutputStream out = null;
+                try {
+                    DiskLruCache.Snapshot snapshot = cache.get(key);
+                    if (snapshot != null) {
+                        Log.d(""DLRU: not putting, already exists key="" + key);
+                        return;
+                    }
+                    edit = cache.edit(key);
+                    out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
+                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
+                    edit.commit();
+                } catch (IOException e) {
+                    if (edit != null) {
+                        try {
+                            edit.abort();
+                        } catch (IOException e1) {
+                            e1.printStackTrace();
+                        }
+                    }
+                    e.printStackTrace();
+                } finally {
+                    if (out != null) {
+                        try {
+                            out.close();
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                    }
+
+                }
+            }
+        });
+    }
+
+    public void get(final String key, final GetCallback cb) {
+        Log.d(""DLRU: get key="" + key);
+        getHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                InputStream result = null;
+                try {
+                    DiskLruCache.Snapshot snapshot = cache.get(key);
+
+                    if (snapshot != null) {
+                        result = snapshot.getInputStream(VALUE_COUNT - 1);
+                    } else {
+                        Log.d(""DLRU: not found key="" + key);
+                    }
+                } catch (IOException e) {
+                    Log.d(""DLRU: IOException? key="" + key);
+                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                    try {
+                        cache.remove(key);
+                    } catch (IOException e1) {
+                        Log.d(""DLRU: error removing bitmap key="" + key);
+                        e1.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                    }
+                }
+
+                final InputStream finalResult = result;
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        cb.onGet(finalResult);
+                    }
+                });
+            }
+        });
+    }
+}
","1 package com.bumptech.photos.cache;
2 
3 import android.graphics.Bitmap;
4 import android.os.Handler;
5 import com.bumptech.photos.util.Log;
6 import com.jakewharton.DiskLruCache;
7 
8 import java.io.BufferedOutputStream;
9 import java.io.File;
10 import java.io.IOException;
11 import java.io.InputStream;
12 import java.io.OutputStream;
13 
14 /**
15  * Created by IntelliJ IDEA.
16  * User: sam
17  * Date: 10/20/12
18  * Time: 1:25 PM
19  * To change this template use File | Settings | File Templates.
20  */
21 public class PhotoDiskCache {
22     private static int APP_VERSION = 0;
23     private static int VALUE_COUNT = 1; //values per cache entry
24     private DiskLruCache cache;
25     private Handler mainHandler;
26     private Handler getHandler;
27     private Handler putHandler;
28 
29     public interface GetCallback {
30         public void onGet(InputStream is);
31     };
32 
33     public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
34         try {
35             cache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
36         } catch (IOException e) {
37             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
38         }
39         this.putHandler = loadHandler;
40         this.mainHandler = mainHandler;
41         this.getHandler = loadHandler;
42     }
43 
44     public void put(final String key, final Bitmap bitmap) {
45         if (bitmap == null) return;
46 
47         Log.d(""DLRU: doPut key="" + key);
48         putHandler.post(new Runnable() {
49             @Override
50             public void run() {
51                 Log.d(""DLRU: run put key="" + key);
52                 DiskLruCache.Editor edit = null;
53                 OutputStream out = null;
54                 try {
55                     DiskLruCache.Snapshot snapshot = cache.get(key);
56                     if (snapshot != null) {
57                         Log.d(""DLRU: not putting, already exists key="" + key);
58                         return;
59                     }
60                     edit = cache.edit(key);
61                     out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
62                     bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
63                     edit.commit();
64                 } catch (IOException e) {
65                     if (edit != null) {
66                         try {
67                             edit.abort();
68                         } catch (IOException e1) {
69                             e1.printStackTrace();
70                         }
71                     }
72                     e.printStackTrace();
73                 } finally {
74                     if (out != null) {
75                         try {
76                             out.close();
77                         } catch (IOException e) {
78                             e.printStackTrace();
79                         }
80                     }
81 
82                 }
83             }
84         });
85     }
86 
87     public void get(final String key, final GetCallback cb) {
88         Log.d(""DLRU: get key="" + key);
89         getHandler.post(new Runnable() {
90             @Override
91             public void run() {
92                 InputStream result = null;
93                 try {
94                     DiskLruCache.Snapshot snapshot = cache.get(key);
95 
96                     if (snapshot != null) {
97                         result = snapshot.getInputStream(VALUE_COUNT - 1);
98                     } else {
99                         Log.d(""DLRU: not found key="" + key);
100                     }
101                 } catch (IOException e) {
102                     Log.d(""DLRU: IOException? key="" + key);
103                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
104                     try {
105                         cache.remove(key);
106                     } catch (IOException e1) {
107                         Log.d(""DLRU: error removing bitmap key="" + key);
108                         e1.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
109                     }
110                 }
111 
112                 final InputStream finalResult = result;
113                 mainHandler.post(new Runnable() {
114                     @Override
115                     public void run() {
116                         cb.onGet(finalResult);
117                     }
118                 });
119             }
120         });
121     }
122 }",No
,src\com\bumptech\photos\resize\PhotoStreamResizer.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
+ */
+package com.bumptech.photos.resize;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.os.Handler;
+
+import java.io.InputStream;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+
+/**
+ * @author sam
+ *
+ */
+public class PhotoStreamResizer {
+
+    private final Handler loadHandler;
+    private Handler mainHandler;
+
+    public interface ResizeCallback {
+        void onResizeComplete(Bitmap resized);
+        void onResizeFailed(Exception e);
+    }
+
+    public PhotoStreamResizer(Handler mainHandler, Handler loadHandler){
+        this.mainHandler = mainHandler;
+        this.loadHandler = loadHandler;
+    }
+
+    public Future<Bitmap> resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
+        Callable<Bitmap> task = new Callable<Bitmap>(){
+            @Override
+            public Bitmap call() throws Exception {
+                Bitmap result = null, streamed = null;
+                streamed = Utils.streamIn(path, width, height);
+
+                if (streamed.getWidth() == width && streamed.getHeight() == height) {
+                    return streamed;
+                }
+
+                //from ImageView/Bitmap.createScaledBitmap
+                //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
+                //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
+                final float scale;
+                float dx = 0, dy = 0;
+                Matrix m = new Matrix();
+                if (streamed.getWidth() * height > width * streamed.getHeight()) {
+                    scale = (float) height / (float) streamed.getHeight();
+                    dx = (width - streamed.getWidth() * scale) * 0.5f;
+                } else {
+                    scale = (float) width / (float) streamed.getWidth();
+                    dy = (height - streamed.getHeight() * scale) * 0.5f;
+                }
+
+                m.setScale(scale, scale);
+                m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
+                Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());
+                Canvas canvas = new Canvas(bitmap);
+                Paint paint = new Paint();
+                //only if scaling up
+                paint.setFilterBitmap(false);
+                paint.setAntiAlias(true);
+                canvas.drawBitmap(streamed, m, paint);
+                result = bitmap;
+
+                return result;
+            }
+        };
+        return startTask(task, callback);
+    }
+
+    public Future<Bitmap> fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
+        Callable<Bitmap> task = new Callable<Bitmap>() {
+            @Override
+            public Bitmap call() throws Exception {
+                final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
+                return Utils.fitInSpace(streamed, width, height);
+            }
+        };
+        return startTask(task, callback);
+    }
+
+    public Future<Bitmap> loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
+        Callable<Bitmap> task = new Callable<Bitmap>() {
+            @Override
+            public Bitmap call() throws Exception {
+                return Utils.streamIn(path, width, height);
+            }
+        };
+        return startTask(task, callback);
+    }
+
+    public Future<Bitmap> loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
+        Callable<Bitmap> task = new Callable<Bitmap>() {
+            @Override
+            public Bitmap call() throws Exception {
+                return Utils.load(is, recycle);
+            }
+        };
+        return startTask(task, callback);
+    }
+
+    public Future<Bitmap> loadAsIs(String path, ResizeCallback callback){
+        return loadAsIs(path, null, callback);
+    }
+
+    public Future<Bitmap> loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
+        Callable<Bitmap> task  = new Callable<Bitmap>() {
+            @Override
+            public Bitmap call() throws Exception {
+                return Utils.load(path, recycled);
+            }
+        };
+        return startTask(task, callback);
+    }
+
+    private Future<Bitmap> startTask(Callable<Bitmap> task, ResizeCallback callback){
+        StreamResizeFuture future = new StreamResizeFuture(task, mainHandler, callback);
+        loadHandler.post(future);
+        return future;
+    }
+
+    private static class StreamResizeFuture extends FutureTask<Bitmap> {
+        private final Handler mainHandler;
+        private final ResizeCallback callback;
+        private Bitmap result;
+
+        public StreamResizeFuture(Callable<Bitmap> resizeTask, Handler mainHandler, ResizeCallback callback) {
+            super(resizeTask);
+            this.mainHandler = mainHandler;
+            this.callback = callback;
+        }
+
+        @Override
+        protected void done() {
+            super.done();
+            if (!isCancelled()){
+                try {
+                    result = get();
+                    mainHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onResizeComplete(result);
+                        }
+                    });
+                } catch (final Exception e) {
+                    e.printStackTrace();
+                    mainHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onResizeFailed(e);
+                        }
+                    });
+                }
+            }
+        }
+    }
+}
","1 /*
2  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
3  */
4 package com.bumptech.photos.resize;
5 
6 import android.graphics.Bitmap;
7 import android.graphics.Canvas;
8 import android.graphics.Matrix;
9 import android.graphics.Paint;
10 import android.os.Handler;
11 
12 import java.io.InputStream;
13 import java.util.concurrent.Callable;
14 import java.util.concurrent.Future;
15 import java.util.concurrent.FutureTask;
16 
17 /**
18  * @author sam
19  *
20  */
21 public class PhotoStreamResizer {
22 
23     private final Handler loadHandler;
24     private Handler mainHandler;
25 
26     public interface ResizeCallback {
27         void onResizeComplete(Bitmap resized);
28         void onResizeFailed(Exception e);
29     }
30 
31     public PhotoStreamResizer(Handler mainHandler, Handler loadHandler){
32         this.mainHandler = mainHandler;
33         this.loadHandler = loadHandler;
34     }
35 
36     public Future<Bitmap> resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
37         Callable<Bitmap> task = new Callable<Bitmap>(){
38             @Override
39             public Bitmap call() throws Exception {
40                 Bitmap result = null, streamed = null;
41                 streamed = Utils.streamIn(path, width, height);
42 
43                 if (streamed.getWidth() == width && streamed.getHeight() == height) {
44                     return streamed;
45                 }
46 
47                 //from ImageView/Bitmap.createScaledBitmap
48                 //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
49                 //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
50                 final float scale;
51                 float dx = 0, dy = 0;
52                 Matrix m = new Matrix();
53                 if (streamed.getWidth() * height > width * streamed.getHeight()) {
54                     scale = (float) height / (float) streamed.getHeight();
55                     dx = (width - streamed.getWidth() * scale) * 0.5f;
56                 } else {
57                     scale = (float) width / (float) streamed.getWidth();
58                     dy = (height - streamed.getHeight() * scale) * 0.5f;
59                 }
60 
61                 m.setScale(scale, scale);
62                 m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
63                 Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());
64                 Canvas canvas = new Canvas(bitmap);
65                 Paint paint = new Paint();
66                 //only if scaling up
67                 paint.setFilterBitmap(false);
68                 paint.setAntiAlias(true);
69                 canvas.drawBitmap(streamed, m, paint);
70                 result = bitmap;
71 
72                 return result;
73             }
74         };
75         return startTask(task, callback);
76     }
77 
78     public Future<Bitmap> fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
79         Callable<Bitmap> task = new Callable<Bitmap>() {
80             @Override
81             public Bitmap call() throws Exception {
82                 final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
83                 return Utils.fitInSpace(streamed, width, height);
84             }
85         };
86         return startTask(task, callback);
87     }
88 
89     public Future<Bitmap> loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
90         Callable<Bitmap> task = new Callable<Bitmap>() {
91             @Override
92             public Bitmap call() throws Exception {
93                 return Utils.streamIn(path, width, height);
94             }
95         };
96         return startTask(task, callback);
97     }
98 
99     public Future<Bitmap> loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
100         Callable<Bitmap> task = new Callable<Bitmap>() {
101             @Override
102             public Bitmap call() throws Exception {
103                 return Utils.load(is, recycle);
104             }
105         };
106         return startTask(task, callback);
107     }
108 
109     public Future<Bitmap> loadAsIs(String path, ResizeCallback callback){
110         return loadAsIs(path, null, callback);
111     }
112 
113     public Future<Bitmap> loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
114         Callable<Bitmap> task  = new Callable<Bitmap>() {
115             @Override
116             public Bitmap call() throws Exception {
117                 return Utils.load(path, recycled);
118             }
119         };
120         return startTask(task, callback);
121     }
122 
123     private Future<Bitmap> startTask(Callable<Bitmap> task, ResizeCallback callback){
124         StreamResizeFuture future = new StreamResizeFuture(task, mainHandler, callback);
125         loadHandler.post(future);
126         return future;
127     }
128 
129     private static class StreamResizeFuture extends FutureTask<Bitmap> {
130         private final Handler mainHandler;
131         private final ResizeCallback callback;
132         private Bitmap result;
133 
134         public StreamResizeFuture(Callable<Bitmap> resizeTask, Handler mainHandler, ResizeCallback callback) {
135             super(resizeTask);
136             this.mainHandler = mainHandler;
137             this.callback = callback;
138         }
139 
140         @Override
141         protected void done() {
142             super.done();
143             if (!isCancelled()){
144                 try {
145                     result = get();
146                     mainHandler.post(new Runnable() {
147                         @Override
148                         public void run() {
149                             callback.onResizeComplete(result);
150                         }
151                     });
152                 } catch (final Exception e) {
153                     e.printStackTrace();
154                     mainHandler.post(new Runnable() {
155                         @Override
156                         public void run() {
157                             callback.onResizeFailed(e);
158                         }
159                     });
160                 }
161             }
162         }
163     }
164 }",No
,src\com\bumptech\photos\resize\Utils.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,168 @@
+package com.bumptech.photos.resize;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import com.bumptech.photos.util.Photo;
+import com.bumptech.photos.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/20/12
+ * Time: 1:55 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Utils {
+
+    public static Bitmap cropToWidth(Bitmap toCrop, int width) {
+        Bitmap cropped = toCrop;
+        if (toCrop.getWidth() > width) {
+            int extraWidth = toCrop.getWidth() - width;
+            cropped = Bitmap.createBitmap(toCrop, extraWidth / 2, 0, width, toCrop.getHeight());
+            toCrop.recycle();
+        }
+        return cropped;
+    }
+
+    //crops a section height pixels tall in the center of the image with equal
+    //amounts discarded above and below
+    public static Bitmap cropToHeight(Bitmap toCrop, int height){
+        Bitmap cropped = toCrop;
+        if (toCrop.getHeight() > height){
+            int extraHeight = toCrop.getHeight() - height;
+            cropped = Bitmap.createBitmap(toCrop, 0, extraHeight / 2, toCrop.getWidth(), height);
+            toCrop.recycle();
+        }
+        return cropped;
+    }
+
+    //shrinks to the given width, shrinking the height to maintain the original image proportions
+    public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
+        //get exactly the right width
+        float widthPercent = ((float) width/toShrink.getWidth());
+        int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
+        Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
+        toShrink.recycle();
+        return shrunk;
+    }
+
+    public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
+        float heightPercent = ((float) height/toShrink.getHeight());
+        int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
+        Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
+        toShrink.recycle();
+        return shrunk;
+    }
+
+    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
+        if (height > width){
+            return shrinkToWidth(toFit, width);
+        } else {
+            return shrinkToHeight(toFit, height);
+        }
+    }
+
+    public static Bitmap load(String path) {
+        return load(path, null);
+    }
+
+    public static Bitmap load(String path, Bitmap recycle) {
+        Bitmap result = null;
+        try {
+            result = load(new FileInputStream(path), recycle);
+        } catch (FileNotFoundException e) {
+            Log.d(""PSR: file not found loading bitmap at: "" + path);
+            e.printStackTrace();
+        }
+        return result == null ? null : Photo.orientImage(path, result);
+    }
+
+    public static Bitmap load(InputStream is) {
+        return load(is, null);
+    }
+
+    public static Bitmap load(InputStream is, Bitmap recycle){
+        final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
+        decodeBitmapOptions.inSampleSize = 1;
+        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
+        decodeBitmapOptions.inDither = false;
+        if (Build.VERSION.SDK_INT >= 11) {
+            decodeBitmapOptions.inMutable = true; //required or next attempt to recycle will fail
+            if (recycle != null) {
+                decodeBitmapOptions.inBitmap = recycle; //we can load photo without a bitmap to recycle,
+                                                        //its just less efficient
+            }
+        }
+        InputStream stream;
+        Bitmap result = null;
+        try {
+            stream = new BufferedInputStream(is);
+            result = BitmapFactory.decodeStream(stream, null, decodeBitmapOptions);
+            stream.close();
+        } catch (IOException e) {
+            Log.d(""PSR: io exception: "" + e + "" loading bitmap"");
+        }
+        return result;
+    }
+
+    //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
+    //streams in to near, but not exactly at the desired width and height.
+    public static Bitmap streamIn(String path, int width, int height) {
+        int orientation = Photo.getOrientation(path);
+        if(orientation == 90 || orientation == 270) {
+            //Swap width and height for initial downsample calculation if its oriented so.
+            //The image will then be rotated back to normal.
+            int w = width;
+            width = height;
+            height = w;
+        }
+
+        Bitmap result = null;
+        try {
+            final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
+            // For further memory savings, you may want to consider using this option
+            decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
+            decodeBitmapOptions.inDither = false;
+            //avoid markInvalidated by creating two streams, rather than one and resetting it
+            //readLimit would have to be size of entire photo, which can be huge
+            InputStream first = new BufferedInputStream(new FileInputStream(path), 16384);
+
+            //find the dimensions of the actual image
+            final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
+            decodeBoundsOptions.inJustDecodeBounds = true;
+            BitmapFactory.decodeStream(first, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
+            first.close();
+
+            final int originalWidth = decodeBoundsOptions.outWidth;
+            final int originalHeight = decodeBoundsOptions.outHeight;
+
+            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
+            int sampleSize = Math.min(originalHeight / height, originalWidth / width);
+            InputStream second = new BufferedInputStream(new FileInputStream(path), 16384);
+
+            decodeBitmapOptions.inSampleSize = sampleSize;
+            if (Build.VERSION.SDK_INT > 11) {
+                decodeBitmapOptions.inMutable = true;
+            }
+            Log.d(""PSR: Loading image with sample size: "" + sampleSize);
+            result = BitmapFactory.decodeStream(second, null, decodeBitmapOptions);
+            if(orientation != 0) {
+                result = Photo.rotateImage(result, orientation);
+            }
+            second.close();
+        } catch (Exception e){
+            Log.d(""PSR: error decoding image: "" + e);
+        } catch (OutOfMemoryError e){
+            Log.d(""PSR: not enough memory to resize image at "" + path);
+            Log.d(e.toString());
+        }
+        return result;
+    }
+}
","1 package com.bumptech.photos.resize;
2 
3 import android.graphics.Bitmap;
4 import android.graphics.BitmapFactory;
5 import android.os.Build;
6 import com.bumptech.photos.util.Photo;
7 import com.bumptech.photos.util.Log;
8 
9 import java.io.BufferedInputStream;
10 import java.io.FileInputStream;
11 import java.io.FileNotFoundException;
12 import java.io.IOException;
13 import java.io.InputStream;
14 
15 /**
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/20/12
19  * Time: 1:55 PM
20  * To change this template use File | Settings | File Templates.
21  */
22 public class Utils {
23 
24     public static Bitmap cropToWidth(Bitmap toCrop, int width) {
25         Bitmap cropped = toCrop;
26         if (toCrop.getWidth() > width) {
27             int extraWidth = toCrop.getWidth() - width;
28             cropped = Bitmap.createBitmap(toCrop, extraWidth / 2, 0, width, toCrop.getHeight());
29             toCrop.recycle();
30         }
31         return cropped;
32     }
33 
34     //crops a section height pixels tall in the center of the image with equal
35     //amounts discarded above and below
36     public static Bitmap cropToHeight(Bitmap toCrop, int height){
37         Bitmap cropped = toCrop;
38         if (toCrop.getHeight() > height){
39             int extraHeight = toCrop.getHeight() - height;
40             cropped = Bitmap.createBitmap(toCrop, 0, extraHeight / 2, toCrop.getWidth(), height);
41             toCrop.recycle();
42         }
43         return cropped;
44     }
45 
46     //shrinks to the given width, shrinking the height to maintain the original image proportions
47     public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
48         //get exactly the right width
49         float widthPercent = ((float) width/toShrink.getWidth());
50         int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
51         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
52         toShrink.recycle();
53         return shrunk;
54     }
55 
56     public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
57         float heightPercent = ((float) height/toShrink.getHeight());
58         int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
59         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
60         toShrink.recycle();
61         return shrunk;
62     }
63 
64     public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
65         if (height > width){
66             return shrinkToWidth(toFit, width);
67         } else {
68             return shrinkToHeight(toFit, height);
69         }
70     }
71 
72     public static Bitmap load(String path) {
73         return load(path, null);
74     }
75 
76     public static Bitmap load(String path, Bitmap recycle) {
77         Bitmap result = null;
78         try {
79             result = load(new FileInputStream(path), recycle);
80         } catch (FileNotFoundException e) {
81             Log.d(""PSR: file not found loading bitmap at: "" + path);
82             e.printStackTrace();
83         }
84         return result == null ? null : Photo.orientImage(path, result);
85     }
86 
87     public static Bitmap load(InputStream is) {
88         return load(is, null);
89     }
90 
91     public static Bitmap load(InputStream is, Bitmap recycle){
92         final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
93         decodeBitmapOptions.inSampleSize = 1;
94         decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
95         decodeBitmapOptions.inDither = false;
96         if (Build.VERSION.SDK_INT >= 11) {
97             decodeBitmapOptions.inMutable = true; //required or next attempt to recycle will fail
98             if (recycle != null) {
99                 decodeBitmapOptions.inBitmap = recycle; //we can load photo without a bitmap to recycle,
100                                                         //its just less efficient
101             }
102         }
103         InputStream stream;
104         Bitmap result = null;
105         try {
106             stream = new BufferedInputStream(is);
107             result = BitmapFactory.decodeStream(stream, null, decodeBitmapOptions);
108             stream.close();
109         } catch (IOException e) {
110             Log.d(""PSR: io exception: "" + e + "" loading bitmap"");
111         }
112         return result;
113     }
114 
115     //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
116     //streams in to near, but not exactly at the desired width and height.
117     public static Bitmap streamIn(String path, int width, int height) {
118         int orientation = Photo.getOrientation(path);
119         if(orientation == 90 || orientation == 270) {
120             //Swap width and height for initial downsample calculation if its oriented so.
121             //The image will then be rotated back to normal.
122             int w = width;
123             width = height;
124             height = w;
125         }
126 
127         Bitmap result = null;
128         try {
129             final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
130             // For further memory savings, you may want to consider using this option
131             decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
132             decodeBitmapOptions.inDither = false;
133             //avoid markInvalidated by creating two streams, rather than one and resetting it
134             //readLimit would have to be size of entire photo, which can be huge
135             InputStream first = new BufferedInputStream(new FileInputStream(path), 16384);
136 
137             //find the dimensions of the actual image
138             final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
139             decodeBoundsOptions.inJustDecodeBounds = true;
140             BitmapFactory.decodeStream(first, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
141             first.close();
142 
143             final int originalWidth = decodeBoundsOptions.outWidth;
144             final int originalHeight = decodeBoundsOptions.outHeight;
145 
146             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
147             int sampleSize = Math.min(originalHeight / height, originalWidth / width);
148             InputStream second = new BufferedInputStream(new FileInputStream(path), 16384);
149 
150             decodeBitmapOptions.inSampleSize = sampleSize;
151             if (Build.VERSION.SDK_INT > 11) {
152                 decodeBitmapOptions.inMutable = true;
153             }
154             Log.d(""PSR: Loading image with sample size: "" + sampleSize);
155             result = BitmapFactory.decodeStream(second, null, decodeBitmapOptions);
156             if(orientation != 0) {
157                 result = Photo.rotateImage(result, orientation);
158             }
159             second.close();
160         } catch (Exception e){
161             Log.d(""PSR: error decoding image: "" + e);
162         } catch (OutOfMemoryError e){
163             Log.d(""PSR: not enough memory to resize image at "" + path);
164             Log.d(e.toString());
165         }
166         return result;
167     }
168 }",No
,src\com\bumptech\photos\util\Log.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,48 @@
+package com.bumptech.photos.util;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: sam
+ * Date: 10/11/12
+ * Time: 10:11 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Log {
+    private static final String TAG = ""BUMP_PHOTOS"";
+    private static final DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
+
+    public static void e(String message, Object... args) {
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        android.util.Log.e(TAG, formatted);
+    }
+
+    public static void e(String message, Throwable t, Object... args){
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        android.util.Log.e(TAG, formatted, t);
+    }
+
+    public static void w(String message, Object... args) {
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        android.util.Log.w(TAG, formatted);
+    }
+
+    public static void i(String message, Object... args) {
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        android.util.Log.i(TAG, formatted);
+    }
+
+    public static void d(String message, Object... args) {
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        formatted = ""["" + dateFormat.format(new Date()) + ""] "" + formatted;
+        android.util.Log.d(TAG, formatted);
+    }
+
+    public static void v(String message, Object... args) {
+        String formatted = args.length > 0 ? String.format(message, args) : message;
+        android.util.Log.v(TAG, formatted);
+    }
+}
","1 package com.bumptech.photos.util;
2 
3 import java.text.DateFormat;
4 import java.text.SimpleDateFormat;
5 import java.util.Date;
6 
7 /**
8  * Created by IntelliJ IDEA.
9  * User: sam
10  * Date: 10/11/12
11  * Time: 10:11 AM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class Log {
15     private static final String TAG = ""BUMP_PHOTOS"";
16     private static final DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
17 
18     public static void e(String message, Object... args) {
19         String formatted = args.length > 0 ? String.format(message, args) : message;
20         android.util.Log.e(TAG, formatted);
21     }
22 
23     public static void e(String message, Throwable t, Object... args){
24         String formatted = args.length > 0 ? String.format(message, args) : message;
25         android.util.Log.e(TAG, formatted, t);
26     }
27 
28     public static void w(String message, Object... args) {
29         String formatted = args.length > 0 ? String.format(message, args) : message;
30         android.util.Log.w(TAG, formatted);
31     }
32 
33     public static void i(String message, Object... args) {
34         String formatted = args.length > 0 ? String.format(message, args) : message;
35         android.util.Log.i(TAG, formatted);
36     }
37 
38     public static void d(String message, Object... args) {
39         String formatted = args.length > 0 ? String.format(message, args) : message;
40         formatted = ""["" + dateFormat.format(new Date()) + ""] "" + formatted;
41         android.util.Log.d(TAG, formatted);
42     }
43 
44     public static void v(String message, Object... args) {
45         String formatted = args.length > 0 ? String.format(message, args) : message;
46         android.util.Log.v(TAG, formatted);
47     }
48 }",No
,src\com\bumptech\photos\util\Photo.java,1903a3ba2b980fd5c0556bfe869333a34411f5f5,45bc62776a5312e0d5d40712e298247c9bdfed63,initial commit of source from project,"@@ -0,0 +1,83 @@
+/* * Copyright (c) 2011. Bump Technologies Inc.
+*/
+
+package com.bumptech.photos.util;
+
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.media.ExifInterface;
+
+import java.io.IOException;
+
+public class Photo {
+
+    /**
+     * Returns a matrix with rotation set based on Exif orientation tag.
+     * If the orientation is undefined or 0 null is returned.
+     *
+     * @param pathToOriginal Path to original image file that may have exif data.
+     * @return  A rotation in degrees based on exif orientation
+     */
+    public static int getOrientation(String pathToOriginal) {
+        int degreesToRotate = 0;
+        try{
+            ExifInterface exif = new ExifInterface(pathToOriginal);
+            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
+            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
+                degreesToRotate = 90;
+            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
+                degreesToRotate = 180;
+            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
+                degreesToRotate = 270;
+            }
+        } catch (IOException e){
+            Log.w(""IOException for image with filePath="" + pathToOriginal);
+        } catch (Exception e) {
+            Log.w(""Exception when trying to get image orientation matrix"");
+            e.printStackTrace();
+        }
+        return degreesToRotate;
+    }
+
+    /**
+     * This is an expensive operation that copies the image in place with the pixels rotated.
+     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
+     *
+     * @param pathToOriginal Path to original image file that may have exif data.
+     * @param imageToOrient Image Bitmap to orient.
+     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
+     */
+    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
+        int degreesToRotate = Photo.getOrientation(pathToOriginal);
+        return rotateImage(imageToOrient, degreesToRotate);
+    }
+
+    /**
+     * This is an expensive operation that copies the image in place with the pixels rotated.
+     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
+     *
+     * @param imageToOrient Image Bitmap to orient.
+     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
+     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
+     */
+    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
+        try{
+            if(degreesToRotate != 0) {
+                Matrix matrix = new Matrix();
+                matrix.setRotate(degreesToRotate);
+                imageToOrient = Bitmap.createBitmap(
+                        imageToOrient,
+                        0,
+                        0,
+                        imageToOrient.getWidth(),
+                        imageToOrient.getHeight(),
+                        matrix,
+                        true);
+            }
+        } catch (Exception e) {
+            Log.w(""Exception when trying to orient image"");
+            e.printStackTrace();
+        }
+        return imageToOrient;
+    }
+}
","1 /* * Copyright (c) 2011. Bump Technologies Inc.
2 */
3 
4 package com.bumptech.photos.util;
5 
6 import android.graphics.Bitmap;
7 import android.graphics.Matrix;
8 import android.media.ExifInterface;
9 
10 import java.io.IOException;
11 
12 public class Photo {
13 
14     /**
15      * Returns a matrix with rotation set based on Exif orientation tag.
16      * If the orientation is undefined or 0 null is returned.
17      *
18      * @param pathToOriginal Path to original image file that may have exif data.
19      * @return  A rotation in degrees based on exif orientation
20      */
21     public static int getOrientation(String pathToOriginal) {
22         int degreesToRotate = 0;
23         try{
24             ExifInterface exif = new ExifInterface(pathToOriginal);
25             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
26             if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
27                 degreesToRotate = 90;
28             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
29                 degreesToRotate = 180;
30             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
31                 degreesToRotate = 270;
32             }
33         } catch (IOException e){
34             Log.w(""IOException for image with filePath="" + pathToOriginal);
35         } catch (Exception e) {
36             Log.w(""Exception when trying to get image orientation matrix"");
37             e.printStackTrace();
38         }
39         return degreesToRotate;
40     }
41 
42     /**
43      * This is an expensive operation that copies the image in place with the pixels rotated.
44      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
45      *
46      * @param pathToOriginal Path to original image file that may have exif data.
47      * @param imageToOrient Image Bitmap to orient.
48      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
49      */
50     public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
51         int degreesToRotate = Photo.getOrientation(pathToOriginal);
52         return rotateImage(imageToOrient, degreesToRotate);
53     }
54 
55     /**
56      * This is an expensive operation that copies the image in place with the pixels rotated.
57      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
58      *
59      * @param imageToOrient Image Bitmap to orient.
60      * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
61      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
62      */
63     public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
64         try{
65             if(degreesToRotate != 0) {
66                 Matrix matrix = new Matrix();
67                 matrix.setRotate(degreesToRotate);
68                 imageToOrient = Bitmap.createBitmap(
69                         imageToOrient,
70                         0,
71                         0,
72                         imageToOrient.getWidth(),
73                         imageToOrient.getHeight(),
74                         matrix,
75                         true);
76             }
77         } catch (Exception e) {
78             Log.w(""Exception when trying to orient image"");
79             e.printStackTrace();
80         }
81         return imageToOrient;
82     }
83 }",No
README,README,a7497732813cff1233667ad41b8a07393c1bcad3,1903a3ba2b980fd5c0556bfe869333a34411f5f5,add readme,,,Yes
.gitmodules,.gitmodules,4dcd5c51d9e15c3eb4e635851a3a3391b7c6454a,a7497732813cff1233667ad41b8a07393c1bcad3,Replace disklru cache with an equivalent jar,"@@ -1,3 +0,0 @@
-[submodule ""DiskLruCache""]
-	path = DiskLruCache
-	url = https://github.com/JakeWharton/DiskLruCache.git
","1 [submodule ""DiskLruCache""]
2 	path = DiskLruCache
3 	url = https://github.com/JakeWharton/DiskLruCache.git",Yes
DiskLruCache,,4dcd5c51d9e15c3eb4e635851a3a3391b7c6454a,a7497732813cff1233667ad41b8a07393c1bcad3,Replace disklru cache with an equivalent jar,"@@ -1 +0,0 @@
-Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc
",1 Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc,Yes
libs\disklrucache-1.2.1.jar,libs\disklrucache-1.2.1.jar,4dcd5c51d9e15c3eb4e635851a3a3391b7c6454a,a7497732813cff1233667ad41b8a07393c1bcad3,Replace disklru cache with an equivalent jar,"Binary files /dev/null and b/libs/disklrucache-1.2.1.jar differ
",,No
project.properties,project.properties,13b6a3fde4af5c6d841d923f58e4de37d913ef2c,4dcd5c51d9e15c3eb4e635851a3a3391b7c6454a,increase target version,"@@ -12,4 +12,4 @@
 
 android.library=true
 # Project target.
-target=android-10
+target=android-16
","15 target=android-16
15 target=android-10",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,8930013603d92aaead50840a8b22e2ca2327225d,13b6a3fde4af5c6d841d923f58e4de37d913ef2c,remove unused argument to returnFromCache,"@@ -56,7 +56,7 @@ public class PhotoManager {
     public Object getImage(final String path, final Bitmap recycled, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path);
-        if (!returnFromCache(key, token, cb)) {
+        if (!returnFromCache(key, cb)) {
             final Future task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
             taskManager.put(token, task);
         }
@@ -79,7 +79,7 @@ public class PhotoManager {
     public Object getImage(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
-        if (!returnFromCache(key, token, cb)) {
+        if (!returnFromCache(key, cb)) {
             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
@@ -108,7 +108,7 @@ public class PhotoManager {
     public Object centerSlice(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
-        if (!returnFromCache(key, token, cb)) {
+        if (!returnFromCache(key, cb)) {
             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
                 @Override
                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
@@ -136,7 +136,7 @@ public class PhotoManager {
     public Object fitCenter(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
-        if (!returnFromCache(key, token, cb)) {
+        if (!returnFromCache(key, cb)) {
             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
@@ -147,7 +147,7 @@ public class PhotoManager {
         return token;
     }
 
-    private boolean returnFromCache(String key, Object token, LoadedCallback cb) {
+    private boolean returnFromCache(String key, LoadedCallback cb) {
         boolean found = false;
         if (Build.VERSION.SDK_INT < 11) {
             Bitmap inCache = memoryCache.get(key);
","59         if (!returnFromCache(key, cb)) {
82         if (!returnFromCache(key, cb)) {
111         if (!returnFromCache(key, cb)) {
139         if (!returnFromCache(key, cb)) {
150     private boolean returnFromCache(String key, LoadedCallback cb) {
59         if (!returnFromCache(key, token, cb)) {
82         if (!returnFromCache(key, token, cb)) {
111         if (!returnFromCache(key, token, cb)) {
139         if (!returnFromCache(key, token, cb)) {
150     private boolean returnFromCache(String key, Object token, LoadedCallback cb) {",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,5f788c90a6d69c917004fe50cc085f6cb4929bd8,8930013603d92aaead50840a8b22e2ca2327225d,Move centerCrop function into utils,"@@ -7,6 +7,7 @@ package com.bumptech.photos;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Handler;
+import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
 import com.bumptech.photos.cache.PhotoDiskCache;
 import com.bumptech.photos.resize.PhotoStreamResizer;
@@ -18,7 +19,6 @@ import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.Future;
 
 /**
  * Created by IntelliJ IDEA.
@@ -31,7 +31,6 @@ public class PhotoManager {
     private PhotoDiskCache diskCache;
     private LruPhotoCache memoryCache;
     private PhotoStreamResizer resizer;
-    private Map<Object, Future> taskManager = new HashMap<Object, Future>();
     private Handler backgroundHandler;
 
     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
@@ -39,7 +38,7 @@ public class PhotoManager {
         if (Build.VERSION.SDK_INT < 11)
             this.memoryCache = new LruPhotoCache(maxMemCacheSize);
         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
-        this.resizer = new PhotoStreamResizer(mainHandler, backgroundHandler);
+        this.resizer = new PhotoStreamResizer(mainHandler);
     }
 
     public Object getImage(final String path, final LoadedCallback cb) {
@@ -57,8 +56,8 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path);
         if (!returnFromCache(key, cb)) {
-            final Future task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
-            taskManager.put(token, task);
+            final Runnable task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
+            postJob(task, token);
         }
         return token;
     }
@@ -80,12 +79,13 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
-                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.loadApproximate(path, width, height, resizeCallback);
                 }
             });
+            postJob(checkDiskCache, token);
         }
         return token;
     }
@@ -109,12 +109,13 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
                 @Override
-                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
                 }
             });
+            postJob(checkDiskCache, token);
         }
         return token;
     }
@@ -137,12 +138,13 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
-                public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.fitInSpace(path, width, height, resizeCallback);
                 }
             });
+            postJob(checkDiskCache, token);
         }
         return token;
     }
@@ -180,7 +182,7 @@ public class PhotoManager {
 
         @Override
         public void onGet(InputStream is) {
-            final Future task;
+            final Runnable task;
             final boolean inDiskCache = is != null;
             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, useDiskCache);
             if (inDiskCache) {
@@ -188,10 +190,10 @@ public class PhotoManager {
             } else {
                 task = resizeIfNotFound(resizeCb);
             }
-            taskManager.put(token, task);
+            postJob(task, token);
         }
 
-        public abstract Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
+        public abstract Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
     }
 
     private PhotoStreamResizer.ResizeCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache ) {
@@ -202,9 +204,9 @@ public class PhotoManager {
                     memoryCache.put(key, resized);
                 }
                 if (!inDiskCache && useDiskCache) {
-                    diskCache.put(key, resized);
+                    Runnable putToDiskCache = diskCache.put(key, resized);
+                    postJob(putToDiskCache, token);
                 }
-                taskManager.remove(token);
                 cb.loadCompleted(resized);
             }
 
@@ -215,11 +217,13 @@ public class PhotoManager {
         };
     }
 
+    private void postJob(Runnable job, Object token) {
+        backgroundHandler.postAtTime(job, token, SystemClock.uptimeMillis());
+    }
+
     public void cancelTask(Object token){
         backgroundHandler.removeCallbacksAndMessages(token);
-        final Future task = taskManager.get(token);
-        if (task != null){
-            task.cancel(true);
+    }
         }
     }
 
","10 import android.os.SystemClock;
41         this.resizer = new PhotoStreamResizer(mainHandler);
59             final Runnable task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
60             postJob(task, token);
82             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
84                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
88             postJob(checkDiskCache, token);
112             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
114                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
118             postJob(checkDiskCache, token);
141             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
143                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
147             postJob(checkDiskCache, token);
185             final Runnable task;
193             postJob(task, token);
196         public abstract Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
207                     Runnable putToDiskCache = diskCache.put(key, resized);
208                     postJob(putToDiskCache, token);
220     private void postJob(Runnable job, Object token) {
221         backgroundHandler.postAtTime(job, token, SystemClock.uptimeMillis());
222     }
223 
226     }
21 import java.util.concurrent.Future;
34     private Map<Object, Future> taskManager = new HashMap<Object, Future>();
42         this.resizer = new PhotoStreamResizer(mainHandler, backgroundHandler);
60             final Future task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
61             taskManager.put(token, task);
83             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
85                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
112             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
114                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
140             diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
142                 public Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
183             final Future task;
191             taskManager.put(token, task);
194         public abstract Future resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
205                     diskCache.put(key, resized);
207                 taskManager.remove(token);
220         final Future task = taskManager.get(token);
221         if (task != null){
222             task.cancel(true);",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,5f788c90a6d69c917004fe50cc085f6cb4929bd8,8930013603d92aaead50840a8b22e2ca2327225d,Move centerCrop function into utils,"@@ -43,33 +43,9 @@ public class PhotoStreamResizer {
                 if (streamed.getWidth() == width && streamed.getHeight() == height) {
                     return streamed;
                 }
-
-                //from ImageView/Bitmap.createScaledBitmap
-                //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
-                //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
-                final float scale;
-                float dx = 0, dy = 0;
-                Matrix m = new Matrix();
-                if (streamed.getWidth() * height > width * streamed.getHeight()) {
-                    scale = (float) height / (float) streamed.getHeight();
-                    dx = (width - streamed.getWidth() * scale) * 0.5f;
                 } else {
-                    scale = (float) width / (float) streamed.getWidth();
-                    dy = (height - streamed.getHeight() * scale) * 0.5f;
-                }
-
-                m.setScale(scale, scale);
-                m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
-                Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());
-                Canvas canvas = new Canvas(bitmap);
-                Paint paint = new Paint();
-                //only if scaling up
-                paint.setFilterBitmap(false);
-                paint.setAntiAlias(true);
-                canvas.drawBitmap(streamed, m, paint);
-                result = bitmap;
-
-                return result;
+                    return Utils.centerCrop(streamed, width, height);
+                }
             }
         };
         return startTask(task, callback);
","47                     return Utils.centerCrop(streamed, width, height);
46 
47                 //from ImageView/Bitmap.createScaledBitmap
48                 //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
49                 //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
50                 final float scale;
51                 float dx = 0, dy = 0;
52                 Matrix m = new Matrix();
53                 if (streamed.getWidth() * height > width * streamed.getHeight()) {
54                     scale = (float) height / (float) streamed.getHeight();
55                     dx = (width - streamed.getWidth() * scale) * 0.5f;
57                     scale = (float) width / (float) streamed.getWidth();
58                     dy = (height - streamed.getHeight() * scale) * 0.5f;
60 
61                 m.setScale(scale, scale);
62                 m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
63                 Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());
64                 Canvas canvas = new Canvas(bitmap);
65                 Paint paint = new Paint();
66                 //only if scaling up
67                 paint.setFilterBitmap(false);
68                 paint.setAntiAlias(true);
69                 canvas.drawBitmap(streamed, m, paint);
70                 result = bitmap;
71 
72                 return result;",No
src\com\bumptech\photos\resize\Utils.java,src\com\bumptech\photos\resize\Utils.java,5f788c90a6d69c917004fe50cc085f6cb4929bd8,8930013603d92aaead50840a8b22e2ca2327225d,Move centerCrop function into utils,"@@ -2,9 +2,12 @@ package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
 import android.os.Build;
-import com.bumptech.photos.util.Photo;
 import com.bumptech.photos.util.Log;
+import com.bumptech.photos.util.Photo;
 
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
@@ -21,6 +24,36 @@ import java.io.InputStream;
  */
 public class Utils {
 
+    public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
+        if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
+            return toCrop;
+        }
+        //from ImageView/Bitmap.createScaledBitmap
+        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
+        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
+        final float scale;
+        float dx = 0, dy = 0;
+        Matrix m = new Matrix();
+        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
+            scale = (float) height / (float) toCrop.getHeight();
+            dx = (width - toCrop.getWidth() * scale) * 0.5f;
+        } else {
+            scale = (float) width / (float) toCrop.getWidth();
+            dy = (height - toCrop.getHeight() * scale) * 0.5f;
+        }
+
+        m.setScale(scale, scale);
+        m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
+        Bitmap result = Bitmap.createBitmap(width, height, toCrop.getConfig());
+        Canvas canvas = new Canvas(result);
+        Paint paint = new Paint();
+        //only if scaling up
+        paint.setFilterBitmap(false);
+        paint.setAntiAlias(true);
+        canvas.drawBitmap(toCrop, m, paint);
+        return result;
+    }
+
     public static Bitmap cropToWidth(Bitmap toCrop, int width) {
         Bitmap cropped = toCrop;
         if (toCrop.getWidth() > width) {
","5 import android.graphics.Canvas;
6 import android.graphics.Matrix;
7 import android.graphics.Paint;
10 import com.bumptech.photos.util.Photo;
27     public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
28         if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
29             return toCrop;
30         }
31         //from ImageView/Bitmap.createScaledBitmap
32         //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
33         //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
34         final float scale;
35         float dx = 0, dy = 0;
36         Matrix m = new Matrix();
37         if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
38             scale = (float) height / (float) toCrop.getHeight();
39             dx = (width - toCrop.getWidth() * scale) * 0.5f;
40         } else {
41             scale = (float) width / (float) toCrop.getWidth();
42             dy = (height - toCrop.getHeight() * scale) * 0.5f;
43         }
44 
45         m.setScale(scale, scale);
46         m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
47         Bitmap result = Bitmap.createBitmap(width, height, toCrop.getConfig());
48         Canvas canvas = new Canvas(result);
49         Paint paint = new Paint();
50         //only if scaling up
51         paint.setFilterBitmap(false);
52         paint.setAntiAlias(true);
53         canvas.drawBitmap(toCrop, m, paint);
54         return result;
55     }
56 
6 import com.bumptech.photos.util.Photo;",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,9f35fb44d12058cababa7d60c1de7b0f751824ac,5f788c90a6d69c917004fe50cc085f6cb4929bd8,"Make classes return runnables to photo manager

Allows for uniform scheduling/cancelling interface
and for all posting to background threads to be
done in one place.","@@ -41,22 +41,17 @@ public class PhotoManager {
         this.resizer = new PhotoStreamResizer(mainHandler);
     }
 
-    public Object getImage(final String path, final LoadedCallback cb) {
-        return getImage(path, null, cb);
-    }
-
     /**
      * Loads the image for the given id
      * @param path - the path id to the image
-     * @param recycled - a mutable bitmap of the same width and height as image at path to be reused
      * @param cb - the callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImage(final String path, final Bitmap recycled, final LoadedCallback cb){
+    public Object getImage(final String path, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path);
         if (!returnFromCache(key, cb)) {
-            final Runnable task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));
+            final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));
             postJob(task, token);
         }
         return token;
","50     public Object getImage(final String path, final LoadedCallback cb){
54             final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));
44     public Object getImage(final String path, final LoadedCallback cb) {
45         return getImage(path, null, cb);
46     }
47 
51      * @param recycled - a mutable bitmap of the same width and height as image at path to be reused
55     public Object getImage(final String path, final Bitmap recycled, final LoadedCallback cb){
59             final Runnable task = resizer.loadAsIs(path, recycled, getResizeCb(key, token, cb, false, false));",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,9f35fb44d12058cababa7d60c1de7b0f751824ac,5f788c90a6d69c917004fe50cc085f6cb4929bd8,"Make classes return runnables to photo manager

Allows for uniform scheduling/cancelling interface
and for all posting to background threads to be
done in one place.","@@ -41,13 +41,13 @@ public class PhotoDiskCache {
         this.getHandler = loadHandler;
     }
 
-    public void put(final String key, final Bitmap bitmap) {
-        if (bitmap == null) return;
-
+    public Runnable put(final String key, final Bitmap bitmap) {
         Log.d(""DLRU: doPut key="" + key);
-        putHandler.post(new Runnable() {
+        return new Runnable() {
             @Override
             public void run() {
+                if (bitmap == null) return;
+
                 Log.d(""DLRU: run put key="" + key);
                 DiskLruCache.Editor edit = null;
                 OutputStream out = null;
@@ -81,12 +81,12 @@ public class PhotoDiskCache {
 
                 }
             }
-        });
+        };
     }
 
-    public void get(final String key, final GetCallback cb) {
+    public Runnable get(final String key, final GetCallback cb) {
         Log.d(""DLRU: get key="" + key);
-        getHandler.post(new Runnable() {
+        return new Runnable() {
             @Override
             public void run() {
                 InputStream result = null;
@@ -117,6 +117,6 @@ public class PhotoDiskCache {
                     }
                 });
             }
-        });
+        };
     }
 }
","44     public Runnable put(final String key, final Bitmap bitmap) {
46         return new Runnable() {
49                 if (bitmap == null) return;
50 
84         };
87     public Runnable get(final String key, final GetCallback cb) {
89         return new Runnable() {
120         };
44     public void put(final String key, final Bitmap bitmap) {
45         if (bitmap == null) return;
46 
48         putHandler.post(new Runnable() {
84         });
87     public void get(final String key, final GetCallback cb) {
89         getHandler.post(new Runnable() {
120         });",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,9f35fb44d12058cababa7d60c1de7b0f751824ac,5f788c90a6d69c917004fe50cc085f6cb4929bd8,"Make classes return runnables to photo manager

Allows for uniform scheduling/cancelling interface
and for all posting to background threads to be
done in one place.","@@ -4,15 +4,9 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Matrix;
-import android.graphics.Paint;
 import android.os.Handler;
 
 import java.io.InputStream;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
-import java.util.concurrent.FutureTask;
 
 /**
  * @author sam
@@ -20,7 +14,6 @@ import java.util.concurrent.FutureTask;
  */
 public class PhotoStreamResizer {
 
-    private final Handler loadHandler;
     private Handler mainHandler;
 
     public interface ResizeCallback {
@@ -28,97 +21,77 @@ public class PhotoStreamResizer {
         void onResizeFailed(Exception e);
     }
 
-    public PhotoStreamResizer(Handler mainHandler, Handler loadHandler){
+    public PhotoStreamResizer(Handler mainHandler){
         this.mainHandler = mainHandler;
-        this.loadHandler = loadHandler;
     }
 
-    public Future<Bitmap> resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
-        Callable<Bitmap> task = new Callable<Bitmap>(){
+    public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
+        return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap call() throws Exception {
-                Bitmap result = null, streamed = null;
-                streamed = Utils.streamIn(path, width, height);
+            public Bitmap resize() {
+                Bitmap streamed = Utils.streamIn(path, width, height);
 
                 if (streamed.getWidth() == width && streamed.getHeight() == height) {
                     return streamed;
-                }
                 } else {
                     return Utils.centerCrop(streamed, width, height);
                 }
             }
         };
-        return startTask(task, callback);
     }
 
-    public Future<Bitmap> fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
-        Callable<Bitmap> task = new Callable<Bitmap>() {
+    public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
+        return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap call() throws Exception {
+            public Bitmap resize() {
                 final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
                 return Utils.fitInSpace(streamed, width, height);
             }
         };
-        return startTask(task, callback);
     }
 
-    public Future<Bitmap> loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
-        Callable<Bitmap> task = new Callable<Bitmap>() {
+    public Runnable loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
+        return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap call() throws Exception {
+            public Bitmap resize() {
                 return Utils.streamIn(path, width, height);
             }
         };
-        return startTask(task, callback);
     }
 
-    public Future<Bitmap> loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
-        Callable<Bitmap> task = new Callable<Bitmap>() {
+    public Runnable loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
+        return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap call() throws Exception {
+            public Bitmap resize() {
                 return Utils.load(is, recycle);
             }
         };
-        return startTask(task, callback);
     }
 
-    public Future<Bitmap> loadAsIs(String path, ResizeCallback callback){
+    public Runnable loadAsIs(String path, ResizeCallback callback){
         return loadAsIs(path, null, callback);
     }
 
-    public Future<Bitmap> loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
-        Callable<Bitmap> task  = new Callable<Bitmap>() {
+    public Runnable loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
+        return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap call() throws Exception {
+            public Bitmap resize() {
                 return Utils.load(path, recycled);
             }
         };
-        return startTask(task, callback);
-    }
-
-    private Future<Bitmap> startTask(Callable<Bitmap> task, ResizeCallback callback){
-        StreamResizeFuture future = new StreamResizeFuture(task, mainHandler, callback);
-        loadHandler.post(future);
-        return future;
-    }
+    };
 
-    private static class StreamResizeFuture extends FutureTask<Bitmap> {
-        private final Handler mainHandler;
-        private final ResizeCallback callback;
-        private Bitmap result;
+    private abstract class StreamResizeRunnable implements Runnable {
+        private final PhotoStreamResizer.ResizeCallback callback;
 
-        public StreamResizeFuture(Callable<Bitmap> resizeTask, Handler mainHandler, ResizeCallback callback) {
-            super(resizeTask);
-            this.mainHandler = mainHandler;
+        public StreamResizeRunnable(PhotoStreamResizer.ResizeCallback callback) {
             this.callback = callback;
         }
 
         @Override
-        protected void done() {
-            super.done();
-            if (!isCancelled()){
+        public final void run() {
             try {
-                    result = get();
+                final Bitmap result = resize();
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -135,6 +108,7 @@ public class PhotoStreamResizer {
                 });
             }
         }
-        }
+
+        public abstract Bitmap resize();
     }
 }
","24     public PhotoStreamResizer(Handler mainHandler){
28     public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
29         return new StreamResizeRunnable(callback) {
31             public Bitmap resize() {
32                 Bitmap streamed = Utils.streamIn(path, width, height);
43     public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
44         return new StreamResizeRunnable(callback) {
46             public Bitmap resize() {
53     public Runnable loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
54         return new StreamResizeRunnable(callback) {
56             public Bitmap resize() {
62     public Runnable loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
63         return new StreamResizeRunnable(callback) {
65             public Bitmap resize() {
71     public Runnable loadAsIs(String path, ResizeCallback callback){
75     public Runnable loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
76         return new StreamResizeRunnable(callback) {
78             public Bitmap resize() {
82     };
84     private abstract class StreamResizeRunnable implements Runnable {
85         private final PhotoStreamResizer.ResizeCallback callback;
87         public StreamResizeRunnable(PhotoStreamResizer.ResizeCallback callback) {
92         public final void run() {
94                 final Bitmap result = resize();
111 
112         public abstract Bitmap resize();
7 import android.graphics.Canvas;
8 import android.graphics.Matrix;
9 import android.graphics.Paint;
13 import java.util.concurrent.Callable;
14 import java.util.concurrent.Future;
15 import java.util.concurrent.FutureTask;
23     private final Handler loadHandler;
31     public PhotoStreamResizer(Handler mainHandler, Handler loadHandler){
33         this.loadHandler = loadHandler;
36     public Future<Bitmap> resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
37         Callable<Bitmap> task = new Callable<Bitmap>(){
39             public Bitmap call() throws Exception {
40                 Bitmap result = null, streamed = null;
41                 streamed = Utils.streamIn(path, width, height);
45                 }
51         return startTask(task, callback);
54     public Future<Bitmap> fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
55         Callable<Bitmap> task = new Callable<Bitmap>() {
57             public Bitmap call() throws Exception {
62         return startTask(task, callback);
65     public Future<Bitmap> loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
66         Callable<Bitmap> task = new Callable<Bitmap>() {
68             public Bitmap call() throws Exception {
72         return startTask(task, callback);
75     public Future<Bitmap> loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
76         Callable<Bitmap> task = new Callable<Bitmap>() {
78             public Bitmap call() throws Exception {
82         return startTask(task, callback);
85     public Future<Bitmap> loadAsIs(String path, ResizeCallback callback){
89     public Future<Bitmap> loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
90         Callable<Bitmap> task  = new Callable<Bitmap>() {
92             public Bitmap call() throws Exception {
96         return startTask(task, callback);
97     }
99     private Future<Bitmap> startTask(Callable<Bitmap> task, ResizeCallback callback){
100         StreamResizeFuture future = new StreamResizeFuture(task, mainHandler, callback);
101         loadHandler.post(future);
102         return future;
103     }
105     private static class StreamResizeFuture extends FutureTask<Bitmap> {
106         private final Handler mainHandler;
107         private final ResizeCallback callback;
108         private Bitmap result;
109 
110         public StreamResizeFuture(Callable<Bitmap> resizeTask, Handler mainHandler, ResizeCallback callback) {
111             super(resizeTask);
112             this.mainHandler = mainHandler;
117         protected void done() {
118             super.done();
119             if (!isCancelled()){
121                     result = get();
138         }",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,22219f2918d067387143a3eebe5a3252fac1b240,9f35fb44d12058cababa7d60c1de7b0f751824ac,Add reference counting methods for bitmaps,"@@ -18,7 +18,9 @@ import java.math.BigInteger;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.Map;
+import java.util.Queue;
 
 /**
  * Created by IntelliJ IDEA.
@@ -32,11 +34,20 @@ public class PhotoManager {
     private LruPhotoCache memoryCache;
     private PhotoStreamResizer resizer;
     private Handler backgroundHandler;
+    private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
+    private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();
 
     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
         this.backgroundHandler = backgroundHandler;
         if (Build.VERSION.SDK_INT < 11)
         this.memoryCache = new LruPhotoCache(maxMemCacheSize);
+        memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
+            @Override
+            public void onPhotoRemoved(String key, Bitmap bitmap) {
+                Log.d(""RECYCLE: onPhotoRemoved key="" + key + "" bitmap="" + bitmap);
+                releaseBitmap(bitmap);
+            }
+        });
         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
         this.resizer = new PhotoStreamResizer(mainHandler);
     }
@@ -196,8 +207,9 @@ public class PhotoManager {
             @Override
             public void onResizeComplete(Bitmap resized) {
                 if (Build.VERSION.SDK_INT < 11) {
-                    memoryCache.put(key, resized);
                 }
+                memoryCache.put(key, resized);
+                acquireBitmap(resized);
                 if (!inDiskCache && useDiskCache) {
                     Runnable putToDiskCache = diskCache.put(key, resized);
                     postJob(putToDiskCache, token);
@@ -219,7 +231,38 @@ public class PhotoManager {
     public void cancelTask(Object token){
         backgroundHandler.removeCallbacksAndMessages(token);
     }
+
+    public void acquireBitmap(Bitmap b) {
+        if (!b.isMutable()) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b);
+        if (currentCount == null) {
+            currentCount = 0;
+        }
+        bitmapReferenceCounter.put(b, currentCount+1);
     }
+
+    public void releaseBitmap(Bitmap b) {
+        if (!b.isMutable()) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b);
+        currentCount--;
+        if (currentCount == 0) {
+            bitmapReferenceCounter.remove(b);
+            final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());
+            Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);
+            if (available == null) {
+                available = new LinkedList<Bitmap>();
+                recycledBitmapsForSize.put(sizeKey, available);
+            }
+            available.add(b);
+        } else {
+            bitmapReferenceCounter.put(b, currentCount);
+        }
+    }
+
+    private static String getSizeKey(int width, int height) {
+        return ""_"" + width + ""_"" + height;
     }
 
     private static String getKey(String path){
@@ -227,7 +270,7 @@ public class PhotoManager {
     }
 
     private static String getKey(String path, int width, int height){
-        return sha1Hash(path) + ""_"" + String.valueOf(width) + ""_"" + String.valueOf(height);
+        return sha1Hash(path) + getSizeKey(width, height);
     }
 
     private static String sha1Hash(String toHash) {
","21 import java.util.LinkedList;
23 import java.util.Queue;
37     private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
38     private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();
44         memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
45             @Override
46             public void onPhotoRemoved(String key, Bitmap bitmap) {
47                 Log.d(""RECYCLE: onPhotoRemoved key="" + key + "" bitmap="" + bitmap);
48                 releaseBitmap(bitmap);
49             }
50         });
211                 memoryCache.put(key, resized);
212                 acquireBitmap(resized);
234 
235     public void acquireBitmap(Bitmap b) {
236         if (!b.isMutable()) return;
237 
238         Integer currentCount = bitmapReferenceCounter.get(b);
239         if (currentCount == null) {
240             currentCount = 0;
242         bitmapReferenceCounter.put(b, currentCount+1);
243     }
244 
245     public void releaseBitmap(Bitmap b) {
246         if (!b.isMutable()) return;
247 
248         Integer currentCount = bitmapReferenceCounter.get(b);
249         currentCount--;
250         if (currentCount == 0) {
251             bitmapReferenceCounter.remove(b);
252             final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());
253             Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);
254             if (available == null) {
255                 available = new LinkedList<Bitmap>();
256                 recycledBitmapsForSize.put(sizeKey, available);
257             }
258             available.add(b);
259         } else {
260             bitmapReferenceCounter.put(b, currentCount);
261         }
262     }
263 
264     private static String getSizeKey(int width, int height) {
265         return ""_"" + width + ""_"" + height;
273         return sha1Hash(path) + getSizeKey(width, height);
199                     memoryCache.put(key, resized);
230         return sha1Hash(path) + ""_"" + String.valueOf(width) + ""_"" + String.valueOf(height);",No
src\com\bumptech\photos\cache\LruPhotoCache.java,src\com\bumptech\photos\cache\LruPhotoCache.java,22219f2918d067387143a3eebe5a3252fac1b240,9f35fb44d12058cababa7d60c1de7b0f751824ac,Add reference counting methods for bitmaps,"@@ -19,6 +19,11 @@ import android.support.v4.util.LruCache;
 public class LruPhotoCache{
     private static final float SIZE_RATIO = 1f/8f;
     private final PhotoCache photoCache;
+    private PhotoRemovedListener photoRemovedListener;
+
+    public interface PhotoRemovedListener {
+        public void onPhotoRemoved(String key, Bitmap bitmap);
+    }
 
     /*
     Can only call after context is created (ie in onCreate or later...)
@@ -40,12 +45,25 @@ public class LruPhotoCache{
             //get the size, getByteCount() is API 12+...
             return value.getHeight() * value.getRowBytes();
         }
+
+        @Override
+        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
+            super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
+            Log.d(""RECYCLE entryRemoved evicted="" + evicted + "" oldValue="" + oldValue + "" newValue="" + newValue);
+            if (evicted && photoRemovedListener != null) {
+                photoRemovedListener.onPhotoRemoved(key, oldValue);
+            }
+        }
     }
 
     public LruPhotoCache(int size) {
         photoCache = new PhotoCache(size);
     }
 
+    public void setPhotoRemovedListener(PhotoRemovedListener listener) {
+        this.photoRemovedListener = listener;
+    }
+
     public void put(String key, Bitmap bitmap) {
         photoCache.put(key, bitmap);
     }
","22     private PhotoRemovedListener photoRemovedListener;
23 
24     public interface PhotoRemovedListener {
25         public void onPhotoRemoved(String key, Bitmap bitmap);
26     }
48 
49         @Override
50         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
51             super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
52             Log.d(""RECYCLE entryRemoved evicted="" + evicted + "" oldValue="" + oldValue + "" newValue="" + newValue);
53             if (evicted && photoRemovedListener != null) {
54                 photoRemovedListener.onPhotoRemoved(key, oldValue);
55             }
56         }
63     public void setPhotoRemovedListener(PhotoRemovedListener listener) {
64         this.photoRemovedListener = listener;
65     }
66 ",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,6ce02e8cd583210dcedfcdd748a1f9db5e64b765,22219f2918d067387143a3eebe5a3252fac1b240,"Cache bitmaps in lru and mutables in memory

Removes requirement not to use memory cache on
devices that use bitmap recycling because ref
counting prevents us from recyling a bitmap that
is being used for something else (either by
another view or by a cache). Also removes
requirement to pass in bitmap to be recycled to
photo manager, though adds the requirement that
views call acquire and release as they use and
release bitmaps","@@ -5,7 +5,6 @@
 package com.bumptech.photos;
 
 import android.graphics.Bitmap;
-import android.os.Build;
 import android.os.Handler;
 import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
@@ -39,7 +38,6 @@ public class PhotoManager {
 
     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
         this.backgroundHandler = backgroundHandler;
-        if (Build.VERSION.SDK_INT < 11)
         this.memoryCache = new LruPhotoCache(maxMemCacheSize);
         memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
             @Override
@@ -68,23 +66,19 @@ public class PhotoManager {
         return token;
     }
 
-    public Object getImage(String path, int width, int height, LoadedCallback cb) {
-        return getImage(path, width, height, null, cb);
-    }
-
     /**
      * Loads the image for the given id to nearly the given width and height maintaining the original proportions
      * @param path - the id of the image
      * @param width - the desired width in pixels
      * @param height - the desired height of the slice
-     * @param recycled - a mutable bitmap of the same width and height to be reused
      * @param cb - the callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object getImage(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+    public Object getImage(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
+            final Bitmap recycled = getRecycledBitmap(width, height);
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
@@ -96,9 +90,15 @@ public class PhotoManager {
         return token;
     }
 
-
-    public Object centerSlice(String path, int width, int height, LoadedCallback cb) {
-        return centerSlice(path, width, height, null, cb);
+    private Bitmap getRecycledBitmap(int width, int height) {
+        Bitmap result = null;
+        if (width != 0 && height != 0) {
+            Queue<Bitmap> available = recycledBitmapsForSize.get(getSizeKey(width, height));
+            if (available != null && available.size() > 0) {
+                result = available.remove();
+            }
+        }
+        return result;
     }
 
     /**
@@ -107,15 +107,15 @@ public class PhotoManager {
      * @param path - the id of the image
      * @param width - the desired width in pixels
      * @param height - the desired height of the slice
-     * @param recycled - a mutable bitmap of the same width and height to be reused
      * @param cb - the callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object centerSlice(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+    public Object centerSlice(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
+            final Bitmap recycled = getRecycledBitmap(width, height);
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
@@ -126,24 +126,20 @@ public class PhotoManager {
         return token;
     }
 
-    public Object fitCenter(String path, int width, int height, LoadedCallback cb) {
-        return fitCenter(path, width, height, null, cb);
-    }
-
     /**
      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
      * an area of width*height.
      * @param path - the id of the image
      * @param width - the width of the space
      * @param height - the height of the space
-     * @param recycled - a mutable bitmap of the same width and height to be reused
      * @param cb - the callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object fitCenter(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
+    public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
+            final Bitmap recycled = getRecycledBitmap(width, height);
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
@@ -157,13 +153,11 @@ public class PhotoManager {
 
     private boolean returnFromCache(String key, LoadedCallback cb) {
         boolean found = false;
-        if (Build.VERSION.SDK_INT < 11) {
         Bitmap inCache = memoryCache.get(key);
         if (inCache != null) {
             found = true;
             cb.loadCompleted(inCache);
         }
-        }
         return found;
     }
 
@@ -172,25 +166,19 @@ public class PhotoManager {
         private Object token;
         private Bitmap recycled;
         private LoadedCallback cb;
-        private boolean useDiskCache;
 
-        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb, boolean useDiskCache) {
+        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
             this.key = key;
             this.token = token;
             this.recycled = recycled;
             this.cb = cb;
-            this.useDiskCache = useDiskCache;
-        }
-
-        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
-            this(key, token, recycled, cb, true);
         }
 
         @Override
         public void onGet(InputStream is) {
             final Runnable task;
             final boolean inDiskCache = is != null;
-            final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, useDiskCache);
+            final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
             if (inDiskCache) {
                 task = resizer.loadAsIs(is, recycled, resizeCb);
             } else {
@@ -206,8 +194,6 @@ public class PhotoManager {
         return new PhotoStreamResizer.ResizeCallback() {
             @Override
             public void onResizeComplete(Bitmap resized) {
-                if (Build.VERSION.SDK_INT < 11) {
-                }
                 memoryCache.put(key, resized);
                 acquireBitmap(resized);
                 if (!inDiskCache && useDiskCache) {
","77     public Object getImage(final String path, final int width, final int height, final LoadedCallback cb){
81             final Bitmap recycled = getRecycledBitmap(width, height);
93     private Bitmap getRecycledBitmap(int width, int height) {
94         Bitmap result = null;
95         if (width != 0 && height != 0) {
96             Queue<Bitmap> available = recycledBitmapsForSize.get(getSizeKey(width, height));
97             if (available != null && available.size() > 0) {
98                 result = available.remove();
99             }
100         }
101         return result;
113     public Object centerSlice(final String path, final int width, final int height, final LoadedCallback cb){
117             final Bitmap recycled = getRecycledBitmap(width, height);
118             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
138     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
142             final Bitmap recycled = getRecycledBitmap(width, height);
170         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
181             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
8 import android.os.Build;
42         if (Build.VERSION.SDK_INT < 11)
71     public Object getImage(String path, int width, int height, LoadedCallback cb) {
72         return getImage(path, width, height, null, cb);
73     }
74 
80      * @param recycled - a mutable bitmap of the same width and height to be reused
84     public Object getImage(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
99 
100     public Object centerSlice(String path, int width, int height, LoadedCallback cb) {
101         return centerSlice(path, width, height, null, cb);
110      * @param recycled - a mutable bitmap of the same width and height to be reused
114     public Object centerSlice(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
118             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb, false) {
129     public Object fitCenter(String path, int width, int height, LoadedCallback cb) {
130         return fitCenter(path, width, height, null, cb);
131     }
132 
139      * @param recycled - a mutable bitmap of the same width and height to be reused
143     public Object fitCenter(final String path, final int width, final int height, final Bitmap recycled, final LoadedCallback cb){
160         if (Build.VERSION.SDK_INT < 11) {
166         }
175         private boolean useDiskCache;
177         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb, boolean useDiskCache) {
182             this.useDiskCache = useDiskCache;
183         }
184 
185         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
186             this(key, token, recycled, cb, true);
193             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, useDiskCache);
209                 if (Build.VERSION.SDK_INT < 11) {
210                 }",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,4cd65eb2366b162171d76f8df6dd47b9e13c8734,6ce02e8cd583210dcedfcdd748a1f9db5e64b765,"Only hash keys for disk cache

disk cache requires a subset of characters,
otherwise it doesn't matter. hashing is expensive
compared to concatenating strings, so use
concatentation when possible and only hash in
background.","@@ -13,9 +13,6 @@ import com.bumptech.photos.resize.PhotoStreamResizer;
 
 import java.io.File;
 import java.io.InputStream;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
@@ -248,7 +245,7 @@ public class PhotoManager {
     }
 
     private static String getSizeKey(int width, int height) {
-        return ""_"" + width + ""_"" + height;
+        return width + ""_"" + height;
     }
 
     private static String getKey(String path){
@@ -256,20 +253,10 @@ public class PhotoManager {
     }
 
     private static String getKey(String path, int width, int height){
-        return sha1Hash(path) + getSizeKey(width, height);
+        return getKey(path, getSizeKey(width, height));
     }
 
-    private static String sha1Hash(String toHash) {
-        String hash = null;
-        try {
-            byte[] bytes = toHash.getBytes();
-            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
-            digest.update(bytes, 0, bytes.length);
-            hash = new BigInteger(1, digest.digest()).toString(16);
-        } catch (NoSuchAlgorithmException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
-        }
-        return hash;
+    private static String getKey(String path, String sizeKey) {
+        return path + sizeKey;
     }
-
 }
","248         return width + ""_"" + height;
256         return getKey(path, getSizeKey(width, height));
259     private static String getKey(String path, String sizeKey) {
260         return path + sizeKey;
16 import java.math.BigInteger;
17 import java.security.MessageDigest;
18 import java.security.NoSuchAlgorithmException;
251         return ""_"" + width + ""_"" + height;
259         return sha1Hash(path) + getSizeKey(width, height);
262     private static String sha1Hash(String toHash) {
263         String hash = null;
264         try {
265             byte[] bytes = toHash.getBytes();
266             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
267             digest.update(bytes, 0, bytes.length);
268             hash = new BigInteger(1, digest.digest()).toString(16);
269         } catch (NoSuchAlgorithmException e) {
270             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
272         return hash;
273     }
274 ",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,4cd65eb2366b162171d76f8df6dd47b9e13c8734,6ce02e8cd583210dcedfcdd748a1f9db5e64b765,"Only hash keys for disk cache

disk cache requires a subset of characters,
otherwise it doesn't matter. hashing is expensive
compared to concatenating strings, so use
concatentation when possible and only hash in
background.","@@ -10,6 +10,9 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 
 /**
  * Created by IntelliJ IDEA.
@@ -47,17 +50,18 @@ public class PhotoDiskCache {
             @Override
             public void run() {
                 if (bitmap == null) return;
+                final String safeKey = sha1Hash(key);
 
                 Log.d(""DLRU: run put key="" + key);
                 DiskLruCache.Editor edit = null;
                 OutputStream out = null;
                 try {
-                    DiskLruCache.Snapshot snapshot = cache.get(key);
+                    DiskLruCache.Snapshot snapshot = cache.get(safeKey);
                     if (snapshot != null) {
                         Log.d(""DLRU: not putting, already exists key="" + key);
                         return;
                     }
-                    edit = cache.edit(key);
+                    edit = cache.edit(safeKey);
                     out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
                     bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
                     edit.commit();
@@ -89,9 +93,10 @@ public class PhotoDiskCache {
         return new Runnable() {
             @Override
             public void run() {
+                final String safeKey = sha1Hash(key);
                 InputStream result = null;
                 try {
-                    DiskLruCache.Snapshot snapshot = cache.get(key);
+                    DiskLruCache.Snapshot snapshot = cache.get(safeKey);
 
                     if (snapshot != null) {
                         result = snapshot.getInputStream(VALUE_COUNT - 1);
@@ -102,7 +107,7 @@ public class PhotoDiskCache {
                     Log.d(""DLRU: IOException? key="" + key);
                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                     try {
-                        cache.remove(key);
+                        cache.remove(safeKey);
                     } catch (IOException e1) {
                         Log.d(""DLRU: error removing bitmap key="" + key);
                         e1.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
@@ -119,4 +124,17 @@ public class PhotoDiskCache {
             }
         };
     }
+
+    private static String sha1Hash(String toHash) {
+        String hash = null;
+        try {
+            byte[] bytes = toHash.getBytes();
+            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
+            digest.update(bytes, 0, bytes.length);
+            hash = new BigInteger(1, digest.digest()).toString(16);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        return hash;
+    }
 }
","13 import java.math.BigInteger;
14 import java.security.MessageDigest;
15 import java.security.NoSuchAlgorithmException;
53                 final String safeKey = sha1Hash(key);
59                     DiskLruCache.Snapshot snapshot = cache.get(safeKey);
64                     edit = cache.edit(safeKey);
96                 final String safeKey = sha1Hash(key);
99                     DiskLruCache.Snapshot snapshot = cache.get(safeKey);
110                         cache.remove(safeKey);
127 
128     private static String sha1Hash(String toHash) {
129         String hash = null;
130         try {
131             byte[] bytes = toHash.getBytes();
132             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
133             digest.update(bytes, 0, bytes.length);
134             hash = new BigInteger(1, digest.digest()).toString(16);
135         } catch (NoSuchAlgorithmException e) {
136             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
137         }
138         return hash;
139     }
55                     DiskLruCache.Snapshot snapshot = cache.get(key);
60                     edit = cache.edit(key);
94                     DiskLruCache.Snapshot snapshot = cache.get(key);
105                         cache.remove(key);",No
src\com\bumptech\photos\resize\Utils.java,src\com\bumptech\photos\resize\Utils.java,9d3bcff816a033b2a8f9f93ae8d338c570fdec15,4cd65eb2366b162171d76f8df6dd47b9e13c8734,Refactor out method to get size of photo on disk,"@@ -145,6 +145,31 @@ public class Utils {
         return result;
     }
 
+    public static int[] getDimensions(String path) {
+        int[] dimens = new int[]{-1, -1};
+        try {
+            InputStream is = new BufferedInputStream(new FileInputStream(path));
+            dimens = getDimension(is);
+            is.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        } catch (IOException e) {
+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+        }
+        return dimens;
+    }
+
+    public static int[] getDimension(InputStream is) {
+        int originalWidth = -1;
+        int originalHeight = -1;
+        final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
+        decodeBoundsOptions.inJustDecodeBounds = true;
+        BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
+
+        originalWidth = decodeBoundsOptions.outWidth;
+        originalHeight = decodeBoundsOptions.outHeight;
+        return new int[] { originalWidth, originalHeight };
+    }
     //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
     //streams in to near, but not exactly at the desired width and height.
     public static Bitmap streamIn(String path, int width, int height) {
@@ -159,25 +184,18 @@ public class Utils {
 
         Bitmap result = null;
         try {
+            final int[] dimens = getDimensions(path);
+            final int originalWidth = dimens[0];
+            final int originalHeight = dimens[1];
+
+            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
+            int sampleSize = Math.min(originalHeight / height, originalWidth / width);
+
             final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
             // For further memory savings, you may want to consider using this option
             decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
             decodeBitmapOptions.inDither = false;
-            //avoid markInvalidated by creating two streams, rather than one and resetting it
-            //readLimit would have to be size of entire photo, which can be huge
-            InputStream first = new BufferedInputStream(new FileInputStream(path), 16384);
-
-            //find the dimensions of the actual image
-            final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
-            decodeBoundsOptions.inJustDecodeBounds = true;
-            BitmapFactory.decodeStream(first, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
-            first.close();
-
-            final int originalWidth = decodeBoundsOptions.outWidth;
-            final int originalHeight = decodeBoundsOptions.outHeight;
 
-            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-            int sampleSize = Math.min(originalHeight / height, originalWidth / width);
             InputStream second = new BufferedInputStream(new FileInputStream(path), 16384);
 
             decodeBitmapOptions.inSampleSize = sampleSize;
","148     public static int[] getDimensions(String path) {
149         int[] dimens = new int[]{-1, -1};
150         try {
151             InputStream is = new BufferedInputStream(new FileInputStream(path));
152             dimens = getDimension(is);
153             is.close();
154         } catch (FileNotFoundException e) {
155             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
156         } catch (IOException e) {
157             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
158         }
159         return dimens;
160     }
161 
162     public static int[] getDimension(InputStream is) {
163         int originalWidth = -1;
164         int originalHeight = -1;
165         final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
166         decodeBoundsOptions.inJustDecodeBounds = true;
167         BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
168 
169         originalWidth = decodeBoundsOptions.outWidth;
170         originalHeight = decodeBoundsOptions.outHeight;
171         return new int[] { originalWidth, originalHeight };
172     }
187             final int[] dimens = getDimensions(path);
188             final int originalWidth = dimens[0];
189             final int originalHeight = dimens[1];
190 
191             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
192             int sampleSize = Math.min(originalHeight / height, originalWidth / width);
193 
166             //avoid markInvalidated by creating two streams, rather than one and resetting it
167             //readLimit would have to be size of entire photo, which can be huge
168             InputStream first = new BufferedInputStream(new FileInputStream(path), 16384);
170             //find the dimensions of the actual image
171             final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
172             decodeBoundsOptions.inJustDecodeBounds = true;
173             BitmapFactory.decodeStream(first, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
174             first.close();
175 
176             final int originalWidth = decodeBoundsOptions.outWidth;
177             final int originalHeight = decodeBoundsOptions.outHeight;
178 
179             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
180             int sampleSize = Math.min(originalHeight / height, originalWidth / width);",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,da3bd5e1015d9c90c066ed4e9cd07d474650b4fa,9d3bcff816a033b2a8f9f93ae8d338c570fdec15,"Move getting recycled bitmaps into stream resizer

Lets us actually determine the size of the bitmap
we want to load and use that to see if a recycled
one is available. Otherwise we would have to pass
in values which would be difficult to keep track
of. Side affect is we need to get two input
different input streams from the disk cache, one
to check the size and one to actually load the
image.","@@ -9,14 +9,13 @@ import android.os.Handler;
 import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
 import com.bumptech.photos.cache.PhotoDiskCache;
+import com.bumptech.photos.cache.SizedBitmapCache;
 import com.bumptech.photos.resize.PhotoStreamResizer;
 
 import java.io.File;
 import java.io.InputStream;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.Map;
-import java.util.Queue;
 
 /**
  * Created by IntelliJ IDEA.
@@ -31,7 +30,7 @@ public class PhotoManager {
     private PhotoStreamResizer resizer;
     private Handler backgroundHandler;
     private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
-    private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();
+    private SizedBitmapCache bitmapCache = new SizedBitmapCache();
 
     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
         this.backgroundHandler = backgroundHandler;
@@ -44,7 +43,7 @@ public class PhotoManager {
             }
         });
         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
-        this.resizer = new PhotoStreamResizer(mainHandler);
+        this.resizer = new PhotoStreamResizer(mainHandler, bitmapCache);
     }
 
     /**
@@ -75,8 +74,7 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            final Bitmap recycled = getRecycledBitmap(width, height);
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.loadApproximate(path, width, height, resizeCallback);
@@ -87,17 +85,6 @@ public class PhotoManager {
         return token;
     }
 
-    private Bitmap getRecycledBitmap(int width, int height) {
-        Bitmap result = null;
-        if (width != 0 && height != 0) {
-            Queue<Bitmap> available = recycledBitmapsForSize.get(getSizeKey(width, height));
-            if (available != null && available.size() > 0) {
-                result = available.remove();
-            }
-        }
-        return result;
-    }
-
     /**
      * Loads the image for the given id, resizes it to be exactly width pixels wide keeping proportions,
      * and then returns a section from the center of image exactly height pixels tall
@@ -111,8 +98,7 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            final Bitmap recycled = getRecycledBitmap(width, height);
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
@@ -136,8 +122,7 @@ public class PhotoManager {
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
-            final Bitmap recycled = getRecycledBitmap(width, height);
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
+            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
                     return resizer.fitInSpace(path, width, height, resizeCallback);
@@ -159,25 +144,23 @@ public class PhotoManager {
     }
 
     private abstract class DiskCacheCallback implements PhotoDiskCache.GetCallback {
-        private String key;
         private Object token;
-        private Bitmap recycled;
         private LoadedCallback cb;
+        private final String key;
 
-        public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
+        public DiskCacheCallback(String key, Object token, LoadedCallback cb) {
             this.key = key;
             this.token = token;
-            this.recycled = recycled;
             this.cb = cb;
         }
 
         @Override
-        public void onGet(InputStream is) {
+        public void onGet(InputStream is1, InputStream is2) {
             final Runnable task;
-            final boolean inDiskCache = is != null;
+            final boolean inDiskCache = is1 != null && is2 != null;
             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
             if (inDiskCache) {
-                task = resizer.loadAsIs(is, recycled, resizeCb);
+                task = resizer.loadAsIs(is1, is2, resizeCb);
             } else {
                 task = resizeIfNotFound(resizeCb);
             }
@@ -232,13 +215,7 @@ public class PhotoManager {
         currentCount--;
         if (currentCount == 0) {
             bitmapReferenceCounter.remove(b);
-            final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());
-            Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);
-            if (available == null) {
-                available = new LinkedList<Bitmap>();
-                recycledBitmapsForSize.put(sizeKey, available);
-            }
-            available.add(b);
+            bitmapCache.put(b);
         } else {
             bitmapReferenceCounter.put(b, currentCount);
         }
","12 import com.bumptech.photos.cache.SizedBitmapCache;
33     private SizedBitmapCache bitmapCache = new SizedBitmapCache();
46         this.resizer = new PhotoStreamResizer(mainHandler, bitmapCache);
77             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
101             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
125             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
149         private final String key;
151         public DiskCacheCallback(String key, Object token, LoadedCallback cb) {
158         public void onGet(InputStream is1, InputStream is2) {
160             final boolean inDiskCache = is1 != null && is2 != null;
163                 task = resizer.loadAsIs(is1, is2, resizeCb);
218             bitmapCache.put(b);
17 import java.util.LinkedList;
19 import java.util.Queue;
34     private Map<String, Queue<Bitmap>> recycledBitmapsForSize = new HashMap<String, Queue<Bitmap>>();
47         this.resizer = new PhotoStreamResizer(mainHandler);
78             final Bitmap recycled = getRecycledBitmap(width, height);
79             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
90     private Bitmap getRecycledBitmap(int width, int height) {
91         Bitmap result = null;
92         if (width != 0 && height != 0) {
93             Queue<Bitmap> available = recycledBitmapsForSize.get(getSizeKey(width, height));
94             if (available != null && available.size() > 0) {
95                 result = available.remove();
96             }
97         }
98         return result;
99     }
100 
114             final Bitmap recycled = getRecycledBitmap(width, height);
115             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
139             final Bitmap recycled = getRecycledBitmap(width, height);
140             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, recycled, cb) {
162         private String key;
164         private Bitmap recycled;
167         public DiskCacheCallback(String key, Object token, Bitmap recycled, LoadedCallback cb) {
170             this.recycled = recycled;
175         public void onGet(InputStream is) {
177             final boolean inDiskCache = is != null;
180                 task = resizer.loadAsIs(is, recycled, resizeCb);
235             final String sizeKey = getSizeKey(b.getWidth(), b.getHeight());
236             Queue<Bitmap> available = recycledBitmapsForSize.get(sizeKey);
237             if (available == null) {
238                 available = new LinkedList<Bitmap>();
239                 recycledBitmapsForSize.put(sizeKey, available);
240             }
241             available.add(b);",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,da3bd5e1015d9c90c066ed4e9cd07d474650b4fa,9d3bcff816a033b2a8f9f93ae8d338c570fdec15,"Move getting recycled bitmaps into stream resizer

Lets us actually determine the size of the bitmap
we want to load and use that to see if a recycled
one is available. Otherwise we would have to pass
in values which would be difficult to keep track
of. Side affect is we need to get two input
different input streams from the disk cache, one
to check the size and one to actually load the
image.","@@ -30,7 +30,7 @@ public class PhotoDiskCache {
     private Handler putHandler;
 
     public interface GetCallback {
-        public void onGet(InputStream is);
+        public void onGet(InputStream is1, InputStream is2);
     };
 
     public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
@@ -93,16 +93,27 @@ public class PhotoDiskCache {
         return new Runnable() {
             @Override
             public void run() {
+                //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
                 final String safeKey = sha1Hash(key);
-                InputStream result = null;
+                InputStream result1 = null;
+                InputStream result2 = null;
                 try {
-                    DiskLruCache.Snapshot snapshot = cache.get(safeKey);
+                    DiskLruCache.Snapshot snapshot1 = cache.get(safeKey);
 
-                    if (snapshot != null) {
-                        result = snapshot.getInputStream(VALUE_COUNT - 1);
+                    if (snapshot1 != null) {
+                        result1 = snapshot1.getInputStream(VALUE_COUNT - 1);
+                    } else {
+                        Log.d(""DLRU: not found key="" + key);
+                    }
+                     DiskLruCache.Snapshot snapshot2 = cache.get(safeKey);
+
+                    if (snapshot2 != null) {
+                        result2 = snapshot2.getInputStream(VALUE_COUNT - 1);
                     } else {
                         Log.d(""DLRU: not found key="" + key);
                     }
+
+
                 } catch (IOException e) {
                     Log.d(""DLRU: IOException? key="" + key);
                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
@@ -114,11 +125,12 @@ public class PhotoDiskCache {
                     }
                 }
 
-                final InputStream finalResult = result;
+                final InputStream finalResult1 = result1;
+                final InputStream finalResult2 = result2;
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        cb.onGet(finalResult);
+                        cb.onGet(finalResult1, finalResult2);
                     }
                 });
             }
","33         public void onGet(InputStream is1, InputStream is2);
96                 //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
98                 InputStream result1 = null;
99                 InputStream result2 = null;
101                     DiskLruCache.Snapshot snapshot1 = cache.get(safeKey);
103                     if (snapshot1 != null) {
104                         result1 = snapshot1.getInputStream(VALUE_COUNT - 1);
108                      DiskLruCache.Snapshot snapshot2 = cache.get(safeKey);
109 
110                     if (snapshot2 != null) {
111                         result2 = snapshot2.getInputStream(VALUE_COUNT - 1);
112                     } else {
113                         Log.d(""DLRU: not found key="" + key);
114                     }
115 
116 
128                 final InputStream finalResult1 = result1;
129                 final InputStream finalResult2 = result2;
133                         cb.onGet(finalResult1, finalResult2);
33         public void onGet(InputStream is);
97                 InputStream result = null;
99                     DiskLruCache.Snapshot snapshot = cache.get(safeKey);
101                     if (snapshot != null) {
102                         result = snapshot.getInputStream(VALUE_COUNT - 1);
117                 final InputStream finalResult = result;
121                         cb.onGet(finalResult);",No
,src\com\bumptech\photos\cache\SizedBitmapCache.java,da3bd5e1015d9c90c066ed4e9cd07d474650b4fa,9d3bcff816a033b2a8f9f93ae8d338c570fdec15,"Move getting recycled bitmaps into stream resizer

Lets us actually determine the size of the bitmap
we want to load and use that to see if a recycled
one is available. Otherwise we would have to pass
in values which would be difficult to keep track
of. Side affect is we need to get two input
different input streams from the disk cache, one
to check the size and one to actually load the
image.","@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.cache;
+
+import android.graphics.Bitmap;
+import com.bumptech.photos.util.Log;
+
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 4:31 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class SizedBitmapCache {
+    private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
+
+    public void put(Bitmap bitmap) {
+        final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
+        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
+        if (available == null) {
+            available = new LinkedList<Bitmap>();
+            availableBitmaps.put(sizeKey, available);
+        }
+
+        available.add(bitmap);
+        Log.d(""SBC: added bitmap sizeKey="" + sizeKey + "" available="" + available.size());
+    }
+
+    public Bitmap get(int width, int height) {
+        final String sizeKey = getSizeKey(width, height);
+        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
+        if (available == null || available.size() == 0) {
+            return null;
+        } else {
+            Log.d(""SBC: removed bitmap sizeKey="" + sizeKey + "" available="" + (available.size()-1));
+            return available.remove();
+        }
+    }
+
+    private static final String getSizeKey(int width, int height) {
+        return width + ""_"" + height;
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.cache;
6 
7 import android.graphics.Bitmap;
8 import com.bumptech.photos.util.Log;
9 
10 import java.util.HashMap;
11 import java.util.LinkedList;
12 import java.util.Map;
13 import java.util.Queue;
14 
15 /**
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/25/12
19  * Time: 4:31 PM
20  * To change this template use File | Settings | File Templates.
21  */
22 public class SizedBitmapCache {
23     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
24 
25     public void put(Bitmap bitmap) {
26         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
27         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
28         if (available == null) {
29             available = new LinkedList<Bitmap>();
30             availableBitmaps.put(sizeKey, available);
31         }
32 
33         available.add(bitmap);
34         Log.d(""SBC: added bitmap sizeKey="" + sizeKey + "" available="" + available.size());
35     }
36 
37     public Bitmap get(int width, int height) {
38         final String sizeKey = getSizeKey(width, height);
39         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
40         if (available == null || available.size() == 0) {
41             return null;
42         } else {
43             Log.d(""SBC: removed bitmap sizeKey="" + sizeKey + "" available="" + (available.size()-1));
44             return available.remove();
45         }
46     }
47 
48     private static final String getSizeKey(int width, int height) {
49         return width + ""_"" + height;
50     }
51 }",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,da3bd5e1015d9c90c066ed4e9cd07d474650b4fa,9d3bcff816a033b2a8f9f93ae8d338c570fdec15,"Move getting recycled bitmaps into stream resizer

Lets us actually determine the size of the bitmap
we want to load and use that to see if a recycled
one is available. Otherwise we would have to pass
in values which would be difficult to keep track
of. Side affect is we need to get two input
different input streams from the disk cache, one
to check the size and one to actually load the
image.","@@ -4,8 +4,11 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
+import android.os.Build;
 import android.os.Handler;
+import com.bumptech.photos.cache.SizedBitmapCache;
 
+import java.io.IOException;
 import java.io.InputStream;
 
 /**
@@ -13,22 +16,25 @@ import java.io.InputStream;
  *
  */
 public class PhotoStreamResizer {
+    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private Handler mainHandler;
+    private final SizedBitmapCache bitmapCache;
 
     public interface ResizeCallback {
         void onResizeComplete(Bitmap resized);
         void onResizeFailed(Exception e);
     }
 
-    public PhotoStreamResizer(Handler mainHandler){
+    public PhotoStreamResizer(Handler mainHandler, SizedBitmapCache bitmapCache){
         this.mainHandler = mainHandler;
+        this.bitmapCache = bitmapCache;
     }
 
     public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
-        return new StreamResizeRunnable(callback) {
+        return new SimpleStreamResizeRunnable(callback) {
             @Override
-            public Bitmap resize() {
+            public Bitmap resize(Bitmap recycled) {
                 Bitmap streamed = Utils.streamIn(path, width, height);
 
                 if (streamed.getWidth() == width && streamed.getHeight() == height) {
@@ -41,9 +47,9 @@ public class PhotoStreamResizer {
     }
 
     public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
-        return new StreamResizeRunnable(callback) {
+        return new SimpleStreamResizeRunnable(callback) {
             @Override
-            public Bitmap resize() {
+            public Bitmap resize(Bitmap recycled) {
                 final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
                 return Utils.fitInSpace(streamed, width, height);
             }
@@ -51,47 +57,90 @@ public class PhotoStreamResizer {
     }
 
     public Runnable loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
-        return new StreamResizeRunnable(callback) {
+        return new SimpleStreamResizeRunnable(callback) {
+
             @Override
-            public Bitmap resize() {
+            public Bitmap resize(Bitmap recycled) {
                 return Utils.streamIn(path, width, height);
             }
         };
     }
 
-    public Runnable loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
+    public Runnable loadAsIs(final InputStream is1, final InputStream is2, final ResizeCallback callback) {
         return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap resize() {
-                return Utils.load(is, recycle);
+            public Bitmap getRecycledBitmap() {
+                int[] dimens = new int[] {-1, -1};
+                try {
+                    dimens = Utils.getDimension(is1);
+                } finally {
+                    try {
+                        is1.close();
+                    } catch (IOException e) {
+                        e.printStackTrace();
                     }
-        };
+                }
+                return bitmapCache.get(dimens[0], dimens[1]);
             }
 
-    public Runnable loadAsIs(String path, ResizeCallback callback){
-        return loadAsIs(path, null, callback);
+            @Override
+            public Bitmap resize(Bitmap recycled) {
+                Bitmap resized = null;
+                try {
+                    resized = Utils.load(is2, recycled);
+                } finally {
+                    try {
+                        is2.close();
+                    } catch (IOException e) {
+                    }
+                }
+                return resized;
+            }
+        };
     }
 
-    public Runnable loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
+    public Runnable loadAsIs(final String path, ResizeCallback callback){
         return new StreamResizeRunnable(callback) {
             @Override
-            public Bitmap resize() {
+            public Bitmap getRecycledBitmap() {
+                int[] dimens = Utils.getDimensions(path);
+                return bitmapCache.get(dimens[0], dimens[1]);
+            }
+
+            @Override
+            public Bitmap resize(Bitmap recycled) {
                 return Utils.load(path, recycled);
             }
         };
     };
 
+    private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
+
+        public SimpleStreamResizeRunnable(ResizeCallback callback) {
+            super(callback);
+        }
+
+        @Override
+        public final Bitmap getRecycledBitmap() {
+            return null;
+        }
+    }
+
     private abstract class StreamResizeRunnable implements Runnable {
         private final PhotoStreamResizer.ResizeCallback callback;
 
-        public StreamResizeRunnable(PhotoStreamResizer.ResizeCallback callback) {
+        public StreamResizeRunnable(ResizeCallback callback) {
             this.callback = callback;
         }
 
         @Override
         public final void run() {
             try {
-                final Bitmap result = resize();
+                Bitmap recycled = null;
+                if (CAN_RECYCLE) {
+                    recycled = getRecycledBitmap();
+                }
+                final Bitmap result = resize(recycled);
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -109,6 +158,8 @@ public class PhotoStreamResizer {
             }
         }
 
-        public abstract Bitmap resize();
+        public abstract Bitmap getRecycledBitmap();
+
+        public abstract Bitmap resize(Bitmap recycled);
     }
 }
","7 import android.os.Build;
9 import com.bumptech.photos.cache.SizedBitmapCache;
11 import java.io.IOException;
19     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
22     private final SizedBitmapCache bitmapCache;
29     public PhotoStreamResizer(Handler mainHandler, SizedBitmapCache bitmapCache){
31         this.bitmapCache = bitmapCache;
35         return new SimpleStreamResizeRunnable(callback) {
37             public Bitmap resize(Bitmap recycled) {
50         return new SimpleStreamResizeRunnable(callback) {
52             public Bitmap resize(Bitmap recycled) {
60         return new SimpleStreamResizeRunnable(callback) {
61 
63             public Bitmap resize(Bitmap recycled) {
69     public Runnable loadAsIs(final InputStream is1, final InputStream is2, final ResizeCallback callback) {
72             public Bitmap getRecycledBitmap() {
73                 int[] dimens = new int[] {-1, -1};
74                 try {
75                     dimens = Utils.getDimension(is1);
76                 } finally {
77                     try {
78                         is1.close();
79                     } catch (IOException e) {
80                         e.printStackTrace();
81                     }
82                 }
83                 return bitmapCache.get(dimens[0], dimens[1]);
84             }
85 
86             @Override
87             public Bitmap resize(Bitmap recycled) {
88                 Bitmap resized = null;
89                 try {
90                     resized = Utils.load(is2, recycled);
91                 } finally {
92                     try {
93                         is2.close();
94                     } catch (IOException e) {
95                     }
96                 }
97                 return resized;
102     public Runnable loadAsIs(final String path, ResizeCallback callback){
105             public Bitmap getRecycledBitmap() {
106                 int[] dimens = Utils.getDimensions(path);
107                 return bitmapCache.get(dimens[0], dimens[1]);
108             }
109 
110             @Override
111             public Bitmap resize(Bitmap recycled) {
117     private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
118 
119         public SimpleStreamResizeRunnable(ResizeCallback callback) {
120             super(callback);
121         }
122 
123         @Override
124         public final Bitmap getRecycledBitmap() {
125             return null;
126         }
127     }
128 
132         public StreamResizeRunnable(ResizeCallback callback) {
139                 Bitmap recycled = null;
140                 if (CAN_RECYCLE) {
141                     recycled = getRecycledBitmap();
142                 }
143                 final Bitmap result = resize(recycled);
161         public abstract Bitmap getRecycledBitmap();
162 
163         public abstract Bitmap resize(Bitmap recycled);
24     public PhotoStreamResizer(Handler mainHandler){
29         return new StreamResizeRunnable(callback) {
31             public Bitmap resize() {
44         return new StreamResizeRunnable(callback) {
46             public Bitmap resize() {
54         return new StreamResizeRunnable(callback) {
56             public Bitmap resize() {
62     public Runnable loadAsIs(final InputStream is, final Bitmap recycle, final ResizeCallback callback) {
65             public Bitmap resize() {
66                 return Utils.load(is, recycle);
71     public Runnable loadAsIs(String path, ResizeCallback callback){
72         return loadAsIs(path, null, callback);
73     }
74 
75     public Runnable loadAsIs(final String path, final Bitmap recycled, ResizeCallback callback){
78             public Bitmap resize() {
87         public StreamResizeRunnable(PhotoStreamResizer.ResizeCallback callback) {
94                 final Bitmap result = resize();
112         public abstract Bitmap resize();",No
src\com\bumptech\photos\cache\SizedBitmapCache.java,src\com\bumptech\photos\cache\SizedBitmapCache.java,37f4761b3d7d008f7adc4f866e383cf91fb5431a,da3bd5e1015d9c90c066ed4e9cd07d474650b4fa,"Add a max # of bitmaps per size to store

Also remove some logging","@@ -5,7 +5,6 @@
 package com.bumptech.photos.cache;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.util.Log;
 
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -20,6 +19,7 @@ import java.util.Queue;
  * To change this template use File | Settings | File Templates.
  */
 public class SizedBitmapCache {
+    private static final int MAX_PER_SIZE = 5;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
 
     public void put(Bitmap bitmap) {
@@ -30,8 +30,9 @@ public class SizedBitmapCache {
             availableBitmaps.put(sizeKey, available);
         }
 
+        if (available.size() < MAX_PER_SIZE) {
             available.add(bitmap);
-        Log.d(""SBC: added bitmap sizeKey="" + sizeKey + "" available="" + available.size());
+        }
     }
 
     public Bitmap get(int width, int height) {
@@ -40,7 +41,6 @@ public class SizedBitmapCache {
         if (available == null || available.size() == 0) {
             return null;
         } else {
-            Log.d(""SBC: removed bitmap sizeKey="" + sizeKey + "" available="" + (available.size()-1));
             return available.remove();
         }
     }
","22     private static final int MAX_PER_SIZE = 5;
33         if (available.size() < MAX_PER_SIZE) {
35         }
8 import com.bumptech.photos.util.Log;
34         Log.d(""SBC: added bitmap sizeKey="" + sizeKey + "" available="" + available.size());
43             Log.d(""SBC: removed bitmap sizeKey="" + sizeKey + "" available="" + (available.size()-1));",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,2bb9f85da9e0449459869e09fc11e6cc7666ed79,37f4761b3d7d008f7adc4f866e383cf91fb5431a,Minor code cleanup,"@@ -38,7 +38,6 @@ public class PhotoManager {
         memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
             @Override
             public void onPhotoRemoved(String key, Bitmap bitmap) {
-                Log.d(""RECYCLE: onPhotoRemoved key="" + key + "" bitmap="" + bitmap);
                 releaseBitmap(bitmap);
             }
         });
@@ -94,7 +93,7 @@ public class PhotoManager {
      * @param cb - the callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object centerSlice(final String path, final int width, final int height, final LoadedCallback cb){
+    public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height);
         if (!returnFromCache(key, cb)) {
@@ -209,10 +208,7 @@ public class PhotoManager {
     }
 
     public void releaseBitmap(Bitmap b) {
-        if (!b.isMutable()) return;
-
-        Integer currentCount = bitmapReferenceCounter.get(b);
-        currentCount--;
+        Integer currentCount = bitmapReferenceCounter.get(b) - 1;
         if (currentCount == 0) {
             bitmapReferenceCounter.remove(b);
             bitmapCache.put(b);
@@ -221,19 +217,11 @@ public class PhotoManager {
         }
     }
 
-    private static String getSizeKey(int width, int height) {
-        return width + ""_"" + height;
-    }
-
     private static String getKey(String path){
         return getKey(path, 0, 0);
     }
 
     private static String getKey(String path, int width, int height){
-        return getKey(path, getSizeKey(width, height));
-    }
-
-    private static String getKey(String path, String sizeKey) {
-        return path + sizeKey;
+        return path + width + ""_"" + height;
     }
 }
","96     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
211         Integer currentCount = bitmapReferenceCounter.get(b) - 1;
225         return path + width + ""_"" + height;
41                 Log.d(""RECYCLE: onPhotoRemoved key="" + key + "" bitmap="" + bitmap);
97     public Object centerSlice(final String path, final int width, final int height, final LoadedCallback cb){
212         if (!b.isMutable()) return;
213 
214         Integer currentCount = bitmapReferenceCounter.get(b);
215         currentCount--;
224     private static String getSizeKey(int width, int height) {
225         return width + ""_"" + height;
226     }
227 
233         return getKey(path, getSizeKey(width, height));
234     }
235 
236     private static String getKey(String path, String sizeKey) {
237         return path + sizeKey;",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,2bb9f85da9e0449459869e09fc11e6cc7666ed79,37f4761b3d7d008f7adc4f866e383cf91fb5431a,Minor code cleanup,"@@ -22,12 +22,10 @@ import java.security.NoSuchAlgorithmException;
  * To change this template use File | Settings | File Templates.
  */
 public class PhotoDiskCache {
-    private static int APP_VERSION = 0;
-    private static int VALUE_COUNT = 1; //values per cache entry
+    private final static int APP_VERSION = 0;
+    private final static int VALUE_COUNT = 1; //values per cache entry
     private DiskLruCache cache;
     private Handler mainHandler;
-    private Handler getHandler;
-    private Handler putHandler;
 
     public interface GetCallback {
         public void onGet(InputStream is1, InputStream is2);
@@ -39,20 +37,16 @@ public class PhotoDiskCache {
         } catch (IOException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
-        this.putHandler = loadHandler;
         this.mainHandler = mainHandler;
-        this.getHandler = loadHandler;
     }
 
     public Runnable put(final String key, final Bitmap bitmap) {
-        Log.d(""DLRU: doPut key="" + key);
         return new Runnable() {
             @Override
             public void run() {
                 if (bitmap == null) return;
                 final String safeKey = sha1Hash(key);
 
-                Log.d(""DLRU: run put key="" + key);
                 DiskLruCache.Editor edit = null;
                 OutputStream out = null;
                 try {
@@ -89,7 +83,6 @@ public class PhotoDiskCache {
     }
 
     public Runnable get(final String key, final GetCallback cb) {
-        Log.d(""DLRU: get key="" + key);
         return new Runnable() {
             @Override
             public void run() {
","25     private final static int APP_VERSION = 0;
26     private final static int VALUE_COUNT = 1; //values per cache entry
25     private static int APP_VERSION = 0;
26     private static int VALUE_COUNT = 1; //values per cache entry
29     private Handler getHandler;
30     private Handler putHandler;
42         this.putHandler = loadHandler;
44         this.getHandler = loadHandler;
48         Log.d(""DLRU: doPut key="" + key);
55                 Log.d(""DLRU: run put key="" + key);
92         Log.d(""DLRU: get key="" + key);",No
src\com\bumptech\photos\resize\Utils.java,src\com\bumptech\photos\resize\Utils.java,2bb9f85da9e0449459869e09fc11e6cc7666ed79,37f4761b3d7d008f7adc4f866e383cf91fb5431a,Minor code cleanup,"@@ -160,15 +160,10 @@ public class Utils {
     }
 
     public static int[] getDimension(InputStream is) {
-        int originalWidth = -1;
-        int originalHeight = -1;
         final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
         decodeBoundsOptions.inJustDecodeBounds = true;
         BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
-
-        originalWidth = decodeBoundsOptions.outWidth;
-        originalHeight = decodeBoundsOptions.outHeight;
-        return new int[] { originalWidth, originalHeight };
+        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
     //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
     //streams in to near, but not exactly at the desired width and height.
@@ -196,18 +191,17 @@ public class Utils {
             decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
             decodeBitmapOptions.inDither = false;
 
-            InputStream second = new BufferedInputStream(new FileInputStream(path), 16384);
+            InputStream is = new BufferedInputStream(new FileInputStream(path), 16384);
 
             decodeBitmapOptions.inSampleSize = sampleSize;
             if (Build.VERSION.SDK_INT > 11) {
                 decodeBitmapOptions.inMutable = true;
             }
-            Log.d(""PSR: Loading image with sample size: "" + sampleSize);
-            result = BitmapFactory.decodeStream(second, null, decodeBitmapOptions);
+            result = BitmapFactory.decodeStream(is, null, decodeBitmapOptions);
             if (orientation != 0) {
                 result = Photo.rotateImage(result, orientation);
             }
-            second.close();
+            is.close();
         } catch (Exception e){
             Log.d(""PSR: error decoding image: "" + e);
         } catch (OutOfMemoryError e){
","166         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
194             InputStream is = new BufferedInputStream(new FileInputStream(path), 16384);
200             result = BitmapFactory.decodeStream(is, null, decodeBitmapOptions);
204             is.close();
163         int originalWidth = -1;
164         int originalHeight = -1;
168 
169         originalWidth = decodeBoundsOptions.outWidth;
170         originalHeight = decodeBoundsOptions.outHeight;
171         return new int[] { originalWidth, originalHeight };
199             InputStream second = new BufferedInputStream(new FileInputStream(path), 16384);
205             Log.d(""PSR: Loading image with sample size: "" + sampleSize);
206             result = BitmapFactory.decodeStream(second, null, decodeBitmapOptions);
210             second.close();",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,1950a4bf64cbd8a20bb0dbff34a8e6914e0f56ed,2bb9f85da9e0449459869e09fc11e6cc7666ed79,"Allow PSR to not use recycled bitmaps

Increases the standalone utility of the class","@@ -26,6 +26,10 @@ public class PhotoStreamResizer {
         void onResizeFailed(Exception e);
     }
 
+    public PhotoStreamResizer(Handler mainHandler) {
+        this(mainHandler, null);
+    }
+
     public PhotoStreamResizer(Handler mainHandler, SizedBitmapCache bitmapCache){
         this.mainHandler = mainHandler;
         this.bitmapCache = bitmapCache;
@@ -33,6 +37,7 @@ public class PhotoStreamResizer {
 
     public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
         return new SimpleStreamResizeRunnable(callback) {
+
             @Override
             public Bitmap resize(Bitmap recycled) {
                 Bitmap streamed = Utils.streamIn(path, width, height);
@@ -48,6 +53,7 @@ public class PhotoStreamResizer {
 
     public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
         return new SimpleStreamResizeRunnable(callback) {
+
             @Override
             public Bitmap resize(Bitmap recycled) {
                 final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
@@ -68,6 +74,7 @@ public class PhotoStreamResizer {
 
     public Runnable loadAsIs(final InputStream is1, final InputStream is2, final ResizeCallback callback) {
         return new StreamResizeRunnable(callback) {
+
             @Override
             public Bitmap getRecycledBitmap() {
                 int[] dimens = new int[] {-1, -1};
@@ -137,7 +144,7 @@ public class PhotoStreamResizer {
         public final void run() {
             try {
                 Bitmap recycled = null;
-                if (CAN_RECYCLE) {
+                if (CAN_RECYCLE && bitmapCache != null) {
                     recycled = getRecycledBitmap();
                 }
                 final Bitmap result = resize(recycled);
","29     public PhotoStreamResizer(Handler mainHandler) {
30         this(mainHandler, null);
31     }
32 
40 
56 
77 
147                 if (CAN_RECYCLE && bitmapCache != null) {
140                 if (CAN_RECYCLE) {",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,50eb50f03911d9270670ea68bf3af29043069bf2,1950a4bf64cbd8a20bb0dbff34a8e6914e0f56ed,"Allow caching of same photo in different types

Adds an enum to be appended onto keys so that keys
identify not just the size but also the type of
type.","@@ -32,6 +32,13 @@ public class PhotoManager {
     private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
     private SizedBitmapCache bitmapCache = new SizedBitmapCache();
 
+    private enum ResizeType {
+        CENTER_CROP,
+        FIT_CENTER,
+        APPROXIMATE,
+        AS_IS
+    }
+
     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
         this.backgroundHandler = backgroundHandler;
         this.memoryCache = new LruPhotoCache(maxMemCacheSize);
@@ -53,7 +60,7 @@ public class PhotoManager {
      */
     public Object getImage(final String path, final LoadedCallback cb){
         final Object token = cb;
-        final String key = getKey(path);
+        final String key = getKey(path, 0, 0, ResizeType.AS_IS);
         if (!returnFromCache(key, cb)) {
             final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));
             postJob(task, token);
@@ -71,7 +78,7 @@ public class PhotoManager {
      */
     public Object getImage(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
-        final String key = getKey(path, width, height);
+        final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
@@ -95,7 +102,7 @@ public class PhotoManager {
      */
     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
-        final String key = getKey(path, width, height);
+        final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
@@ -119,7 +126,7 @@ public class PhotoManager {
      */
     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
-        final String key = getKey(path, width, height);
+        final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
@@ -217,11 +224,7 @@ public class PhotoManager {
         }
     }
 
-    private static String getKey(String path){
-        return getKey(path, 0, 0);
-    }
-
-    private static String getKey(String path, int width, int height){
-        return path + width + ""_"" + height;
+    private static String getKey(String path, int width, int height, ResizeType type){
+        return path + width + ""_"" + height + type.name();
     }
 }
","35     private enum ResizeType {
36         CENTER_CROP,
37         FIT_CENTER,
38         APPROXIMATE,
39         AS_IS
40     }
41 
63         final String key = getKey(path, 0, 0, ResizeType.AS_IS);
81         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
105         final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
129         final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
227     private static String getKey(String path, int width, int height, ResizeType type){
228         return path + width + ""_"" + height + type.name();
56         final String key = getKey(path);
74         final String key = getKey(path, width, height);
98         final String key = getKey(path, width, height);
122         final String key = getKey(path, width, height);
220     private static String getKey(String path){
221         return getKey(path, 0, 0);
222     }
223 
224     private static String getKey(String path, int width, int height){
225         return path + width + ""_"" + height;",No
src\com\bumptech\photos\LoadedCallback.java,src\com\bumptech\photos\LoadedCallback.java,e7b292bab443e478a37af8f68cd7f7c338686b61,50eb50f03911d9270670ea68bf3af29043069bf2,"Replace ResizeCallback with LoadedCallback

removes a redundant callback since both had 
essentially the same two methods.","@@ -14,6 +14,6 @@ import android.graphics.Bitmap;
  * To change this template use File | Settings | File Templates.
  */
 public interface LoadedCallback {
-    public void loadCompleted(Bitmap loaded);
+    public void onLoadCompleted(Bitmap loaded);
     public void onLoadFailed(Exception e);
 }
","17     public void onLoadCompleted(Bitmap loaded);
17     public void loadCompleted(Bitmap loaded);",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,e7b292bab443e478a37af8f68cd7f7c338686b61,50eb50f03911d9270670ea68bf3af29043069bf2,"Replace ResizeCallback with LoadedCallback

removes a redundant callback since both had 
essentially the same two methods.","@@ -82,7 +82,7 @@ public class PhotoManager {
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
-                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
                     return resizer.loadApproximate(path, width, height, resizeCallback);
                 }
             });
@@ -106,7 +106,7 @@ public class PhotoManager {
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
-                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
                 }
             });
@@ -130,7 +130,7 @@ public class PhotoManager {
         if (!returnFromCache(key, cb)) {
             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
                 @Override
-                public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
+                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
                     return resizer.fitInSpace(path, width, height, resizeCallback);
                 }
             });
@@ -144,7 +144,7 @@ public class PhotoManager {
         Bitmap inCache = memoryCache.get(key);
         if (inCache != null) {
             found = true;
-            cb.loadCompleted(inCache);
+            cb.onLoadCompleted(inCache);
         }
         return found;
     }
@@ -164,7 +164,7 @@ public class PhotoManager {
         public void onGet(InputStream is1, InputStream is2) {
             final Runnable task;
             final boolean inDiskCache = is1 != null && is2 != null;
-            final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
+            final LoadedCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
             if (inDiskCache) {
                 task = resizer.loadAsIs(is1, is2, resizeCb);
             } else {
@@ -173,24 +173,24 @@ public class PhotoManager {
             postJob(task, token);
         }
 
-        public abstract Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
+        public abstract Runnable resizeIfNotFound(LoadedCallback cb);
     }
 
-    private PhotoStreamResizer.ResizeCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
-        return new PhotoStreamResizer.ResizeCallback() {
+    private LoadedCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
+        return new LoadedCallback() {
             @Override
-            public void onResizeComplete(Bitmap resized) {
+            public void onLoadCompleted(Bitmap resized) {
                 memoryCache.put(key, resized);
                 acquireBitmap(resized);
                 if (!inDiskCache && useDiskCache) {
                     Runnable putToDiskCache = diskCache.put(key, resized);
                     postJob(putToDiskCache, token);
                 }
-                cb.loadCompleted(resized);
+                cb.onLoadCompleted(resized);
             }
 
             @Override
-            public void onResizeFailed(Exception e) {
+            public void onLoadFailed(Exception e) {
                 cb.onLoadFailed(e);
             }
         };
","85                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
109                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
133                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
147             cb.onLoadCompleted(inCache);
167             final LoadedCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
176         public abstract Runnable resizeIfNotFound(LoadedCallback cb);
179     private LoadedCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
180         return new LoadedCallback() {
182             public void onLoadCompleted(Bitmap resized) {
189                 cb.onLoadCompleted(resized);
193             public void onLoadFailed(Exception e) {
85                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
109                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
133                 public Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback resizeCallback) {
147             cb.loadCompleted(inCache);
167             final PhotoStreamResizer.ResizeCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
176         public abstract Runnable resizeIfNotFound(PhotoStreamResizer.ResizeCallback cb);
179     private PhotoStreamResizer.ResizeCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
180         return new PhotoStreamResizer.ResizeCallback() {
182             public void onResizeComplete(Bitmap resized) {
189                 cb.loadCompleted(resized);
193             public void onResizeFailed(Exception e) {",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,e7b292bab443e478a37af8f68cd7f7c338686b61,50eb50f03911d9270670ea68bf3af29043069bf2,"Replace ResizeCallback with LoadedCallback

removes a redundant callback since both had 
essentially the same two methods.","@@ -6,6 +6,7 @@ package com.bumptech.photos.resize;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Handler;
+import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.cache.SizedBitmapCache;
 
 import java.io.IOException;
@@ -21,11 +22,6 @@ public class PhotoStreamResizer {
     private Handler mainHandler;
     private final SizedBitmapCache bitmapCache;
 
-    public interface ResizeCallback {
-        void onResizeComplete(Bitmap resized);
-        void onResizeFailed(Exception e);
-    }
-
     public PhotoStreamResizer(Handler mainHandler) {
         this(mainHandler, null);
     }
@@ -35,7 +31,7 @@ public class PhotoStreamResizer {
         this.bitmapCache = bitmapCache;
     }
 
-    public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
+    public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){
         return new SimpleStreamResizeRunnable(callback) {
 
             @Override
@@ -51,7 +47,7 @@ public class PhotoStreamResizer {
         };
     }
 
-    public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
+    public Runnable fitInSpace(final String path, final int width, final int height, LoadedCallback callback){
         return new SimpleStreamResizeRunnable(callback) {
 
             @Override
@@ -62,7 +58,7 @@ public class PhotoStreamResizer {
         };
     }
 
-    public Runnable loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
+    public Runnable loadApproximate(final String path, final int width, final int height, LoadedCallback callback){
         return new SimpleStreamResizeRunnable(callback) {
 
             @Override
@@ -72,7 +68,7 @@ public class PhotoStreamResizer {
         };
     }
 
-    public Runnable loadAsIs(final InputStream is1, final InputStream is2, final ResizeCallback callback) {
+    public Runnable loadAsIs(final InputStream is1, final InputStream is2, final LoadedCallback callback) {
         return new StreamResizeRunnable(callback) {
 
             @Override
@@ -106,7 +102,7 @@ public class PhotoStreamResizer {
         };
     }
 
-    public Runnable loadAsIs(final String path, ResizeCallback callback){
+    public Runnable loadAsIs(final String path, LoadedCallback callback){
         return new StreamResizeRunnable(callback) {
             @Override
             public Bitmap getRecycledBitmap() {
@@ -123,7 +119,7 @@ public class PhotoStreamResizer {
 
     private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
 
-        public SimpleStreamResizeRunnable(ResizeCallback callback) {
+        public SimpleStreamResizeRunnable(LoadedCallback callback) {
             super(callback);
         }
 
@@ -134,9 +130,9 @@ public class PhotoStreamResizer {
     }
 
     private abstract class StreamResizeRunnable implements Runnable {
-        private final PhotoStreamResizer.ResizeCallback callback;
+        private final LoadedCallback callback;
 
-        public StreamResizeRunnable(ResizeCallback callback) {
+        public StreamResizeRunnable(LoadedCallback callback) {
             this.callback = callback;
         }
 
@@ -151,7 +147,7 @@ public class PhotoStreamResizer {
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        callback.onResizeComplete(result);
+                        callback.onLoadCompleted(result);
                     }
                 });
             } catch (final Exception e) {
@@ -159,7 +155,7 @@ public class PhotoStreamResizer {
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        callback.onResizeFailed(e);
+                        callback.onLoadFailed(e);
                     }
                 });
             }
","9 import com.bumptech.photos.LoadedCallback;
34     public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){
50     public Runnable fitInSpace(final String path, final int width, final int height, LoadedCallback callback){
61     public Runnable loadApproximate(final String path, final int width, final int height, LoadedCallback callback){
71     public Runnable loadAsIs(final InputStream is1, final InputStream is2, final LoadedCallback callback) {
105     public Runnable loadAsIs(final String path, LoadedCallback callback){
122         public SimpleStreamResizeRunnable(LoadedCallback callback) {
133         private final LoadedCallback callback;
135         public StreamResizeRunnable(LoadedCallback callback) {
150                         callback.onLoadCompleted(result);
158                         callback.onLoadFailed(e);
24     public interface ResizeCallback {
25         void onResizeComplete(Bitmap resized);
26         void onResizeFailed(Exception e);
27     }
28 
38     public Runnable resizeCenterCrop(final String path, final int width, final int height, ResizeCallback callback){
54     public Runnable fitInSpace(final String path, final int width, final int height, ResizeCallback callback){
65     public Runnable loadApproximate(final String path, final int width, final int height, ResizeCallback callback){
75     public Runnable loadAsIs(final InputStream is1, final InputStream is2, final ResizeCallback callback) {
109     public Runnable loadAsIs(final String path, ResizeCallback callback){
126         public SimpleStreamResizeRunnable(ResizeCallback callback) {
137         private final PhotoStreamResizer.ResizeCallback callback;
139         public StreamResizeRunnable(ResizeCallback callback) {
154                         callback.onResizeComplete(result);
162                         callback.onResizeFailed(e);",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,589712b7897fea08cc4588bc2dc977a4a0aeaedc,e7b292bab443e478a37af8f68cd7f7c338686b61,Don't remove all queued items if token == null,"@@ -201,8 +201,10 @@ public class PhotoManager {
     }
 
     public void cancelTask(Object token){
+        if (token != null) {
             backgroundHandler.removeCallbacksAndMessages(token);
         }
+    }
 
     public void acquireBitmap(Bitmap b) {
         if (!b.isMutable()) return;
","204         if (token != null) {
207     }",No
src\com\bumptech\photos\cache\SizedBitmapCache.java,src\com\bumptech\photos\cache\SizedBitmapCache.java,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,589712b7897fea08cc4588bc2dc977a4a0aeaedc,Increase # of each bitmap type to keep around,"@@ -19,7 +19,7 @@ import java.util.Queue;
  * To change this template use File | Settings | File Templates.
  */
 public class SizedBitmapCache {
-    private static final int MAX_PER_SIZE = 5;
+    private static final int MAX_PER_SIZE = 8;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
 
     public void put(Bitmap bitmap) {
","22     private static final int MAX_PER_SIZE = 8;
22     private static final int MAX_PER_SIZE = 5;",No
,src\com\bumptech\photos\view\AssetPresenter.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
+import com.bumptech.photos.view.loader.ImageLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:05 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class AssetPresenter {
+    private final PhotoManager photoManager;
+
+    private int height = 0;
+    private int width = 0;
+    private Drawable placeholderDrawable;
+    private ImageSetCallback fullSetCallback;
+
+    private String fullAssetId;
+    private boolean isImageSet;
+    private Object fullToken;
+    private int fullCount;
+    protected final ImageView imageView;
+
+    private final AssetPathConverter assetIdToPath;
+    private Bitmap showing = null;
+    private final ImageLoader imageLoader;
+
+    public AssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
+        this.imageView = imageView;
+        this.photoManager = photoManager;
+        this.assetIdToPath = assetIdToPath;
+        this.imageLoader = imageLoader;
+    }
+
+    public void setDimens(int width, int height) {
+        this.width = width;
+        this.height = height;
+    }
+
+    public void setPlaceholderDrawable(Drawable placeholderDrawable) {
+        this.placeholderDrawable = placeholderDrawable;
+    }
+
+    public void setOnImageSetCallback(ImageSetCallback cb) {
+        this.fullSetCallback = cb;
+    }
+
+    public void setAssetId(final String assetId) {
+        if (fullAssetId != null && fullAssetId.equals(assetId)) return;
+
+        final int loadCount = ++fullCount;
+        prepareResize(assetId);
+        maybeCancelOldTask();
+
+        if (assetId != null) {
+            fetchPath(assetId, new AssetPathConverter.PathReadyListener() {
+                @Override
+                public void onPathReady(String path) {
+                    if (loadCount == fullCount) {
+                        fullToken = loadImage(path, imageLoader, fullResizeCallback(loadCount));
+                    }
+                }
+            });
+        }
+
+        if (!isImageSet()) {
+            resetPlaceHolder();
+        }
+    }
+
+    public void resetPlaceHolder() {
+        if (placeholderDrawable != null) {
+            imageView.setImageDrawable(placeholderDrawable);
+        }
+    }
+
+    public void clear() {
+        fullCount++;
+        maybeCancelOldTask();
+        imageView.setImageBitmap(null);
+        prepareResize(null);
+    }
+
+    protected boolean isImageSet() {
+        return isImageSet;
+    }
+
+    protected void maybeCancelOldTask() {
+        if (fullToken != null) {
+            cancelTask(fullToken);
+            fullToken = null;
+        }
+    }
+
+    protected void cancelTask(Object token) {
+        photoManager.cancelTask(token);
+    }
+
+    protected Object loadImage(String path, ImageLoader loader, LoadedCallback cb) {
+        return loader.loadImage(photoManager, path, width, height, cb);
+    }
+
+    protected void fetchPath(String assetId, AssetPathConverter.PathReadyListener listener) {
+        assetIdToPath.fetchPath(assetId, listener);
+    }
+
+    protected void updateAcquiredBitmap(Bitmap old, Bitmap next) {
+        if (old != null) {
+            photoManager.releaseBitmap(old);
+        }
+        if (next != null) {
+            photoManager.acquireBitmap(next);
+        }
+    }
+
+    private LoadedCallback fullResizeCallback(final int loadCount){
+        return new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                if (loadCount == fullCount) {
+                    if (fullSetCallback != null)
+                        fullSetCallback.onImageSet(imageView, false);
+                    imageView.setImageBitmap(loaded);
+                    isImageSet = true;
+
+                    updateAcquiredBitmap(showing, loaded);
+                    showing = loaded;
+                }
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                imageLoader.onLoadFailed(e);
+            }
+        };
+    }
+
+    private void prepareResize(String fullId) {
+        fullAssetId = fullId;
+        isImageSet = false;
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view;
6 
7 import android.graphics.Bitmap;
8 import android.graphics.drawable.Drawable;
9 import android.widget.ImageView;
10 import com.bumptech.photos.LoadedCallback;
11 import com.bumptech.photos.PhotoManager;
12 import com.bumptech.photos.view.assetpath.AssetPathConverter;
13 import com.bumptech.photos.view.loader.ImageLoader;
14 
15 /**
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/25/12
19  * Time: 10:05 PM
20  * To change this template use File | Settings | File Templates.
21  */
22 public class AssetPresenter {
23     private final PhotoManager photoManager;
24 
25     private int height = 0;
26     private int width = 0;
27     private Drawable placeholderDrawable;
28     private ImageSetCallback fullSetCallback;
29 
30     private String fullAssetId;
31     private boolean isImageSet;
32     private Object fullToken;
33     private int fullCount;
34     protected final ImageView imageView;
35 
36     private final AssetPathConverter assetIdToPath;
37     private Bitmap showing = null;
38     private final ImageLoader imageLoader;
39 
40     public AssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
41         this.imageView = imageView;
42         this.photoManager = photoManager;
43         this.assetIdToPath = assetIdToPath;
44         this.imageLoader = imageLoader;
45     }
46 
47     public void setDimens(int width, int height) {
48         this.width = width;
49         this.height = height;
50     }
51 
52     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
53         this.placeholderDrawable = placeholderDrawable;
54     }
55 
56     public void setOnImageSetCallback(ImageSetCallback cb) {
57         this.fullSetCallback = cb;
58     }
59 
60     public void setAssetId(final String assetId) {
61         if (fullAssetId != null && fullAssetId.equals(assetId)) return;
62 
63         final int loadCount = ++fullCount;
64         prepareResize(assetId);
65         maybeCancelOldTask();
66 
67         if (assetId != null) {
68             fetchPath(assetId, new AssetPathConverter.PathReadyListener() {
69                 @Override
70                 public void onPathReady(String path) {
71                     if (loadCount == fullCount) {
72                         fullToken = loadImage(path, imageLoader, fullResizeCallback(loadCount));
73                     }
74                 }
75             });
76         }
77 
78         if (!isImageSet()) {
79             resetPlaceHolder();
80         }
81     }
82 
83     public void resetPlaceHolder() {
84         if (placeholderDrawable != null) {
85             imageView.setImageDrawable(placeholderDrawable);
86         }
87     }
88 
89     public void clear() {
90         fullCount++;
91         maybeCancelOldTask();
92         imageView.setImageBitmap(null);
93         prepareResize(null);
94     }
95 
96     protected boolean isImageSet() {
97         return isImageSet;
98     }
99 
100     protected void maybeCancelOldTask() {
101         if (fullToken != null) {
102             cancelTask(fullToken);
103             fullToken = null;
104         }
105     }
106 
107     protected void cancelTask(Object token) {
108         photoManager.cancelTask(token);
109     }
110 
111     protected Object loadImage(String path, ImageLoader loader, LoadedCallback cb) {
112         return loader.loadImage(photoManager, path, width, height, cb);
113     }
114 
115     protected void fetchPath(String assetId, AssetPathConverter.PathReadyListener listener) {
116         assetIdToPath.fetchPath(assetId, listener);
117     }
118 
119     protected void updateAcquiredBitmap(Bitmap old, Bitmap next) {
120         if (old != null) {
121             photoManager.releaseBitmap(old);
122         }
123         if (next != null) {
124             photoManager.acquireBitmap(next);
125         }
126     }
127 
128     private LoadedCallback fullResizeCallback(final int loadCount){
129         return new LoadedCallback() {
130             @Override
131             public void onLoadCompleted(Bitmap loaded) {
132                 if (loadCount == fullCount) {
133                     if (fullSetCallback != null)
134                         fullSetCallback.onImageSet(imageView, false);
135                     imageView.setImageBitmap(loaded);
136                     isImageSet = true;
137 
138                     updateAcquiredBitmap(showing, loaded);
139                     showing = loaded;
140                 }
141             }
142 
143             @Override
144             public void onLoadFailed(Exception e) {
145                 imageLoader.onLoadFailed(e);
146             }
147         };
148     }
149 
150     private void prepareResize(String fullId) {
151         fullAssetId = fullId;
152         isImageSet = false;
153     }
154 }",No
,src\com\bumptech\photos\view\ImageSetCallback.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view;
+
+import android.widget.ImageView;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:04 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface ImageSetCallback {
+    public void onImageSet(ImageView view, boolean fromCache);
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view;
6 
7 import android.widget.ImageView;
8 
9 /**
10  * Created with IntelliJ IDEA.
11  * User: sam
12  * Date: 12/25/12
13  * Time: 10:04 PM
14  * To change this template use File | Settings | File Templates.
15  */
16 public interface ImageSetCallback {
17     public void onImageSet(ImageView view, boolean fromCache);
18 }",No
,src\com\bumptech\photos\view\ThumbnailAssetPresenter.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view;
+
+import android.graphics.Bitmap;
+import android.widget.ImageView;
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
+import com.bumptech.photos.view.loader.AsIs;
+import com.bumptech.photos.view.loader.ImageLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:59 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class ThumbnailAssetPresenter extends AssetPresenter {
+    private ImageSetCallback thumbSetCallback = null;
+    private String thumbAssetId = null;
+    private Object thumbToken = null;
+    private int thumbCount = 0;
+    private final AsIs thumbLoader;
+    private Bitmap currentThumbnail = null;
+
+    public ThumbnailAssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
+        super(imageView, photoManager, assetIdToPath, imageLoader);
+        thumbLoader = new AsIs();
+    }
+
+    public void setOnThumbSetCallback(ImageSetCallback cb) {
+        this.thumbSetCallback = cb;
+    }
+
+    public void setAssetIds(String fullId, final String thumbId) {
+        setAssetId(fullId);
+        if (!isImageSet()) {
+            final int loadCount = ++thumbCount;
+            thumbAssetId = thumbId;
+            if (thumbAssetId != null) {
+                fetchPath(thumbId, new AssetPathConverter.PathReadyListener() {
+                    @Override
+                    public void onPathReady(String path) {
+                        if (loadCount == thumbCount && !isImageSet()) {
+                            thumbToken = loadImage(path, thumbLoader, thumbResizeCallback(loadCount));
+                        }
+                    }
+                });
+            }
+        }
+    }
+
+    @Override
+    public void clear() {
+        thumbCount++;
+        thumbAssetId = null;
+        super.clear();
+    }
+
+    @Override
+    protected void maybeCancelOldTask() {
+        super.maybeCancelOldTask();
+        if (thumbToken != null) {
+            cancelTask(thumbToken);
+            thumbToken = null;
+        }
+    }
+
+    private LoadedCallback thumbResizeCallback(final int loadCount) {
+        return new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                if (loadCount == thumbCount && !isImageSet()) {
+                    if (thumbSetCallback != null) {
+                        thumbSetCallback.onImageSet(imageView, false);
+                    }
+                    imageView.setImageBitmap(loaded);
+
+                    updateAcquiredBitmap(currentThumbnail, loaded);
+                    currentThumbnail = loaded;
+                }
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) { }
+        };
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view;
6 
7 import android.graphics.Bitmap;
8 import android.widget.ImageView;
9 import com.bumptech.photos.LoadedCallback;
10 import com.bumptech.photos.PhotoManager;
11 import com.bumptech.photos.view.assetpath.AssetPathConverter;
12 import com.bumptech.photos.view.loader.AsIs;
13 import com.bumptech.photos.view.loader.ImageLoader;
14 
15 /**
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/25/12
19  * Time: 10:59 PM
20  * To change this template use File | Settings | File Templates.
21  */
22 public class ThumbnailAssetPresenter extends AssetPresenter {
23     private ImageSetCallback thumbSetCallback = null;
24     private String thumbAssetId = null;
25     private Object thumbToken = null;
26     private int thumbCount = 0;
27     private final AsIs thumbLoader;
28     private Bitmap currentThumbnail = null;
29 
30     public ThumbnailAssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
31         super(imageView, photoManager, assetIdToPath, imageLoader);
32         thumbLoader = new AsIs();
33     }
34 
35     public void setOnThumbSetCallback(ImageSetCallback cb) {
36         this.thumbSetCallback = cb;
37     }
38 
39     public void setAssetIds(String fullId, final String thumbId) {
40         setAssetId(fullId);
41         if (!isImageSet()) {
42             final int loadCount = ++thumbCount;
43             thumbAssetId = thumbId;
44             if (thumbAssetId != null) {
45                 fetchPath(thumbId, new AssetPathConverter.PathReadyListener() {
46                     @Override
47                     public void onPathReady(String path) {
48                         if (loadCount == thumbCount && !isImageSet()) {
49                             thumbToken = loadImage(path, thumbLoader, thumbResizeCallback(loadCount));
50                         }
51                     }
52                 });
53             }
54         }
55     }
56 
57     @Override
58     public void clear() {
59         thumbCount++;
60         thumbAssetId = null;
61         super.clear();
62     }
63 
64     @Override
65     protected void maybeCancelOldTask() {
66         super.maybeCancelOldTask();
67         if (thumbToken != null) {
68             cancelTask(thumbToken);
69             thumbToken = null;
70         }
71     }
72 
73     private LoadedCallback thumbResizeCallback(final int loadCount) {
74         return new LoadedCallback() {
75             @Override
76             public void onLoadCompleted(Bitmap loaded) {
77                 if (loadCount == thumbCount && !isImageSet()) {
78                     if (thumbSetCallback != null) {
79                         thumbSetCallback.onImageSet(imageView, false);
80                     }
81                     imageView.setImageBitmap(loaded);
82 
83                     updateAcquiredBitmap(currentThumbnail, loaded);
84                     currentThumbnail = loaded;
85                 }
86             }
87 
88             @Override
89             public void onLoadFailed(Exception e) { }
90         };
91     }
92 }",No
,src\com\bumptech\photos\view\assetpath\AssetPathConverter.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.assetpath;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 8:51 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface AssetPathConverter<T> {
+    public interface PathReadyListener {
+        public void onPathReady(String path);
+    }
+
+    public void fetchPath(T model, PathReadyListener listener);
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.assetpath;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:51 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public interface AssetPathConverter<T> {
15     public interface PathReadyListener {
16         public void onPathReady(String path);
17     }
18 
19     public void fetchPath(T model, PathReadyListener listener);
20 }",No
,src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.assetpath;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 8:52 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {
+    @Override
+    public void fetchPath(String assetId, PathReadyListener listener) {
+        listener.onPathReady(assetId);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.assetpath;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:52 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {
15     @Override
16     public void fetchPath(String assetId, PathReadyListener listener) {
17         listener.onPathReady(assetId);
18     }
19 }",No
,src\com\bumptech\photos\view\loader\Approximate.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:58 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Approximate implements ImageLoader {
+    @Override
+    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, cb);
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) { }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 
10 /**
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/25/12
14  * Time: 10:58 PM
15  * To change this template use File | Settings | File Templates.
16  */
17 public class Approximate implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.getImage(path, cb);
21     }
22 
23     @Override
24     public void onLoadFailed(Exception e) { }
25 }",No
,src\com\bumptech\photos\view\loader\AsIs.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:57 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class AsIs implements ImageLoader {
+    @Override
+    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, width, height, cb);
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) { }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 
10 /**
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/25/12
14  * Time: 10:57 PM
15  * To change this template use File | Settings | File Templates.
16  */
17 public class AsIs implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.getImage(path, width, height, cb);
21     }
22 
23     @Override
24     public void onLoadFailed(Exception e) { }
25 }",No
,src\com\bumptech\photos\view\loader\CenterCrop.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:54 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class CenterCrop implements ImageLoader {
+    @Override
+    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
+        return photoManager.centerCrop(path, width, height, cb);
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) { }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 
10 /**
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/25/12
14  * Time: 10:54 PM
15  * To change this template use File | Settings | File Templates.
16  */
17 public class CenterCrop implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.centerCrop(path, width, height, cb);
21     }
22 
23     @Override
24     public void onLoadFailed(Exception e) { }
25 }",No
,src\com\bumptech\photos\view\loader\FitCenter.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:56 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FitCenter implements ImageLoader {
+    @Override
+    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
+        return photoManager.fitCenter(path, width, height, cb);
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) { }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 
10 /**
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/25/12
14  * Time: 10:56 PM
15  * To change this template use File | Settings | File Templates.
16  */
17 public class FitCenter implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.fitCenter(path, width, height, cb);
21     }
22 
23     @Override
24     public void onLoadFailed(Exception e) { }
25 }",No
,src\com\bumptech\photos\view\loader\ImageLoader.java,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,78aa6fcce8f6d5a05a62d435f72be113b903d0f1,Add presenter system for wrapping imageviews,"@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:49 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface ImageLoader {
+    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb);
+    public void onLoadFailed(Exception e);
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 
10 /**
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/25/12
14  * Time: 10:49 PM
15  * To change this template use File | Settings | File Templates.
16  */
17 public interface ImageLoader {
18     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb);
19     public void onLoadFailed(Exception e);
20 }",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,490d51166be490c37e0515de479d7759e1cd6662,f9a436a1bfb5e4b6901506ea61dc490a9b2fe5ae,"Track bitmaps using hashcode, not the object

Prevents us from accidently leaking bitmaps if
we fail to call acquire and release in the correct
order.","@@ -29,7 +29,7 @@ public class PhotoManager {
     private LruPhotoCache memoryCache;
     private PhotoStreamResizer resizer;
     private Handler backgroundHandler;
-    private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
+    private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private SizedBitmapCache bitmapCache = new SizedBitmapCache();
 
     private enum ResizeType {
@@ -207,22 +207,21 @@ public class PhotoManager {
     }
 
     public void acquireBitmap(Bitmap b) {
-        if (!b.isMutable()) return;
-
-        Integer currentCount = bitmapReferenceCounter.get(b);
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
         if (currentCount == null) {
             currentCount = 0;
         }
-        bitmapReferenceCounter.put(b, currentCount + 1);
+        bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
     }
 
     public void releaseBitmap(Bitmap b) {
-        Integer currentCount = bitmapReferenceCounter.get(b) - 1;
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
+        Log.d(""PhotoManager: releaseBitmap currentCount="" + (currentCount));
         if (currentCount == 0) {
-            bitmapReferenceCounter.remove(b);
+            bitmapReferenceCounter.remove(b.hashCode());
             bitmapCache.put(b);
         } else {
-            bitmapReferenceCounter.put(b, currentCount);
+            bitmapReferenceCounter.put(b.hashCode(), currentCount);
         }
     }
 
","32     private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
210         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
214         bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
218         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
219         Log.d(""PhotoManager: releaseBitmap currentCount="" + (currentCount));
221             bitmapReferenceCounter.remove(b.hashCode());
224             bitmapReferenceCounter.put(b.hashCode(), currentCount);
32     private Map<Bitmap, Integer> bitmapReferenceCounter = new HashMap<Bitmap, Integer>();
210         if (!b.isMutable()) return;
211 
212         Integer currentCount = bitmapReferenceCounter.get(b);
216         bitmapReferenceCounter.put(b, currentCount + 1);
220         Integer currentCount = bitmapReferenceCounter.get(b) - 1;
222             bitmapReferenceCounter.remove(b);
225             bitmapReferenceCounter.put(b, currentCount);",No
src\com\bumptech\photos\view\AssetPresenter.java,src\com\bumptech\photos\view\AssetPresenter.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -4,14 +4,13 @@
 
 package com.bumptech.photos.view;
 
-import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
 import com.bumptech.photos.view.assetpath.AssetPathConverter;
 import com.bumptech.photos.view.loader.ImageLoader;
 
+import java.lang.ref.WeakReference;
+
 /**
  * Created with IntelliJ IDEA.
  * User: sam
@@ -19,27 +18,25 @@ import com.bumptech.photos.view.loader.ImageLoader;
  * Time: 10:05 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AssetPresenter {
-    private final PhotoManager photoManager;
-
+public class AssetPresenter<T> {
     private int height = 0;
     private int width = 0;
+
     private Drawable placeholderDrawable;
-    private ImageSetCallback fullSetCallback;
+    private ImageSetCallback imageSetCallback;
+
+    private T currentModel;
+    private int currentCount;
 
-    private String fullAssetId;
     private boolean isImageSet;
-    private Object fullToken;
-    private int fullCount;
     protected final ImageView imageView;
 
-    private final AssetPathConverter assetIdToPath;
-    private Bitmap showing = null;
+    private final AssetPathConverter<T> assetIdToPath;
     private final ImageLoader imageLoader;
 
-    public AssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
+
+    public AssetPresenter(ImageView imageView, AssetPathConverter<T> assetIdToPath, ImageLoader imageLoader) {
         this.imageView = imageView;
-        this.photoManager = photoManager;
         this.assetIdToPath = assetIdToPath;
         this.imageLoader = imageLoader;
     }
@@ -49,106 +46,115 @@ public class AssetPresenter {
         this.height = height;
     }
 
+
     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
         this.placeholderDrawable = placeholderDrawable;
     }
 
     public void setOnImageSetCallback(ImageSetCallback cb) {
-        this.fullSetCallback = cb;
+        this.imageSetCallback = cb;
     }
 
-    public void setAssetId(final String assetId) {
-        if (fullAssetId != null && fullAssetId.equals(assetId)) return;
+    public void setAssetModel(final T model) {
+        if (model == null || model.equals(currentModel)) return;
 
-        final int loadCount = ++fullCount;
-        prepareResize(assetId);
-        maybeCancelOldTask();
+        final int loadCount = ++currentCount;
+        currentModel = model;
+        isImageSet = false;
 
-        if (assetId != null) {
-            fetchPath(assetId, new AssetPathConverter.PathReadyListener() {
-                @Override
-                public void onPathReady(String path) {
-                    if (loadCount == fullCount) {
-                        fullToken = loadImage(path, imageLoader, fullResizeCallback(loadCount));
-                    }
-                }
-            });
-        }
+        assetIdToPath.fetchPath(model, new PathReadyCallback(this, loadCount));
 
         if (!isImageSet()) {
             resetPlaceHolder();
         }
     }
 
+    public void onPathReady(String path, int loadCount) {
+        if (loadCount != currentCount) return;
+
+        imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
+    }
+
+    public void onImageReady(int loadCount) {
+        if (loadCount != currentCount || !canSetImage()) return;
+
+        if (imageSetCallback != null)
+            imageSetCallback.onImageSet(imageView, false);
+        imageView.setImageBitmap(imageLoader.getReadyBitmap());
+        isImageSet = true;
+    }
+
     public void resetPlaceHolder() {
-        if (placeholderDrawable != null) {
+        if (placeholderDrawable == null || !canSetPlaceholder()) return;
+
         imageView.setImageDrawable(placeholderDrawable);
     }
-    }
 
     public void clear() {
-        fullCount++;
-        maybeCancelOldTask();
+        currentCount++;
         imageView.setImageBitmap(null);
-        prepareResize(null);
+        currentModel = null;
+        isImageSet = false;
     }
 
-    protected boolean isImageSet() {
-        return isImageSet;
+    public int getWidth() {
+        return width;
     }
 
-    protected void maybeCancelOldTask() {
-        if (fullToken != null) {
-            cancelTask(fullToken);
-            fullToken = null;
-        }
+    public int getHeight() {
+        return height;
     }
 
-    protected void cancelTask(Object token) {
-        photoManager.cancelTask(token);
+    protected boolean isImageSet() {
+        return isImageSet;
     }
 
-    protected Object loadImage(String path, ImageLoader loader, LoadedCallback cb) {
-        return loader.loadImage(photoManager, path, width, height, cb);
+    private boolean canSetImage() {
+        return coordinator == null || coordinator.canSetImage(this);
     }
 
-    protected void fetchPath(String assetId, AssetPathConverter.PathReadyListener listener) {
-        assetIdToPath.fetchPath(assetId, listener);
+    private boolean canSetPlaceholder() {
+        return coordinator == null || coordinator.canSetPlaceholder(this);
     }
 
-    protected void updateAcquiredBitmap(Bitmap old, Bitmap next) {
-        if (old != null) {
-            photoManager.releaseBitmap(old);
+    private static class ImageReadyCallback implements ImageLoader.ImageReadyCallback{
+
+        private final WeakReference<AssetPresenter> assetPresenterRef;
+        private final int loadCount;
+
+        public ImageReadyCallback(AssetPresenter assetPresenter, int loadCount) {
+            this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
+            this.loadCount = loadCount;
         }
-        if (next != null) {
-            photoManager.acquireBitmap(next);
+
+        @Override
+        public void onImageReady() {
+            final AssetPresenter assetPresenter = assetPresenterRef.get();
+            if (assetPresenter != null ) {
+                assetPresenter.onImageReady(loadCount);
             }
         }
 
-    private LoadedCallback fullResizeCallback(final int loadCount){
-        return new LoadedCallback() {
         @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                if (loadCount == fullCount) {
-                    if (fullSetCallback != null)
-                        fullSetCallback.onImageSet(imageView, false);
-                    imageView.setImageBitmap(loaded);
-                    isImageSet = true;
-
-                    updateAcquiredBitmap(showing, loaded);
-                    showing = loaded;
+        public void onLoadFailed(Exception e) { }
     }
+
+    private static class PathReadyCallback implements AssetPathConverter.PathReadyListener {
+
+        private final int loadCount;
+        private final WeakReference<AssetPresenter> assetPresenterRef;
+
+        public PathReadyCallback(AssetPresenter assetPresenter, int loadCount) {
+            this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
+            this.loadCount = loadCount;
         }
 
         @Override
-            public void onLoadFailed(Exception e) {
-                imageLoader.onLoadFailed(e);
+        public void onPathReady(String path) {
+            final AssetPresenter assetPresenter = assetPresenterRef.get();
+            if (assetPresenter != null) {
+                assetPresenter.onPathReady(path, loadCount);
             }
-        };
         }
-
-    private void prepareResize(String fullId) {
-        fullAssetId = fullId;
-        isImageSet = false;
     }
 }
","12 import java.lang.ref.WeakReference;
13 
21 public class AssetPresenter<T> {
25     private Drawable placeholderDrawable;
26     private ImageSetCallback imageSetCallback;
27 
28     private T currentModel;
29     private int currentCount;
30 
34     private final AssetPathConverter<T> assetIdToPath;
37 
38     public AssetPresenter(ImageView imageView, AssetPathConverter<T> assetIdToPath, ImageLoader imageLoader) {
49 
55         this.imageSetCallback = cb;
58     public void setAssetModel(final T model) {
59         if (model == null || model.equals(currentModel)) return;
61         final int loadCount = ++currentCount;
62         currentModel = model;
63         isImageSet = false;
65         assetIdToPath.fetchPath(model, new PathReadyCallback(this, loadCount));
72     public void onPathReady(String path, int loadCount) {
73         if (loadCount != currentCount) return;
74 
75         imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
77 
78     public void onImageReady(int loadCount) {
79         if (loadCount != currentCount || !canSetImage()) return;
80 
81         if (imageSetCallback != null)
82             imageSetCallback.onImageSet(imageView, false);
83         imageView.setImageBitmap(imageLoader.getReadyBitmap());
84         isImageSet = true;
85     }
86 
87     public void resetPlaceHolder() {
88         if (placeholderDrawable == null || !canSetPlaceholder()) return;
89 
90         imageView.setImageDrawable(placeholderDrawable);
94         currentCount++;
96         currentModel = null;
97         isImageSet = false;
98     }
99 
100     public int getWidth() {
101         return width;
102     }
103 
104     public int getHeight() {
105         return height;
112     private boolean canSetImage() {
113         return coordinator == null || coordinator.canSetImage(this);
116     private boolean canSetPlaceholder() {
117         return coordinator == null || coordinator.canSetPlaceholder(this);
120     private static class ImageReadyCallback implements ImageLoader.ImageReadyCallback{
121 
122         private final WeakReference<AssetPresenter> assetPresenterRef;
123         private final int loadCount;
124 
125         public ImageReadyCallback(AssetPresenter assetPresenter, int loadCount) {
126             this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
127             this.loadCount = loadCount;
131         public void onImageReady() {
132             final AssetPresenter assetPresenter = assetPresenterRef.get();
133             if (assetPresenter != null ) {
134                 assetPresenter.onImageReady(loadCount);
139         public void onLoadFailed(Exception e) { }
142     private static class PathReadyCallback implements AssetPathConverter.PathReadyListener {
143 
144         private final int loadCount;
145         private final WeakReference<AssetPresenter> assetPresenterRef;
146 
147         public PathReadyCallback(AssetPresenter assetPresenter, int loadCount) {
148             this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
149             this.loadCount = loadCount;
150         }
151 
152         @Override
153         public void onPathReady(String path) {
154             final AssetPresenter assetPresenter = assetPresenterRef.get();
155             if (assetPresenter != null) {
156                 assetPresenter.onPathReady(path, loadCount);
157             }
158         }
7 import android.graphics.Bitmap;
10 import com.bumptech.photos.LoadedCallback;
11 import com.bumptech.photos.PhotoManager;
22 public class AssetPresenter {
23     private final PhotoManager photoManager;
24 
27     private Drawable placeholderDrawable;
28     private ImageSetCallback fullSetCallback;
30     private String fullAssetId;
32     private Object fullToken;
33     private int fullCount;
36     private final AssetPathConverter assetIdToPath;
37     private Bitmap showing = null;
40     public AssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
42         this.photoManager = photoManager;
57         this.fullSetCallback = cb;
60     public void setAssetId(final String assetId) {
61         if (fullAssetId != null && fullAssetId.equals(assetId)) return;
63         final int loadCount = ++fullCount;
64         prepareResize(assetId);
65         maybeCancelOldTask();
67         if (assetId != null) {
68             fetchPath(assetId, new AssetPathConverter.PathReadyListener() {
69                 @Override
70                 public void onPathReady(String path) {
71                     if (loadCount == fullCount) {
72                         fullToken = loadImage(path, imageLoader, fullResizeCallback(loadCount));
73                     }
74                 }
75             });
76         }
83     public void resetPlaceHolder() {
84         if (placeholderDrawable != null) {
85             imageView.setImageDrawable(placeholderDrawable);
90         fullCount++;
91         maybeCancelOldTask();
93         prepareResize(null);
100     protected void maybeCancelOldTask() {
101         if (fullToken != null) {
102             cancelTask(fullToken);
103             fullToken = null;
104         }
107     protected void cancelTask(Object token) {
108         photoManager.cancelTask(token);
111     protected Object loadImage(String path, ImageLoader loader, LoadedCallback cb) {
112         return loader.loadImage(photoManager, path, width, height, cb);
115     protected void fetchPath(String assetId, AssetPathConverter.PathReadyListener listener) {
116         assetIdToPath.fetchPath(assetId, listener);
117     }
118 
119     protected void updateAcquiredBitmap(Bitmap old, Bitmap next) {
120         if (old != null) {
121             photoManager.releaseBitmap(old);
122         }
123         if (next != null) {
124             photoManager.acquireBitmap(next);
125         }
126     }
127 
128     private LoadedCallback fullResizeCallback(final int loadCount){
129         return new LoadedCallback() {
131             public void onLoadCompleted(Bitmap loaded) {
132                 if (loadCount == fullCount) {
133                     if (fullSetCallback != null)
134                         fullSetCallback.onImageSet(imageView, false);
135                     imageView.setImageBitmap(loaded);
136                     isImageSet = true;
137 
138                     updateAcquiredBitmap(showing, loaded);
139                     showing = loaded;
144             public void onLoadFailed(Exception e) {
145                 imageLoader.onLoadFailed(e);
146             }
147         };
150     private void prepareResize(String fullId) {
151         fullAssetId = fullId;
152         isImageSet = false;",No
src\com\bumptech\photos\view\loader\Approximate.java,src\com\bumptech\photos\view\loader\Approximate.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -14,12 +14,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:58 PM
  * To change this template use File | Settings | File Templates.
  */
-public class Approximate implements ImageLoader {
-    @Override
-    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, cb);
+public class Approximate extends ImageLoader {
+
+    public Approximate(PhotoManager photoManager) {
+        super(photoManager);
     }
 
     @Override
-    public void onLoadFailed(Exception e) { }
+    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, width, height, cb);
+    }
 }
","17 public class Approximate extends ImageLoader {
18 
19     public Approximate(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
25         return photoManager.getImage(path, width, height, cb);
26     }
17 public class Approximate implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.getImage(path, cb);
24     public void onLoadFailed(Exception e) { }",No
src\com\bumptech\photos\view\loader\AsIs.java,src\com\bumptech\photos\view\loader\AsIs.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -14,12 +14,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:57 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AsIs implements ImageLoader {
-    @Override
-    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, width, height, cb);
+public class AsIs extends ImageLoader {
+
+    public AsIs(PhotoManager photoManager) {
+        super(photoManager);
     }
 
     @Override
-    public void onLoadFailed(Exception e) { }
+    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, cb);
+    }
 }
","17 public class AsIs extends ImageLoader {
18 
19     public AsIs(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
25         return photoManager.getImage(path, cb);
26     }
17 public class AsIs implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.getImage(path, width, height, cb);
24     public void onLoadFailed(Exception e) { }",No
src\com\bumptech\photos\view\loader\CenterCrop.java,src\com\bumptech\photos\view\loader\CenterCrop.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -14,12 +14,13 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:54 PM
  * To change this template use File | Settings | File Templates.
  */
-public class CenterCrop implements ImageLoader {
-    @Override
-    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
-        return photoManager.centerCrop(path, width, height, cb);
+public class CenterCrop extends ImageLoader {
+    public CenterCrop(PhotoManager photoManager) {
+        super(photoManager);
     }
 
     @Override
-    public void onLoadFailed(Exception e) { }
+    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.centerCrop(path, width, height, cb);
+    }
 }
","17 public class CenterCrop extends ImageLoader {
18     public CenterCrop(PhotoManager photoManager) {
19         super(photoManager);
23     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
24         return photoManager.centerCrop(path, width, height, cb);
25     }
17 public class CenterCrop implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.centerCrop(path, width, height, cb);
24     public void onLoadFailed(Exception e) { }",No
src\com\bumptech\photos\view\loader\FitCenter.java,src\com\bumptech\photos\view\loader\FitCenter.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -14,12 +14,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:56 PM
  * To change this template use File | Settings | File Templates.
  */
-public class FitCenter implements ImageLoader {
-    @Override
-    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
-        return photoManager.fitCenter(path, width, height, cb);
+public class FitCenter extends ImageLoader {
+
+    public FitCenter(PhotoManager photoManager) {
+        super(photoManager);
     }
 
     @Override
-    public void onLoadFailed(Exception e) { }
+    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.fitCenter(path, width, height, cb);
+    }
 }
","17 public class FitCenter extends ImageLoader {
18 
19     public FitCenter(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
25         return photoManager.fitCenter(path, width, height, cb);
26     }
17 public class FitCenter implements ImageLoader {
18     @Override
19     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb) {
20         return photoManager.fitCenter(path, width, height, cb);
24     public void onLoadFailed(Exception e) { }",No
src\com\bumptech\photos\view\loader\ImageLoader.java,src\com\bumptech\photos\view\loader\ImageLoader.java,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,490d51166be490c37e0515de479d7759e1cd6662,"Loading logic->ImageLoaders, and use weak refs

Prevents us from leaking views if a path fetch or
image load doesn't complete or takes a long time.
Also better encapsulates loading code so that the
presenter is entirely independent of the photo 
loading code.","@@ -4,17 +4,61 @@
 
 package com.bumptech.photos.view.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.PhotoManager;
 
 /**
  * Created with IntelliJ IDEA.
  * User: sam
- * Date: 12/25/12
- * Time: 10:49 PM
+ * Date: 12/28/12
+ * Time: 9:53 AM
  * To change this template use File | Settings | File Templates.
  */
-public interface ImageLoader {
-    public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb);
+public abstract class ImageLoader {
+    protected final PhotoManager photoManager;
+    private Bitmap acquired = null;
+    private Bitmap ready = null;
+    private Object loadToken = null;
+
+    public interface ImageReadyCallback {
+        public void onImageReady();
         public void onLoadFailed(Exception e);
     }
+
+    public ImageLoader(PhotoManager photoManager) {
+        this.photoManager = photoManager;
+    }
+
+    public void loadImage(String path, int width, int height, final ImageReadyCallback callback) {
+        photoManager.cancelTask(loadToken);
+
+        loadToken = doLoad(path, width, height, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                ready = loaded;
+                callback.onImageReady();
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                callback.onLoadFailed(e);
+            }
+        });
+    }
+
+    public Bitmap getReadyBitmap() {
+        if (acquired != null) {
+            photoManager.releaseBitmap(acquired);
+            acquired = null;
+        }
+        if (ready != null) {
+            photoManager.acquireBitmap(ready);
+            acquired = ready;
+            ready = null;
+        }
+        return acquired;
+    }
+
+    protected abstract Object doLoad(String path, int width, int height, LoadedCallback cb);
+}
","7 import android.graphics.Bitmap;
14  * Date: 12/28/12
15  * Time: 9:53 AM
18 public abstract class ImageLoader {
19     protected final PhotoManager photoManager;
20     private Bitmap acquired = null;
21     private Bitmap ready = null;
22     private Object loadToken = null;
23 
24     public interface ImageReadyCallback {
25         public void onImageReady();
28 
29     public ImageLoader(PhotoManager photoManager) {
30         this.photoManager = photoManager;
31     }
32 
33     public void loadImage(String path, int width, int height, final ImageReadyCallback callback) {
34         photoManager.cancelTask(loadToken);
35 
36         loadToken = doLoad(path, width, height, new LoadedCallback() {
37             @Override
38             public void onLoadCompleted(Bitmap loaded) {
39                 ready = loaded;
40                 callback.onImageReady();
41             }
42 
43             @Override
44             public void onLoadFailed(Exception e) {
45                 callback.onLoadFailed(e);
46             }
47         });
48     }
49 
50     public Bitmap getReadyBitmap() {
51         if (acquired != null) {
52             photoManager.releaseBitmap(acquired);
53             acquired = null;
54         }
55         if (ready != null) {
56             photoManager.acquireBitmap(ready);
57             acquired = ready;
58             ready = null;
59         }
60         return acquired;
61     }
62 
63     protected abstract Object doLoad(String path, int width, int height, LoadedCallback cb);
64 }
13  * Date: 12/25/12
14  * Time: 10:49 PM
17 public interface ImageLoader {
18     public Object loadImage(PhotoManager photoManager, String path, int width, int height, LoadedCallback cb);",No
src\com\bumptech\photos\view\AssetPresenter.java,src\com\bumptech\photos\view\AssetPresenter.java,c63fed175ae10b0c90ecd883da58d04cc88526af,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,"Replace thumbnail inheritance with composition

Removes need to write load checking logic in two
places. Use a presenter coordinating interface to
keep minimal track of the presenter's states.","@@ -33,7 +33,12 @@ public class AssetPresenter<T> {
 
     private final AssetPathConverter<T> assetIdToPath;
     private final ImageLoader imageLoader;
+    private AssetPresenterCoordinator coordinator;
 
+    public interface AssetPresenterCoordinator<T> {
+        public boolean canSetImage(AssetPresenter<T> presenter);
+        public boolean canSetPlaceholder(AssetPresenter<T> presenter);
+    }
 
     public AssetPresenter(ImageView imageView, AssetPathConverter<T> assetIdToPath, ImageLoader imageLoader) {
         this.imageView = imageView;
@@ -46,6 +51,9 @@ public class AssetPresenter<T> {
         this.height = height;
     }
 
+    public void setCoordinator(AssetPresenterCoordinator<T> controller) {
+        this.coordinator = controller;
+    }
 
     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
         this.placeholderDrawable = placeholderDrawable;
","36     private AssetPresenterCoordinator coordinator;
38     public interface AssetPresenterCoordinator<T> {
39         public boolean canSetImage(AssetPresenter<T> presenter);
40         public boolean canSetPlaceholder(AssetPresenter<T> presenter);
41     }
54     public void setCoordinator(AssetPresenterCoordinator<T> controller) {
55         this.coordinator = controller;
56     }",No
,src\com\bumptech\photos\view\ThumbAssetPresenter.java,c63fed175ae10b0c90ecd883da58d04cc88526af,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,"Replace thumbnail inheritance with composition

Removes need to write load checking logic in two
places. Use a presenter coordinating interface to
keep minimal track of the presenter's states.","@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/28/12
+ * Time: 12:49 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoordinator<T> {
+    private final AssetPresenter<T> fullPresenter;
+    private final AssetPresenter<T> thumbPresenter;
+
+    public ThumbAssetPresenter(AssetPresenter<T> full, AssetPresenter<T> thumb) {
+        fullPresenter = full;
+        thumbPresenter = thumb;
+        thumbPresenter.setCoordinator(this);
+        fullPresenter.setCoordinator(this);
+    }
+
+    public void setAssetModels(T fullModel, T thumbModel) {
+        fullPresenter.setAssetModel(fullModel);
+        if (!fullPresenter.isImageSet()) {
+            thumbPresenter.setAssetModel(thumbModel);
+        }
+    }
+
+    public void setDimens(int width, int height) {
+        fullPresenter.setDimens(width, height);
+        thumbPresenter.setDimens(width, height);
+    }
+
+    public void clear(){
+        fullPresenter.clear();
+        thumbPresenter.clear();
+    }
+
+    @Override
+    public boolean canSetImage(AssetPresenter presenter) {
+        return presenter == fullPresenter || !fullPresenter.isImageSet();
+    }
+
+    @Override
+    public boolean canSetPlaceholder(AssetPresenter presenter) {
+        return presenter == fullPresenter;
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/28/12
11  * Time: 12:49 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoordinator<T> {
15     private final AssetPresenter<T> fullPresenter;
16     private final AssetPresenter<T> thumbPresenter;
17 
18     public ThumbAssetPresenter(AssetPresenter<T> full, AssetPresenter<T> thumb) {
19         fullPresenter = full;
20         thumbPresenter = thumb;
21         thumbPresenter.setCoordinator(this);
22         fullPresenter.setCoordinator(this);
23     }
24 
25     public void setAssetModels(T fullModel, T thumbModel) {
26         fullPresenter.setAssetModel(fullModel);
27         if (!fullPresenter.isImageSet()) {
28             thumbPresenter.setAssetModel(thumbModel);
29         }
30     }
31 
32     public void setDimens(int width, int height) {
33         fullPresenter.setDimens(width, height);
34         thumbPresenter.setDimens(width, height);
35     }
36 
37     public void clear(){
38         fullPresenter.clear();
39         thumbPresenter.clear();
40     }
41 
42     @Override
43     public boolean canSetImage(AssetPresenter presenter) {
44         return presenter == fullPresenter || !fullPresenter.isImageSet();
45     }
46 
47     @Override
48     public boolean canSetPlaceholder(AssetPresenter presenter) {
49         return presenter == fullPresenter;
50     }
51 }",No
src\com\bumptech\photos\view\ThumbnailAssetPresenter.java,,c63fed175ae10b0c90ecd883da58d04cc88526af,2d8d67d75ae964474e108e3481ca4e4ce5cf08ea,"Replace thumbnail inheritance with composition

Removes need to write load checking logic in two
places. Use a presenter coordinating interface to
keep minimal track of the presenter's states.","@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view;
-
-import android.graphics.Bitmap;
-import android.widget.ImageView;
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-import com.bumptech.photos.view.loader.AsIs;
-import com.bumptech.photos.view.loader.ImageLoader;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:59 PM
- * To change this template use File | Settings | File Templates.
- */
-public class ThumbnailAssetPresenter extends AssetPresenter {
-    private ImageSetCallback thumbSetCallback = null;
-    private String thumbAssetId = null;
-    private Object thumbToken = null;
-    private int thumbCount = 0;
-    private final AsIs thumbLoader;
-    private Bitmap currentThumbnail = null;
-
-    public ThumbnailAssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
-        super(imageView, photoManager, assetIdToPath, imageLoader);
-        thumbLoader = new AsIs();
-    }
-
-    public void setOnThumbSetCallback(ImageSetCallback cb) {
-        this.thumbSetCallback = cb;
-    }
-
-    public void setAssetIds(String fullId, final String thumbId) {
-        setAssetId(fullId);
-        if (!isImageSet()) {
-            final int loadCount = ++thumbCount;
-            thumbAssetId = thumbId;
-            if (thumbAssetId != null) {
-                fetchPath(thumbId, new AssetPathConverter.PathReadyListener() {
-                    @Override
-                    public void onPathReady(String path) {
-                        if (loadCount == thumbCount && !isImageSet()) {
-                            thumbToken = loadImage(path, thumbLoader, thumbResizeCallback(loadCount));
-                        }
-                    }
-                });
-            }
-        }
-    }
-
-    @Override
-    public void clear() {
-        thumbCount++;
-        thumbAssetId = null;
-        super.clear();
-    }
-
-    @Override
-    protected void maybeCancelOldTask() {
-        super.maybeCancelOldTask();
-        if (thumbToken != null) {
-            cancelTask(thumbToken);
-            thumbToken = null;
-        }
-    }
-
-    private LoadedCallback thumbResizeCallback(final int loadCount) {
-        return new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                if (loadCount == thumbCount && !isImageSet()) {
-                    if (thumbSetCallback != null) {
-                        thumbSetCallback.onImageSet(imageView, false);
-                    }
-                    imageView.setImageBitmap(loaded);
-
-                    updateAcquiredBitmap(currentThumbnail, loaded);
-                    currentThumbnail = loaded;
-                }
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) { }
-        };
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view;
6 
7 import android.graphics.Bitmap;
8 import android.widget.ImageView;
9 import com.bumptech.photos.LoadedCallback;
10 import com.bumptech.photos.PhotoManager;
11 import com.bumptech.photos.view.assetpath.AssetPathConverter;
12 import com.bumptech.photos.view.loader.AsIs;
13 import com.bumptech.photos.view.loader.ImageLoader;
14 
15 /**
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/25/12
19  * Time: 10:59 PM
20  * To change this template use File | Settings | File Templates.
21  */
22 public class ThumbnailAssetPresenter extends AssetPresenter {
23     private ImageSetCallback thumbSetCallback = null;
24     private String thumbAssetId = null;
25     private Object thumbToken = null;
26     private int thumbCount = 0;
27     private final AsIs thumbLoader;
28     private Bitmap currentThumbnail = null;
29 
30     public ThumbnailAssetPresenter(ImageView imageView, PhotoManager photoManager, AssetPathConverter assetIdToPath, ImageLoader imageLoader) {
31         super(imageView, photoManager, assetIdToPath, imageLoader);
32         thumbLoader = new AsIs();
33     }
34 
35     public void setOnThumbSetCallback(ImageSetCallback cb) {
36         this.thumbSetCallback = cb;
37     }
38 
39     public void setAssetIds(String fullId, final String thumbId) {
40         setAssetId(fullId);
41         if (!isImageSet()) {
42             final int loadCount = ++thumbCount;
43             thumbAssetId = thumbId;
44             if (thumbAssetId != null) {
45                 fetchPath(thumbId, new AssetPathConverter.PathReadyListener() {
46                     @Override
47                     public void onPathReady(String path) {
48                         if (loadCount == thumbCount && !isImageSet()) {
49                             thumbToken = loadImage(path, thumbLoader, thumbResizeCallback(loadCount));
50                         }
51                     }
52                 });
53             }
54         }
55     }
56 
57     @Override
58     public void clear() {
59         thumbCount++;
60         thumbAssetId = null;
61         super.clear();
62     }
63 
64     @Override
65     protected void maybeCancelOldTask() {
66         super.maybeCancelOldTask();
67         if (thumbToken != null) {
68             cancelTask(thumbToken);
69             thumbToken = null;
70         }
71     }
72 
73     private LoadedCallback thumbResizeCallback(final int loadCount) {
74         return new LoadedCallback() {
75             @Override
76             public void onLoadCompleted(Bitmap loaded) {
77                 if (loadCount == thumbCount && !isImageSet()) {
78                     if (thumbSetCallback != null) {
79                         thumbSetCallback.onImageSet(imageView, false);
80                     }
81                     imageView.setImageBitmap(loaded);
82 
83                     updateAcquiredBitmap(currentThumbnail, loaded);
84                     currentThumbnail = loaded;
85                 }
86             }
87 
88             @Override
89             public void onLoadFailed(Exception e) { }
90         };
91     }
92 }",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,1f6fd1482a0015b07d3bd5157f00c4e9e0a7c96b,c63fed175ae10b0c90ecd883da58d04cc88526af,Only fetch missing entries in disk cache once,"@@ -95,17 +95,16 @@ public class PhotoDiskCache {
 
                     if (snapshot1 != null) {
                         result1 = snapshot1.getInputStream(VALUE_COUNT - 1);
-                    } else {
-                        Log.d(""DLRU: not found key="" + key);
-                    }
                         DiskLruCache.Snapshot snapshot2 = cache.get(safeKey);
 
                         if (snapshot2 != null) {
                             result2 = snapshot2.getInputStream(VALUE_COUNT - 1);
                         } else {
-                        Log.d(""DLRU: not found key="" + key);
+                            Log.d(""DLRU: second snapshot not found key="" + key);
+                        }
+                    } else {
+                        Log.d(""DLRU: first snapshot not found key="" + key);
                     }
-
 
                 } catch (IOException e) {
                     Log.d(""DLRU: IOException? key="" + key);
","103                             Log.d(""DLRU: second snapshot not found key="" + key);
104                         }
105                     } else {
106                         Log.d(""DLRU: first snapshot not found key="" + key);
98                     } else {
99                         Log.d(""DLRU: not found key="" + key);
100                     }
106                         Log.d(""DLRU: not found key="" + key);
108 ",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,a0ef71a0d9b25dc69f22bd10fe8feec90db7d6c1,1f6fd1482a0015b07d3bd5157f00c4e9e0a7c96b,"Don't cancel disk cache puts

No point in doing the same work repeatedly, might
as well eagerly incur the cost of putting to the
disk cache and avoid having to resize again later.","@@ -184,7 +184,7 @@ public class PhotoManager {
                 acquireBitmap(resized);
                 if (!inDiskCache && useDiskCache) {
                     Runnable putToDiskCache = diskCache.put(key, resized);
-                    postJob(putToDiskCache, token);
+                    postJob(putToDiskCache, null);
                 }
                 cb.onLoadCompleted(resized);
             }
","187                     postJob(putToDiskCache, null);
187                     postJob(putToDiskCache, token);",No
src\com\bumptech\photos\view\ThumbAssetPresenter.java,src\com\bumptech\photos\view\ThumbAssetPresenter.java,7d123344ca35c80e24868f9a9f969c80683e80ec,a0ef71a0d9b25dc69f22bd10fe8feec90db7d6c1,Add more helper methods to thumb asset presenter,"@@ -4,6 +4,11 @@
 
 package com.bumptech.photos.view;
 
+import android.graphics.drawable.Drawable;
+import android.widget.ImageView;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
+import com.bumptech.photos.view.loader.ImageLoader;
+
 /**
  * Created with IntelliJ IDEA.
  * User: sam
@@ -15,6 +20,10 @@ public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoor
     private final AssetPresenter<T> fullPresenter;
     private final AssetPresenter<T> thumbPresenter;
 
+    public ThumbAssetPresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
+        this(new AssetPresenter<T>(imageView, converter,  fullLoader), new AssetPresenter<T>(imageView, converter, thumbLoader));
+    }
+
     public ThumbAssetPresenter(AssetPresenter<T> full, AssetPresenter<T> thumb) {
         fullPresenter = full;
         thumbPresenter = thumb;
@@ -34,6 +43,18 @@ public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoor
         thumbPresenter.setDimens(width, height);
     }
 
+    public void setOnFullSetCallback(ImageSetCallback cb) {
+        fullPresenter.setOnImageSetCallback(cb);
+    }
+
+    public void setOnThumbSetCallback(ImageSetCallback cb) {
+        thumbPresenter.setOnImageSetCallback(cb);
+    }
+
+    public void setPlaceholderDrawable(Drawable placeholderDrawable) {
+        fullPresenter.setPlaceholderDrawable(placeholderDrawable);
+    }
+
     public void clear(){
         fullPresenter.clear();
         thumbPresenter.clear();
","7 import android.graphics.drawable.Drawable;
8 import android.widget.ImageView;
9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
10 import com.bumptech.photos.view.loader.ImageLoader;
11 
23     public ThumbAssetPresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
24         this(new AssetPresenter<T>(imageView, converter,  fullLoader), new AssetPresenter<T>(imageView, converter, thumbLoader));
25     }
26 
46     public void setOnFullSetCallback(ImageSetCallback cb) {
47         fullPresenter.setOnImageSetCallback(cb);
48     }
49 
50     public void setOnThumbSetCallback(ImageSetCallback cb) {
51         thumbPresenter.setOnImageSetCallback(cb);
52     }
53 
54     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
55         fullPresenter.setPlaceholderDrawable(placeholderDrawable);
56     }
57 ",No
src\com\bumptech\photos\cache\SizedBitmapCache.java,src\com\bumptech\photos\cache\SizedBitmapCache.java,82e98eefdf8d3c867f98b138236914e7267a97dc,7d123344ca35c80e24868f9a9f969c80683e80ec,Increaes the size of the bitmap cache,"@@ -19,7 +19,7 @@ import java.util.Queue;
  * To change this template use File | Settings | File Templates.
  */
 public class SizedBitmapCache {
-    private static final int MAX_PER_SIZE = 8;
+    private static final int MAX_PER_SIZE = 10;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
 
     public void put(Bitmap bitmap) {
","22     private static final int MAX_PER_SIZE = 10;
22     private static final int MAX_PER_SIZE = 8;",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,203c74c40595dfb33aa038be015c7d7981bdb4f0,82e98eefdf8d3c867f98b138236914e7267a97dc,Don't try to track or recycle bitmaps if < 3.0,"@@ -5,6 +5,7 @@
 package com.bumptech.photos;
 
 import android.graphics.Bitmap;
+import android.os.Build;
 import android.os.Handler;
 import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
@@ -25,6 +26,8 @@ import java.util.Map;
  * To change this template use File | Settings | File Templates.
  */
 public class PhotoManager {
+    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
+
     private PhotoDiskCache diskCache;
     private LruPhotoCache memoryCache;
     private PhotoStreamResizer resizer;
@@ -49,7 +52,7 @@ public class PhotoManager {
             }
         });
         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
-        this.resizer = new PhotoStreamResizer(mainHandler, bitmapCache);
+        this.resizer = new PhotoStreamResizer(mainHandler, CAN_RECYCLE ? bitmapCache : null);
     }
 
     /**
@@ -207,6 +210,8 @@ public class PhotoManager {
     }
 
     public void acquireBitmap(Bitmap b) {
+        if (!CAN_RECYCLE) return;
+
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
         if (currentCount == null) {
             currentCount = 0;
@@ -215,8 +220,9 @@ public class PhotoManager {
     }
 
     public void releaseBitmap(Bitmap b) {
+        if (!CAN_RECYCLE) return;
+
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
-        Log.d(""PhotoManager: releaseBitmap currentCount="" + (currentCount));
         if (currentCount == 0) {
             bitmapReferenceCounter.remove(b.hashCode());
             bitmapCache.put(b);
","8 import android.os.Build;
29     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
30 
55         this.resizer = new PhotoStreamResizer(mainHandler, CAN_RECYCLE ? bitmapCache : null);
213         if (!CAN_RECYCLE) return;
214 
223         if (!CAN_RECYCLE) return;
224 
52         this.resizer = new PhotoStreamResizer(mainHandler, bitmapCache);
219         Log.d(""PhotoManager: releaseBitmap currentCount="" + (currentCount));",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\PhotoStreamResizer.java,203c74c40595dfb33aa038be015c7d7981bdb4f0,82e98eefdf8d3c867f98b138236914e7267a97dc,Don't try to track or recycle bitmaps if < 3.0,"@@ -4,7 +4,6 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import android.os.Build;
 import android.os.Handler;
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.cache.SizedBitmapCache;
@@ -17,7 +16,6 @@ import java.io.InputStream;
  *
  */
 public class PhotoStreamResizer {
-    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private Handler mainHandler;
     private final SizedBitmapCache bitmapCache;
@@ -140,7 +138,7 @@ public class PhotoStreamResizer {
         public final void run() {
             try {
                 Bitmap recycled = null;
-                if (CAN_RECYCLE && bitmapCache != null) {
+                if (bitmapCache != null) {
                     recycled = getRecycledBitmap();
                 }
                 final Bitmap result = resize(recycled);
","141                 if (bitmapCache != null) {
7 import android.os.Build;
20     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
143                 if (CAN_RECYCLE && bitmapCache != null) {",No
src\com\bumptech\photos\view\AssetPresenter.java,src\com\bumptech\photos\view\AssetPresenter.java,d4c1098771750e5ba8fc6c3838c836524b42a81a,203c74c40595dfb33aa038be015c7d7981bdb4f0,Remove requirement to set dimens in assetpresenter,"@@ -6,6 +6,7 @@ package com.bumptech.photos.view;
 
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
+import com.bumptech.photos.util.Log;
 import com.bumptech.photos.view.assetpath.AssetPathConverter;
 import com.bumptech.photos.view.loader.ImageLoader;
 
@@ -34,23 +35,35 @@ public class AssetPresenter<T> {
     private final AssetPathConverter<T> assetIdToPath;
     private final ImageLoader imageLoader;
     private AssetPresenterCoordinator coordinator;
+    final Runnable getDimens = new Runnable() {
+        @Override
+        public void run() {
+            width = imageView.getWidth();
+            height = imageView.getHeight();
+            Log.d(""AP: getDimens run width="" + width + "" height="" + height);
+            if (pendingLoad != null) {
+                if (width != 0 && height != 0) {
+                    imageView.post(pendingLoad);
+                    pendingLoad = null;
+                } else {
+                    imageView.postDelayed(getDimens, 50);
+                }
+            }
+        }
+    };
+    private Runnable pendingLoad = null;
 
     public interface AssetPresenterCoordinator<T> {
         public boolean canSetImage(AssetPresenter<T> presenter);
         public boolean canSetPlaceholder(AssetPresenter<T> presenter);
     }
 
-    public AssetPresenter(ImageView imageView, AssetPathConverter<T> assetIdToPath, ImageLoader imageLoader) {
+    public AssetPresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
         this.imageView = imageView;
         this.assetIdToPath = assetIdToPath;
         this.imageLoader = imageLoader;
     }
 
-    public void setDimens(int width, int height) {
-        this.width = width;
-        this.height = height;
-    }
-
     public void setCoordinator(AssetPresenterCoordinator<T> controller) {
         this.coordinator = controller;
     }
@@ -59,6 +72,10 @@ public class AssetPresenter<T> {
         this.placeholderDrawable = placeholderDrawable;
     }
 
+    public void setPlaceholderResource(int resourceId) {
+        this.placeholderDrawable = imageView.getResources().getDrawable(resourceId);
+    }
+
     public void setOnImageSetCallback(ImageSetCallback cb) {
         this.imageSetCallback = cb;
     }
@@ -77,9 +94,23 @@ public class AssetPresenter<T> {
         }
     }
 
-    public void onPathReady(String path, int loadCount) {
+    public void onPathReady(final String path, final int loadCount) {
         if (loadCount != currentCount) return;
 
+        if (width == 0 || height == 0) {
+            pendingLoad = new Runnable() {
+                @Override
+                public void run() {
+                    doLoad(path, loadCount);
+                }
+            };
+            imageView.post(getDimens);
+        } else {
+            doLoad(path, loadCount);
+        }
+    }
+
+    private void doLoad(String path, int loadCount) {
         imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
     }
 
","9 import com.bumptech.photos.util.Log;
38     final Runnable getDimens = new Runnable() {
39         @Override
40         public void run() {
41             width = imageView.getWidth();
42             height = imageView.getHeight();
43             Log.d(""AP: getDimens run width="" + width + "" height="" + height);
44             if (pendingLoad != null) {
45                 if (width != 0 && height != 0) {
46                     imageView.post(pendingLoad);
47                     pendingLoad = null;
48                 } else {
49                     imageView.postDelayed(getDimens, 50);
50                 }
51             }
52         }
53     };
54     private Runnable pendingLoad = null;
61     public AssetPresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
75     public void setPlaceholderResource(int resourceId) {
76         this.placeholderDrawable = imageView.getResources().getDrawable(resourceId);
77     }
78 
97     public void onPathReady(final String path, final int loadCount) {
100         if (width == 0 || height == 0) {
101             pendingLoad = new Runnable() {
102                 @Override
103                 public void run() {
104                     doLoad(path, loadCount);
105                 }
106             };
107             imageView.post(getDimens);
108         } else {
109             doLoad(path, loadCount);
110         }
111     }
112 
113     private void doLoad(String path, int loadCount) {
43     public AssetPresenter(ImageView imageView, AssetPathConverter<T> assetIdToPath, ImageLoader imageLoader) {
49     public void setDimens(int width, int height) {
50         this.width = width;
51         this.height = height;
52     }
53 
80     public void onPathReady(String path, int loadCount) {",No
src\com\bumptech\photos\view\ThumbAssetPresenter.java,src\com\bumptech\photos\view\ThumbAssetPresenter.java,d4c1098771750e5ba8fc6c3838c836524b42a81a,203c74c40595dfb33aa038be015c7d7981bdb4f0,Remove requirement to set dimens in assetpresenter,"@@ -38,11 +38,6 @@ public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoor
         }
     }
 
-    public void setDimens(int width, int height) {
-        fullPresenter.setDimens(width, height);
-        thumbPresenter.setDimens(width, height);
-    }
-
     public void setOnFullSetCallback(ImageSetCallback cb) {
         fullPresenter.setOnImageSetCallback(cb);
     }
","41     public void setDimens(int width, int height) {
42         fullPresenter.setDimens(width, height);
43         thumbPresenter.setDimens(width, height);
44     }
45 ",No
src\com\bumptech\photos\cache\LruPhotoCache.java,src\com\bumptech\photos\cache\LruPhotoCache.java,e01000c25ec231389438425c51a345ae34884c1f,d4c1098771750e5ba8fc6c3838c836524b42a81a,Remove log line,"@@ -49,7 +49,6 @@ public class LruPhotoCache{
         @Override
         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
             super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
-            Log.d(""RECYCLE entryRemoved evicted="" + evicted + "" oldValue="" + oldValue + "" newValue="" + newValue);
             if (evicted && photoRemovedListener != null) {
                 photoRemovedListener.onPhotoRemoved(key, oldValue);
             }
","52             Log.d(""RECYCLE entryRemoved evicted="" + evicted + "" oldValue="" + oldValue + "" newValue="" + newValue);",No
src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,de3fdb890a29f7fd547e409a3e130cc672c39f7b,e01000c25ec231389438425c51a345ae34884c1f,SimpleAssetPath just takes and returns a path,"@@ -13,7 +13,7 @@ package com.bumptech.photos.view.assetpath;
  */
 public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {
     @Override
-    public void fetchPath(String assetId, PathReadyListener listener) {
-        listener.onPathReady(assetId);
+    public void fetchPath(String path, PathReadyListener listener) {
+        listener.onPathReady(path);
     }
 }
","16     public void fetchPath(String path, PathReadyListener listener) {
17         listener.onPathReady(path);
16     public void fetchPath(String assetId, PathReadyListener listener) {
17         listener.onPathReady(assetId);",No
src\com\bumptech\photos\view\AssetPresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,52cba7bd25ed55ff12b348b673ae4b41c5390c4c,de3fdb890a29f7fd547e409a3e130cc672c39f7b,Rename Asset->Image presenters,"@@ -19,7 +19,7 @@ import java.lang.ref.WeakReference;
  * Time: 10:05 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AssetPresenter<T> {
+public class ImagePresenter<T> {
     private int height = 0;
     private int width = 0;
 
@@ -54,11 +54,11 @@ public class AssetPresenter<T> {
     private Runnable pendingLoad = null;
 
     public interface AssetPresenterCoordinator<T> {
-        public boolean canSetImage(AssetPresenter<T> presenter);
-        public boolean canSetPlaceholder(AssetPresenter<T> presenter);
+        public boolean canSetImage(ImagePresenter<T> presenter);
+        public boolean canSetPlaceholder(ImagePresenter<T> presenter);
     }
 
-    public AssetPresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
+    public ImagePresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
         this.imageView = imageView;
         this.assetIdToPath = assetIdToPath;
         this.imageLoader = imageLoader;
@@ -158,19 +158,19 @@ public class AssetPresenter<T> {
 
     private static class ImageReadyCallback implements ImageLoader.ImageReadyCallback{
 
-        private final WeakReference<AssetPresenter> assetPresenterRef;
+        private final WeakReference<ImagePresenter> assetPresenterRef;
         private final int loadCount;
 
-        public ImageReadyCallback(AssetPresenter assetPresenter, int loadCount) {
-            this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
+        public ImageReadyCallback(ImagePresenter imagePresenter, int loadCount) {
+            this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
             this.loadCount = loadCount;
         }
 
         @Override
         public void onImageReady() {
-            final AssetPresenter assetPresenter = assetPresenterRef.get();
-            if (assetPresenter != null ) {
-                assetPresenter.onImageReady(loadCount);
+            final ImagePresenter imagePresenter = assetPresenterRef.get();
+            if (imagePresenter != null ) {
+                imagePresenter.onImageReady(loadCount);
             }
         }
 
@@ -181,18 +181,18 @@ public class AssetPresenter<T> {
     private static class PathReadyCallback implements AssetPathConverter.PathReadyListener {
 
         private final int loadCount;
-        private final WeakReference<AssetPresenter> assetPresenterRef;
+        private final WeakReference<ImagePresenter> assetPresenterRef;
 
-        public PathReadyCallback(AssetPresenter assetPresenter, int loadCount) {
-            this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
+        public PathReadyCallback(ImagePresenter imagePresenter, int loadCount) {
+            this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
             this.loadCount = loadCount;
         }
 
         @Override
         public void onPathReady(String path) {
-            final AssetPresenter assetPresenter = assetPresenterRef.get();
-            if (assetPresenter != null) {
-                assetPresenter.onPathReady(path, loadCount);
+            final ImagePresenter imagePresenter = assetPresenterRef.get();
+            if (imagePresenter != null) {
+                imagePresenter.onPathReady(path, loadCount);
             }
         }
     }
","22 public class ImagePresenter<T> {
57         public boolean canSetImage(ImagePresenter<T> presenter);
58         public boolean canSetPlaceholder(ImagePresenter<T> presenter);
61     public ImagePresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
161         private final WeakReference<ImagePresenter> assetPresenterRef;
164         public ImageReadyCallback(ImagePresenter imagePresenter, int loadCount) {
165             this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
171             final ImagePresenter imagePresenter = assetPresenterRef.get();
172             if (imagePresenter != null ) {
173                 imagePresenter.onImageReady(loadCount);
184         private final WeakReference<ImagePresenter> assetPresenterRef;
186         public PathReadyCallback(ImagePresenter imagePresenter, int loadCount) {
187             this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
193             final ImagePresenter imagePresenter = assetPresenterRef.get();
194             if (imagePresenter != null) {
195                 imagePresenter.onPathReady(path, loadCount);
22 public class AssetPresenter<T> {
57         public boolean canSetImage(AssetPresenter<T> presenter);
58         public boolean canSetPlaceholder(AssetPresenter<T> presenter);
61     public AssetPresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
161         private final WeakReference<AssetPresenter> assetPresenterRef;
164         public ImageReadyCallback(AssetPresenter assetPresenter, int loadCount) {
165             this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
171             final AssetPresenter assetPresenter = assetPresenterRef.get();
172             if (assetPresenter != null ) {
173                 assetPresenter.onImageReady(loadCount);
184         private final WeakReference<AssetPresenter> assetPresenterRef;
186         public PathReadyCallback(AssetPresenter assetPresenter, int loadCount) {
187             this.assetPresenterRef = new WeakReference<AssetPresenter>(assetPresenter);
193             final AssetPresenter assetPresenter = assetPresenterRef.get();
194             if (assetPresenter != null) {
195                 assetPresenter.onPathReady(path, loadCount);",No
src\com\bumptech\photos\view\ThumbAssetPresenter.java,src\com\bumptech\photos\view\ThumbImagePresenter.java,52cba7bd25ed55ff12b348b673ae4b41c5390c4c,de3fdb890a29f7fd547e409a3e130cc672c39f7b,Rename Asset->Image presenters,"@@ -16,15 +16,15 @@ import com.bumptech.photos.view.loader.ImageLoader;
  * Time: 12:49 PM
  * To change this template use File | Settings | File Templates.
  */
-public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoordinator<T> {
-    private final AssetPresenter<T> fullPresenter;
-    private final AssetPresenter<T> thumbPresenter;
+public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoordinator<T> {
+    private final ImagePresenter<T> fullPresenter;
+    private final ImagePresenter<T> thumbPresenter;
 
-    public ThumbAssetPresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
-        this(new AssetPresenter<T>(imageView, converter,  fullLoader), new AssetPresenter<T>(imageView, converter, thumbLoader));
+    public ThumbImagePresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
+        this(new ImagePresenter<T>(imageView, converter,  fullLoader), new ImagePresenter<T>(imageView, converter, thumbLoader));
     }
 
-    public ThumbAssetPresenter(AssetPresenter<T> full, AssetPresenter<T> thumb) {
+    public ThumbImagePresenter(ImagePresenter<T> full, ImagePresenter<T> thumb) {
         fullPresenter = full;
         thumbPresenter = thumb;
         thumbPresenter.setCoordinator(this);
@@ -56,12 +56,12 @@ public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoor
     }
 
     @Override
-    public boolean canSetImage(AssetPresenter presenter) {
+    public boolean canSetImage(ImagePresenter presenter) {
         return presenter == fullPresenter || !fullPresenter.isImageSet();
     }
 
     @Override
-    public boolean canSetPlaceholder(AssetPresenter presenter) {
+    public boolean canSetPlaceholder(ImagePresenter presenter) {
         return presenter == fullPresenter;
     }
 }
","19 public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoordinator<T> {
20     private final ImagePresenter<T> fullPresenter;
21     private final ImagePresenter<T> thumbPresenter;
23     public ThumbImagePresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
24         this(new ImagePresenter<T>(imageView, converter,  fullLoader), new ImagePresenter<T>(imageView, converter, thumbLoader));
27     public ThumbImagePresenter(ImagePresenter<T> full, ImagePresenter<T> thumb) {
59     public boolean canSetImage(ImagePresenter presenter) {
64     public boolean canSetPlaceholder(ImagePresenter presenter) {
19 public class ThumbAssetPresenter<T> implements AssetPresenter.AssetPresenterCoordinator<T> {
20     private final AssetPresenter<T> fullPresenter;
21     private final AssetPresenter<T> thumbPresenter;
23     public ThumbAssetPresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
24         this(new AssetPresenter<T>(imageView, converter,  fullLoader), new AssetPresenter<T>(imageView, converter, thumbLoader));
27     public ThumbAssetPresenter(AssetPresenter<T> full, AssetPresenter<T> thumb) {
59     public boolean canSetImage(AssetPresenter presenter) {
64     public boolean canSetPlaceholder(AssetPresenter presenter) {",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,12fcbf8629d2c7df78e075e22ba76380989987df,52cba7bd25ed55ff12b348b673ae4b41c5390c4c,Rename stream resizer to match what it now does,"@@ -11,7 +11,7 @@ import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
 import com.bumptech.photos.cache.PhotoDiskCache;
 import com.bumptech.photos.cache.SizedBitmapCache;
-import com.bumptech.photos.resize.PhotoStreamResizer;
+import com.bumptech.photos.resize.ResizeJobGenerator;
 
 import java.io.File;
 import java.io.InputStream;
@@ -30,7 +30,7 @@ public class PhotoManager {
 
     private PhotoDiskCache diskCache;
     private LruPhotoCache memoryCache;
-    private PhotoStreamResizer resizer;
+    private ResizeJobGenerator resizer;
     private Handler backgroundHandler;
     private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private SizedBitmapCache bitmapCache = new SizedBitmapCache();
@@ -52,7 +52,7 @@ public class PhotoManager {
             }
         });
         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
-        this.resizer = new PhotoStreamResizer(mainHandler, CAN_RECYCLE ? bitmapCache : null);
+        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);
     }
 
     /**
","14 import com.bumptech.photos.resize.ResizeJobGenerator;
33     private ResizeJobGenerator resizer;
55         this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);
14 import com.bumptech.photos.resize.PhotoStreamResizer;
33     private PhotoStreamResizer resizer;
55         this.resizer = new PhotoStreamResizer(mainHandler, CAN_RECYCLE ? bitmapCache : null);",No
src\com\bumptech\photos\resize\PhotoStreamResizer.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,12fcbf8629d2c7df78e075e22ba76380989987df,52cba7bd25ed55ff12b348b673ae4b41c5390c4c,Rename stream resizer to match what it now does,"@@ -15,16 +15,16 @@ import java.io.InputStream;
  * @author sam
  *
  */
-public class PhotoStreamResizer {
+public class ResizeJobGenerator {
 
     private Handler mainHandler;
     private final SizedBitmapCache bitmapCache;
 
-    public PhotoStreamResizer(Handler mainHandler) {
+    public ResizeJobGenerator(Handler mainHandler) {
         this(mainHandler, null);
     }
 
-    public PhotoStreamResizer(Handler mainHandler, SizedBitmapCache bitmapCache){
+    public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){
         this.mainHandler = mainHandler;
         this.bitmapCache = bitmapCache;
     }
","18 public class ResizeJobGenerator {
23     public ResizeJobGenerator(Handler mainHandler) {
27     public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){
18 public class PhotoStreamResizer {
23     public PhotoStreamResizer(Handler mainHandler) {
27     public PhotoStreamResizer(Handler mainHandler, SizedBitmapCache bitmapCache){",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,ef5b145fcd68bb3d4c216b29f0c0b820ab909aff,12fcbf8629d2c7df78e075e22ba76380989987df,Use builder pattern for image presenters,"@@ -20,11 +20,68 @@ import java.lang.ref.WeakReference;
  * To change this template use File | Settings | File Templates.
  */
 public class ImagePresenter<T> {
+    public static class Builder<T> {
+        private ImageView imageView;
+        private AssetPathConverter<T> assetPathConverter;
+        private ImageLoader imageLoader;
+        private int placeholderResourceId;
+        private Drawable placeholderDrawable;
+        private ImageSetCallback imageSetCallback;
+        private AssetPresenterCoordinator coordinator;
+
+        public ImagePresenter<T> build(){
+            assert imageView != null : ""cannot create presenter without an image view"";
+            assert assetPathConverter != null : ""cannot create presenter without an asset to path converter"";
+            assert imageLoader != null : ""cannot create presenter without an image loader"";
+
+            return new ImagePresenter<T>(this);
+        }
+
+        public Builder<T> setImageView(ImageView imageView) {
+            this.imageView = imageView;
+            return this;
+        }
+
+        public Builder<T> setAssetPathConverter(AssetPathConverter<T> converter) {
+            this.assetPathConverter = converter;
+            return this;
+        }
+
+        public Builder<T> setImageLoader(ImageLoader imageLoader) {
+            this.imageLoader = imageLoader;
+            return this;
+        }
+
+        public Builder<T> setPlaceholderResource(int resourceId) {
+            assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
+
+            this.placeholderResourceId = resourceId;
+            return this;
+        }
+
+        public Builder<T> setPlaceholderDrawable(Drawable placeholderDrawable) {
+            assert placeholderDrawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
+
+            this.placeholderDrawable = placeholderDrawable;
+            return this;
+        }
+
+        public Builder<T> setImageSetCallback(ImageSetCallback cb) {
+            this.imageSetCallback = cb;
+            return this;
+        }
+
+        public Builder<T> setAssetPresenterCoordinator(AssetPresenterCoordinator<T> coordinator) {
+            this.coordinator = coordinator;
+            return this;
+        }
+    }
+
     private int height = 0;
     private int width = 0;
 
-    private Drawable placeholderDrawable;
-    private ImageSetCallback imageSetCallback;
+    private final Drawable placeholderDrawable;
+    private final ImageSetCallback imageSetCallback;
 
     private T currentModel;
     private int currentCount;
@@ -34,7 +91,8 @@ public class ImagePresenter<T> {
 
     private final AssetPathConverter<T> assetIdToPath;
     private final ImageLoader imageLoader;
-    private AssetPresenterCoordinator coordinator;
+    private final AssetPresenterCoordinator coordinator;
+
     final Runnable getDimens = new Runnable() {
         @Override
         public void run() {
@@ -58,26 +116,21 @@ public class ImagePresenter<T> {
         public boolean canSetPlaceholder(ImagePresenter<T> presenter);
     }
 
-    public ImagePresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
-        this.imageView = imageView;
-        this.assetIdToPath = assetIdToPath;
-        this.imageLoader = imageLoader;
-    }
-
-    public void setCoordinator(AssetPresenterCoordinator<T> controller) {
-        this.coordinator = controller;
-    }
-
-    public void setPlaceholderDrawable(Drawable placeholderDrawable) {
-        this.placeholderDrawable = placeholderDrawable;
+    private ImagePresenter(Builder<T> builder) {
+        this.imageView = builder.imageView;
+        this.assetIdToPath = builder.assetPathConverter;
+        this.imageLoader = builder.imageLoader;
+        if (builder.placeholderResourceId != 0) {
+            this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
+        } else {
+            this.placeholderDrawable = builder.placeholderDrawable;
         }
-
-    public void setPlaceholderResource(int resourceId) {
-        this.placeholderDrawable = imageView.getResources().getDrawable(resourceId);
+        this.coordinator = builder.coordinator;
+        this.imageSetCallback = builder.imageSetCallback;
     }
 
-    public void setOnImageSetCallback(ImageSetCallback cb) {
-        this.imageSetCallback = cb;
+    public ImageView getImageView() {
+        return imageView;
     }
 
     public void setAssetModel(final T model) {
@@ -110,10 +163,6 @@ public class ImagePresenter<T> {
         }
     }
 
-    private void doLoad(String path, int loadCount) {
-        imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
-    }
-
     public void onImageReady(int loadCount) {
         if (loadCount != currentCount || !canSetImage()) return;
 
@@ -148,6 +197,10 @@ public class ImagePresenter<T> {
         return isImageSet;
     }
 
+    private void doLoad(String path, int loadCount) {
+        imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
+    }
+
     private boolean canSetImage() {
         return coordinator == null || coordinator.canSetImage(this);
     }
","23     public static class Builder<T> {
24         private ImageView imageView;
25         private AssetPathConverter<T> assetPathConverter;
26         private ImageLoader imageLoader;
27         private int placeholderResourceId;
28         private Drawable placeholderDrawable;
29         private ImageSetCallback imageSetCallback;
30         private AssetPresenterCoordinator coordinator;
31 
32         public ImagePresenter<T> build(){
33             assert imageView != null : ""cannot create presenter without an image view"";
34             assert assetPathConverter != null : ""cannot create presenter without an asset to path converter"";
35             assert imageLoader != null : ""cannot create presenter without an image loader"";
36 
37             return new ImagePresenter<T>(this);
38         }
39 
40         public Builder<T> setImageView(ImageView imageView) {
41             this.imageView = imageView;
42             return this;
43         }
44 
45         public Builder<T> setAssetPathConverter(AssetPathConverter<T> converter) {
46             this.assetPathConverter = converter;
47             return this;
48         }
49 
50         public Builder<T> setImageLoader(ImageLoader imageLoader) {
51             this.imageLoader = imageLoader;
52             return this;
53         }
54 
55         public Builder<T> setPlaceholderResource(int resourceId) {
56             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
57 
58             this.placeholderResourceId = resourceId;
59             return this;
60         }
61 
62         public Builder<T> setPlaceholderDrawable(Drawable placeholderDrawable) {
63             assert placeholderDrawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
64 
65             this.placeholderDrawable = placeholderDrawable;
66             return this;
67         }
68 
69         public Builder<T> setImageSetCallback(ImageSetCallback cb) {
70             this.imageSetCallback = cb;
71             return this;
72         }
73 
74         public Builder<T> setAssetPresenterCoordinator(AssetPresenterCoordinator<T> coordinator) {
75             this.coordinator = coordinator;
76             return this;
77         }
78     }
79 
83     private final Drawable placeholderDrawable;
84     private final ImageSetCallback imageSetCallback;
94     private final AssetPresenterCoordinator coordinator;
95 
119     private ImagePresenter(Builder<T> builder) {
120         this.imageView = builder.imageView;
121         this.assetIdToPath = builder.assetPathConverter;
122         this.imageLoader = builder.imageLoader;
123         if (builder.placeholderResourceId != 0) {
124             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
125         } else {
126             this.placeholderDrawable = builder.placeholderDrawable;
127         }
128         this.coordinator = builder.coordinator;
129         this.imageSetCallback = builder.imageSetCallback;
132     public ImageView getImageView() {
133         return imageView;
200     private void doLoad(String path, int loadCount) {
201         imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
202     }
203 
26     private Drawable placeholderDrawable;
27     private ImageSetCallback imageSetCallback;
37     private AssetPresenterCoordinator coordinator;
61     public ImagePresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {
62         this.imageView = imageView;
63         this.assetIdToPath = assetIdToPath;
64         this.imageLoader = imageLoader;
67     public void setCoordinator(AssetPresenterCoordinator<T> controller) {
68         this.coordinator = controller;
69     }
70 
71     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
72         this.placeholderDrawable = placeholderDrawable;
73     }
74 
75     public void setPlaceholderResource(int resourceId) {
76         this.placeholderDrawable = imageView.getResources().getDrawable(resourceId);
77     }
78 
79     public void setOnImageSetCallback(ImageSetCallback cb) {
80         this.imageSetCallback = cb;
113     private void doLoad(String path, int loadCount) {
114         imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
115     }
116 ",No
src\com\bumptech\photos\view\ThumbImagePresenter.java,src\com\bumptech\photos\view\ThumbImagePresenter.java,ef5b145fcd68bb3d4c216b29f0c0b820ab909aff,12fcbf8629d2c7df78e075e22ba76380989987df,Use builder pattern for image presenters,"@@ -7,7 +7,6 @@ package com.bumptech.photos.view;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
 import com.bumptech.photos.view.assetpath.AssetPathConverter;
-import com.bumptech.photos.view.loader.ImageLoader;
 
 /**
  * Created with IntelliJ IDEA.
@@ -17,37 +16,80 @@ import com.bumptech.photos.view.loader.ImageLoader;
  * To change this template use File | Settings | File Templates.
  */
 public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoordinator<T> {
-    private final ImagePresenter<T> fullPresenter;
-    private final ImagePresenter<T> thumbPresenter;
 
-    public ThumbImagePresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
-        this(new ImagePresenter<T>(imageView, converter,  fullLoader), new ImagePresenter<T>(imageView, converter, thumbLoader));
+    public static class Builder<T> {
+        private ImagePresenter.Builder<T> fullPresenterBuilder;
+        private ImagePresenter.Builder<T> thumbPresenterBuilder;
+        private ImageView imageView;
+        private Drawable placeholderDrawable;
+        private int placeholderResourceId;
+
+        public ThumbImagePresenter<T> build(){
+            assert fullPresenterBuilder != null : ""you must include a builder for the full image presenter"";
+            assert thumbPresenterBuilder != null : ""you must include a builder for the thumb image presenter"";
+            assert imageView != null : ""cannot create presenter without an image view"";
+
+            return new ThumbImagePresenter<T>(this);
         }
 
-    public ThumbImagePresenter(ImagePresenter<T> full, ImagePresenter<T> thumb) {
-        fullPresenter = full;
-        thumbPresenter = thumb;
-        thumbPresenter.setCoordinator(this);
-        fullPresenter.setCoordinator(this);
+        public Builder<T> setFullPresenterBuilder(ImagePresenter.Builder<T> builder) {
+            this.fullPresenterBuilder = builder;
+            return this;
         }
 
-    public void setAssetModels(T fullModel, T thumbModel) {
-        fullPresenter.setAssetModel(fullModel);
-        if (!fullPresenter.isImageSet()) {
-            thumbPresenter.setAssetModel(thumbModel);
+        public Builder<T> setThumbPresenterBuilder(ImagePresenter.Builder<T> builder) {
+            this.thumbPresenterBuilder = builder;
+            return this;
+        }
+
+        public Builder<T> setImageView(ImageView imageView) {
+            this.imageView = imageView;
+            return this;
+        }
+
+        public Builder<T> setPlaceholderDrawable(Drawable drawable) {
+            assert drawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
+
+            this.placeholderDrawable = drawable;
+            return this;
+        }
+
+        public Builder<T> setPlaceholderResource(int resourceId) {
+            assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
+
+            this.placeholderResourceId = resourceId;
+            return this;
         }
     }
 
-    public void setOnFullSetCallback(ImageSetCallback cb) {
-        fullPresenter.setOnImageSetCallback(cb);
+    private final ImagePresenter<T> fullPresenter;
+    private final ImagePresenter<T> thumbPresenter;
+
+    private ThumbImagePresenter(Builder<T> builder) {
+        fullPresenter = builder.fullPresenterBuilder
+                .setAssetPresenterCoordinator(this)
+                .setImageView(builder.imageView)
+                .setPlaceholderResource(0)
+                .setPlaceholderDrawable(builder.placeholderDrawable == null ?
+                        builder.imageView.getResources().getDrawable(builder.placeholderResourceId) : builder.placeholderDrawable)
+                .build();
+        thumbPresenter = builder.thumbPresenterBuilder
+                .setAssetPresenterCoordinator(this)
+                .setImageView(builder.imageView)
+                .setPlaceholderDrawable(null)
+                .setPlaceholderResource(0)
+                .build();
     }
 
-    public void setOnThumbSetCallback(ImageSetCallback cb) {
-        thumbPresenter.setOnImageSetCallback(cb);
+    public void setAssetModels(T fullModel, T thumbModel) {
+        fullPresenter.setAssetModel(fullModel);
+        if (!fullPresenter.isImageSet()) {
+            thumbPresenter.setAssetModel(thumbModel);
+        }
     }
 
-    public void setPlaceholderDrawable(Drawable placeholderDrawable) {
-        fullPresenter.setPlaceholderDrawable(placeholderDrawable);
+    public ImageView getImageView() {
+        return fullPresenter.getImageView();
     }
 
     public void clear(){
","19 
20     public static class Builder<T> {
21         private ImagePresenter.Builder<T> fullPresenterBuilder;
22         private ImagePresenter.Builder<T> thumbPresenterBuilder;
23         private ImageView imageView;
24         private Drawable placeholderDrawable;
25         private int placeholderResourceId;
26 
27         public ThumbImagePresenter<T> build(){
28             assert fullPresenterBuilder != null : ""you must include a builder for the full image presenter"";
29             assert thumbPresenterBuilder != null : ""you must include a builder for the thumb image presenter"";
30             assert imageView != null : ""cannot create presenter without an image view"";
31 
32             return new ThumbImagePresenter<T>(this);
33         }
34 
35         public Builder<T> setFullPresenterBuilder(ImagePresenter.Builder<T> builder) {
36             this.fullPresenterBuilder = builder;
37             return this;
38         }
39 
40         public Builder<T> setThumbPresenterBuilder(ImagePresenter.Builder<T> builder) {
41             this.thumbPresenterBuilder = builder;
42             return this;
43         }
44 
45         public Builder<T> setImageView(ImageView imageView) {
46             this.imageView = imageView;
47             return this;
48         }
49 
50         public Builder<T> setPlaceholderDrawable(Drawable drawable) {
51             assert drawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
52 
53             this.placeholderDrawable = drawable;
54             return this;
55         }
56 
57         public Builder<T> setPlaceholderResource(int resourceId) {
58             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
59 
60             this.placeholderResourceId = resourceId;
61             return this;
62         }
63     }
64 
68     private ThumbImagePresenter(Builder<T> builder) {
69         fullPresenter = builder.fullPresenterBuilder
70                 .setAssetPresenterCoordinator(this)
71                 .setImageView(builder.imageView)
72                 .setPlaceholderResource(0)
73                 .setPlaceholderDrawable(builder.placeholderDrawable == null ?
74                         builder.imageView.getResources().getDrawable(builder.placeholderResourceId) : builder.placeholderDrawable)
75                 .build();
76         thumbPresenter = builder.thumbPresenterBuilder
77                 .setAssetPresenterCoordinator(this)
78                 .setImageView(builder.imageView)
79                 .setPlaceholderDrawable(null)
80                 .setPlaceholderResource(0)
81                 .build();
91     public ImageView getImageView() {
92         return fullPresenter.getImageView();
10 import com.bumptech.photos.view.loader.ImageLoader;
23     public ThumbImagePresenter(ImageView imageView, AssetPathConverter<T> converter, ImageLoader fullLoader, ImageLoader thumbLoader) {
24         this(new ImagePresenter<T>(imageView, converter,  fullLoader), new ImagePresenter<T>(imageView, converter, thumbLoader));
25     }
26 
27     public ThumbImagePresenter(ImagePresenter<T> full, ImagePresenter<T> thumb) {
28         fullPresenter = full;
29         thumbPresenter = thumb;
30         thumbPresenter.setCoordinator(this);
31         fullPresenter.setCoordinator(this);
41     public void setOnFullSetCallback(ImageSetCallback cb) {
42         fullPresenter.setOnImageSetCallback(cb);
43     }
44 
45     public void setOnThumbSetCallback(ImageSetCallback cb) {
46         thumbPresenter.setOnImageSetCallback(cb);
47     }
48 
49     public void setPlaceholderDrawable(Drawable placeholderDrawable) {
50         fullPresenter.setPlaceholderDrawable(placeholderDrawable);",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,c23e55e744febc38b831dd8956831180fb9b1cc1,ef5b145fcd68bb3d4c216b29f0c0b820ab909aff,"Fix a memory leak

If a view hadn't been measured by the time the 
path was loaded, the dimens runnable would repost
itself until it was. For views that are invisible,
this would occur forever, or until the view became
visible. If the view never became visible, the
runnable would be reposted infinitely and retain
its references infinitely -> leaking photo manager","@@ -5,6 +5,7 @@
 package com.bumptech.photos.view;
 
 import android.graphics.drawable.Drawable;
+import android.view.ViewTreeObserver;
 import android.widget.ImageView;
 import com.bumptech.photos.util.Log;
 import com.bumptech.photos.view.assetpath.AssetPathConverter;
@@ -77,35 +78,34 @@ public class ImagePresenter<T> {
         }
     }
 
-    private int height = 0;
-    private int width = 0;
-
+    private final AssetPathConverter<T> assetIdToPath;
+    private final ImageLoader imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
+    private final AssetPresenterCoordinator coordinator;
+    protected final ImageView imageView;
+
+    private int height = 0;
+    private int width = 0;
 
     private T currentModel;
     private int currentCount;
 
     private boolean isImageSet;
-    protected final ImageView imageView;
 
-    private final AssetPathConverter<T> assetIdToPath;
-    private final ImageLoader imageLoader;
-    private final AssetPresenterCoordinator coordinator;
+    private boolean setLayoutListener = false;
+    private final Runnable getDimens = new Runnable() {
 
-    final Runnable getDimens = new Runnable() {
         @Override
         public void run() {
+            Log.d(""AP: getDimens run width="" + width + "" height="" + height);
             width = imageView.getWidth();
             height = imageView.getHeight();
-            Log.d(""AP: getDimens run width="" + width + "" height="" + height);
-            if (pendingLoad != null) {
-                if (width != 0 && height != 0) {
+            if ((width == 0 || height == 0) && !setLayoutListener) {
+                imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
+                setLayoutListener = true;
+            } else if (pendingLoad != null) {
                 imageView.post(pendingLoad);
-                    pendingLoad = null;
-                } else {
-                    imageView.postDelayed(getDimens, 50);
-                }
             }
         }
     };
@@ -157,7 +157,7 @@ public class ImagePresenter<T> {
                     doLoad(path, loadCount);
                 }
             };
-            imageView.post(getDimens);
+            getDimens();
         } else {
             doLoad(path, loadCount);
         }
@@ -193,6 +193,10 @@ public class ImagePresenter<T> {
         return height;
     }
 
+    public void getDimens() {
+        imageView.post(getDimens);
+    }
+
     protected boolean isImageSet() {
         return isImageSet;
     }
@@ -249,4 +253,24 @@ public class ImagePresenter<T> {
             }
         }
     }
+
+    private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
+
+        private final WeakReference<ImageView> imageViewRef;
+        private final WeakReference<ImagePresenter> imagePresenterRef;
+
+        public SizeObserver(ImageView imageVew, ImagePresenter imagePresenter) {
+            imageViewRef = new WeakReference<ImageView>(imageVew);
+            imagePresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
+        }
+
+        @Override
+        public void onGlobalLayout() {
+            ImageView imageView = imageViewRef.get();
+            ImagePresenter presenter = imagePresenterRef.get();
+            if (imageView != null && presenter != null && imageView.getWidth() > 0 && imageView.getHeight() > 0) {
+                presenter.getDimens();
+            }
+        }
+    }
 }
","8 import android.view.ViewTreeObserver;
81     private final AssetPathConverter<T> assetIdToPath;
82     private final ImageLoader imageLoader;
85     private final AssetPresenterCoordinator coordinator;
86     protected final ImageView imageView;
87 
88     private int height = 0;
89     private int width = 0;
96     private boolean setLayoutListener = false;
97     private final Runnable getDimens = new Runnable() {
101             Log.d(""AP: getDimens run width="" + width + "" height="" + height);
104             if ((width == 0 || height == 0) && !setLayoutListener) {
105                 imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
106                 setLayoutListener = true;
107             } else if (pendingLoad != null) {
160             getDimens();
196     public void getDimens() {
197         imageView.post(getDimens);
198     }
199 
256 
257     private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
258 
259         private final WeakReference<ImageView> imageViewRef;
260         private final WeakReference<ImagePresenter> imagePresenterRef;
261 
262         public SizeObserver(ImageView imageVew, ImagePresenter imagePresenter) {
263             imageViewRef = new WeakReference<ImageView>(imageVew);
264             imagePresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
265         }
266 
267         @Override
268         public void onGlobalLayout() {
269             ImageView imageView = imageViewRef.get();
270             ImagePresenter presenter = imagePresenterRef.get();
271             if (imageView != null && presenter != null && imageView.getWidth() > 0 && imageView.getHeight() > 0) {
272                 presenter.getDimens();
273             }
274         }
275     }
80     private int height = 0;
81     private int width = 0;
82 
90     protected final ImageView imageView;
92     private final AssetPathConverter<T> assetIdToPath;
93     private final ImageLoader imageLoader;
94     private final AssetPresenterCoordinator coordinator;
96     final Runnable getDimens = new Runnable() {
101             Log.d(""AP: getDimens run width="" + width + "" height="" + height);
102             if (pendingLoad != null) {
103                 if (width != 0 && height != 0) {
105                     pendingLoad = null;
106                 } else {
107                     imageView.postDelayed(getDimens, 50);
108                 }
160             imageView.post(getDimens);",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -4,11 +4,11 @@
 
 package com.bumptech.photos.view;
 
+import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
 import com.bumptech.photos.util.Log;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
 import com.bumptech.photos.view.loader.ImageLoader;
 
 import java.lang.ref.WeakReference;
@@ -21,10 +21,12 @@ import java.lang.ref.WeakReference;
  * To change this template use File | Settings | File Templates.
  */
 public class ImagePresenter<T> {
+    private Object pathToken;
+    private Object imageToken;
+
     public static class Builder<T> {
         private ImageView imageView;
-        private AssetPathConverter<T> assetPathConverter;
-        private ImageLoader imageLoader;
+        private ImageLoader<T> imageLoader;
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
         private ImageSetCallback imageSetCallback;
@@ -32,7 +34,6 @@ public class ImagePresenter<T> {
 
         public ImagePresenter<T> build(){
             assert imageView != null : ""cannot create presenter without an image view"";
-            assert assetPathConverter != null : ""cannot create presenter without an asset to path converter"";
             assert imageLoader != null : ""cannot create presenter without an image loader"";
 
             return new ImagePresenter<T>(this);
@@ -43,12 +44,7 @@ public class ImagePresenter<T> {
             return this;
         }
 
-        public Builder<T> setAssetPathConverter(AssetPathConverter<T> converter) {
-            this.assetPathConverter = converter;
-            return this;
-        }
-
-        public Builder<T> setImageLoader(ImageLoader imageLoader) {
+        public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
             this.imageLoader = imageLoader;
             return this;
         }
@@ -78,8 +74,7 @@ public class ImagePresenter<T> {
         }
     }
 
-    private final AssetPathConverter<T> assetIdToPath;
-    private final ImageLoader imageLoader;
+    private final ImageLoader<T> imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
     private final AssetPresenterCoordinator coordinator;
@@ -101,9 +96,11 @@ public class ImagePresenter<T> {
             Log.d(""AP: getDimens run width="" + width + "" height="" + height);
             width = imageView.getWidth();
             height = imageView.getHeight();
-            if ((width == 0 || height == 0) && !setLayoutListener) {
+            if (width == 0 || height == 0) {
+                if (!setLayoutListener) {
                     imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
                     setLayoutListener = true;
+                }
             } else if (pendingLoad != null) {
                 imageView.post(pendingLoad);
             }
@@ -118,7 +115,6 @@ public class ImagePresenter<T> {
 
     private ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
-        this.assetIdToPath = builder.assetPathConverter;
         this.imageLoader = builder.imageLoader;
         if (builder.placeholderResourceId != 0) {
             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
@@ -140,36 +136,21 @@ public class ImagePresenter<T> {
         currentModel = model;
         isImageSet = false;
 
-        assetIdToPath.fetchPath(model, new PathReadyCallback(this, loadCount));
-
-        if (!isImageSet()) {
-            resetPlaceHolder();
-        }
-    }
-
-    public void onPathReady(final String path, final int loadCount) {
-        if (loadCount != currentCount) return;
-
         if (width == 0 || height == 0) {
             pendingLoad = new Runnable() {
                 @Override
                 public void run() {
-                    doLoad(path, loadCount);
+                    fetchPath(model, loadCount);
                 }
             };
             getDimens();
         } else {
-            doLoad(path, loadCount);
-        }
+            fetchPath(model, loadCount);
         }
 
-    public void onImageReady(int loadCount) {
-        if (loadCount != currentCount || !canSetImage()) return;
-
-        if (imageSetCallback != null)
-            imageSetCallback.onImageSet(imageView, false);
-        imageView.setImageBitmap(imageLoader.getReadyBitmap());
-        isImageSet = true;
+        if (!isImageSet()) {
+            resetPlaceHolder();
+        }
     }
 
     public void resetPlaceHolder() {
@@ -183,6 +164,8 @@ public class ImagePresenter<T> {
         imageView.setImageBitmap(null);
         currentModel = null;
         isImageSet = false;
+        imageToken = null;
+        pathToken = null;
     }
 
     public int getWidth() {
@@ -193,65 +176,53 @@ public class ImagePresenter<T> {
         return height;
     }
 
-    public void getDimens() {
-        imageView.post(getDimens);
-    }
-
-    protected boolean isImageSet() {
-        return isImageSet;
-    }
-
-    private void doLoad(String path, int loadCount) {
-        imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
-    }
+    private void fetchPath(final T model, final int loadCount) {
+        pathToken = imageLoader.fetchPath(model, getWidth(), getHeight(), new ImageLoader.PathReadyCallback() {
+            @Override
+            public boolean onPathReady(String path) {
+                if (loadCount != currentCount) return false;
 
-    private boolean canSetImage() {
-        return coordinator == null || coordinator.canSetImage(this);
+                fetchImage(path, model, loadCount);
+                return true;
             }
 
-    private boolean canSetPlaceholder() {
-        return coordinator == null || coordinator.canSetPlaceholder(this);
+            @Override
+            public void onError(Exception e) { }
+        });
     }
 
-    private static class ImageReadyCallback implements ImageLoader.ImageReadyCallback{
-
-        private final WeakReference<ImagePresenter> assetPresenterRef;
-        private final int loadCount;
+    private void fetchImage(String path, T model, final int loadCount) {
+         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
+            @Override
+            public boolean onImageReady(Bitmap image) {
+                if (loadCount != currentCount || !canSetImage()) return false;
 
-        public ImageReadyCallback(ImagePresenter imagePresenter, int loadCount) {
-            this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
-            this.loadCount = loadCount;
+                if (imageSetCallback != null)
+                    imageSetCallback.onImageSet(imageView, false);
+                imageView.setImageBitmap(image);
+                isImageSet = true;
+                return true;
             }
 
             @Override
-        public void onImageReady() {
-            final ImagePresenter imagePresenter = assetPresenterRef.get();
-            if (imagePresenter != null ) {
-                imagePresenter.onImageReady(loadCount);
-            }
+            public void onError(Exception e) { }
+        });
     }
 
-        @Override
-        public void onLoadFailed(Exception e) { }
+    private void getDimens() {
+        imageView.post(getDimens);
     }
 
-    private static class PathReadyCallback implements AssetPathConverter.PathReadyListener {
-
-        private final int loadCount;
-        private final WeakReference<ImagePresenter> assetPresenterRef;
-
-        public PathReadyCallback(ImagePresenter imagePresenter, int loadCount) {
-            this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
-            this.loadCount = loadCount;
+    protected boolean isImageSet() {
+        return isImageSet;
     }
 
-        @Override
-        public void onPathReady(String path) {
-            final ImagePresenter imagePresenter = assetPresenterRef.get();
-            if (imagePresenter != null) {
-                imagePresenter.onPathReady(path, loadCount);
-            }
+    private boolean canSetImage() {
+        return coordinator == null || coordinator.canSetImage(this);
     }
+
+    private boolean canSetPlaceholder() {
+        return coordinator == null || coordinator.canSetPlaceholder(this);
     }
 
     private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
","7 import android.graphics.Bitmap;
24     private Object pathToken;
25     private Object imageToken;
26 
29         private ImageLoader<T> imageLoader;
47         public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
77     private final ImageLoader<T> imageLoader;
99             if (width == 0 || height == 0) {
100                 if (!setLayoutListener) {
103                 }
143                     fetchPath(model, loadCount);
148             fetchPath(model, loadCount);
151         if (!isImageSet()) {
152             resetPlaceHolder();
153         }
167         imageToken = null;
168         pathToken = null;
179     private void fetchPath(final T model, final int loadCount) {
180         pathToken = imageLoader.fetchPath(model, getWidth(), getHeight(), new ImageLoader.PathReadyCallback() {
181             @Override
182             public boolean onPathReady(String path) {
183                 if (loadCount != currentCount) return false;
184 
185                 fetchImage(path, model, loadCount);
186                 return true;
187             }
188 
189             @Override
190             public void onError(Exception e) { }
191         });
192     }
193 
194     private void fetchImage(String path, T model, final int loadCount) {
195          imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
196             @Override
197             public boolean onImageReady(Bitmap image) {
198                 if (loadCount != currentCount || !canSetImage()) return false;
199 
200                 if (imageSetCallback != null)
201                     imageSetCallback.onImageSet(imageView, false);
202                 imageView.setImageBitmap(image);
203                 isImageSet = true;
204                 return true;
205             }
206 
207             @Override
208             public void onError(Exception e) { }
209         });
210     }
211 
212     private void getDimens() {
11 import com.bumptech.photos.view.assetpath.AssetPathConverter;
26         private AssetPathConverter<T> assetPathConverter;
27         private ImageLoader imageLoader;
35             assert assetPathConverter != null : ""cannot create presenter without an asset to path converter"";
46         public Builder<T> setAssetPathConverter(AssetPathConverter<T> converter) {
47             this.assetPathConverter = converter;
48             return this;
49         }
50 
51         public Builder<T> setImageLoader(ImageLoader imageLoader) {
81     private final AssetPathConverter<T> assetIdToPath;
82     private final ImageLoader imageLoader;
104             if ((width == 0 || height == 0) && !setLayoutListener) {
121         this.assetIdToPath = builder.assetPathConverter;
143         assetIdToPath.fetchPath(model, new PathReadyCallback(this, loadCount));
144 
145         if (!isImageSet()) {
146             resetPlaceHolder();
147         }
148     }
149 
150     public void onPathReady(final String path, final int loadCount) {
151         if (loadCount != currentCount) return;
152 
157                     doLoad(path, loadCount);
162             doLoad(path, loadCount);
163         }
166     public void onImageReady(int loadCount) {
167         if (loadCount != currentCount || !canSetImage()) return;
168 
169         if (imageSetCallback != null)
170             imageSetCallback.onImageSet(imageView, false);
171         imageView.setImageBitmap(imageLoader.getReadyBitmap());
172         isImageSet = true;
196     public void getDimens() {
204     private void doLoad(String path, int loadCount) {
205         imageLoader.loadImage(path, width, height, new ImageReadyCallback(this, loadCount));
206     }
207 
216     private static class ImageReadyCallback implements ImageLoader.ImageReadyCallback{
217 
218         private final WeakReference<ImagePresenter> assetPresenterRef;
219         private final int loadCount;
220 
221         public ImageReadyCallback(ImagePresenter imagePresenter, int loadCount) {
222             this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
223             this.loadCount = loadCount;
224         }
225 
226         @Override
227         public void onImageReady() {
228             final ImagePresenter imagePresenter = assetPresenterRef.get();
229             if (imagePresenter != null ) {
230                 imagePresenter.onImageReady(loadCount);
231             }
232         }
233 
234         @Override
235         public void onLoadFailed(Exception e) { }
236     }
237 
238     private static class PathReadyCallback implements AssetPathConverter.PathReadyListener {
239 
240         private final int loadCount;
241         private final WeakReference<ImagePresenter> assetPresenterRef;
242 
243         public PathReadyCallback(ImagePresenter imagePresenter, int loadCount) {
244             this.assetPresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
245             this.loadCount = loadCount;
246         }
247 
248         @Override
249         public void onPathReady(String path) {
250             final ImagePresenter imagePresenter = assetPresenterRef.get();
251             if (imagePresenter != null) {
252                 imagePresenter.onPathReady(path, loadCount);
253             }
254         }
255     }
256 ",No
src\com\bumptech\photos\view\assetpath\AssetPathConverter.java,src\com\bumptech\photos\view\assetpath\AssetPathConverter.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -13,8 +13,9 @@ package com.bumptech.photos.view.assetpath;
  */
 public interface AssetPathConverter<T> {
     public interface PathReadyListener {
-        public void onPathReady(String path);
+        public void pathReady(String path);
+        public void onError(Exception e);
     }
 
-    public void fetchPath(T model, PathReadyListener listener);
+    public void fetchPath(T model, int width, int height, PathReadyListener listener);
 }
","16         public void pathReady(String path);
17         public void onError(Exception e);
20     public void fetchPath(T model, int width, int height, PathReadyListener listener);
16         public void onPathReady(String path);
19     public void fetchPath(T model, PathReadyListener listener);",No
src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -12,8 +12,12 @@ package com.bumptech.photos.view.assetpath;
  * To change this template use File | Settings | File Templates.
  */
 public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {
-    @Override
     public void fetchPath(String path, PathReadyListener listener) {
-        listener.onPathReady(path);
+        fetchPath(path, 0, 0, listener);
+    }
+
+    @Override
+    public void fetchPath(String path, int width, int height, PathReadyListener listener) {
+        listener.pathReady(path);
     }
 }
","16         fetchPath(path, 0, 0, listener);
17     }
18 
19     @Override
20     public void fetchPath(String path, int width, int height, PathReadyListener listener) {
21         listener.pathReady(path);
15     @Override
17         listener.onPathReady(path);",No
src\com\bumptech\photos\view\loader\Approximate.java,src\com\bumptech\photos\view\loader\Approximate.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -6,6 +6,7 @@ package com.bumptech.photos.view.loader;
 
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
 
 /**
  * Created with IntelliJ IDEA.
@@ -14,14 +15,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:58 PM
  * To change this template use File | Settings | File Templates.
  */
-public class Approximate extends ImageLoader {
+public class Approximate<T> extends PhotoManagerLoader<T> {
 
-    public Approximate(PhotoManager photoManager) {
-        super(photoManager);
+    public Approximate(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        super(photoManager, assetToPath);
     }
 
     @Override
-    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
         return photoManager.getImage(path, width, height, cb);
     }
 }
","9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
18 public class Approximate<T> extends PhotoManagerLoader<T> {
20     public Approximate(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
17 public class Approximate extends ImageLoader {
19     public Approximate(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {",No
src\com\bumptech\photos\view\loader\AsIs.java,src\com\bumptech\photos\view\loader\AsIs.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -6,6 +6,7 @@ package com.bumptech.photos.view.loader;
 
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
 
 /**
  * Created with IntelliJ IDEA.
@@ -14,14 +15,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:57 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AsIs extends ImageLoader {
+public class AsIs<T> extends PhotoManagerLoader<T> {
 
-    public AsIs(PhotoManager photoManager) {
-        super(photoManager);
+    public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        super(photoManager, assetToPath);
     }
 
     @Override
-    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
         return photoManager.getImage(path, cb);
     }
 }
","9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
18 public class AsIs<T> extends PhotoManagerLoader<T> {
20     public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
17 public class AsIs extends ImageLoader {
19     public AsIs(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {",No
,src\com\bumptech\photos\view\loader\BaseImageLoader.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import android.graphics.Bitmap;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/29/12
+ * Time: 2:05 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class BaseImageLoader<T> implements ImageLoader<T> {
+
+    @Override
+    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
+        doFetchPath(model, width, height, cb);
+        return cb;
+    }
+
+    protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
+
+    private final void onPathReady(String path, PathReadyCallback cb) {
+        onPathReady(path, cb.onPathReady(path));
+    }
+
+    protected void onPathReady(String path, boolean isUsed) {}
+
+    protected void onPathFetchFailed(Exception e, PathReadyCallback cb) {
+        cb.onError(e);
+    }
+
+    @Override
+    public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
+        doFetchImage(path, model, width, height, cb);
+        return cb;
+    }
+
+    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
+
+    private final void onImageReady(Bitmap image, ImageReadyCallback cb) {
+        onImageReady(image, cb.onImageReady(image));
+    }
+
+    protected void onImageReady(Bitmap image, boolean isUsed) {}
+
+    protected void onImageLoadFailed(Exception e, ImageReadyCallback cb) {
+        cb.onError(e);
+    }
+
+    public abstract static class ImageLoaderCallback<T> {
+        private final WeakReference<BaseImageLoader<T>> imageLoaderRef;
+
+        public ImageLoaderCallback(BaseImageLoader<T> imageLoader) {
+            imageLoaderRef = new WeakReference<BaseImageLoader<T>>(imageLoader);
+        }
+
+        public BaseImageLoader<T> getImageLoader() {
+            return imageLoaderRef.get();
+        }
+    }
+
+    public abstract static class InternalPathReadyCallback<T> extends ImageLoaderCallback<T>{
+        private final WeakReference<PathReadyCallback> cbRef;
+
+        public InternalPathReadyCallback(BaseImageLoader<T> imageLoader, PathReadyCallback cb) {
+            super(imageLoader);
+            this.cbRef = new WeakReference<PathReadyCallback>(cb);
+        }
+
+        protected final void onPathReady(String path) {
+            final BaseImageLoader<T> imageLoader = getImageLoader();
+            final PathReadyCallback cb = cbRef.get();
+            if (imageLoader != null && cb != null) {
+                imageLoader.onPathReady(path, cb);
+            }
+        }
+
+        protected final void onPathLoadFailed(Exception e) {
+            final BaseImageLoader<T> imageLoader = getImageLoader();
+            final PathReadyCallback cb = cbRef.get();
+            if (imageLoader != null && cb != null) {
+                imageLoader.onPathFetchFailed(e, cb);
+            }
+        }
+    }
+
+    public abstract static class InternalImageReadyCallback<T> extends ImageLoaderCallback<T>{
+        private final WeakReference<ImageReadyCallback> cbRef;
+
+        public InternalImageReadyCallback(BaseImageLoader<T> imageLoader, ImageReadyCallback cb) {
+            super(imageLoader);
+            this.cbRef = new WeakReference<ImageReadyCallback>(cb);
+        }
+
+        protected final void onImageReady(Bitmap image) {
+            final BaseImageLoader<T> imageLoader = getImageLoader();
+            final ImageReadyCallback cb = cbRef.get();
+            if (imageLoader != null && cb != null) {
+                imageLoader.onImageReady(image, cb);
+            }
+        }
+
+        protected final void onImageLoadFailed(Exception e) {
+            final BaseImageLoader<T> imageLoader = getImageLoader();
+            final ImageReadyCallback cb = cbRef.get();
+            if (imageLoader != null && cb != null) {
+                imageLoader.onImageLoadFailed(e, cb);
+            }
+        }
+    }
+
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import android.graphics.Bitmap;
8 
9 import java.lang.ref.WeakReference;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/29/12
15  * Time: 2:05 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
19 
20     @Override
21     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
22         doFetchPath(model, width, height, cb);
23         return cb;
24     }
25 
26     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
27 
28     private final void onPathReady(String path, PathReadyCallback cb) {
29         onPathReady(path, cb.onPathReady(path));
30     }
31 
32     protected void onPathReady(String path, boolean isUsed) {}
33 
34     protected void onPathFetchFailed(Exception e, PathReadyCallback cb) {
35         cb.onError(e);
36     }
37 
38     @Override
39     public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
40         doFetchImage(path, model, width, height, cb);
41         return cb;
42     }
43 
44     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
45 
46     private final void onImageReady(Bitmap image, ImageReadyCallback cb) {
47         onImageReady(image, cb.onImageReady(image));
48     }
49 
50     protected void onImageReady(Bitmap image, boolean isUsed) {}
51 
52     protected void onImageLoadFailed(Exception e, ImageReadyCallback cb) {
53         cb.onError(e);
54     }
55 
56     public abstract static class ImageLoaderCallback<T> {
57         private final WeakReference<BaseImageLoader<T>> imageLoaderRef;
58 
59         public ImageLoaderCallback(BaseImageLoader<T> imageLoader) {
60             imageLoaderRef = new WeakReference<BaseImageLoader<T>>(imageLoader);
61         }
62 
63         public BaseImageLoader<T> getImageLoader() {
64             return imageLoaderRef.get();
65         }
66     }
67 
68     public abstract static class InternalPathReadyCallback<T> extends ImageLoaderCallback<T>{
69         private final WeakReference<PathReadyCallback> cbRef;
70 
71         public InternalPathReadyCallback(BaseImageLoader<T> imageLoader, PathReadyCallback cb) {
72             super(imageLoader);
73             this.cbRef = new WeakReference<PathReadyCallback>(cb);
74         }
75 
76         protected final void onPathReady(String path) {
77             final BaseImageLoader<T> imageLoader = getImageLoader();
78             final PathReadyCallback cb = cbRef.get();
79             if (imageLoader != null && cb != null) {
80                 imageLoader.onPathReady(path, cb);
81             }
82         }
83 
84         protected final void onPathLoadFailed(Exception e) {
85             final BaseImageLoader<T> imageLoader = getImageLoader();
86             final PathReadyCallback cb = cbRef.get();
87             if (imageLoader != null && cb != null) {
88                 imageLoader.onPathFetchFailed(e, cb);
89             }
90         }
91     }
92 
93     public abstract static class InternalImageReadyCallback<T> extends ImageLoaderCallback<T>{
94         private final WeakReference<ImageReadyCallback> cbRef;
95 
96         public InternalImageReadyCallback(BaseImageLoader<T> imageLoader, ImageReadyCallback cb) {
97             super(imageLoader);
98             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
99         }
100 
101         protected final void onImageReady(Bitmap image) {
102             final BaseImageLoader<T> imageLoader = getImageLoader();
103             final ImageReadyCallback cb = cbRef.get();
104             if (imageLoader != null && cb != null) {
105                 imageLoader.onImageReady(image, cb);
106             }
107         }
108 
109         protected final void onImageLoadFailed(Exception e) {
110             final BaseImageLoader<T> imageLoader = getImageLoader();
111             final ImageReadyCallback cb = cbRef.get();
112             if (imageLoader != null && cb != null) {
113                 imageLoader.onImageLoadFailed(e, cb);
114             }
115         }
116     }
117 
118 }",No
src\com\bumptech\photos\view\loader\CenterCrop.java,src\com\bumptech\photos\view\loader\CenterCrop.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -6,6 +6,7 @@ package com.bumptech.photos.view.loader;
 
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
 
 /**
  * Created with IntelliJ IDEA.
@@ -14,13 +15,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:54 PM
  * To change this template use File | Settings | File Templates.
  */
-public class CenterCrop extends ImageLoader {
-    public CenterCrop(PhotoManager photoManager) {
-        super(photoManager);
+public class CenterCrop<T> extends PhotoManagerLoader<T> {
+
+    public CenterCrop(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        super(photoManager, assetToPath);
     }
 
     @Override
-    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
         return photoManager.centerCrop(path, width, height, cb);
     }
 }
","9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
18 public class CenterCrop<T> extends PhotoManagerLoader<T> {
19 
20     public CenterCrop(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
17 public class CenterCrop extends ImageLoader {
18     public CenterCrop(PhotoManager photoManager) {
19         super(photoManager);
23     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {",No
src\com\bumptech\photos\view\loader\FitCenter.java,src\com\bumptech\photos\view\loader\FitCenter.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -6,6 +6,7 @@ package com.bumptech.photos.view.loader;
 
 import com.bumptech.photos.LoadedCallback;
 import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
 
 /**
  * Created with IntelliJ IDEA.
@@ -14,14 +15,14 @@ import com.bumptech.photos.PhotoManager;
  * Time: 10:56 PM
  * To change this template use File | Settings | File Templates.
  */
-public class FitCenter extends ImageLoader {
+public class FitCenter<T> extends PhotoManagerLoader<T> {
 
-    public FitCenter(PhotoManager photoManager) {
-        super(photoManager);
+    public FitCenter(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        super(photoManager, assetToPath);
     }
 
     @Override
-    protected Object doLoad(String path, int width, int height, LoadedCallback cb) {
+    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
         return photoManager.fitCenter(path, width, height, cb);
     }
 }
","9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
18 public class FitCenter<T> extends PhotoManagerLoader<T> {
20     public FitCenter(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
17 public class FitCenter extends ImageLoader {
19     public FitCenter(PhotoManager photoManager) {
20         super(photoManager);
24     protected Object doLoad(String path, int width, int height, LoadedCallback cb) {",No
src\com\bumptech\photos\view\loader\ImageLoader.java,src\com\bumptech\photos\view\loader\ImageLoader.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -5,60 +5,26 @@
 package com.bumptech.photos.view.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
 
 /**
  * Created with IntelliJ IDEA.
  * User: sam
- * Date: 12/28/12
- * Time: 9:53 AM
+ * Date: 12/29/12
+ * Time: 11:32 AM
  * To change this template use File | Settings | File Templates.
  */
-public abstract class ImageLoader {
-    protected final PhotoManager photoManager;
-    private Bitmap acquired = null;
-    private Bitmap ready = null;
-    private Object loadToken = null;
-
-    public interface ImageReadyCallback {
-        public void onImageReady();
-        public void onLoadFailed(Exception e);
-    }
-
-    public ImageLoader(PhotoManager photoManager) {
-        this.photoManager = photoManager;
-    }
-
-    public void loadImage(String path, int width, int height, final ImageReadyCallback callback) {
-        photoManager.cancelTask(loadToken);
-
-        loadToken = doLoad(path, width, height, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                ready = loaded;
-                callback.onImageReady();
+public interface ImageLoader<T>  {
+    public interface PathReadyCallback {
+        public boolean onPathReady(String path);
+        public void onError(Exception e);
     }
 
-            @Override
-            public void onLoadFailed(Exception e) {
-                callback.onLoadFailed(e);
-            }
-        });
+    public interface ImageReadyCallback {
+        public boolean onImageReady(Bitmap image);
+        public void onError(Exception e);
     }
 
-    public Bitmap getReadyBitmap() {
-        if (acquired != null) {
-            photoManager.releaseBitmap(acquired);
-            acquired = null;
-        }
-        if (ready != null) {
-            photoManager.acquireBitmap(ready);
-            acquired = ready;
-            ready = null;
-        }
-        return acquired;
-    }
+    public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
+    public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
 
-    protected abstract Object doLoad(String path, int width, int height, LoadedCallback cb);
 }
","12  * Date: 12/29/12
13  * Time: 11:32 AM
16 public interface ImageLoader<T>  {
17     public interface PathReadyCallback {
18         public boolean onPathReady(String path);
19         public void onError(Exception e);
20     }
23         public boolean onImageReady(Bitmap image);
24         public void onError(Exception e);
27     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
28     public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
8 import com.bumptech.photos.LoadedCallback;
9 import com.bumptech.photos.PhotoManager;
14  * Date: 12/28/12
15  * Time: 9:53 AM
18 public abstract class ImageLoader {
19     protected final PhotoManager photoManager;
20     private Bitmap acquired = null;
21     private Bitmap ready = null;
22     private Object loadToken = null;
25         public void onImageReady();
26         public void onLoadFailed(Exception e);
29     public ImageLoader(PhotoManager photoManager) {
30         this.photoManager = photoManager;
31     }
33     public void loadImage(String path, int width, int height, final ImageReadyCallback callback) {
34         photoManager.cancelTask(loadToken);
35 
36         loadToken = doLoad(path, width, height, new LoadedCallback() {
37             @Override
38             public void onLoadCompleted(Bitmap loaded) {
39                 ready = loaded;
40                 callback.onImageReady();
41             }
42 
43             @Override
44             public void onLoadFailed(Exception e) {
45                 callback.onLoadFailed(e);
46             }
47         });
48     }
49 
50     public Bitmap getReadyBitmap() {
51         if (acquired != null) {
52             photoManager.releaseBitmap(acquired);
53             acquired = null;
54         }
55         if (ready != null) {
56             photoManager.acquireBitmap(ready);
57             acquired = ready;
58             ready = null;
59         }
60         return acquired;
61     }
62 
63     protected abstract Object doLoad(String path, int width, int height, LoadedCallback cb);",No
,src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,2f75519799a09db2b467b202df6283fb2c636b3f,c23e55e744febc38b831dd8956831180fb9b1cc1,"BaseImageLoader manages refs and loader lifecycle

Allows simpler callbacks in the presenter or
higher levels and moves responsibility for not 
leaking referneces into the image loader. ALso
combines ImageLoader and AssetPathConverter 
interface to simplify the external interface and
make it possible to use a presenter with a model
that already has a path or otherwise doesn't need
to fetch one.","@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.loader;
+
+import android.graphics.Bitmap;
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/28/12
+ * Time: 9:53 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
+
+    protected final PhotoManager photoManager;
+    private final AssetPathConverter<T> assetToPath;
+    private Bitmap acquired = null;
+    private Object loadToken = null;
+
+    public PhotoManagerLoader(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        this.photoManager = photoManager;
+        this.assetToPath = assetToPath;
+    }
+
+    @Override
+    public final void doFetchPath(T model, int width, int height, ImageLoader.PathReadyCallback cb) {
+        assetToPath.fetchPath(model, width, height, new PathReadyCallback(this, cb));
+    }
+
+    @Override
+    protected final void doFetchImage(String path, T model, int width, int height, ImageLoader.ImageReadyCallback cb) {
+        if (loadToken != null)  {
+            photoManager.cancelTask(loadToken);
+        }
+
+        loadToken = doFetchImage(path, model, width, height, new ImageReadyCallback(this, cb));
+    }
+
+    protected abstract Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb);
+
+    @Override
+    protected void onImageReady(Bitmap image, boolean isUsed) {
+         if (isUsed) {
+            if (acquired != null) {
+                photoManager.releaseBitmap(acquired);
+            }
+            photoManager.acquireBitmap(image);
+            acquired = image;
+        }
+    }
+
+    @Override
+    public void onImageLoadFailed(Exception e, ImageLoader.ImageReadyCallback cb) {
+        cb.onError(e);
+    }
+
+    private static class PathReadyCallback<T> extends BaseImageLoader.InternalPathReadyCallback<T> implements AssetPathConverter.PathReadyListener {
+
+        public PathReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.PathReadyCallback cb) {
+            super(imageLoader, cb);
+        }
+
+        @Override
+        public void pathReady(String path) {
+            onPathReady(path);
+        }
+
+        @Override
+        public void onError(Exception e) {
+            onPathLoadFailed(e);
+        }
+    }
+
+    private static class ImageReadyCallback<T> extends BaseImageLoader.InternalImageReadyCallback<T> implements LoadedCallback{
+
+        public ImageReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.ImageReadyCallback cb) {
+            super(imageLoader, cb);
+        }
+
+        @Override
+        public void onLoadCompleted(Bitmap loaded) {
+            onImageReady(loaded);
+        }
+
+        @Override
+        public void onLoadFailed(Exception e) {
+            onImageLoadFailed(e);
+        }
+    }
+
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import android.graphics.Bitmap;
8 import com.bumptech.photos.LoadedCallback;
9 import com.bumptech.photos.PhotoManager;
10 import com.bumptech.photos.view.assetpath.AssetPathConverter;
11 
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 12/28/12
16  * Time: 9:53 AM
17  * To change this template use File | Settings | File Templates.
18  */
19 public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
20 
21     protected final PhotoManager photoManager;
22     private final AssetPathConverter<T> assetToPath;
23     private Bitmap acquired = null;
24     private Object loadToken = null;
25 
26     public PhotoManagerLoader(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
27         this.photoManager = photoManager;
28         this.assetToPath = assetToPath;
29     }
30 
31     @Override
32     public final void doFetchPath(T model, int width, int height, ImageLoader.PathReadyCallback cb) {
33         assetToPath.fetchPath(model, width, height, new PathReadyCallback(this, cb));
34     }
35 
36     @Override
37     protected final void doFetchImage(String path, T model, int width, int height, ImageLoader.ImageReadyCallback cb) {
38         if (loadToken != null)  {
39             photoManager.cancelTask(loadToken);
40         }
41 
42         loadToken = doFetchImage(path, model, width, height, new ImageReadyCallback(this, cb));
43     }
44 
45     protected abstract Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb);
46 
47     @Override
48     protected void onImageReady(Bitmap image, boolean isUsed) {
49          if (isUsed) {
50             if (acquired != null) {
51                 photoManager.releaseBitmap(acquired);
52             }
53             photoManager.acquireBitmap(image);
54             acquired = image;
55         }
56     }
57 
58     @Override
59     public void onImageLoadFailed(Exception e, ImageLoader.ImageReadyCallback cb) {
60         cb.onError(e);
61     }
62 
63     private static class PathReadyCallback<T> extends BaseImageLoader.InternalPathReadyCallback<T> implements AssetPathConverter.PathReadyListener {
64 
65         public PathReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.PathReadyCallback cb) {
66             super(imageLoader, cb);
67         }
68 
69         @Override
70         public void pathReady(String path) {
71             onPathReady(path);
72         }
73 
74         @Override
75         public void onError(Exception e) {
76             onPathLoadFailed(e);
77         }
78     }
79 
80     private static class ImageReadyCallback<T> extends BaseImageLoader.InternalImageReadyCallback<T> implements LoadedCallback{
81 
82         public ImageReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.ImageReadyCallback cb) {
83             super(imageLoader, cb);
84         }
85 
86         @Override
87         public void onLoadCompleted(Bitmap loaded) {
88             onImageReady(loaded);
89         }
90 
91         @Override
92         public void onLoadFailed(Exception e) {
93             onImageLoadFailed(e);
94         }
95     }
96 
97 }",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,e074e84df1af85f0ce6425a8a05d13bc3b07cfe8,2f75519799a09db2b467b202df6283fb2c636b3f,Add a way to queue bitmaps that are never aquired,"@@ -209,6 +209,16 @@ public class PhotoManager {
         }
     }
 
+    public void rejectBitmap(Bitmap b) {
+        if (!CAN_RECYCLE) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
+        if (currentCount == null || currentCount == 0) {
+            bitmapReferenceCounter.remove(b.hashCode());
+            bitmapCache.put(b);
+        }
+    }
+
     public void acquireBitmap(Bitmap b) {
         if (!CAN_RECYCLE) return;
 
","212     public void rejectBitmap(Bitmap b) {
213         if (!CAN_RECYCLE) return;
214 
215         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
216         if (currentCount == null || currentCount == 0) {
217             bitmapReferenceCounter.remove(b.hashCode());
218             bitmapCache.put(b);
219         }
220     }
221 ",No
src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,e074e84df1af85f0ce6425a8a05d13bc3b07cfe8,2f75519799a09db2b467b202df6283fb2c636b3f,Add a way to queue bitmaps that are never aquired,"@@ -52,6 +52,8 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
             }
             photoManager.acquireBitmap(image);
             acquired = image;
+        } else {
+            photoManager.rejectBitmap(image);
         }
     }
 
","55         } else {
56             photoManager.rejectBitmap(image);",No
src\com\bumptech\photos\cache\LruPhotoCache.java,src\com\bumptech\photos\cache\LruPhotoCache.java,9e19bf0d4784d355f3740371397d74a6d139cac8,e074e84df1af85f0ce6425a8a05d13bc3b07cfe8,"Fix losing track of bitmaps when they are replaced

If the bitmap in the cache were replaced, rather
than being evicted, the listener would not be 
notified and we would leak a reference.","@@ -49,7 +49,7 @@ public class LruPhotoCache{
         @Override
         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
             super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
-            if (evicted && photoRemovedListener != null) {
+            if (photoRemovedListener != null) {
                 photoRemovedListener.onPhotoRemoved(key, oldValue);
             }
         }
","52             if (photoRemovedListener != null) {
52             if (evicted && photoRemovedListener != null) {",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,e8f337ac173ee4713592c461a041222838cbe3b5,9e19bf0d4784d355f3740371397d74a6d139cac8,Use recycled bitmaps when performing a center crop,"@@ -30,7 +30,12 @@ public class ResizeJobGenerator {
     }
 
     public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){
-        return new SimpleStreamResizeRunnable(callback) {
+        return new StreamResizeRunnable(callback) {
+
+            @Override
+            public Bitmap getRecycledBitmap() {
+                return bitmapCache.get(width, height);
+            }
 
             @Override
             public Bitmap resize(Bitmap recycled) {
@@ -39,7 +44,7 @@ public class ResizeJobGenerator {
                 if (streamed.getWidth() == width && streamed.getHeight() == height) {
                     return streamed;
                 } else {
-                    return Utils.centerCrop(streamed, width, height);
+                    return Utils.centerCrop(recycled, streamed, width, height);
                 }
             }
         };
","33         return new StreamResizeRunnable(callback) {
34 
35             @Override
36             public Bitmap getRecycledBitmap() {
37                 return bitmapCache.get(width, height);
38             }
47                     return Utils.centerCrop(recycled, streamed, width, height);
33         return new SimpleStreamResizeRunnable(callback) {
42                     return Utils.centerCrop(streamed, width, height);",No
src\com\bumptech\photos\resize\Utils.java,src\com\bumptech\photos\resize\Utils.java,e8f337ac173ee4713592c461a041222838cbe3b5,9e19bf0d4784d355f3740371397d74a6d139cac8,Use recycled bitmaps when performing a center crop,"@@ -25,6 +25,10 @@ import java.io.InputStream;
 public class Utils {
 
     public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
+        return centerCrop(null, toCrop, width, height);
+    }
+
+    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
         if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
             return toCrop;
         }
@@ -44,7 +48,7 @@ public class Utils {
 
         m.setScale(scale, scale);
         m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
-        Bitmap result = Bitmap.createBitmap(width, height, toCrop.getConfig());
+        Bitmap result = recycled != null ? recycled : Bitmap.createBitmap(width, height, toCrop.getConfig());
         Canvas canvas = new Canvas(result);
         Paint paint = new Paint();
         //only if scaling up
","28         return centerCrop(null, toCrop, width, height);
29     }
30 
31     public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
51         Bitmap result = recycled != null ? recycled : Bitmap.createBitmap(width, height, toCrop.getConfig());
47         Bitmap result = Bitmap.createBitmap(width, height, toCrop.getConfig());",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,55e575b69f1b37507e0612c9e3be64169f3717a2,e8f337ac173ee4713592c461a041222838cbe3b5,Pass in correct value if image comes from cache,"@@ -87,6 +87,7 @@ public class ImagePresenter<T> {
     private int currentCount;
 
     private boolean isImageSet;
+    private boolean loadedFromCache = false;
 
     private boolean setLayoutListener = false;
     private final Runnable getDimens = new Runnable() {
@@ -132,6 +133,7 @@ public class ImagePresenter<T> {
     public void setAssetModel(final T model) {
         if (model == null || model.equals(currentModel)) return;
 
+        loadedFromCache = true;
         final int loadCount = ++currentCount;
         currentModel = model;
         isImageSet = false;
@@ -148,6 +150,8 @@ public class ImagePresenter<T> {
             fetchPath(model, loadCount);
         }
 
+        loadedFromCache = false;
+
         if (!isImageSet()) {
             resetPlaceHolder();
         }
@@ -191,14 +195,14 @@ public class ImagePresenter<T> {
         });
     }
 
-    private void fetchImage(String path, T model, final int loadCount) {
+    private void fetchImage(final String path, T model, final int loadCount) {
         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage()) return false;
 
                 if (imageSetCallback != null)
-                    imageSetCallback.onImageSet(imageView, false);
+                    imageSetCallback.onImageSet(imageView, loadedFromCache);
                 imageView.setImageBitmap(image);
                 isImageSet = true;
                 return true;
","90     private boolean loadedFromCache = false;
136         loadedFromCache = true;
153         loadedFromCache = false;
154 
198     private void fetchImage(final String path, T model, final int loadCount) {
205                     imageSetCallback.onImageSet(imageView, loadedFromCache);
194     private void fetchImage(String path, T model, final int loadCount) {
201                     imageSetCallback.onImageSet(imageView, false);",No
src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,73f79153c3e4c4902374c6300f4c831b089e9d53,55e575b69f1b37507e0612c9e3be64169f3717a2,"Release bitmaps when we request a new one

Maximizes potential for recycling, each loader now
only needs to hold on to at most one bitmap at a 
time. Before it would hold on to the old bitmap
and request a new one, using twice the memory","@@ -38,6 +38,10 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
         if (loadToken != null)  {
             photoManager.cancelTask(loadToken);
         }
+        if (acquired != null) {
+            photoManager.releaseBitmap(acquired);
+            acquired = null;
+        }
 
         loadToken = doFetchImage(path, model, width, height, new ImageReadyCallback(this, cb));
     }
","41         if (acquired != null) {
42             photoManager.releaseBitmap(acquired);
43             acquired = null;
44         }",No
src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,6cd830a540d1fb4c503cff45d5009ba7da494d6e,73f79153c3e4c4902374c6300f4c831b089e9d53,SimpleAssetPathConverter is not abstract...,"@@ -11,7 +11,7 @@ package com.bumptech.photos.view.assetpath;
  * Time: 8:52 PM
  * To change this template use File | Settings | File Templates.
  */
-public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {
+public class SimpleAssetPathConverter implements AssetPathConverter<String> {
     public void fetchPath(String path, PathReadyListener listener) {
         fetchPath(path, 0, 0, listener);
     }
","14 public class SimpleAssetPathConverter implements AssetPathConverter<String> {
14 public abstract class SimpleAssetPathConverter implements AssetPathConverter<String> {",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\PhotoManager.java,4719e28963b9efcf509549c76fa9f6eb71af01e9,6cd830a540d1fb4c503cff45d5009ba7da494d6e,"Add load to get an image assumed to be given size

Allows us to skip the somewhat expensive fetch of
the image size from the data on disk to retrieve
a recycled bitmap.","@@ -71,6 +71,24 @@ public class PhotoManager {
         return token;
     }
 
+    /**
+     * Loads the image for the given id assuming its width and height are exactly those given
+     * @param path - the path to the image
+     * @param width - the width of the image on disk
+     * @param height - the height of the image on disk
+     * @param cb - the callback called when the load completes
+     * @return A token tracking this request
+     */
+    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {
+        final Object token = cb;
+        final String key = getKey(path, width, height, ResizeType.AS_IS);
+        if (!returnFromCache(key, cb)) {
+            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));
+            postJob(task, token);
+        }
+        return token;
+    }
+
     /**
      * Loads the image for the given id to nearly the given width and height maintaining the original proportions
      * @param path - the id of the image
@@ -79,7 +97,7 @@ public class PhotoManager {
      * @param cb - the callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object getImage(final String path, final int width, final int height, final LoadedCallback cb){
+    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
         final Object token = cb;
         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
         if (!returnFromCache(key, cb)) {
","74     /**
75      * Loads the image for the given id assuming its width and height are exactly those given
76      * @param path - the path to the image
77      * @param width - the width of the image on disk
78      * @param height - the height of the image on disk
79      * @param cb - the callback called when the load completes
80      * @return A token tracking this request
81      */
82     public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {
83         final Object token = cb;
84         final String key = getKey(path, width, height, ResizeType.AS_IS);
85         if (!returnFromCache(key, cb)) {
86             final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));
87             postJob(task, token);
88         }
89         return token;
90     }
91 
100     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
82     public Object getImage(final String path, final int width, final int height, final LoadedCallback cb){",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,4719e28963b9efcf509549c76fa9f6eb71af01e9,6cd830a540d1fb4c503cff45d5009ba7da494d6e,"Add load to get an image assumed to be given size

Allows us to skip the somewhat expensive fetch of
the image size from the data on disk to retrieve
a recycled bitmap.","@@ -105,6 +105,20 @@ public class ResizeJobGenerator {
         };
     }
 
+    public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {
+        return new StreamResizeRunnable(cb) {
+            @Override
+            public Bitmap getRecycledBitmap() {
+                return bitmapCache.get(width, height);
+            }
+
+            @Override
+            public Bitmap resize(Bitmap recycled) {
+                return Utils.load(path, recycled);
+            }
+        };
+    }
+
     public Runnable loadAsIs(final String path, LoadedCallback callback){
         return new StreamResizeRunnable(callback) {
             @Override
@@ -118,7 +132,7 @@ public class ResizeJobGenerator {
                 return Utils.load(path, recycled);
             }
         };
-    };
+    }
 
     private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
 
","108     public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {
109         return new StreamResizeRunnable(cb) {
110             @Override
111             public Bitmap getRecycledBitmap() {
112                 return bitmapCache.get(width, height);
113             }
114 
115             @Override
116             public Bitmap resize(Bitmap recycled) {
117                 return Utils.load(path, recycled);
118             }
119         };
120     }
121 
135     }
121     };",No
src\com\bumptech\photos\view\loader\Approximate.java,src\com\bumptech\photos\view\loader\Approximate.java,4719e28963b9efcf509549c76fa9f6eb71af01e9,6cd830a540d1fb4c503cff45d5009ba7da494d6e,"Add load to get an image assumed to be given size

Allows us to skip the somewhat expensive fetch of
the image size from the data on disk to retrieve
a recycled bitmap.","@@ -23,6 +23,6 @@ public class Approximate<T> extends PhotoManagerLoader<T> {
 
     @Override
     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, width, height, cb);
+        return photoManager.getImageApproximate(path, width, height, cb);
     }
 }
","26         return photoManager.getImageApproximate(path, width, height, cb);
26         return photoManager.getImage(path, width, height, cb);",No
src\com\bumptech\photos\view\loader\AsIs.java,src\com\bumptech\photos\view\loader\Exact.java,4719e28963b9efcf509549c76fa9f6eb71af01e9,6cd830a540d1fb4c503cff45d5009ba7da494d6e,"Add load to get an image assumed to be given size

Allows us to skip the somewhat expensive fetch of
the image size from the data on disk to retrieve
a recycled bitmap.","@@ -15,14 +15,14 @@ import com.bumptech.photos.view.assetpath.AssetPathConverter;
  * Time: 10:57 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AsIs<T> extends PhotoManagerLoader<T> {
+public class Exact<T> extends PhotoManagerLoader<T> {
 
-    public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+    public Exact(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
         super(photoManager, assetToPath);
     }
 
     @Override
     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, cb);
+        return photoManager.getImageExact(path, width, height, cb);
     }
 }
","18 public class Exact<T> extends PhotoManagerLoader<T> {
20     public Exact(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
26         return photoManager.getImageExact(path, width, height, cb);
18 public class AsIs<T> extends PhotoManagerLoader<T> {
20     public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
26         return photoManager.getImage(path, cb);",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,513575b90373f263b08df6b3d88c2bbb520cfd69,4719e28963b9efcf509549c76fa9f6eb71af01e9,"Add a clear method to image loader

Also don't cancel load tasks. We incur the gc
penalty early on, so though cancelling might save
some cpu work, it causes more gcing and worse
performance early on because we toss the allocated
bitmap rather than storing and reusing it.","@@ -168,8 +168,7 @@ public class ImagePresenter<T> {
         imageView.setImageBitmap(null);
         currentModel = null;
         isImageSet = false;
-        imageToken = null;
-        pathToken = null;
+        imageLoader.clear();
     }
 
     public int getWidth() {
","171         imageLoader.clear();
171         imageToken = null;
172         pathToken = null;",No
src\com\bumptech\photos\view\loader\ImageLoader.java,src\com\bumptech\photos\view\loader\ImageLoader.java,513575b90373f263b08df6b3d88c2bbb520cfd69,4719e28963b9efcf509549c76fa9f6eb71af01e9,"Add a clear method to image loader

Also don't cancel load tasks. We incur the gc
penalty early on, so though cancelling might save
some cpu work, it causes more gcing and worse
performance early on because we toss the allocated
bitmap rather than storing and reusing it.","@@ -26,5 +26,6 @@ public interface ImageLoader<T>  {
 
     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
     public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
+    public void clear();
 
 }
",29     public void clear();,No
src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,513575b90373f263b08df6b3d88c2bbb520cfd69,4719e28963b9efcf509549c76fa9f6eb71af01e9,"Add a clear method to image loader

Also don't cancel load tasks. We incur the gc
penalty early on, so though cancelling might save
some cpu work, it causes more gcing and worse
performance early on because we toss the allocated
bitmap rather than storing and reusing it.","@@ -66,6 +66,14 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
         cb.onError(e);
     }
 
+    @Override
+    public void clear() {
+        if (acquired != null) {
+            photoManager.releaseBitmap(acquired);
+            acquired = null;
+        }
+    }
+
     private static class PathReadyCallback<T> extends BaseImageLoader.InternalPathReadyCallback<T> implements AssetPathConverter.PathReadyListener {
 
         public PathReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.PathReadyCallback cb) {
","69     @Override
70     public void clear() {
71         if (acquired != null) {
72             photoManager.releaseBitmap(acquired);
73             acquired = null;
74         }
75     }
76 ",No
,src\com\bumptech\photos\view\loader\AsIs.java,45a8b2bbb2d6cdc4ab8938bd4c5f109b9453173b,513575b90373f263b08df6b3d88c2bbb520cfd69,Add an AsIs photo manager loader,"@@ -0,0 +1,23 @@
+package com.bumptech.photos.view.loader;
+
+import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.PhotoManager;
+import com.bumptech.photos.view.assetpath.AssetPathConverter;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/31/12
+ * Time: 4:56 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class AsIs<T> extends PhotoManagerLoader<T>{
+    public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
+        super(photoManager, assetToPath);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, cb);
+    }
+}
","1 package com.bumptech.photos.view.loader;
2 
3 import com.bumptech.photos.LoadedCallback;
4 import com.bumptech.photos.PhotoManager;
5 import com.bumptech.photos.view.assetpath.AssetPathConverter;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/31/12
11  * Time: 4:56 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class AsIs<T> extends PhotoManagerLoader<T>{
15     public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
16         super(photoManager, assetToPath);
17     }
18 
19     @Override
20     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
21         return photoManager.getImage(path, cb);
22     }
23 }",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,142a8e5dc4f035b44093d3d84715595b50585c72,45a8b2bbb2d6cdc4ab8938bd4c5f109b9453173b,"Delay image fetch until view size is stable

Fixes a case where we load an image for a view 
part way through a property animation so when
the animation finishes the loaded image only fits
in part of the view.","@@ -6,9 +6,10 @@ package com.bumptech.photos.view;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.SystemClock;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import com.bumptech.photos.util.Log;
 import com.bumptech.photos.view.loader.ImageLoader;
 
 import java.lang.ref.WeakReference;
@@ -21,8 +22,6 @@ import java.lang.ref.WeakReference;
  * To change this template use File | Settings | File Templates.
  */
 public class ImagePresenter<T> {
-    private Object pathToken;
-    private Object imageToken;
 
     public static class Builder<T> {
         private ImageView imageView;
@@ -74,6 +73,12 @@ public class ImagePresenter<T> {
         }
     }
 
+    private static final String PENDING_LOAD_TOKEN = ""pending_load"";
+    private static final int PENDING_LOAD_DELAY = 20; //60 fps = 1000/60 = 16.67 ms
+
+    private Object pathToken;
+    private Object imageToken;
+
     private final ImageLoader<T> imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
@@ -83,27 +88,21 @@ public class ImagePresenter<T> {
     private int height = 0;
     private int width = 0;
 
+    private Handler handler = new Handler();
+
     private T currentModel;
     private int currentCount;
 
     private boolean isImageSet;
     private boolean loadedFromCache = false;
 
-    private boolean setLayoutListener = false;
     private final Runnable getDimens = new Runnable() {
-
         @Override
         public void run() {
-            Log.d(""AP: getDimens run width="" + width + "" height="" + height);
             width = imageView.getWidth();
             height = imageView.getHeight();
-            if (width == 0 || height == 0) {
-                if (!setLayoutListener) {
-                    imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
-                    setLayoutListener = true;
-                }
-            } else if (pendingLoad != null) {
-                imageView.post(pendingLoad);
+            if (width != 0 && height != 0) {
+                postPendingLoad();
             }
         }
     };
@@ -124,6 +123,7 @@ public class ImagePresenter<T> {
         }
         this.coordinator = builder.coordinator;
         this.imageSetCallback = builder.imageSetCallback;
+        imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
     }
 
     public ImageView getImageView() {
@@ -143,6 +143,7 @@ public class ImagePresenter<T> {
                 @Override
                 public void run() {
                     fetchPath(model, loadCount);
+                    pendingLoad = null;
                 }
             };
             getDimens();
@@ -179,6 +180,17 @@ public class ImagePresenter<T> {
         return height;
     }
 
+    private void postPendingLoad() {
+        if (pendingLoad == null) return;
+
+        //If an image view is actively changing sizes, we want to delay our resize job until
+        //the size has stabilized so that the image we load will match the final size, rather than some
+        //size part way through the change. One example of this is as part of an animation where a view is
+        //expanding or shrinking
+        handler.removeCallbacksAndMessages(PENDING_LOAD_TOKEN);
+        handler.postAtTime(pendingLoad, PENDING_LOAD_TOKEN, SystemClock.uptimeMillis() + PENDING_LOAD_DELAY);
+    }
+
     private void fetchPath(final T model, final int loadCount) {
         pathToken = imageLoader.fetchPath(model, getWidth(), getHeight(), new ImageLoader.PathReadyCallback() {
             @Override
","9 import android.os.Handler;
10 import android.os.SystemClock;
76     private static final String PENDING_LOAD_TOKEN = ""pending_load"";
77     private static final int PENDING_LOAD_DELAY = 20; //60 fps = 1000/60 = 16.67 ms
78 
79     private Object pathToken;
80     private Object imageToken;
81 
91     private Handler handler = new Handler();
92 
104             if (width != 0 && height != 0) {
105                 postPendingLoad();
126         imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
146                     pendingLoad = null;
183     private void postPendingLoad() {
184         if (pendingLoad == null) return;
185 
186         //If an image view is actively changing sizes, we want to delay our resize job until
187         //the size has stabilized so that the image we load will match the final size, rather than some
188         //size part way through the change. One example of this is as part of an animation where a view is
189         //expanding or shrinking
190         handler.removeCallbacksAndMessages(PENDING_LOAD_TOKEN);
191         handler.postAtTime(pendingLoad, PENDING_LOAD_TOKEN, SystemClock.uptimeMillis() + PENDING_LOAD_DELAY);
192     }
193 
11 import com.bumptech.photos.util.Log;
24     private Object pathToken;
25     private Object imageToken;
92     private boolean setLayoutListener = false;
94 
97             Log.d(""AP: getDimens run width="" + width + "" height="" + height);
100             if (width == 0 || height == 0) {
101                 if (!setLayoutListener) {
102                     imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
103                     setLayoutListener = true;
104                 }
105             } else if (pendingLoad != null) {
106                 imageView.post(pendingLoad);",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,5648d3a9b4ec2a12bb48c98792e0767ae245443a,142a8e5dc4f035b44093d3d84715595b50585c72,Reset to a placeholder when clearing a presenter,"@@ -166,7 +166,7 @@ public class ImagePresenter<T> {
 
     public void clear() {
         currentCount++;
-        imageView.setImageBitmap(null);
+        resetPlaceHolder();
         currentModel = null;
         isImageSet = false;
         imageLoader.clear();
","169         resetPlaceHolder();
169         imageView.setImageBitmap(null);",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,22ed787c395cd0b7dac301f2fc45f291e210bc61,5648d3a9b4ec2a12bb48c98792e0767ae245443a,Reset to blank if no placeholder is set,"@@ -159,7 +159,7 @@ public class ImagePresenter<T> {
     }
 
     public void resetPlaceHolder() {
-        if (placeholderDrawable == null || !canSetPlaceholder()) return;
+        if (!canSetPlaceholder()) return;
 
         imageView.setImageDrawable(placeholderDrawable);
     }
","162         if (!canSetPlaceholder()) return;
162         if (placeholderDrawable == null || !canSetPlaceholder()) return;",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,140bc3a11a2415b100a3691bfe2ce378022fefe9,22ed787c395cd0b7dac301f2fc45f291e210bc61,Increase the odds of letting an animation finish,"@@ -74,7 +74,7 @@ public class ImagePresenter<T> {
     }
 
     private static final String PENDING_LOAD_TOKEN = ""pending_load"";
-    private static final int PENDING_LOAD_DELAY = 20; //60 fps = 1000/60 = 16.67 ms
+    private static final int PENDING_LOAD_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
 
     private Object pathToken;
     private Object imageToken;
@@ -99,6 +99,8 @@ public class ImagePresenter<T> {
     private final Runnable getDimens = new Runnable() {
         @Override
         public void run() {
+            if (imageView.getWidth() == width && imageView.getHeight() == height) return;
+
             width = imageView.getWidth();
             height = imageView.getHeight();
             if (width != 0 && height != 0) {
","77     private static final int PENDING_LOAD_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
102             if (imageView.getWidth() == width && imageView.getHeight() == height) return;
103 
77     private static final int PENDING_LOAD_DELAY = 20; //60 fps = 1000/60 = 16.67 ms",No
src\com\bumptech\photos\LoadedCallback.java,src\com\bumptech\photos\photomanager\LoadedCallback.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos;
+package com.bumptech.photos.photomanager;
 
 import android.graphics.Bitmap;
 
","5 package com.bumptech.photos.photomanager;
5 package com.bumptech.photos;",No
src\com\bumptech\photos\PhotoManager.java,src\com\bumptech\photos\photomanager\PhotoManager.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos;
+package com.bumptech.photos.photomanager;
 
 import android.graphics.Bitmap;
 import android.os.Build;
","5 package com.bumptech.photos.photomanager;
5 package com.bumptech.photos;",No
,src\com\bumptech\photos\photomanager\PhotoManagerLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,71 @@
+package com.bumptech.photos.photomanager;
+
+import android.graphics.Bitmap;
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.view.loader.BaseImageLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/1/13
+ * Time: 2:51 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
+
+    protected final PhotoManager photoManager;
+    private Bitmap acquired;
+    private Object loadToken;
+
+    public PhotoManagerLoader(PhotoManager photoManager) {
+        this.photoManager = photoManager;
+    }
+    @Override
+    protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
+        releaseAcquired();
+        loadToken = doFetchImage(path, width, height, new PhotoManagerLoaderCallback(this, cb));
+    }
+
+    protected abstract Object doFetchImage(String path, int width, int height, LoadedCallback cb);
+
+    @Override
+    protected void onImageReady(Bitmap image, boolean isUsed) {
+        if (isUsed) {
+            releaseAcquired();
+            photoManager.acquireBitmap(image);
+            acquired = image;
+        } else {
+            photoManager.rejectBitmap(image);
+        }
+    }
+
+    @Override
+    public void clear() {
+        releaseAcquired();
+    }
+
+    private void releaseAcquired() {
+        if (acquired != null) {
+            photoManager.releaseBitmap(acquired);
+            acquired = null;
+        }
+    }
+
+    protected static class PhotoManagerLoaderCallback extends InternalImageReadyCallback implements LoadedCallback {
+
+        public PhotoManagerLoaderCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
+            super(imageLoader, cb);
+        }
+
+        @Override
+        public void onLoadCompleted(Bitmap loaded) {
+            onImageReady(loaded);
+        }
+
+        @Override
+        public void onLoadFailed(Exception e) {
+            onError(e);
+        }
+    }
+}
","1 package com.bumptech.photos.photomanager;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.photos.photomanager.LoadedCallback;
5 import com.bumptech.photos.photomanager.PhotoManager;
6 import com.bumptech.photos.view.loader.BaseImageLoader;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 1/1/13
12  * Time: 2:51 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
16 
17     protected final PhotoManager photoManager;
18     private Bitmap acquired;
19     private Object loadToken;
20 
21     public PhotoManagerLoader(PhotoManager photoManager) {
22         this.photoManager = photoManager;
23     }
24     @Override
25     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
26         releaseAcquired();
27         loadToken = doFetchImage(path, width, height, new PhotoManagerLoaderCallback(this, cb));
28     }
29 
30     protected abstract Object doFetchImage(String path, int width, int height, LoadedCallback cb);
31 
32     @Override
33     protected void onImageReady(Bitmap image, boolean isUsed) {
34         if (isUsed) {
35             releaseAcquired();
36             photoManager.acquireBitmap(image);
37             acquired = image;
38         } else {
39             photoManager.rejectBitmap(image);
40         }
41     }
42 
43     @Override
44     public void clear() {
45         releaseAcquired();
46     }
47 
48     private void releaseAcquired() {
49         if (acquired != null) {
50             photoManager.releaseBitmap(acquired);
51             acquired = null;
52         }
53     }
54 
55     protected static class PhotoManagerLoaderCallback extends InternalImageReadyCallback implements LoadedCallback {
56 
57         public PhotoManagerLoaderCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
58             super(imageLoader, cb);
59         }
60 
61         @Override
62         public void onLoadCompleted(Bitmap loaded) {
63             onImageReady(loaded);
64         }
65 
66         @Override
67         public void onLoadFailed(Exception e) {
68             onError(e);
69         }
70     }
71 }",No
,src\com\bumptech\photos\photomanager\loader\Approximate.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.photomanager.loader;
+
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.photomanager.PhotoManagerLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:58 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Approximate<T> extends PhotoManagerLoader<T> {
+
+    public Approximate(PhotoManager photoManager) {
+        super(photoManager);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImageApproximate(path, width, height, cb);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.photomanager.loader;
6 
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
9 import com.bumptech.photos.photomanager.PhotoManagerLoader;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:58 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class Approximate<T> extends PhotoManagerLoader<T> {
19 
20     public Approximate(PhotoManager photoManager) {
21         super(photoManager);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
26         return photoManager.getImageApproximate(path, width, height, cb);
27     }
28 }",No
,src\com\bumptech\photos\photomanager\loader\AsIs.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,24 @@
+package com.bumptech.photos.photomanager.loader;
+
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.photomanager.PhotoManagerLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/31/12
+ * Time: 4:56 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class AsIs<T> extends PhotoManagerLoader<T> {
+
+    public AsIs(PhotoManager photoManager) {
+        super(photoManager);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImage(path, cb);
+    }
+}
","1 package com.bumptech.photos.photomanager.loader;
2 
3 import com.bumptech.photos.photomanager.LoadedCallback;
4 import com.bumptech.photos.photomanager.PhotoManager;
5 import com.bumptech.photos.photomanager.PhotoManagerLoader;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/31/12
11  * Time: 4:56 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class AsIs<T> extends PhotoManagerLoader<T> {
15 
16     public AsIs(PhotoManager photoManager) {
17         super(photoManager);
18     }
19 
20     @Override
21     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
22         return photoManager.getImage(path, cb);
23     }
24 }",No
,src\com\bumptech\photos\photomanager\loader\CenterCrop.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.photomanager.loader;
+
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.photomanager.PhotoManagerLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:54 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class CenterCrop<T> extends PhotoManagerLoader<T> {
+
+    public CenterCrop(PhotoManager photoManager) {
+        super(photoManager);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.centerCrop(path, width, height, cb);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.photomanager.loader;
6 
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
9 import com.bumptech.photos.photomanager.PhotoManagerLoader;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:54 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class CenterCrop<T> extends PhotoManagerLoader<T> {
19 
20     public CenterCrop(PhotoManager photoManager) {
21         super(photoManager);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
26         return photoManager.centerCrop(path, width, height, cb);
27     }
28 }",No
,src\com\bumptech\photos\photomanager\loader\Exact.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.photomanager.loader;
+
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.photomanager.PhotoManagerLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:57 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Exact<T> extends PhotoManagerLoader<T> {
+
+    public Exact(PhotoManager photoManager) {
+        super(photoManager);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.getImageExact(path, width, height, cb);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.photomanager.loader;
6 
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
9 import com.bumptech.photos.photomanager.PhotoManagerLoader;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:57 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class Exact<T> extends PhotoManagerLoader<T> {
19 
20     public Exact(PhotoManager photoManager) {
21         super(photoManager);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
26         return photoManager.getImageExact(path, width, height, cb);
27     }
28 }",No
,src\com\bumptech\photos\photomanager\loader\FitCenter.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.photomanager.loader;
+
+import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.photomanager.PhotoManagerLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 10:56 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FitCenter<T> extends PhotoManagerLoader<T> {
+
+    public FitCenter(PhotoManager photoManager) {
+        super(photoManager);
+    }
+
+    @Override
+    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
+        return photoManager.fitCenter(path, width, height, cb);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.photomanager.loader;
6 
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
9 import com.bumptech.photos.photomanager.PhotoManagerLoader;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:56 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class FitCenter<T> extends PhotoManagerLoader<T> {
19 
20     public FitCenter(PhotoManager photoManager) {
21         super(photoManager);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
26         return photoManager.fitCenter(path, width, height, cb);
27     }
28 }",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -5,7 +5,7 @@ package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-import com.bumptech.photos.LoadedCallback;
+import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.cache.SizedBitmapCache;
 
 import java.io.IOException;
","8 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.LoadedCallback;",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\view\ImagePresenter.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -10,6 +10,8 @@ import android.os.Handler;
 import android.os.SystemClock;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
+import com.bumptech.photos.util.Log;
+import com.bumptech.photos.view.assetpath.PathLoader;
 import com.bumptech.photos.view.loader.ImageLoader;
 
 import java.lang.ref.WeakReference;
@@ -23,17 +25,21 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
+
+
     public static class Builder<T> {
         private ImageView imageView;
-        private ImageLoader<T> imageLoader;
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
         private ImageSetCallback imageSetCallback;
         private AssetPresenterCoordinator coordinator;
+        private ImageLoader<T> imageLoader;
+        private PathLoader<T> pathLoader;
 
         public ImagePresenter<T> build(){
             assert imageView != null : ""cannot create presenter without an image view"";
             assert imageLoader != null : ""cannot create presenter without an image loader"";
+            assert pathLoader != null : ""cannot create presenter without a path loader"";
 
             return new ImagePresenter<T>(this);
         }
@@ -43,6 +49,11 @@ public class ImagePresenter<T> {
             return this;
         }
 
+        public Builder<T> setPathLoader(PathLoader<T> pathLoader) {
+            this.pathLoader = pathLoader;
+            return this;
+        }
+
         public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
             this.imageLoader = imageLoader;
             return this;
@@ -79,6 +90,7 @@ public class ImagePresenter<T> {
     private Object pathToken;
     private Object imageToken;
 
+    private final PathLoader<T> pathLoader;
     private final ImageLoader<T> imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
@@ -103,6 +115,8 @@ public class ImagePresenter<T> {
 
             width = imageView.getWidth();
             height = imageView.getHeight();
+            if (pendingLoad != null)
+                Log.d(""IP: getDimens width="" + width + "" height="" + height);
             if (width != 0 && height != 0) {
                 postPendingLoad();
             }
@@ -118,6 +132,7 @@ public class ImagePresenter<T> {
     private ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
+        this.pathLoader = builder.pathLoader;
         if (builder.placeholderResourceId != 0) {
             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
         } else {
@@ -144,6 +159,7 @@ public class ImagePresenter<T> {
             pendingLoad = new Runnable() {
                 @Override
                 public void run() {
+                    Log.d(""IP: pendingLoad run width="" + width + "" height="" + height);
                     fetchPath(model, loadCount);
                     pendingLoad = null;
                 }
@@ -171,6 +187,7 @@ public class ImagePresenter<T> {
         resetPlaceHolder();
         currentModel = null;
         isImageSet = false;
+        pathLoader.clear();
         imageLoader.clear();
     }
 
@@ -194,7 +211,7 @@ public class ImagePresenter<T> {
     }
 
     private void fetchPath(final T model, final int loadCount) {
-        pathToken = imageLoader.fetchPath(model, getWidth(), getHeight(), new ImageLoader.PathReadyCallback() {
+        pathToken = pathLoader.fetchPath(model, getWidth(), getHeight(), new PathLoader.PathReadyCallback() {
             @Override
             public boolean onPathReady(String path) {
                 if (loadCount != currentCount) return false;
","13 import com.bumptech.photos.util.Log;
14 import com.bumptech.photos.view.assetpath.PathLoader;
28 
29 
36         private ImageLoader<T> imageLoader;
37         private PathLoader<T> pathLoader;
42             assert pathLoader != null : ""cannot create presenter without a path loader"";
52         public Builder<T> setPathLoader(PathLoader<T> pathLoader) {
53             this.pathLoader = pathLoader;
54             return this;
55         }
56 
93     private final PathLoader<T> pathLoader;
118             if (pendingLoad != null)
119                 Log.d(""IP: getDimens width="" + width + "" height="" + height);
135         this.pathLoader = builder.pathLoader;
162                     Log.d(""IP: pendingLoad run width="" + width + "" height="" + height);
190         pathLoader.clear();
214         pathToken = pathLoader.fetchPath(model, getWidth(), getHeight(), new PathLoader.PathReadyCallback() {
28         private ImageLoader<T> imageLoader;
197         pathToken = imageLoader.fetchPath(model, getWidth(), getHeight(), new ImageLoader.PathReadyCallback() {",No
src\com\bumptech\photos\view\ThumbImagePresenter.java,src\com\bumptech\photos\view\ThumbImagePresenter.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -6,7 +6,6 @@ package com.bumptech.photos.view;
 
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
 
 /**
  * Created with IntelliJ IDEA.
",9 import com.bumptech.photos.view.assetpath.AssetPathConverter;,No
,src\com\bumptech\photos\view\assetpath\BasePathLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,57 @@
+package com.bumptech.photos.view.assetpath;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/1/13
+ * Time: 3:04 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class BasePathLoader<T> implements PathLoader<T> {
+    @Override
+    public Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
+        doFetchPath(model, width, height, cb);
+        return cb;
+    }
+
+    @Override
+    public void clear() { }
+
+    protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
+
+    protected void onPathReady(String path, boolean isUsed) { }
+
+    protected void onPathFetchFailed(Exception e) { }
+
+
+    protected static class InternalPathReadyCallback {
+        private final WeakReference<PathReadyCallback> cbRef;
+        private final WeakReference<BasePathLoader> pathLoaderRef;
+
+
+        public InternalPathReadyCallback(BasePathLoader pathLoader, PathReadyCallback cb) {
+            this.pathLoaderRef = new WeakReference<BasePathLoader>(pathLoader);
+            this.cbRef = new WeakReference<PathReadyCallback>(cb);
+        }
+
+        protected final void onPathReady(String path) {
+            final BasePathLoader pathLoader = pathLoaderRef.get();
+            final PathReadyCallback cb = cbRef.get();
+            if (pathLoader != null && cb != null) {
+                pathLoader.onPathReady(path, cb.onPathReady(path));
+            }
+        }
+
+        protected final void onError(Exception e) {
+            final BasePathLoader pathLoader = pathLoaderRef.get();
+            final PathReadyCallback cb = cbRef.get();
+            if (pathLoader != null && cb != null) {
+                cb.onError(e);
+                pathLoader.onPathFetchFailed(e);
+            }
+        }
+    }
+
+}
","1 package com.bumptech.photos.view.assetpath;
2 
3 import java.lang.ref.WeakReference;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 1/1/13
9  * Time: 3:04 PM
10  * To change this template use File | Settings | File Templates.
11  */
12 public abstract class BasePathLoader<T> implements PathLoader<T> {
13     @Override
14     public Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
15         doFetchPath(model, width, height, cb);
16         return cb;
17     }
18 
19     @Override
20     public void clear() { }
21 
22     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
23 
24     protected void onPathReady(String path, boolean isUsed) { }
25 
26     protected void onPathFetchFailed(Exception e) { }
27 
28 
29     protected static class InternalPathReadyCallback {
30         private final WeakReference<PathReadyCallback> cbRef;
31         private final WeakReference<BasePathLoader> pathLoaderRef;
32 
33 
34         public InternalPathReadyCallback(BasePathLoader pathLoader, PathReadyCallback cb) {
35             this.pathLoaderRef = new WeakReference<BasePathLoader>(pathLoader);
36             this.cbRef = new WeakReference<PathReadyCallback>(cb);
37         }
38 
39         protected final void onPathReady(String path) {
40             final BasePathLoader pathLoader = pathLoaderRef.get();
41             final PathReadyCallback cb = cbRef.get();
42             if (pathLoader != null && cb != null) {
43                 pathLoader.onPathReady(path, cb.onPathReady(path));
44             }
45         }
46 
47         protected final void onError(Exception e) {
48             final BasePathLoader pathLoader = pathLoaderRef.get();
49             final PathReadyCallback cb = cbRef.get();
50             if (pathLoader != null && cb != null) {
51                 cb.onError(e);
52                 pathLoader.onPathFetchFailed(e);
53             }
54         }
55     }
56 
57 }",No
src\com\bumptech\photos\view\assetpath\AssetPathConverter.java,src\com\bumptech\photos\view\assetpath\PathLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -11,11 +11,14 @@ package com.bumptech.photos.view.assetpath;
  * Time: 8:51 PM
  * To change this template use File | Settings | File Templates.
  */
-public interface AssetPathConverter<T> {
-    public interface PathReadyListener {
-        public void pathReady(String path);
+public interface PathLoader<T> {
+
+    public interface PathReadyCallback {
+        public boolean onPathReady(String path);
         public void onError(Exception e);
     }
 
-    public void fetchPath(T model, int width, int height, PathReadyListener listener);
+    public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
+
+    public void clear();
 }
","14 public interface PathLoader<T> {
15 
16     public interface PathReadyCallback {
17         public boolean onPathReady(String path);
21     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
22 
23     public void clear();
14 public interface AssetPathConverter<T> {
15     public interface PathReadyListener {
16         public void pathReady(String path);
20     public void fetchPath(T model, int width, int height, PathReadyListener listener);",No
src\com\bumptech\photos\view\assetpath\SimpleAssetPathConverter.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.assetpath;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 8:52 PM
- * To change this template use File | Settings | File Templates.
- */
-public class SimpleAssetPathConverter implements AssetPathConverter<String> {
-    public void fetchPath(String path, PathReadyListener listener) {
-        fetchPath(path, 0, 0, listener);
-    }
-
-    @Override
-    public void fetchPath(String path, int width, int height, PathReadyListener listener) {
-        listener.pathReady(path);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.assetpath;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:52 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class SimpleAssetPathConverter implements AssetPathConverter<String> {
15     public void fetchPath(String path, PathReadyListener listener) {
16         fetchPath(path, 0, 0, listener);
17     }
18 
19     @Override
20     public void fetchPath(String path, int width, int height, PathReadyListener listener) {
21         listener.pathReady(path);
22     }
23 }",No
,src\com\bumptech\photos\view\assetpath\SimplePathLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.view.assetpath;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 12/25/12
+ * Time: 8:52 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class SimplePathLoader extends BasePathLoader<String> {
+    @Override
+    protected void doFetchPath(String model, int width, int height, PathReadyCallback cb) {
+        cb.onPathReady(model);
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.assetpath;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:52 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class SimplePathLoader extends BasePathLoader<String> {
15     @Override
16     protected void doFetchPath(String model, int width, int height, PathReadyCallback cb) {
17         cb.onPathReady(model);
18     }
19 }",No
src\com\bumptech\photos\view\loader\Approximate.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.loader;
-
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:58 PM
- * To change this template use File | Settings | File Templates.
- */
-public class Approximate<T> extends PhotoManagerLoader<T> {
-
-    public Approximate(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        super(photoManager, assetToPath);
-    }
-
-    @Override
-    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.getImageApproximate(path, width, height, cb);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:58 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class Approximate<T> extends PhotoManagerLoader<T> {
19 
20     public Approximate(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
26         return photoManager.getImageApproximate(path, width, height, cb);
27     }
28 }",No
src\com\bumptech\photos\view\loader\AsIs.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,23 +0,0 @@
-package com.bumptech.photos.view.loader;
-
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/31/12
- * Time: 4:56 PM
- * To change this template use File | Settings | File Templates.
- */
-public class AsIs<T> extends PhotoManagerLoader<T>{
-    public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        super(photoManager, assetToPath);
-    }
-
-    @Override
-    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, cb);
-    }
-}
","1 package com.bumptech.photos.view.loader;
2 
3 import com.bumptech.photos.LoadedCallback;
4 import com.bumptech.photos.PhotoManager;
5 import com.bumptech.photos.view.assetpath.AssetPathConverter;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/31/12
11  * Time: 4:56 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class AsIs<T> extends PhotoManagerLoader<T>{
15     public AsIs(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
16         super(photoManager, assetToPath);
17     }
18 
19     @Override
20     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
21         return photoManager.getImage(path, cb);
22     }
23 }",No
src\com\bumptech\photos\view\loader\BaseImageLoader.java,src\com\bumptech\photos\view\loader\BaseImageLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,7 +1,3 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
 package com.bumptech.photos.view.loader;
 
 import android.graphics.Bitmap;
@@ -11,108 +7,51 @@ import java.lang.ref.WeakReference;
 /**
  * Created with IntelliJ IDEA.
  * User: sam
- * Date: 12/29/12
- * Time: 2:05 PM
+ * Date: 1/1/13
+ * Time: 2:45 PM
  * To change this template use File | Settings | File Templates.
  */
 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
-
-    @Override
-    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
-        doFetchPath(model, width, height, cb);
-        return cb;
-    }
-
-    protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
-
-    private final void onPathReady(String path, PathReadyCallback cb) {
-        onPathReady(path, cb.onPathReady(path));
-    }
-
-    protected void onPathReady(String path, boolean isUsed) {}
-
-    protected void onPathFetchFailed(Exception e, PathReadyCallback cb) {
-        cb.onError(e);
-    }
-
     @Override
     public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
         doFetchImage(path, model, width, height, cb);
         return cb;
     }
 
-    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
+    @Override
+    public void clear() { }
 
-    private final void onImageReady(Bitmap image, ImageReadyCallback cb) {
-        onImageReady(image, cb.onImageReady(image));
-    }
+    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
 
     protected void onImageReady(Bitmap image, boolean isUsed) { }
 
-    protected void onImageLoadFailed(Exception e, ImageReadyCallback cb) {
-        cb.onError(e);
-    }
+    protected void onImageLoadFailed(Exception e) { }
 
-    public abstract static class ImageLoaderCallback<T> {
-        private final WeakReference<BaseImageLoader<T>> imageLoaderRef;
 
-        public ImageLoaderCallback(BaseImageLoader<T> imageLoader) {
-            imageLoaderRef = new WeakReference<BaseImageLoader<T>>(imageLoader);
-        }
-
-        public BaseImageLoader<T> getImageLoader() {
-            return imageLoaderRef.get();
-        }
-    }
-
-    public abstract static class InternalPathReadyCallback<T> extends ImageLoaderCallback<T>{
-        private final WeakReference<PathReadyCallback> cbRef;
-
-        public InternalPathReadyCallback(BaseImageLoader<T> imageLoader, PathReadyCallback cb) {
-            super(imageLoader);
-            this.cbRef = new WeakReference<PathReadyCallback>(cb);
-        }
-
-        protected final void onPathReady(String path) {
-            final BaseImageLoader<T> imageLoader = getImageLoader();
-            final PathReadyCallback cb = cbRef.get();
-            if (imageLoader != null && cb != null) {
-                imageLoader.onPathReady(path, cb);
-            }
-        }
-
-        protected final void onPathLoadFailed(Exception e) {
-            final BaseImageLoader<T> imageLoader = getImageLoader();
-            final PathReadyCallback cb = cbRef.get();
-            if (imageLoader != null && cb != null) {
-                imageLoader.onPathFetchFailed(e, cb);
-            }
-        }
-    }
-
-    public abstract static class InternalImageReadyCallback<T> extends ImageLoaderCallback<T>{
+    protected static class InternalImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
+        private final WeakReference<BaseImageLoader> imageLoaderRef;
 
-        public InternalImageReadyCallback(BaseImageLoader<T> imageLoader, ImageReadyCallback cb) {
-            super(imageLoader);
+        public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
+            this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);
             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
         }
 
         protected final void onImageReady(Bitmap image) {
-            final BaseImageLoader<T> imageLoader = getImageLoader();
+            final BaseImageLoader imageLoader = imageLoaderRef.get();
             final ImageReadyCallback cb = cbRef.get();
             if (imageLoader != null && cb != null) {
-                imageLoader.onImageReady(image, cb);
+                imageLoader.onImageReady(image, cb.onImageReady(image));
             }
         }
 
-        protected final void onImageLoadFailed(Exception e) {
-            final BaseImageLoader<T> imageLoader = getImageLoader();
+        protected final void onError(Exception e) {
+            final BaseImageLoader imageLoader = imageLoaderRef.get();
             final ImageReadyCallback cb = cbRef.get();
             if (imageLoader != null && cb != null) {
-                imageLoader.onImageLoadFailed(e, cb);
+                cb.onError(e);
+                imageLoader.onImageLoadFailed(e);
             }
         }
     }
-
 }
","10  * Date: 1/1/13
11  * Time: 2:45 PM
21     @Override
22     public void clear() { }
24     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
28     protected void onImageLoadFailed(Exception e) { }
31     protected static class InternalImageReadyCallback {
33         private final WeakReference<BaseImageLoader> imageLoaderRef;
35         public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
36             this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);
41             final BaseImageLoader imageLoader = imageLoaderRef.get();
44                 imageLoader.onImageReady(image, cb.onImageReady(image));
48         protected final void onError(Exception e) {
49             final BaseImageLoader imageLoader = imageLoaderRef.get();
52                 cb.onError(e);
53                 imageLoader.onImageLoadFailed(e);
1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
14  * Date: 12/29/12
15  * Time: 2:05 PM
19 
20     @Override
21     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
22         doFetchPath(model, width, height, cb);
23         return cb;
24     }
25 
26     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
27 
28     private final void onPathReady(String path, PathReadyCallback cb) {
29         onPathReady(path, cb.onPathReady(path));
30     }
31 
32     protected void onPathReady(String path, boolean isUsed) {}
33 
34     protected void onPathFetchFailed(Exception e, PathReadyCallback cb) {
35         cb.onError(e);
36     }
37 
44     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
46     private final void onImageReady(Bitmap image, ImageReadyCallback cb) {
47         onImageReady(image, cb.onImageReady(image));
48     }
52     protected void onImageLoadFailed(Exception e, ImageReadyCallback cb) {
53         cb.onError(e);
54     }
56     public abstract static class ImageLoaderCallback<T> {
57         private final WeakReference<BaseImageLoader<T>> imageLoaderRef;
59         public ImageLoaderCallback(BaseImageLoader<T> imageLoader) {
60             imageLoaderRef = new WeakReference<BaseImageLoader<T>>(imageLoader);
61         }
62 
63         public BaseImageLoader<T> getImageLoader() {
64             return imageLoaderRef.get();
65         }
66     }
67 
68     public abstract static class InternalPathReadyCallback<T> extends ImageLoaderCallback<T>{
69         private final WeakReference<PathReadyCallback> cbRef;
70 
71         public InternalPathReadyCallback(BaseImageLoader<T> imageLoader, PathReadyCallback cb) {
72             super(imageLoader);
73             this.cbRef = new WeakReference<PathReadyCallback>(cb);
74         }
75 
76         protected final void onPathReady(String path) {
77             final BaseImageLoader<T> imageLoader = getImageLoader();
78             final PathReadyCallback cb = cbRef.get();
79             if (imageLoader != null && cb != null) {
80                 imageLoader.onPathReady(path, cb);
81             }
82         }
83 
84         protected final void onPathLoadFailed(Exception e) {
85             final BaseImageLoader<T> imageLoader = getImageLoader();
86             final PathReadyCallback cb = cbRef.get();
87             if (imageLoader != null && cb != null) {
88                 imageLoader.onPathFetchFailed(e, cb);
89             }
90         }
91     }
92 
93     public abstract static class InternalImageReadyCallback<T> extends ImageLoaderCallback<T>{
96         public InternalImageReadyCallback(BaseImageLoader<T> imageLoader, ImageReadyCallback cb) {
97             super(imageLoader);
102             final BaseImageLoader<T> imageLoader = getImageLoader();
105                 imageLoader.onImageReady(image, cb);
109         protected final void onImageLoadFailed(Exception e) {
110             final BaseImageLoader<T> imageLoader = getImageLoader();
113                 imageLoader.onImageLoadFailed(e, cb);
117 ",No
src\com\bumptech\photos\view\loader\CenterCrop.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.loader;
-
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:54 PM
- * To change this template use File | Settings | File Templates.
- */
-public class CenterCrop<T> extends PhotoManagerLoader<T> {
-
-    public CenterCrop(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        super(photoManager, assetToPath);
-    }
-
-    @Override
-    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.centerCrop(path, width, height, cb);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:54 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class CenterCrop<T> extends PhotoManagerLoader<T> {
19 
20     public CenterCrop(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
26         return photoManager.centerCrop(path, width, height, cb);
27     }
28 }",No
src\com\bumptech\photos\view\loader\Exact.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.loader;
-
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:57 PM
- * To change this template use File | Settings | File Templates.
- */
-public class Exact<T> extends PhotoManagerLoader<T> {
-
-    public Exact(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        super(photoManager, assetToPath);
-    }
-
-    @Override
-    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.getImageExact(path, width, height, cb);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:57 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class Exact<T> extends PhotoManagerLoader<T> {
19 
20     public Exact(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
26         return photoManager.getImageExact(path, width, height, cb);
27     }
28 }",No
src\com\bumptech\photos\view\loader\FitCenter.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.loader;
-
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:56 PM
- * To change this template use File | Settings | File Templates.
- */
-public class FitCenter<T> extends PhotoManagerLoader<T> {
-
-    public FitCenter(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        super(photoManager, assetToPath);
-    }
-
-    @Override
-    protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
-        return photoManager.fitCenter(path, width, height, cb);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import com.bumptech.photos.LoadedCallback;
8 import com.bumptech.photos.PhotoManager;
9 import com.bumptech.photos.view.assetpath.AssetPathConverter;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:56 PM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class FitCenter<T> extends PhotoManagerLoader<T> {
19 
20     public FitCenter(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
21         super(photoManager, assetToPath);
22     }
23 
24     @Override
25     protected Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb) {
26         return photoManager.fitCenter(path, width, height, cb);
27     }
28 }",No
src\com\bumptech\photos\view\loader\ImageLoader.java,src\com\bumptech\photos\view\loader\ImageLoader.java,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,7 +1,3 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
 package com.bumptech.photos.view.loader;
 
 import android.graphics.Bitmap;
@@ -9,23 +5,28 @@ import android.graphics.Bitmap;
 /**
  * Created with IntelliJ IDEA.
  * User: sam
- * Date: 12/29/12
- * Time: 11:32 AM
+ * Date: 1/1/13
+ * Time: 2:21 PM
  * To change this template use File | Settings | File Templates.
  */
 public interface ImageLoader<T> {
-    public interface PathReadyCallback {
-        public boolean onPathReady(String path);
-        public void onError(Exception e);
-    }
 
     public interface ImageReadyCallback {
         public boolean onImageReady(Bitmap image);
         public void onError(Exception e);
     }
 
-    public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
+    /**
+     * Load the image at the given path represented by the given model
+     *
+     * @param path - the path to the image or null if the required information is contained in the model
+     * @param model - the object taht represents or contains an image that can be displayed
+     * @param width - the width of the view where the image will be displayed
+     * @param height - the height of the view where the image will be displayed
+     * @param cb - the callback to call when the bitmap is loaded into memory
+     * @return A reference to the fetch (if needed because of a weak reference) or null
+     */
     public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
-    public void clear();
 
+    public void clear();
 }
","8  * Date: 1/1/13
9  * Time: 2:21 PM
19     /**
20      * Load the image at the given path represented by the given model
21      *
22      * @param path - the path to the image or null if the required information is contained in the model
23      * @param model - the object taht represents or contains an image that can be displayed
24      * @param width - the width of the view where the image will be displayed
25      * @param height - the height of the view where the image will be displayed
26      * @param cb - the callback to call when the bitmap is loaded into memory
27      * @return A reference to the fetch (if needed because of a weak reference) or null
28      */
31     public void clear();
1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
12  * Date: 12/29/12
13  * Time: 11:32 AM
17     public interface PathReadyCallback {
18         public boolean onPathReady(String path);
19         public void onError(Exception e);
20     }
27     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
29     public void clear();",No
src\com\bumptech\photos\view\loader\PhotoManagerLoader.java,,1afd6153d474f6f54a9b42d0df263e48ffaf4154,140bc3a11a2415b100a3691bfe2ce378022fefe9,"Refactor ImageLoader -> PathLoader + ImageLoader

Also create a photomanager package and move 
PhotoManager and related subclasses of image 
loader into that package.","@@ -1,111 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.view.loader;
-
-import android.graphics.Bitmap;
-import com.bumptech.photos.LoadedCallback;
-import com.bumptech.photos.PhotoManager;
-import com.bumptech.photos.view.assetpath.AssetPathConverter;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/28/12
- * Time: 9:53 AM
- * To change this template use File | Settings | File Templates.
- */
-public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
-
-    protected final PhotoManager photoManager;
-    private final AssetPathConverter<T> assetToPath;
-    private Bitmap acquired = null;
-    private Object loadToken = null;
-
-    public PhotoManagerLoader(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
-        this.photoManager = photoManager;
-        this.assetToPath = assetToPath;
-    }
-
-    @Override
-    public final void doFetchPath(T model, int width, int height, ImageLoader.PathReadyCallback cb) {
-        assetToPath.fetchPath(model, width, height, new PathReadyCallback(this, cb));
-    }
-
-    @Override
-    protected final void doFetchImage(String path, T model, int width, int height, ImageLoader.ImageReadyCallback cb) {
-        if (loadToken != null)  {
-            photoManager.cancelTask(loadToken);
-        }
-        if (acquired != null) {
-            photoManager.releaseBitmap(acquired);
-            acquired = null;
-        }
-
-        loadToken = doFetchImage(path, model, width, height, new ImageReadyCallback(this, cb));
-    }
-
-    protected abstract Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb);
-
-    @Override
-    protected void onImageReady(Bitmap image, boolean isUsed) {
-        if (isUsed) {
-            if (acquired != null) {
-                photoManager.releaseBitmap(acquired);
-            }
-            photoManager.acquireBitmap(image);
-            acquired = image;
-        } else {
-            photoManager.rejectBitmap(image);
-        }
-    }
-
-    @Override
-    public void onImageLoadFailed(Exception e, ImageLoader.ImageReadyCallback cb) {
-        cb.onError(e);
-    }
-
-    @Override
-    public void clear() {
-        if (acquired != null) {
-            photoManager.releaseBitmap(acquired);
-            acquired = null;
-        }
-    }
-
-    private static class PathReadyCallback<T> extends BaseImageLoader.InternalPathReadyCallback<T> implements AssetPathConverter.PathReadyListener {
-
-        public PathReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.PathReadyCallback cb) {
-            super(imageLoader, cb);
-        }
-
-        @Override
-        public void pathReady(String path) {
-            onPathReady(path);
-        }
-
-        @Override
-        public void onError(Exception e) {
-            onPathLoadFailed(e);
-        }
-    }
-
-    private static class ImageReadyCallback<T> extends BaseImageLoader.InternalImageReadyCallback<T> implements LoadedCallback{
-
-        public ImageReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.ImageReadyCallback cb) {
-            super(imageLoader, cb);
-        }
-
-        @Override
-        public void onLoadCompleted(Bitmap loaded) {
-            onImageReady(loaded);
-        }
-
-        @Override
-        public void onLoadFailed(Exception e) {
-            onImageLoadFailed(e);
-        }
-    }
-
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.view.loader;
6 
7 import android.graphics.Bitmap;
8 import com.bumptech.photos.LoadedCallback;
9 import com.bumptech.photos.PhotoManager;
10 import com.bumptech.photos.view.assetpath.AssetPathConverter;
11 
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 12/28/12
16  * Time: 9:53 AM
17  * To change this template use File | Settings | File Templates.
18  */
19 public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
20 
21     protected final PhotoManager photoManager;
22     private final AssetPathConverter<T> assetToPath;
23     private Bitmap acquired = null;
24     private Object loadToken = null;
25 
26     public PhotoManagerLoader(PhotoManager photoManager, AssetPathConverter<T> assetToPath) {
27         this.photoManager = photoManager;
28         this.assetToPath = assetToPath;
29     }
30 
31     @Override
32     public final void doFetchPath(T model, int width, int height, ImageLoader.PathReadyCallback cb) {
33         assetToPath.fetchPath(model, width, height, new PathReadyCallback(this, cb));
34     }
35 
36     @Override
37     protected final void doFetchImage(String path, T model, int width, int height, ImageLoader.ImageReadyCallback cb) {
38         if (loadToken != null)  {
39             photoManager.cancelTask(loadToken);
40         }
41         if (acquired != null) {
42             photoManager.releaseBitmap(acquired);
43             acquired = null;
44         }
45 
46         loadToken = doFetchImage(path, model, width, height, new ImageReadyCallback(this, cb));
47     }
48 
49     protected abstract Object doFetchImage(String path, T model, int width, int height, LoadedCallback cb);
50 
51     @Override
52     protected void onImageReady(Bitmap image, boolean isUsed) {
53         if (isUsed) {
54             if (acquired != null) {
55                 photoManager.releaseBitmap(acquired);
56             }
57             photoManager.acquireBitmap(image);
58             acquired = image;
59         } else {
60             photoManager.rejectBitmap(image);
61         }
62     }
63 
64     @Override
65     public void onImageLoadFailed(Exception e, ImageLoader.ImageReadyCallback cb) {
66         cb.onError(e);
67     }
68 
69     @Override
70     public void clear() {
71         if (acquired != null) {
72             photoManager.releaseBitmap(acquired);
73             acquired = null;
74         }
75     }
76 
77     private static class PathReadyCallback<T> extends BaseImageLoader.InternalPathReadyCallback<T> implements AssetPathConverter.PathReadyListener {
78 
79         public PathReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.PathReadyCallback cb) {
80             super(imageLoader, cb);
81         }
82 
83         @Override
84         public void pathReady(String path) {
85             onPathReady(path);
86         }
87 
88         @Override
89         public void onError(Exception e) {
90             onPathLoadFailed(e);
91         }
92     }
93 
94     private static class ImageReadyCallback<T> extends BaseImageLoader.InternalImageReadyCallback<T> implements LoadedCallback{
95 
96         public ImageReadyCallback(BaseImageLoader<T> imageLoader, ImageLoader.ImageReadyCallback cb) {
97             super(imageLoader, cb);
98         }
99 
100         @Override
101         public void onLoadCompleted(Bitmap loaded) {
102             onImageReady(loaded);
103         }
104 
105         @Override
106         public void onLoadFailed(Exception e) {
107             onImageLoadFailed(e);
108         }
109     }
110 
111 }",No
src\com\bumptech\photos\view\loader\BaseImageLoader.java,src\com\bumptech\photos\loader\image\BaseImageLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.view.loader;
+package com.bumptech.photos.loader.image;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.photos.loader.image;
1 package com.bumptech.photos.view.loader;",No
src\com\bumptech\photos\view\loader\ImageLoader.java,src\com\bumptech\photos\loader\image\ImageLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.view.loader;
+package com.bumptech.photos.loader.image;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.photos.loader.image;
1 package com.bumptech.photos.view.loader;",No
src\com\bumptech\photos\view\assetpath\BasePathLoader.java,src\com\bumptech\photos\loader\path\BasePathLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.view.assetpath;
+package com.bumptech.photos.loader.path;
 
 import java.lang.ref.WeakReference;
 
","1 package com.bumptech.photos.loader.path;
1 package com.bumptech.photos.view.assetpath;",No
src\com\bumptech\photos\view\assetpath\PathLoader.java,src\com\bumptech\photos\loader\path\PathLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.view.assetpath;
+package com.bumptech.photos.loader.path;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.loader.path;
5 package com.bumptech.photos.view.assetpath;",No
src\com\bumptech\photos\view\assetpath\SimplePathLoader.java,src\com\bumptech\photos\loader\path\SimplePathLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.view.assetpath;
+package com.bumptech.photos.loader.path;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.loader.path;
5 package com.bumptech.photos.view.assetpath;",No
src\com\bumptech\photos\photomanager\loader\Approximate.java,src\com\bumptech\photos\photomanager\loader\Approximate.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -6,7 +6,6 @@ package com.bumptech.photos.photomanager.loader;
 
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.photomanager.PhotoManagerLoader;
 
 /**
  * Created with IntelliJ IDEA.
",9 import com.bumptech.photos.photomanager.PhotoManagerLoader;,No
src\com\bumptech\photos\photomanager\loader\AsIs.java,src\com\bumptech\photos\photomanager\loader\AsIs.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,6 @@ package com.bumptech.photos.photomanager.loader;
 
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.photomanager.PhotoManagerLoader;
 
 /**
  * Created with IntelliJ IDEA.
",5 import com.bumptech.photos.photomanager.PhotoManagerLoader;,No
src\com\bumptech\photos\photomanager\loader\CenterCrop.java,src\com\bumptech\photos\photomanager\loader\CenterCrop.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -6,7 +6,6 @@ package com.bumptech.photos.photomanager.loader;
 
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.photomanager.PhotoManagerLoader;
 
 /**
  * Created with IntelliJ IDEA.
",9 import com.bumptech.photos.photomanager.PhotoManagerLoader;,No
src\com\bumptech\photos\photomanager\loader\Exact.java,src\com\bumptech\photos\photomanager\loader\Exact.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -6,7 +6,6 @@ package com.bumptech.photos.photomanager.loader;
 
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.photomanager.PhotoManagerLoader;
 
 /**
  * Created with IntelliJ IDEA.
",9 import com.bumptech.photos.photomanager.PhotoManagerLoader;,No
src\com\bumptech\photos\photomanager\loader\FitCenter.java,src\com\bumptech\photos\photomanager\loader\FitCenter.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -6,7 +6,6 @@ package com.bumptech.photos.photomanager.loader;
 
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.photomanager.PhotoManagerLoader;
 
 /**
  * Created with IntelliJ IDEA.
",9 import com.bumptech.photos.photomanager.PhotoManagerLoader;,No
src\com\bumptech\photos\photomanager\PhotoManagerLoader.java,src\com\bumptech\photos\photomanager\loader\PhotoManagerLoader.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -1,9 +1,9 @@
-package com.bumptech.photos.photomanager;
+package com.bumptech.photos.photomanager.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.image.BaseImageLoader;
 import com.bumptech.photos.photomanager.LoadedCallback;
 import com.bumptech.photos.photomanager.PhotoManager;
-import com.bumptech.photos.view.loader.BaseImageLoader;
 
 /**
  * Created with IntelliJ IDEA.
","1 package com.bumptech.photos.photomanager.loader;
4 import com.bumptech.photos.loader.image.BaseImageLoader;
1 package com.bumptech.photos.photomanager;
6 import com.bumptech.photos.view.loader.BaseImageLoader;",No
src\com\bumptech\photos\view\ImagePresenter.java,src\com\bumptech\photos\presenter\ImagePresenter.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.view;
+package com.bumptech.photos.presenter;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
@@ -11,8 +11,8 @@ import android.os.SystemClock;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
 import com.bumptech.photos.util.Log;
-import com.bumptech.photos.view.assetpath.PathLoader;
-import com.bumptech.photos.view.loader.ImageLoader;
+import com.bumptech.photos.loader.path.PathLoader;
+import com.bumptech.photos.loader.image.ImageLoader;
 
 import java.lang.ref.WeakReference;
 
@@ -25,8 +25,6 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
-
-
     public static class Builder<T> {
         private ImageView imageView;
         private int placeholderResourceId;
","5 package com.bumptech.photos.presenter;
14 import com.bumptech.photos.loader.path.PathLoader;
15 import com.bumptech.photos.loader.image.ImageLoader;
5 package com.bumptech.photos.view;
14 import com.bumptech.photos.view.assetpath.PathLoader;
15 import com.bumptech.photos.view.loader.ImageLoader;
28 
29 ",No
src\com\bumptech\photos\view\ImageSetCallback.java,src\com\bumptech\photos\presenter\ImageSetCallback.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.view;
+package com.bumptech.photos.presenter;
 
 import android.widget.ImageView;
 
","5 package com.bumptech.photos.presenter;
5 package com.bumptech.photos.view;",No
src\com\bumptech\photos\view\ThumbImagePresenter.java,src\com\bumptech\photos\presenter\ThumbImagePresenter.java,4b422e94f9f807efa18ee641295fab9fac18b893,1afd6153d474f6f54a9b42d0df263e48ffaf4154,more package cleanup,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.view;
+package com.bumptech.photos.presenter;
 
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
","5 package com.bumptech.photos.presenter;
5 package com.bumptech.photos.view;",No
src\com\bumptech\photos\photomanager\PhotoManager.java,src\com\bumptech\photos\imagemanager\ImageManager.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager;
+package com.bumptech.photos.imagemanager;
 
 import android.graphics.Bitmap;
 import android.os.Build;
@@ -25,7 +25,7 @@ import java.util.Map;
  * Time: 5:02 PM
  * To change this template use File | Settings | File Templates.
  */
-public class PhotoManager {
+public class ImageManager {
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private PhotoDiskCache diskCache;
@@ -42,7 +42,7 @@ public class PhotoManager {
         AS_IS
     }
 
-    public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
+    public ImageManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
         this.backgroundHandler = backgroundHandler;
         this.memoryCache = new LruPhotoCache(maxMemCacheSize);
         memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
","5 package com.bumptech.photos.imagemanager;
28 public class ImageManager {
45     public ImageManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
5 package com.bumptech.photos.photomanager;
28 public class PhotoManager {
45     public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {",No
src\com\bumptech\photos\photomanager\LoadedCallback.java,src\com\bumptech\photos\imagemanager\LoadedCallback.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager;
+package com.bumptech.photos.imagemanager;
 
 import android.graphics.Bitmap;
 
","5 package com.bumptech.photos.imagemanager;
5 package com.bumptech.photos.photomanager;",No
src\com\bumptech\photos\photomanager\loader\Approximate.java,src\com\bumptech\photos\imagemanager\loader\Approximate.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,10 +2,10 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,12 +16,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public class Approximate<T> extends PhotoManagerLoader<T> {
 
-    public Approximate(PhotoManager photoManager) {
-        super(photoManager);
+    public Approximate(ImageManager imageManager) {
+        super(imageManager);
     }
 
     @Override
     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return photoManager.getImageApproximate(path, width, height, cb);
+        return imageManager.getImageApproximate(path, width, height, cb);
     }
 }
","5 package com.bumptech.photos.imagemanager.loader;
7 import com.bumptech.photos.imagemanager.LoadedCallback;
8 import com.bumptech.photos.imagemanager.ImageManager;
19     public Approximate(ImageManager imageManager) {
20         super(imageManager);
25         return imageManager.getImageApproximate(path, width, height, cb);
5 package com.bumptech.photos.photomanager.loader;
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
19     public Approximate(PhotoManager photoManager) {
20         super(photoManager);
25         return photoManager.getImageApproximate(path, width, height, cb);",No
src\com\bumptech\photos\photomanager\loader\AsIs.java,src\com\bumptech\photos\imagemanager\loader\AsIs.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -1,7 +1,7 @@
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -12,12 +12,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public class AsIs<T> extends PhotoManagerLoader<T> {
 
-    public AsIs(PhotoManager photoManager) {
-        super(photoManager);
+    public AsIs(ImageManager imageManager) {
+        super(imageManager);
     }
 
     @Override
     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return photoManager.getImage(path, cb);
+        return imageManager.getImage(path, cb);
     }
 }
","1 package com.bumptech.photos.imagemanager.loader;
3 import com.bumptech.photos.imagemanager.LoadedCallback;
4 import com.bumptech.photos.imagemanager.ImageManager;
15     public AsIs(ImageManager imageManager) {
16         super(imageManager);
21         return imageManager.getImage(path, cb);
1 package com.bumptech.photos.photomanager.loader;
3 import com.bumptech.photos.photomanager.LoadedCallback;
4 import com.bumptech.photos.photomanager.PhotoManager;
15     public AsIs(PhotoManager photoManager) {
16         super(photoManager);
21         return photoManager.getImage(path, cb);",No
src\com\bumptech\photos\photomanager\loader\CenterCrop.java,src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,10 +2,10 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,12 +16,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public class CenterCrop<T> extends PhotoManagerLoader<T> {
 
-    public CenterCrop(PhotoManager photoManager) {
-        super(photoManager);
+    public CenterCrop(ImageManager imageManager) {
+        super(imageManager);
     }
 
     @Override
     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return photoManager.centerCrop(path, width, height, cb);
+        return imageManager.centerCrop(path, width, height, cb);
     }
 }
","5 package com.bumptech.photos.imagemanager.loader;
7 import com.bumptech.photos.imagemanager.LoadedCallback;
8 import com.bumptech.photos.imagemanager.ImageManager;
19     public CenterCrop(ImageManager imageManager) {
20         super(imageManager);
25         return imageManager.centerCrop(path, width, height, cb);
5 package com.bumptech.photos.photomanager.loader;
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
19     public CenterCrop(PhotoManager photoManager) {
20         super(photoManager);
25         return photoManager.centerCrop(path, width, height, cb);",No
src\com\bumptech\photos\photomanager\loader\Exact.java,src\com\bumptech\photos\imagemanager\loader\Exact.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,10 +2,10 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,12 +16,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public class Exact<T> extends PhotoManagerLoader<T> {
 
-    public Exact(PhotoManager photoManager) {
-        super(photoManager);
+    public Exact(ImageManager imageManager) {
+        super(imageManager);
     }
 
     @Override
     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return photoManager.getImageExact(path, width, height, cb);
+        return imageManager.getImageExact(path, width, height, cb);
     }
 }
","5 package com.bumptech.photos.imagemanager.loader;
7 import com.bumptech.photos.imagemanager.LoadedCallback;
8 import com.bumptech.photos.imagemanager.ImageManager;
19     public Exact(ImageManager imageManager) {
20         super(imageManager);
25         return imageManager.getImageExact(path, width, height, cb);
5 package com.bumptech.photos.photomanager.loader;
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
19     public Exact(PhotoManager photoManager) {
20         super(photoManager);
25         return photoManager.getImageExact(path, width, height, cb);",No
src\com\bumptech\photos\photomanager\loader\FitCenter.java,src\com\bumptech\photos\imagemanager\loader\FitCenter.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -2,10 +2,10 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,12 +16,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public class FitCenter<T> extends PhotoManagerLoader<T> {
 
-    public FitCenter(PhotoManager photoManager) {
-        super(photoManager);
+    public FitCenter(ImageManager imageManager) {
+        super(imageManager);
     }
 
     @Override
     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return photoManager.fitCenter(path, width, height, cb);
+        return imageManager.fitCenter(path, width, height, cb);
     }
 }
","5 package com.bumptech.photos.imagemanager.loader;
7 import com.bumptech.photos.imagemanager.LoadedCallback;
8 import com.bumptech.photos.imagemanager.ImageManager;
19     public FitCenter(ImageManager imageManager) {
20         super(imageManager);
25         return imageManager.fitCenter(path, width, height, cb);
5 package com.bumptech.photos.photomanager.loader;
7 import com.bumptech.photos.photomanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.PhotoManager;
19     public FitCenter(PhotoManager photoManager) {
20         super(photoManager);
25         return photoManager.fitCenter(path, width, height, cb);",No
src\com\bumptech\photos\photomanager\loader\PhotoManagerLoader.java,src\com\bumptech\photos\imagemanager\loader\PhotoManagerLoader.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -1,9 +1,9 @@
-package com.bumptech.photos.photomanager.loader;
+package com.bumptech.photos.imagemanager.loader;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.loader.image.BaseImageLoader;
-import com.bumptech.photos.photomanager.LoadedCallback;
-import com.bumptech.photos.photomanager.PhotoManager;
+import com.bumptech.photos.imagemanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
@@ -14,12 +14,12 @@ import com.bumptech.photos.photomanager.PhotoManager;
  */
 public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
 
-    protected final PhotoManager photoManager;
+    protected final ImageManager imageManager;
     private Bitmap acquired;
     private Object loadToken;
 
-    public PhotoManagerLoader(PhotoManager photoManager) {
-        this.photoManager = photoManager;
+    public PhotoManagerLoader(ImageManager imageManager) {
+        this.imageManager = imageManager;
     }
     @Override
     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
@@ -33,10 +33,10 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
     protected void onImageReady(Bitmap image, boolean isUsed) {
         if (isUsed) {
             releaseAcquired();
-            photoManager.acquireBitmap(image);
+            imageManager.acquireBitmap(image);
             acquired = image;
         } else {
-            photoManager.rejectBitmap(image);
+            imageManager.rejectBitmap(image);
         }
     }
 
@@ -47,7 +47,7 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
 
     private void releaseAcquired() {
         if (acquired != null) {
-            photoManager.releaseBitmap(acquired);
+            imageManager.releaseBitmap(acquired);
             acquired = null;
         }
     }
","1 package com.bumptech.photos.imagemanager.loader;
5 import com.bumptech.photos.imagemanager.LoadedCallback;
6 import com.bumptech.photos.imagemanager.ImageManager;
17     protected final ImageManager imageManager;
21     public PhotoManagerLoader(ImageManager imageManager) {
22         this.imageManager = imageManager;
36             imageManager.acquireBitmap(image);
39             imageManager.rejectBitmap(image);
50             imageManager.releaseBitmap(acquired);
1 package com.bumptech.photos.photomanager.loader;
5 import com.bumptech.photos.photomanager.LoadedCallback;
6 import com.bumptech.photos.photomanager.PhotoManager;
17     protected final PhotoManager photoManager;
21     public PhotoManagerLoader(PhotoManager photoManager) {
22         this.photoManager = photoManager;
36             photoManager.acquireBitmap(image);
39             photoManager.rejectBitmap(image);
50             photoManager.releaseBitmap(acquired);",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,808de8fcef7aeedd7bb11648343f2db61d40403d,4b422e94f9f807efa18ee641295fab9fac18b893,PhotoManager->ImageManager,"@@ -5,7 +5,7 @@ package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-import com.bumptech.photos.photomanager.LoadedCallback;
+import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.cache.SizedBitmapCache;
 
 import java.io.IOException;
","8 import com.bumptech.photos.imagemanager.LoadedCallback;
8 import com.bumptech.photos.photomanager.LoadedCallback;",No
src\com\bumptech\photos\presenter\ThumbImagePresenter.java,src\com\bumptech\photos\presenter\ThumbImagePresenter.java,3f14eb04d829f612b559bd6099141a7e317d4a29,808de8fcef7aeedd7bb11648343f2db61d40403d,Add reset placeholder to thumb image presenter,"@@ -105,4 +105,8 @@ public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoor
     public boolean canSetPlaceholder(ImagePresenter presenter) {
         return presenter == fullPresenter;
     }
+
+    public void resetPlaceholder() {
+        fullPresenter.resetPlaceHolder();
+    }
 }
","108 
109     public void resetPlaceholder() {
110         fullPresenter.resetPlaceHolder();
111     }",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,47cb98175b5d600567fef273e33e534e8fda704e,3f14eb04d829f612b559bd6099141a7e317d4a29,"Make disk cache and job generator synchronous

Reduces the number of callbacks and simplifies 
calls to the image manager.","@@ -1,7 +1,6 @@
 package com.bumptech.photos.cache;
 
 import android.graphics.Bitmap;
-import android.os.Handler;
 import com.bumptech.photos.util.Log;
 import com.jakewharton.DiskLruCache;
 
@@ -25,11 +24,7 @@ public class PhotoDiskCache {
     private final static int APP_VERSION = 0;
     private final static int VALUE_COUNT = 1; //values per cache entry
     private DiskLruCache cache;
-    private Handler mainHandler;
 
-    public interface GetCallback {
-        public void onGet(InputStream is1, InputStream is2);
-    };
 
     public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
         try {
@@ -37,13 +32,9 @@ public class PhotoDiskCache {
         } catch (IOException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
-        this.mainHandler = mainHandler;
     }
 
-    public Runnable put(final String key, final Bitmap bitmap) {
-        return new Runnable() {
-            @Override
-            public void run() {
+    public void put(final String key, final Bitmap bitmap) {
         if (bitmap == null) return;
         final String safeKey = sha1Hash(key);
 
@@ -76,34 +67,20 @@ public class PhotoDiskCache {
                     e.printStackTrace();
                 }
             }
-
-                }
         }
-        };
     }
 
-    public Runnable get(final String key, final GetCallback cb) {
-        return new Runnable() {
-            @Override
-            public void run() {
+    public InputStream get(final String key) {
         //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
         final String safeKey = sha1Hash(key);
-                InputStream result1 = null;
-                InputStream result2 = null;
+        InputStream result = null;
         try {
-                    DiskLruCache.Snapshot snapshot1 = cache.get(safeKey);
-
-                    if (snapshot1 != null) {
-                        result1 = snapshot1.getInputStream(VALUE_COUNT - 1);
-                        DiskLruCache.Snapshot snapshot2 = cache.get(safeKey);
+            DiskLruCache.Snapshot snapshot = cache.get(safeKey);
 
-                        if (snapshot2 != null) {
-                            result2 = snapshot2.getInputStream(VALUE_COUNT - 1);
-                        } else {
-                            Log.d(""DLRU: second snapshot not found key="" + key);
-                        }
+            if (snapshot != null) {
+                result = snapshot.getInputStream(VALUE_COUNT - 1);
             } else {
-                        Log.d(""DLRU: first snapshot not found key="" + key);
+                Log.d(""DLRU: snapshot not found key="" + key);
             }
 
         } catch (IOException e) {
@@ -117,16 +94,7 @@ public class PhotoDiskCache {
             }
         }
 
-                final InputStream finalResult1 = result1;
-                final InputStream finalResult2 = result2;
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        cb.onGet(finalResult1, finalResult2);
-                    }
-                });
-            }
-        };
+        return result;
     }
 
     private static String sha1Hash(String toHash) {
","37     public void put(final String key, final Bitmap bitmap) {
73     public InputStream get(final String key) {
76         InputStream result = null;
78             DiskLruCache.Snapshot snapshot = cache.get(safeKey);
80             if (snapshot != null) {
81                 result = snapshot.getInputStream(VALUE_COUNT - 1);
83                 Log.d(""DLRU: snapshot not found key="" + key);
97         return result;
4 import android.os.Handler;
28     private Handler mainHandler;
30     public interface GetCallback {
31         public void onGet(InputStream is1, InputStream is2);
32     };
40         this.mainHandler = mainHandler;
43     public Runnable put(final String key, final Bitmap bitmap) {
44         return new Runnable() {
45             @Override
46             public void run() {
79 
82         };
83     }
85     public Runnable get(final String key, final GetCallback cb) {
86         return new Runnable() {
87             @Override
88             public void run() {
91                 InputStream result1 = null;
92                 InputStream result2 = null;
94                     DiskLruCache.Snapshot snapshot1 = cache.get(safeKey);
96                     if (snapshot1 != null) {
97                         result1 = snapshot1.getInputStream(VALUE_COUNT - 1);
98                         DiskLruCache.Snapshot snapshot2 = cache.get(safeKey);
99 
100                         if (snapshot2 != null) {
101                             result2 = snapshot2.getInputStream(VALUE_COUNT - 1);
103                             Log.d(""DLRU: second snapshot not found key="" + key);
104                         }
105                     } else {
106                         Log.d(""DLRU: first snapshot not found key="" + key);
120                 final InputStream finalResult1 = result1;
121                 final InputStream finalResult2 = result2;
122                 mainHandler.post(new Runnable() {
123                     @Override
124                     public void run() {
125                         cb.onGet(finalResult1, finalResult2);
126                     }
127                 });
128             }
129         };",No
src\com\bumptech\photos\imagemanager\ImageManager.java,src\com\bumptech\photos\imagemanager\ImageManager.java,47cb98175b5d600567fef273e33e534e8fda704e,3f14eb04d829f612b559bd6099141a7e317d4a29,"Make disk cache and job generator synchronous

Reduces the number of callbacks and simplifies 
calls to the image manager.","@@ -62,13 +62,13 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImage(final String path, final LoadedCallback cb){
-        final Object token = cb;
         final String key = getKey(path, 0, 0, ResizeType.AS_IS);
-        if (!returnFromCache(key, cb)) {
-            final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));
-            postJob(task, token);
+        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+            @Override
+            protected Bitmap resizeIfNotFound() {
+                return resizer.loadAsIs(path);
             }
-        return token;
+        });
     }
 
     /**
@@ -79,14 +79,14 @@ public class ImageManager {
      * @param cb - the callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {
-        final Object token = cb;
+    public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
         final String key = getKey(path, width, height, ResizeType.AS_IS);
-        if (!returnFromCache(key, cb)) {
-            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));
-            postJob(task, token);
+        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+            @Override
+            protected Bitmap resizeIfNotFound() {
+                return resizer.loadAsIs(path, width, height);
             }
-        return token;
+        });
     }
 
     /**
@@ -98,18 +98,13 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
-        final Object token = cb;
         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
-        if (!returnFromCache(key, cb)) {
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
-                    return resizer.loadApproximate(path, width, height, resizeCallback);
+            protected Bitmap resizeIfNotFound() {
+                return resizer.loadApproximate(path, width, height);
             }
         });
-            postJob(checkDiskCache, token);
-        }
-        return token;
     }
 
     /**
@@ -122,18 +117,13 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
-        final Object token = cb;
         final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
-        if (!returnFromCache(key, cb)) {
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
-                    return resizer.resizeCenterCrop(path, width, height, resizeCallback);
+            protected Bitmap resizeIfNotFound() {
+                return resizer.resizeCenterCrop(path, width, height);
             }
         });
-            postJob(checkDiskCache, token);
-        }
-        return token;
     }
 
     /**
@@ -146,23 +136,26 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
-        final Object token = cb;
         final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
-        if (!returnFromCache(key, cb)) {
-            Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-                public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
-                    return resizer.fitInSpace(path, width, height, resizeCallback);
+            protected Bitmap resizeIfNotFound() {
+                return resizer.fitInSpace(path, width, height);
             }
         });
-            postJob(checkDiskCache, token);
+    }
+
+    private Object runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
+        final Object token = cb;
+        if (!returnFromCache(key, cb)) {
+            executor.execute(job);
         }
         return token;
     }
 
     private boolean returnFromCache(String key, LoadedCallback cb) {
         boolean found = false;
-        Bitmap inCache = memoryCache.get(key);
+        Bitmap inCache = getFromMemoryCache(key);
         if (inCache != null) {
             found = true;
             cb.onLoadCompleted(inCache);
@@ -170,65 +163,91 @@ public class ImageManager {
         return found;
     }
 
-    private abstract class DiskCacheCallback implements PhotoDiskCache.GetCallback {
-        private Object token;
-        private LoadedCallback cb;
+    private abstract class ImageManagerJob implements Runnable {
         private final String key;
+        private final LoadedCallback cb;
+        private final boolean useDiskCache;
+
+        public ImageManagerJob(String key, LoadedCallback cb) {
+            this(key, cb, true);
+        }
 
-        public DiskCacheCallback(String key, Object token, LoadedCallback cb) {
+        public ImageManagerJob(String key, LoadedCallback cb, boolean useDiskCache) {
             this.key = key;
-            this.token = token;
             this.cb = cb;
+            this.useDiskCache = useDiskCache;
         }
 
         @Override
-        public void onGet(InputStream is1, InputStream is2) {
-            final Runnable task;
-            final boolean inDiskCache = is1 != null && is2 != null;
-            final LoadedCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
-            if (inDiskCache) {
-                task = resizer.loadAsIs(is1, is2, resizeCb);
+        public void run() {
+            InputStream is1 = getFromDiskCache(key);
+            InputStream is2 = null;
+            if (is1 != null) {
+                is2 = getFromDiskCache(key);
+            }
+
+            final boolean isInDiskCache = is1 != null && is2 != null;
+            Bitmap result = null;
+            try {
+                if (isInDiskCache && useDiskCache) {
+                    result = resizer.loadAsIs(is1, is2);
                 } else {
-                task = resizeIfNotFound(resizeCb);
+                    result = resizeIfNotFound();
+                }
+            } catch (Exception e) {
+                cb.onLoadFailed(e);
+            }
+
+            if (result != null) {
+                final Bitmap finalResult = result;
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        acquireBitmap(finalResult);
+                        putInMemoryCache(key, finalResult);
+                        cb.onLoadCompleted(finalResult);
+                    }
+                });
+                //this is time consuming so do it after posting the result
+                if (!isInDiskCache && useDiskCache) {
+                    putInDiskCache(key, result);
+                }
             }
-            postJob(task, token);
         }
 
-        public abstract Runnable resizeIfNotFound(LoadedCallback cb);
+        protected abstract Bitmap resizeIfNotFound();
     }
 
-    private LoadedCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
-        return new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap resized) {
-                memoryCache.put(key, resized);
-                acquireBitmap(resized);
-                if (!inDiskCache && useDiskCache) {
-                    Runnable putToDiskCache = diskCache.put(key, resized);
-                    postJob(putToDiskCache, null);
+    private InputStream getFromDiskCache(String key) {
+        InputStream result = null;
+        if (diskCache != null) {
+            result = diskCache.get(key);
         }
-                cb.onLoadCompleted(resized);
+        return result;
     }
 
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onLoadFailed(e);
+    private void putInDiskCache(String key, Bitmap value) {
+        if (diskCache != null) {
+            diskCache.put(key, value);
         }
-        };
     }
 
-    private void postJob(Runnable job, Object token) {
-        backgroundHandler.postAtTime(job, token, SystemClock.uptimeMillis());
+    private Bitmap getFromMemoryCache(String key) {
+        Bitmap result = null;
+        if (memoryCache != null) {
+            result = memoryCache.get(key);
+        }
+        return result;
     }
 
-    public void cancelTask(Object token){
-        if (token != null) {
-            backgroundHandler.removeCallbacksAndMessages(token);
+    private void putInMemoryCache(String key, Bitmap bitmap) {
+        if (memoryCache != null) {
+            memoryCache.put(key, bitmap);
         }
     }
 
     public void rejectBitmap(Bitmap b) {
-        if (!CAN_RECYCLE) return;
+        if (!isBitmapRecyclingEnabled) return;
 
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
         if (currentCount == null || currentCount == 0) {
@@ -238,7 +257,7 @@ public class ImageManager {
     }
 
     public void acquireBitmap(Bitmap b) {
-        if (!CAN_RECYCLE) return;
+        if (!isBitmapRecyclingEnabled) return;
 
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
         if (currentCount == null) {
@@ -248,7 +267,7 @@ public class ImageManager {
     }
 
     public void releaseBitmap(Bitmap b) {
-        if (!CAN_RECYCLE) return;
+        if (!isBitmapRecyclingEnabled) return;
 
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
         if (currentCount == 0) {
","66         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
67             @Override
68             protected Bitmap resizeIfNotFound() {
69                 return resizer.loadAsIs(path);
71         });
82     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
84         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
85             @Override
86             protected Bitmap resizeIfNotFound() {
87                 return resizer.loadAsIs(path, width, height);
89         });
102         return runJob(key, cb, new ImageManagerJob(key, cb) {
104             protected Bitmap resizeIfNotFound() {
105                 return resizer.loadApproximate(path, width, height);
121         return runJob(key, cb, new ImageManagerJob(key, cb) {
123             protected Bitmap resizeIfNotFound() {
124                 return resizer.resizeCenterCrop(path, width, height);
140         return runJob(key, cb, new ImageManagerJob(key, cb) {
142             protected Bitmap resizeIfNotFound() {
143                 return resizer.fitInSpace(path, width, height);
146     }
147 
148     private Object runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
149         final Object token = cb;
150         if (!returnFromCache(key, cb)) {
151             executor.execute(job);
158         Bitmap inCache = getFromMemoryCache(key);
166     private abstract class ImageManagerJob implements Runnable {
168         private final LoadedCallback cb;
169         private final boolean useDiskCache;
171         public ImageManagerJob(String key, LoadedCallback cb) {
172             this(key, cb, true);
173         }
174 
175         public ImageManagerJob(String key, LoadedCallback cb, boolean useDiskCache) {
178             this.useDiskCache = useDiskCache;
182         public void run() {
183             InputStream is1 = getFromDiskCache(key);
184             InputStream is2 = null;
185             if (is1 != null) {
186                 is2 = getFromDiskCache(key);
187             }
188 
189             final boolean isInDiskCache = is1 != null && is2 != null;
190             Bitmap result = null;
191             try {
192                 if (isInDiskCache && useDiskCache) {
193                     result = resizer.loadAsIs(is1, is2);
195                     result = resizeIfNotFound();
197             } catch (Exception e) {
200 
201             if (result != null) {
202                 final Bitmap finalResult = result;
203                 mainHandler.post(new Runnable() {
204                     @Override
205                     public void run() {
206                         acquireBitmap(finalResult);
207                         putInMemoryCache(key, finalResult);
208                         cb.onLoadCompleted(finalResult);
209                     }
210                 });
211                 //this is time consuming so do it after posting the result
212                 if (!isInDiskCache && useDiskCache) {
213                     putInDiskCache(key, result);
214                 }
215             }
218         protected abstract Bitmap resizeIfNotFound();
221     private InputStream getFromDiskCache(String key) {
222         InputStream result = null;
223         if (diskCache != null) {
224             result = diskCache.get(key);
225         }
226         return result;
227     }
228 
229     private void putInDiskCache(String key, Bitmap value) {
230         if (diskCache != null) {
231             diskCache.put(key, value);
232         }
233     }
234 
235     private Bitmap getFromMemoryCache(String key) {
236         Bitmap result = null;
237         if (memoryCache != null) {
238             result = memoryCache.get(key);
239         }
240         return result;
241     }
242 
243     private void putInMemoryCache(String key, Bitmap bitmap) {
244         if (memoryCache != null) {
245             memoryCache.put(key, bitmap);
250         if (!isBitmapRecyclingEnabled) return;
260         if (!isBitmapRecyclingEnabled) return;
270         if (!isBitmapRecyclingEnabled) return;
65         final Object token = cb;
67         if (!returnFromCache(key, cb)) {
68             final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));
69             postJob(task, token);
71         return token;
82     public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {
83         final Object token = cb;
85         if (!returnFromCache(key, cb)) {
86             final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));
87             postJob(task, token);
89         return token;
101         final Object token = cb;
103         if (!returnFromCache(key, cb)) {
104             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
106                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
107                     return resizer.loadApproximate(path, width, height, resizeCallback);
110             postJob(checkDiskCache, token);
111         }
112         return token;
125         final Object token = cb;
127         if (!returnFromCache(key, cb)) {
128             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
130                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
131                     return resizer.resizeCenterCrop(path, width, height, resizeCallback);
134             postJob(checkDiskCache, token);
135         }
136         return token;
149         final Object token = cb;
151         if (!returnFromCache(key, cb)) {
152             Runnable checkDiskCache = diskCache.get(key, new DiskCacheCallback(key, token, cb) {
154                 public Runnable resizeIfNotFound(LoadedCallback resizeCallback) {
155                     return resizer.fitInSpace(path, width, height, resizeCallback);
158             postJob(checkDiskCache, token);
165         Bitmap inCache = memoryCache.get(key);
173     private abstract class DiskCacheCallback implements PhotoDiskCache.GetCallback {
174         private Object token;
175         private LoadedCallback cb;
178         public DiskCacheCallback(String key, Object token, LoadedCallback cb) {
180             this.token = token;
185         public void onGet(InputStream is1, InputStream is2) {
186             final Runnable task;
187             final boolean inDiskCache = is1 != null && is2 != null;
188             final LoadedCallback resizeCb = getResizeCb(key, token, cb, inDiskCache, true);
189             if (inDiskCache) {
190                 task = resizer.loadAsIs(is1, is2, resizeCb);
192                 task = resizeIfNotFound(resizeCb);
194             postJob(task, token);
195         }
196 
197         public abstract Runnable resizeIfNotFound(LoadedCallback cb);
198     }
199 
200     private LoadedCallback getResizeCb(final String key, final Object token, final LoadedCallback cb, final boolean inDiskCache, final boolean useDiskCache) {
201         return new LoadedCallback() {
202             @Override
203             public void onLoadCompleted(Bitmap resized) {
204                 memoryCache.put(key, resized);
205                 acquireBitmap(resized);
206                 if (!inDiskCache && useDiskCache) {
207                     Runnable putToDiskCache = diskCache.put(key, resized);
208                     postJob(putToDiskCache, null);
209                 }
210                 cb.onLoadCompleted(resized);
211             }
212 
213             @Override
214             public void onLoadFailed(Exception e) {
217         };
220     private void postJob(Runnable job, Object token) {
221         backgroundHandler.postAtTime(job, token, SystemClock.uptimeMillis());
224     public void cancelTask(Object token){
225         if (token != null) {
226             backgroundHandler.removeCallbacksAndMessages(token);
231         if (!CAN_RECYCLE) return;
241         if (!CAN_RECYCLE) return;
251         if (!CAN_RECYCLE) return;",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,47cb98175b5d600567fef273e33e534e8fda704e,3f14eb04d829f612b559bd6099141a7e317d4a29,"Make disk cache and job generator synchronous

Reduces the number of callbacks and simplifies 
calls to the image manager.","@@ -5,7 +5,6 @@ package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.cache.SizedBitmapCache;
 
 import java.io.IOException;
@@ -17,7 +16,6 @@ import java.io.InputStream;
  */
 public class ResizeJobGenerator {
 
-    private Handler mainHandler;
     private final SizedBitmapCache bitmapCache;
 
     public ResizeJobGenerator(Handler mainHandler) {
@@ -25,57 +23,29 @@ public class ResizeJobGenerator {
     }
 
     public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){
-        this.mainHandler = mainHandler;
         this.bitmapCache = bitmapCache;
     }
 
-    public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){
-        return new StreamResizeRunnable(callback) {
-
-            @Override
-            public Bitmap getRecycledBitmap() {
-                return bitmapCache.get(width, height);
-            }
-
-            @Override
-            public Bitmap resize(Bitmap recycled) {
-                Bitmap streamed = Utils.streamIn(path, width, height);
+    public Bitmap resizeCenterCrop(final String path, final int width, final int height){
+        final Bitmap streamed = Utils.streamIn(path, width, height);
 
         if (streamed.getWidth() == width && streamed.getHeight() == height) {
             return streamed;
-                } else {
-                    return Utils.centerCrop(recycled, streamed, width, height);
-                }
-            }
-        };
         }
 
-    public Runnable fitInSpace(final String path, final int width, final int height, LoadedCallback callback){
-        return new SimpleStreamResizeRunnable(callback) {
+        return Utils.centerCrop(getRecycled(width, height), streamed, width, height);
+    }
 
-            @Override
-            public Bitmap resize(Bitmap recycled) {
+    public Bitmap fitInSpace(final String path, final int width, final int height){
         final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
         return Utils.fitInSpace(streamed, width, height);
     }
-        };
-    }
 
-    public Runnable loadApproximate(final String path, final int width, final int height, LoadedCallback callback){
-        return new SimpleStreamResizeRunnable(callback) {
-
-            @Override
-            public Bitmap resize(Bitmap recycled) {
+    public Bitmap loadApproximate(final String path, final int width, final int height){
         return Utils.streamIn(path, width, height);
     }
-        };
-    }
 
-    public Runnable loadAsIs(final InputStream is1, final InputStream is2, final LoadedCallback callback) {
-        return new StreamResizeRunnable(callback) {
-
-            @Override
-            public Bitmap getRecycledBitmap() {
+    public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
         int[] dimens = new int[] {-1, -1};
         try {
             dimens = Utils.getDimension(is1);
@@ -83,103 +53,40 @@ public class ResizeJobGenerator {
             try {
                 is1.close();
             } catch (IOException e) {
-                        e.printStackTrace();
-                    }
+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
             }
-                return bitmapCache.get(dimens[0], dimens[1]);
         }
-
-            @Override
-            public Bitmap resize(Bitmap recycled) {
         Bitmap resized = null;
         try {
-                    resized = Utils.load(is2, recycled);
+            resized = Utils.load(is2, getRecycled(dimens));
         } finally {
             try {
                 is2.close();
             } catch (IOException e) {
+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
             }
         }
         return resized;
     }
-        };
-    }
 
-    public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {
-        return new StreamResizeRunnable(cb) {
-            @Override
-            public Bitmap getRecycledBitmap() {
-                return bitmapCache.get(width, height);
+    public Bitmap loadAsIs(final String path, final int width, final int height) {
+        return Utils.load(path, getRecycled(width, height));
     }
 
-            @Override
-            public Bitmap resize(Bitmap recycled) {
-                return Utils.load(path, recycled);
-            }
-        };
-    }
-
-    public Runnable loadAsIs(final String path, LoadedCallback callback){
-        return new StreamResizeRunnable(callback) {
-            @Override
-            public Bitmap getRecycledBitmap() {
+    public Bitmap loadAsIs(final String path){
         int[] dimens = Utils.getDimensions(path);
-                return bitmapCache.get(dimens[0], dimens[1]);
+        return Utils.load(path, getRecycled(dimens));
     }
 
-            @Override
-            public Bitmap resize(Bitmap recycled) {
-                return Utils.load(path, recycled);
-            }
-        };
+    private Bitmap getRecycled(int[] dimens) {
+        return getRecycled(dimens[0], dimens[1]);
     }
 
-    private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
-
-        public SimpleStreamResizeRunnable(LoadedCallback callback) {
-            super(callback);
-        }
-
-        @Override
-        public final Bitmap getRecycledBitmap() {
-            return null;
-        }
-    }
-
-    private abstract class StreamResizeRunnable implements Runnable {
-        private final LoadedCallback callback;
-
-        public StreamResizeRunnable(LoadedCallback callback) {
-            this.callback = callback;
-        }
-
-        @Override
-        public final void run() {
-            try {
-                Bitmap recycled = null;
+    private Bitmap getRecycled(int width, int height) {
+        Bitmap result = null;
         if (bitmapCache != null) {
-                    recycled = getRecycledBitmap();
-                }
-                final Bitmap result = resize(recycled);
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        callback.onLoadCompleted(result);
-                    }
-                });
-            } catch (final Exception e) {
-                e.printStackTrace();
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        callback.onLoadFailed(e);
+            result = bitmapCache.get(width, height);
         }
-                });
-            }
-        }
-
-        public abstract Bitmap getRecycledBitmap();
-
-        public abstract Bitmap resize(Bitmap recycled);
+        return result;
     }
 }
","29     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
30         final Bitmap streamed = Utils.streamIn(path, width, height);
36         return Utils.centerCrop(getRecycled(width, height), streamed, width, height);
37     }
39     public Bitmap fitInSpace(final String path, final int width, final int height){
44     public Bitmap loadApproximate(final String path, final int width, final int height){
48     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
56                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
61             resized = Utils.load(is2, getRecycled(dimens));
66                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
71 
72     public Bitmap loadAsIs(final String path, final int width, final int height) {
73         return Utils.load(path, getRecycled(width, height));
76     public Bitmap loadAsIs(final String path){
78         return Utils.load(path, getRecycled(dimens));
81     private Bitmap getRecycled(int[] dimens) {
82         return getRecycled(dimens[0], dimens[1]);
85     private Bitmap getRecycled(int width, int height) {
86         Bitmap result = null;
88             result = bitmapCache.get(width, height);
90         return result;
8 import com.bumptech.photos.imagemanager.LoadedCallback;
20     private Handler mainHandler;
28         this.mainHandler = mainHandler;
32     public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){
33         return new StreamResizeRunnable(callback) {
34 
35             @Override
36             public Bitmap getRecycledBitmap() {
37                 return bitmapCache.get(width, height);
38             }
39 
40             @Override
41             public Bitmap resize(Bitmap recycled) {
42                 Bitmap streamed = Utils.streamIn(path, width, height);
46                 } else {
47                     return Utils.centerCrop(recycled, streamed, width, height);
48                 }
49             }
50         };
53     public Runnable fitInSpace(final String path, final int width, final int height, LoadedCallback callback){
54         return new SimpleStreamResizeRunnable(callback) {
56             @Override
57             public Bitmap resize(Bitmap recycled) {
61         };
62     }
64     public Runnable loadApproximate(final String path, final int width, final int height, LoadedCallback callback){
65         return new SimpleStreamResizeRunnable(callback) {
66 
67             @Override
68             public Bitmap resize(Bitmap recycled) {
71         };
72     }
74     public Runnable loadAsIs(final InputStream is1, final InputStream is2, final LoadedCallback callback) {
75         return new StreamResizeRunnable(callback) {
76 
77             @Override
78             public Bitmap getRecycledBitmap() {
86                         e.printStackTrace();
89                 return bitmapCache.get(dimens[0], dimens[1]);
90             }
91 
92             @Override
93             public Bitmap resize(Bitmap recycled) {
96                     resized = Utils.load(is2, recycled);
105         };
108     public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {
109         return new StreamResizeRunnable(cb) {
110             @Override
111             public Bitmap getRecycledBitmap() {
112                 return bitmapCache.get(width, height);
113             }
114 
115             @Override
116             public Bitmap resize(Bitmap recycled) {
117                 return Utils.load(path, recycled);
118             }
119         };
120     }
121 
122     public Runnable loadAsIs(final String path, LoadedCallback callback){
123         return new StreamResizeRunnable(callback) {
124             @Override
125             public Bitmap getRecycledBitmap() {
127                 return bitmapCache.get(dimens[0], dimens[1]);
130             @Override
131             public Bitmap resize(Bitmap recycled) {
132                 return Utils.load(path, recycled);
133             }
134         };
137     private abstract class SimpleStreamResizeRunnable extends StreamResizeRunnable {
138 
139         public SimpleStreamResizeRunnable(LoadedCallback callback) {
140             super(callback);
141         }
142 
143         @Override
144         public final Bitmap getRecycledBitmap() {
145             return null;
146         }
147     }
148 
149     private abstract class StreamResizeRunnable implements Runnable {
150         private final LoadedCallback callback;
151 
152         public StreamResizeRunnable(LoadedCallback callback) {
153             this.callback = callback;
154         }
155 
156         @Override
157         public final void run() {
158             try {
159                 Bitmap recycled = null;
161                     recycled = getRecycledBitmap();
163                 final Bitmap result = resize(recycled);
164                 mainHandler.post(new Runnable() {
165                     @Override
166                     public void run() {
167                         callback.onLoadCompleted(result);
168                     }
169                 });
170             } catch (final Exception e) {
171                 e.printStackTrace();
172                 mainHandler.post(new Runnable() {
173                     @Override
174                     public void run() {
175                         callback.onLoadFailed(e);
176                     }
177                 });
178             }
179         }
180 
181         public abstract Bitmap getRecycledBitmap();
182 
183         public abstract Bitmap resize(Bitmap recycled);",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\cache\PhotoDiskCache.java,86d11d698ff6aa979c6985c47370eeb6d4bfb463,47cb98175b5d600567fef273e33e534e8fda704e,"Add basic options to ImageManager

Makes it possible to specify app version, cache
sizes and use, and whether or not to allow 
recycling bitmaps","@@ -21,16 +21,14 @@ import java.security.NoSuchAlgorithmException;
  * To change this template use File | Settings | File Templates.
  */
 public class PhotoDiskCache {
-    private final static int APP_VERSION = 0;
     private final static int VALUE_COUNT = 1; //values per cache entry
     private DiskLruCache cache;
 
-
-    public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
+    public PhotoDiskCache(File directory, long maxSize, int appVersion) {
         try {
-            cache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
+            cache = DiskLruCache.open(directory, appVersion, VALUE_COUNT, maxSize);
         } catch (IOException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            e.printStackTrace();
         }
     }
 
","27     public PhotoDiskCache(File directory, long maxSize, int appVersion) {
29             cache = DiskLruCache.open(directory, appVersion, VALUE_COUNT, maxSize);
31             e.printStackTrace();
24     private final static int APP_VERSION = 0;
28 
29     public PhotoDiskCache(File directory, long maxSize, Handler mainHandler, Handler loadHandler) {
31             cache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
33             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.",No
,src\com\bumptech\photos\imagemanager\HandlerExecutor.java,86d11d698ff6aa979c6985c47370eeb6d4bfb463,47cb98175b5d600567fef273e33e534e8fda704e,"Add basic options to ImageManager

Makes it possible to specify app version, cache
sizes and use, and whether or not to allow 
recycling bitmaps","@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.imagemanager;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+
+import java.util.concurrent.Executor;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/2/13
+ * Time: 1:49 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class HandlerExecutor implements Executor {
+    private final Handler worker;
+    private final Object token;
+
+    public HandlerExecutor() {
+        HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
+        workerThread.start();
+        this.worker = new Handler(workerThread.getLooper());
+        token = hashCode();
+    }
+
+    public HandlerExecutor(Handler bgHandler) {
+        this.worker = bgHandler;
+        token = hashCode();
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+        worker.postAtTime(runnable,  token, SystemClock.uptimeMillis());
+    }
+}
","1 /*
2  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.imagemanager;
6 
7 import android.os.Handler;
8 import android.os.HandlerThread;
9 import android.os.SystemClock;
10 
11 import java.util.concurrent.Executor;
12 
13 /**
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 1/2/13
17  * Time: 1:49 PM
18  * To change this template use File | Settings | File Templates.
19  */
20 public class HandlerExecutor implements Executor {
21     private final Handler worker;
22     private final Object token;
23 
24     public HandlerExecutor() {
25         HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
26         workerThread.start();
27         this.worker = new Handler(workerThread.getLooper());
28         token = hashCode();
29     }
30 
31     public HandlerExecutor(Handler bgHandler) {
32         this.worker = bgHandler;
33         token = hashCode();
34     }
35 
36     @Override
37     public void execute(Runnable runnable) {
38         worker.postAtTime(runnable,  token, SystemClock.uptimeMillis());
39     }
40 }",No
src\com\bumptech\photos\imagemanager\ImageManager.java,src\com\bumptech\photos\imagemanager\ImageManager.java,86d11d698ff6aa979c6985c47370eeb6d4bfb463,47cb98175b5d600567fef273e33e534e8fda704e,"Add basic options to ImageManager

Makes it possible to specify app version, cache
sizes and use, and whether or not to allow 
recycling bitmaps","@@ -4,10 +4,11 @@
 
 package com.bumptech.photos.imagemanager;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
+import android.os.Environment;
 import android.os.Handler;
-import android.os.SystemClock;
 import com.bumptech.photos.cache.LruPhotoCache;
 import com.bumptech.photos.cache.PhotoDiskCache;
 import com.bumptech.photos.cache.SizedBitmapCache;
@@ -17,6 +18,7 @@ import java.io.File;
 import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.Executor;
 
 /**
  * Created by IntelliJ IDEA.
@@ -26,14 +28,30 @@ import java.util.Map;
  * To change this template use File | Settings | File Templates.
  */
 public class ImageManager {
+    private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
+
+    public static class Options {
+        public int appVersion = 0;
+
+        public boolean useMemoryCache = true;
+        public int maxMemorySize;
+
+        public boolean useDiskCache = true;
+        public int maxDiskCacheSize = 10 * 1024 * 1024;
+
+        public boolean recycleBitmaps = true;
+    }
+
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
-    private PhotoDiskCache diskCache;
-    private LruPhotoCache memoryCache;
-    private ResizeJobGenerator resizer;
-    private Handler backgroundHandler;
-    private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
-    private SizedBitmapCache bitmapCache = new SizedBitmapCache();
+    private final Handler mainHandler;
+    private final LruPhotoCache memoryCache;
+    private final ResizeJobGenerator resizer;
+    private final Executor executor;
+    private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
+    private final SizedBitmapCache bitmapCache;
+    private final PhotoDiskCache diskCache;
+    private final boolean isBitmapRecyclingEnabled;
 
     private enum ResizeType {
         CENTER_CROP,
@@ -42,17 +60,73 @@ public class ImageManager {
         AS_IS
     }
 
-    public ImageManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
-        this.backgroundHandler = backgroundHandler;
-        this.memoryCache = new LruPhotoCache(maxMemCacheSize);
+    public static File getPhotoCacheDir(Context context) {
+        final String cachePath;
+        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
+                !Environment.isExternalStorageRemovable()) {
+            cachePath = context.getExternalCacheDir().getPath();
+        } else {
+            cachePath = context.getCacheDir().getPath();
+        }
+
+        File result = new File(cachePath + File.separatorChar + DISK_CACHE_DIR);
+        if (!result.exists()) {
+            result.mkdir();
+        }
+        return result;
+    }
+
+    public ImageManager(Context context) {
+        this(context, new Options());
+    }
+
+    public ImageManager(Context context, Options options) {
+        this(context, new HandlerExecutor(), options);
+    }
+
+    public ImageManager(Context context, Executor executor, Options options) {
+        this(context, executor, new Handler(), options);
+    }
+
+    public ImageManager(Context context, Executor executor, Handler mainHandler, Options options) {
+        this(context, getPhotoCacheDir(context), executor, mainHandler, options);
+    }
+
+    public ImageManager(Context context, File diskCacheDir, Executor executor, Handler mainHandler, Options options) {
+        isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
+        if (options.useMemoryCache && options.maxMemorySize <= 0) {
+            options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
+        }
+
+        if (diskCacheDir == null || !options.useDiskCache || options.maxDiskCacheSize <= 0) {
+            diskCache = null;
+        } else {
+            diskCache = new PhotoDiskCache(diskCacheDir, options.maxDiskCacheSize, options.appVersion);
+        }
+
+        if (!options.useMemoryCache || options.maxMemorySize <= 0) {
+            memoryCache = null;
+        } else {
+            memoryCache = new LruPhotoCache(options.maxMemorySize);
+        }
+
+        if (isBitmapRecyclingEnabled) {
+            if (memoryCache != null) {
                 memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
                     @Override
                     public void onPhotoRemoved(String key, Bitmap bitmap) {
                         releaseBitmap(bitmap);
                     }
                 });
-        this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
-        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);
+            }
+            bitmapCache = new SizedBitmapCache();
+        } else {
+            bitmapCache = null;
+        }
+
+        this.resizer = new ResizeJobGenerator(bitmapCache);
+        this.mainHandler = mainHandler;
+        this.executor = executor;
     }
 
     /**
","7 import android.content.Context;
10 import android.os.Environment;
21 import java.util.concurrent.Executor;
31     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
32 
33     public static class Options {
34         public int appVersion = 0;
35 
36         public boolean useMemoryCache = true;
37         public int maxMemorySize;
38 
39         public boolean useDiskCache = true;
40         public int maxDiskCacheSize = 10 * 1024 * 1024;
41 
42         public boolean recycleBitmaps = true;
43     }
44 
47     private final Handler mainHandler;
48     private final LruPhotoCache memoryCache;
49     private final ResizeJobGenerator resizer;
50     private final Executor executor;
51     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
52     private final SizedBitmapCache bitmapCache;
53     private final PhotoDiskCache diskCache;
54     private final boolean isBitmapRecyclingEnabled;
63     public static File getPhotoCacheDir(Context context) {
64         final String cachePath;
65         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
66                 !Environment.isExternalStorageRemovable()) {
67             cachePath = context.getExternalCacheDir().getPath();
68         } else {
69             cachePath = context.getCacheDir().getPath();
70         }
71 
72         File result = new File(cachePath + File.separatorChar + DISK_CACHE_DIR);
73         if (!result.exists()) {
74             result.mkdir();
75         }
76         return result;
77     }
78 
79     public ImageManager(Context context) {
80         this(context, new Options());
81     }
82 
83     public ImageManager(Context context, Options options) {
84         this(context, new HandlerExecutor(), options);
85     }
86 
87     public ImageManager(Context context, Executor executor, Options options) {
88         this(context, executor, new Handler(), options);
89     }
90 
91     public ImageManager(Context context, Executor executor, Handler mainHandler, Options options) {
92         this(context, getPhotoCacheDir(context), executor, mainHandler, options);
93     }
94 
95     public ImageManager(Context context, File diskCacheDir, Executor executor, Handler mainHandler, Options options) {
96         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
97         if (options.useMemoryCache && options.maxMemorySize <= 0) {
98             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
99         }
100 
101         if (diskCacheDir == null || !options.useDiskCache || options.maxDiskCacheSize <= 0) {
102             diskCache = null;
103         } else {
104             diskCache = new PhotoDiskCache(diskCacheDir, options.maxDiskCacheSize, options.appVersion);
105         }
106 
107         if (!options.useMemoryCache || options.maxMemorySize <= 0) {
108             memoryCache = null;
109         } else {
110             memoryCache = new LruPhotoCache(options.maxMemorySize);
111         }
112 
113         if (isBitmapRecyclingEnabled) {
114             if (memoryCache != null) {
121             }
122             bitmapCache = new SizedBitmapCache();
123         } else {
124             bitmapCache = null;
125         }
126 
127         this.resizer = new ResizeJobGenerator(bitmapCache);
128         this.mainHandler = mainHandler;
129         this.executor = executor;
10 import android.os.SystemClock;
31     private PhotoDiskCache diskCache;
32     private LruPhotoCache memoryCache;
33     private ResizeJobGenerator resizer;
34     private Handler backgroundHandler;
35     private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
36     private SizedBitmapCache bitmapCache = new SizedBitmapCache();
45     public ImageManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {
46         this.backgroundHandler = backgroundHandler;
47         this.memoryCache = new LruPhotoCache(maxMemCacheSize);
54         this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);
55         this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,src\com\bumptech\photos\resize\ResizeJobGenerator.java,86d11d698ff6aa979c6985c47370eeb6d4bfb463,47cb98175b5d600567fef273e33e534e8fda704e,"Add basic options to ImageManager

Makes it possible to specify app version, cache
sizes and use, and whether or not to allow 
recycling bitmaps","@@ -4,7 +4,6 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import android.os.Handler;
 import com.bumptech.photos.cache.SizedBitmapCache;
 
 import java.io.IOException;
@@ -18,11 +17,11 @@ public class ResizeJobGenerator {
 
     private final SizedBitmapCache bitmapCache;
 
-    public ResizeJobGenerator(Handler mainHandler) {
-        this(mainHandler, null);
+    public ResizeJobGenerator() {
+        this(null);
     }
 
-    public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){
+    public ResizeJobGenerator(SizedBitmapCache bitmapCache){
         this.bitmapCache = bitmapCache;
     }
 
","20     public ResizeJobGenerator() {
21         this(null);
24     public ResizeJobGenerator(SizedBitmapCache bitmapCache){
7 import android.os.Handler;
21     public ResizeJobGenerator(Handler mainHandler) {
22         this(mainHandler, null);
25     public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){",No
src\com\bumptech\photos\imagemanager\loader\Approximate.java,src\com\bumptech\photos\imagemanager\loader\Approximate.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -4,6 +4,7 @@
 
 package com.bumptech.photos.imagemanager.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
 
@@ -21,7 +22,17 @@ public class Approximate<T> extends PhotoManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return imageManager.getImageApproximate(path, width, height, cb);
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onError(e);
+            }
+        });
     }
 }
","7 import android.graphics.Bitmap;
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {
27             @Override
28             public void onLoadCompleted(Bitmap loaded) {
29                 cb.onImageReady(loaded);
30             }
31 
32             @Override
33             public void onLoadFailed(Exception e) {
34                 cb.onError(e);
35             }
36         });
24     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
25         return imageManager.getImageApproximate(path, width, height, cb);",No
src\com\bumptech\photos\imagemanager\loader\AsIs.java,src\com\bumptech\photos\imagemanager\loader\AsIs.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -1,5 +1,6 @@
 package com.bumptech.photos.imagemanager.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
 
@@ -17,7 +18,17 @@ public class AsIs<T> extends PhotoManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return imageManager.getImage(path, cb);
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImage(path, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onError(e);
+            }
+        });
     }
 }
","3 import android.graphics.Bitmap;
21     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
22         return imageManager.getImage(path, new LoadedCallback() {
23             @Override
24             public void onLoadCompleted(Bitmap loaded) {
25                 cb.onImageReady(loaded);
26             }
27 
28             @Override
29             public void onLoadFailed(Exception e) {
30                 cb.onError(e);
31             }
32         });
20     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
21         return imageManager.getImage(path, cb);",No
src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -4,6 +4,7 @@
 
 package com.bumptech.photos.imagemanager.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
 
@@ -21,7 +22,17 @@ public class CenterCrop<T> extends PhotoManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return imageManager.centerCrop(path, width, height, cb);
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.centerCrop(path, width, height, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onError(e);
+            }
+        });
     }
 }
","7 import android.graphics.Bitmap;
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.centerCrop(path, width, height, new LoadedCallback() {
27             @Override
28             public void onLoadCompleted(Bitmap loaded) {
29                 cb.onImageReady(loaded);
30             }
31 
32             @Override
33             public void onLoadFailed(Exception e) {
34                 cb.onError(e);
35             }
36         });
24     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
25         return imageManager.centerCrop(path, width, height, cb);",No
src\com\bumptech\photos\imagemanager\loader\Exact.java,src\com\bumptech\photos\imagemanager\loader\Exact.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -4,6 +4,7 @@
 
 package com.bumptech.photos.imagemanager.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
 
@@ -21,7 +22,17 @@ public class Exact<T> extends PhotoManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return imageManager.getImageExact(path, width, height, cb);
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageExact(path, width, height, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onError(e);
+            }
+        });
     }
 }
","7 import android.graphics.Bitmap;
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.getImageExact(path, width, height, new LoadedCallback() {
27             @Override
28             public void onLoadCompleted(Bitmap loaded) {
29                 cb.onImageReady(loaded);
30             }
31 
32             @Override
33             public void onLoadFailed(Exception e) {
34                 cb.onError(e);
35             }
36         });
24     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
25         return imageManager.getImageExact(path, width, height, cb);",No
src\com\bumptech\photos\imagemanager\loader\FitCenter.java,src\com\bumptech\photos\imagemanager\loader\FitCenter.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -4,6 +4,7 @@
 
 package com.bumptech.photos.imagemanager.loader;
 
+import android.graphics.Bitmap;
 import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
 
@@ -21,7 +22,17 @@ public class FitCenter<T> extends PhotoManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
-        return imageManager.fitCenter(path, width, height, cb);
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.fitCenter(path, width, height, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onError(e);
+            }
+        });
     }
 }
","7 import android.graphics.Bitmap;
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.fitCenter(path, width, height, new LoadedCallback() {
27             @Override
28             public void onLoadCompleted(Bitmap loaded) {
29                 cb.onImageReady(loaded);
30             }
31 
32             @Override
33             public void onLoadFailed(Exception e) {
34                 cb.onError(e);
35             }
36         });
24     protected Object doFetchImage(String path, int width, int height, LoadedCallback cb) {
25         return imageManager.fitCenter(path, width, height, cb);",No
src\com\bumptech\photos\imagemanager\loader\PhotoManagerLoader.java,src\com\bumptech\photos\imagemanager\loader\PhotoManagerLoader.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -1,9 +1,8 @@
 package com.bumptech.photos.imagemanager.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.image.BaseImageLoader;
-import com.bumptech.photos.imagemanager.LoadedCallback;
 import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.loader.image.BaseImageLoader;
 
 /**
  * Created with IntelliJ IDEA.
@@ -24,10 +23,10 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
     @Override
     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
         releaseAcquired();
-        loadToken = doFetchImage(path, width, height, new PhotoManagerLoaderCallback(this, cb));
+        loadToken = doFetchImage(path, width, height, cb);
     }
 
-    protected abstract Object doFetchImage(String path, int width, int height, LoadedCallback cb);
+    protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
 
     @Override
     protected void onImageReady(Bitmap image, boolean isUsed) {
@@ -52,20 +51,4 @@ public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
         }
     }
 
-    protected static class PhotoManagerLoaderCallback extends InternalImageReadyCallback implements LoadedCallback {
-
-        public PhotoManagerLoaderCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
-            super(imageLoader, cb);
-        }
-
-        @Override
-        public void onLoadCompleted(Bitmap loaded) {
-            onImageReady(loaded);
-        }
-
-        @Override
-        public void onLoadFailed(Exception e) {
-            onError(e);
-        }
-    }
 }
","5 import com.bumptech.photos.loader.image.BaseImageLoader;
26         loadToken = doFetchImage(path, width, height, cb);
29     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
4 import com.bumptech.photos.loader.image.BaseImageLoader;
5 import com.bumptech.photos.imagemanager.LoadedCallback;
27         loadToken = doFetchImage(path, width, height, new PhotoManagerLoaderCallback(this, cb));
30     protected abstract Object doFetchImage(String path, int width, int height, LoadedCallback cb);
55     protected static class PhotoManagerLoaderCallback extends InternalImageReadyCallback implements LoadedCallback {
56 
57         public PhotoManagerLoaderCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
58             super(imageLoader, cb);
59         }
60 
61         @Override
62         public void onLoadCompleted(Bitmap loaded) {
63             onImageReady(loaded);
64         }
65 
66         @Override
67         public void onLoadFailed(Exception e) {
68             onError(e);
69         }
70     }",No
src\com\bumptech\photos\loader\image\BaseImageLoader.java,src\com\bumptech\photos\loader\image\BaseImageLoader.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -14,7 +14,7 @@ import java.lang.ref.WeakReference;
 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
     @Override
     public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
-        doFetchImage(path, model, width, height, cb);
+        doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb));
         return cb;
     }
 
@@ -28,29 +28,30 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
     protected void onImageLoadFailed(Exception e) { }
 
 
-    protected static class InternalImageReadyCallback {
+    protected class InternalImageReadyCallback implements ImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
-        private final WeakReference<BaseImageLoader> imageLoaderRef;
 
-        public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
-            this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);
+        public InternalImageReadyCallback(ImageReadyCallback cb) {
             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
         }
 
-        protected final void onImageReady(Bitmap image) {
-            final BaseImageLoader imageLoader = imageLoaderRef.get();
+        @Override
+        public final boolean onImageReady(Bitmap image) {
             final ImageReadyCallback cb = cbRef.get();
-            if (imageLoader != null && cb != null) {
-                imageLoader.onImageReady(image, cb.onImageReady(image));
+            boolean result = false;
+            if (cb != null) {
+                result = cb.onImageReady(image);
+                BaseImageLoader.this.onImageReady(image, result);
             }
+            return result;
         }
 
-        protected final void onError(Exception e) {
-            final BaseImageLoader imageLoader = imageLoaderRef.get();
+        @Override
+        public void onError(Exception e) {
             final ImageReadyCallback cb = cbRef.get();
-            if (imageLoader != null && cb != null) {
+            if (cb != null) {
                 cb.onError(e);
-                imageLoader.onImageLoadFailed(e);
+                BaseImageLoader.this.onImageLoadFailed(e);
             }
         }
     }
","17         doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb));
31     protected class InternalImageReadyCallback implements ImageReadyCallback {
34         public InternalImageReadyCallback(ImageReadyCallback cb) {
38         @Override
39         public final boolean onImageReady(Bitmap image) {
41             boolean result = false;
42             if (cb != null) {
43                 result = cb.onImageReady(image);
44                 BaseImageLoader.this.onImageReady(image, result);
46             return result;
49         @Override
50         public void onError(Exception e) {
52             if (cb != null) {
54                 BaseImageLoader.this.onImageLoadFailed(e);
17         doFetchImage(path, model, width, height, cb);
31     protected static class InternalImageReadyCallback {
33         private final WeakReference<BaseImageLoader> imageLoaderRef;
35         public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {
36             this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);
40         protected final void onImageReady(Bitmap image) {
41             final BaseImageLoader imageLoader = imageLoaderRef.get();
43             if (imageLoader != null && cb != null) {
44                 imageLoader.onImageReady(image, cb.onImageReady(image));
48         protected final void onError(Exception e) {
49             final BaseImageLoader imageLoader = imageLoaderRef.get();
51             if (imageLoader != null && cb != null) {
53                 imageLoader.onImageLoadFailed(e);",No
src\com\bumptech\photos\loader\path\BasePathLoader.java,src\com\bumptech\photos\loader\path\BasePathLoader.java,f3924bdddf58d6482d8100cdd75398ad0aca26d6,86d11d698ff6aa979c6985c47370eeb6d4bfb463,"Don't make subclasses of loaders use internal cb

Simplifies subclasses and makes it easier to 
make callbacks leak proof without sacrificing
safety. If the subclasses have a strong reference
only to the internal callback, they will not 
retain a strong reference to the presenter or the
image view since the internal callback only has a
weak reference to a callback generated by the 
image presenter.","@@ -11,8 +11,8 @@ import java.lang.ref.WeakReference;
  */
 public abstract class BasePathLoader<T> implements PathLoader<T> {
     @Override
-    public Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
-        doFetchPath(model, width, height, cb);
+    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
+        doFetchPath(model, width, height, new InternalPathReadyCallback(cb));
         return cb;
     }
 
@@ -26,30 +26,30 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
     protected void onPathFetchFailed(Exception e) { }
 
 
-    protected static class InternalPathReadyCallback {
+    protected class InternalPathReadyCallback implements PathReadyCallback{
         private final WeakReference<PathReadyCallback> cbRef;
-        private final WeakReference<BasePathLoader> pathLoaderRef;
 
-
-        public InternalPathReadyCallback(BasePathLoader pathLoader, PathReadyCallback cb) {
-            this.pathLoaderRef = new WeakReference<BasePathLoader>(pathLoader);
+        public InternalPathReadyCallback(PathReadyCallback cb) {
             this.cbRef = new WeakReference<PathReadyCallback>(cb);
         }
 
-        protected final void onPathReady(String path) {
-            final BasePathLoader pathLoader = pathLoaderRef.get();
+        @Override
+        public final boolean onPathReady(String path) {
             final PathReadyCallback cb = cbRef.get();
-            if (pathLoader != null && cb != null) {
-                pathLoader.onPathReady(path, cb.onPathReady(path));
+            boolean result = false;
+            if (cb != null) {
+                result = cb.onPathReady(path);
+                BasePathLoader.this.onPathReady(path, result);
             }
+            return result;
         }
 
-        protected final void onError(Exception e) {
-            final BasePathLoader pathLoader = pathLoaderRef.get();
+        @Override
+        public final void onError(Exception e) {
             final PathReadyCallback cb = cbRef.get();
-            if (pathLoader != null && cb != null) {
+            if (cb != null) {
                 cb.onError(e);
-                pathLoader.onPathFetchFailed(e);
+                BasePathLoader.this.onPathFetchFailed(e);
             }
         }
     }
","14     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
15         doFetchPath(model, width, height, new InternalPathReadyCallback(cb));
29     protected class InternalPathReadyCallback implements PathReadyCallback{
32         public InternalPathReadyCallback(PathReadyCallback cb) {
36         @Override
37         public final boolean onPathReady(String path) {
39             boolean result = false;
40             if (cb != null) {
41                 result = cb.onPathReady(path);
42                 BasePathLoader.this.onPathReady(path, result);
44             return result;
47         @Override
48         public final void onError(Exception e) {
50             if (cb != null) {
52                 BasePathLoader.this.onPathFetchFailed(e);
14     public Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
15         doFetchPath(model, width, height, cb);
29     protected static class InternalPathReadyCallback {
31         private final WeakReference<BasePathLoader> pathLoaderRef;
33 
34         public InternalPathReadyCallback(BasePathLoader pathLoader, PathReadyCallback cb) {
35             this.pathLoaderRef = new WeakReference<BasePathLoader>(pathLoader);
39         protected final void onPathReady(String path) {
40             final BasePathLoader pathLoader = pathLoaderRef.get();
42             if (pathLoader != null && cb != null) {
43                 pathLoader.onPathReady(path, cb.onPathReady(path));
47         protected final void onError(Exception e) {
48             final BasePathLoader pathLoader = pathLoaderRef.get();
50             if (pathLoader != null && cb != null) {
52                 pathLoader.onPathFetchFailed(e);",No
src\com\bumptech\photos\presenter\ImagePresenter.java,src\com\bumptech\photos\presenter\ImagePresenter.java,abd8776e1ddefb12d217415ad1487ead992169d9,f3924bdddf58d6482d8100cdd75398ad0aca26d6,Handle null images in image presenter,"@@ -103,7 +103,7 @@ public class ImagePresenter<T> {
     private T currentModel;
     private int currentCount;
 
-    private boolean isImageSet;
+    private boolean isImageSet = false;
     private boolean loadedFromCache = false;
 
     private final Runnable getDimens = new Runnable() {
@@ -227,7 +227,7 @@ public class ImagePresenter<T> {
         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
-                if (loadCount != currentCount || !canSetImage()) return false;
+                if (loadCount != currentCount || !canSetImage() || image == null) return false;
 
                 if (imageSetCallback != null)
                     imageSetCallback.onImageSet(imageView, loadedFromCache);
","106     private boolean isImageSet = false;
230                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
106     private boolean isImageSet;
230                 if (loadCount != currentCount || !canSetImage()) return false;",No
src\com\bumptech\photos\resize\Utils.java,src\com\bumptech\photos\imagemanager\ImageResizer.java,34822333800db30671f408890ea38870d8f8a127,abd8776e1ddefb12d217415ad1487ead992169d9,"reize job gen + resize utils -> ImageResizer

Also move into image manager package","@@ -1,4 +1,7 @@
-package com.bumptech.photos.resize;
+/*
+ * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
+ */
+package com.bumptech.photos.imagemanager;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -6,6 +9,7 @@ import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.os.Build;
+import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
 import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Photo;
 
@@ -16,13 +20,84 @@ import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/20/12
- * Time: 1:55 PM
- * To change this template use File | Settings | File Templates.
+ * @author sam
+ *
  */
-public class Utils {
+public class ImageResizer {
+
+    private final SizedBitmapCache bitmapCache;
+
+    public ImageResizer() {
+        this(null);
+    }
+
+    public ImageResizer(SizedBitmapCache bitmapCache){
+        this.bitmapCache = bitmapCache;
+    }
+
+    public Bitmap resizeCenterCrop(final String path, final int width, final int height){
+        final Bitmap streamed = streamIn(path, width, height);
+
+        if (streamed.getWidth() == width && streamed.getHeight() == height) {
+            return streamed;
+        }
+
+        return centerCrop(getRecycled(width, height), streamed, width, height);
+    }
+
+    public Bitmap fitInSpace(final String path, final int width, final int height){
+        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
+        return fitInSpace(streamed, width, height);
+    }
+
+    public Bitmap loadApproximate(final String path, final int width, final int height){
+        return streamIn(path, width, height);
+    }
+
+    public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
+        int[] dimens = new int[] {-1, -1};
+        try {
+            dimens = getDimension(is1);
+        } finally {
+            try {
+                is1.close();
+            } catch (IOException e) {
+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            }
+        }
+        Bitmap resized = null;
+        try {
+            resized = load(is2, getRecycled(dimens));
+        } finally {
+            try {
+                is2.close();
+            } catch (IOException e) {
+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            }
+        }
+        return resized;
+    }
+
+    public Bitmap loadAsIs(final String path, final int width, final int height) {
+        return load(path, getRecycled(width, height));
+    }
+
+    public Bitmap loadAsIs(final String path){
+        int[] dimens = getDimensions(path);
+        return load(path, getRecycled(dimens));
+    }
+
+    private Bitmap getRecycled(int[] dimens) {
+        return getRecycled(dimens[0], dimens[1]);
+    }
+
+    private Bitmap getRecycled(int width, int height) {
+        Bitmap result = null;
+        if (bitmapCache != null) {
+            result = bitmapCache.get(width, height);
+        }
+        return result;
+    }
 
       public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
         return centerCrop(null, toCrop, width, height);
","1 /*
2  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
3  */
4 package com.bumptech.photos.imagemanager;
12 import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
23  * @author sam
24  *
26 public class ImageResizer {
27 
28     private final SizedBitmapCache bitmapCache;
29 
30     public ImageResizer() {
31         this(null);
32     }
33 
34     public ImageResizer(SizedBitmapCache bitmapCache){
35         this.bitmapCache = bitmapCache;
36     }
37 
38     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
39         final Bitmap streamed = streamIn(path, width, height);
40 
41         if (streamed.getWidth() == width && streamed.getHeight() == height) {
42             return streamed;
43         }
44 
45         return centerCrop(getRecycled(width, height), streamed, width, height);
46     }
47 
48     public Bitmap fitInSpace(final String path, final int width, final int height){
49         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
50         return fitInSpace(streamed, width, height);
51     }
52 
53     public Bitmap loadApproximate(final String path, final int width, final int height){
54         return streamIn(path, width, height);
55     }
56 
57     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
58         int[] dimens = new int[] {-1, -1};
59         try {
60             dimens = getDimension(is1);
61         } finally {
62             try {
63                 is1.close();
64             } catch (IOException e) {
65                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
66             }
67         }
68         Bitmap resized = null;
69         try {
70             resized = load(is2, getRecycled(dimens));
71         } finally {
72             try {
73                 is2.close();
74             } catch (IOException e) {
75                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
76             }
77         }
78         return resized;
79     }
80 
81     public Bitmap loadAsIs(final String path, final int width, final int height) {
82         return load(path, getRecycled(width, height));
83     }
84 
85     public Bitmap loadAsIs(final String path){
86         int[] dimens = getDimensions(path);
87         return load(path, getRecycled(dimens));
88     }
89 
90     private Bitmap getRecycled(int[] dimens) {
91         return getRecycled(dimens[0], dimens[1]);
92     }
93 
94     private Bitmap getRecycled(int width, int height) {
95         Bitmap result = null;
96         if (bitmapCache != null) {
97             result = bitmapCache.get(width, height);
98         }
99         return result;
100     }
1 package com.bumptech.photos.resize;
19  * Created with IntelliJ IDEA.
20  * User: sam
21  * Date: 12/20/12
22  * Time: 1:55 PM
23  * To change this template use File | Settings | File Templates.
25 public class Utils {",No
src\com\bumptech\photos\resize\ResizeJobGenerator.java,,34822333800db30671f408890ea38870d8f8a127,abd8776e1ddefb12d217415ad1487ead992169d9,"reize job gen + resize utils -> ImageResizer

Also move into image manager package","@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
- */
-package com.bumptech.photos.resize;
-
-import android.graphics.Bitmap;
-import com.bumptech.photos.cache.SizedBitmapCache;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * @author sam
- *
- */
-public class ResizeJobGenerator {
-
-    private final SizedBitmapCache bitmapCache;
-
-    public ResizeJobGenerator() {
-        this(null);
-    }
-
-    public ResizeJobGenerator(SizedBitmapCache bitmapCache){
-        this.bitmapCache = bitmapCache;
-    }
-
-    public Bitmap resizeCenterCrop(final String path, final int width, final int height){
-        final Bitmap streamed = Utils.streamIn(path, width, height);
-
-        if (streamed.getWidth() == width && streamed.getHeight() == height) {
-            return streamed;
-        }
-
-        return Utils.centerCrop(getRecycled(width, height), streamed, width, height);
-    }
-
-    public Bitmap fitInSpace(final String path, final int width, final int height){
-        final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
-        return Utils.fitInSpace(streamed, width, height);
-    }
-
-    public Bitmap loadApproximate(final String path, final int width, final int height){
-        return Utils.streamIn(path, width, height);
-    }
-
-    public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
-        int[] dimens = new int[] {-1, -1};
-        try {
-            dimens = Utils.getDimension(is1);
-        } finally {
-            try {
-                is1.close();
-            } catch (IOException e) {
-                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
-            }
-        }
-        Bitmap resized = null;
-        try {
-            resized = Utils.load(is2, getRecycled(dimens));
-        } finally {
-            try {
-                is2.close();
-            } catch (IOException e) {
-                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
-            }
-        }
-        return resized;
-    }
-
-    public Bitmap loadAsIs(final String path, final int width, final int height) {
-        return Utils.load(path, getRecycled(width, height));
-    }
-
-    public Bitmap loadAsIs(final String path){
-        int[] dimens = Utils.getDimensions(path);
-        return Utils.load(path, getRecycled(dimens));
-    }
-
-    private Bitmap getRecycled(int[] dimens) {
-        return getRecycled(dimens[0], dimens[1]);
-    }
-
-    private Bitmap getRecycled(int width, int height) {
-        Bitmap result = null;
-        if (bitmapCache != null) {
-            result = bitmapCache.get(width, height);
-        }
-        return result;
-    }
-}
","1 /*
2  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
3  */
4 package com.bumptech.photos.resize;
5 
6 import android.graphics.Bitmap;
7 import com.bumptech.photos.cache.SizedBitmapCache;
8 
9 import java.io.IOException;
10 import java.io.InputStream;
11 
12 /**
13  * @author sam
14  *
15  */
16 public class ResizeJobGenerator {
17 
18     private final SizedBitmapCache bitmapCache;
19 
20     public ResizeJobGenerator() {
21         this(null);
22     }
23 
24     public ResizeJobGenerator(SizedBitmapCache bitmapCache){
25         this.bitmapCache = bitmapCache;
26     }
27 
28     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
29         final Bitmap streamed = Utils.streamIn(path, width, height);
30 
31         if (streamed.getWidth() == width && streamed.getHeight() == height) {
32             return streamed;
33         }
34 
35         return Utils.centerCrop(getRecycled(width, height), streamed, width, height);
36     }
37 
38     public Bitmap fitInSpace(final String path, final int width, final int height){
39         final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
40         return Utils.fitInSpace(streamed, width, height);
41     }
42 
43     public Bitmap loadApproximate(final String path, final int width, final int height){
44         return Utils.streamIn(path, width, height);
45     }
46 
47     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
48         int[] dimens = new int[] {-1, -1};
49         try {
50             dimens = Utils.getDimension(is1);
51         } finally {
52             try {
53                 is1.close();
54             } catch (IOException e) {
55                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
56             }
57         }
58         Bitmap resized = null;
59         try {
60             resized = Utils.load(is2, getRecycled(dimens));
61         } finally {
62             try {
63                 is2.close();
64             } catch (IOException e) {
65                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
66             }
67         }
68         return resized;
69     }
70 
71     public Bitmap loadAsIs(final String path, final int width, final int height) {
72         return Utils.load(path, getRecycled(width, height));
73     }
74 
75     public Bitmap loadAsIs(final String path){
76         int[] dimens = Utils.getDimensions(path);
77         return Utils.load(path, getRecycled(dimens));
78     }
79 
80     private Bitmap getRecycled(int[] dimens) {
81         return getRecycled(dimens[0], dimens[1]);
82     }
83 
84     private Bitmap getRecycled(int width, int height) {
85         Bitmap result = null;
86         if (bitmapCache != null) {
87             result = bitmapCache.get(width, height);
88         }
89         return result;
90     }
91 }",No
src\com\bumptech\photos\imagemanager\ImageManager.java,src\com\bumptech\photos\imagemanager\ImageManager.java,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,34822333800db30671f408890ea38870d8f8a127,Move cache into imagemanager,"@@ -9,10 +9,9 @@ import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
-import com.bumptech.photos.cache.LruPhotoCache;
-import com.bumptech.photos.cache.PhotoDiskCache;
-import com.bumptech.photos.cache.SizedBitmapCache;
-import com.bumptech.photos.resize.ResizeJobGenerator;
+import com.bumptech.photos.imagemanager.cache.LruPhotoCache;
+import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;
+import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
 
 import java.io.File;
 import java.io.InputStream;
@@ -46,7 +45,7 @@ public class ImageManager {
 
     private final Handler mainHandler;
     private final LruPhotoCache memoryCache;
-    private final ResizeJobGenerator resizer;
+    private final ImageResizer resizer;
     private final Executor executor;
     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private final SizedBitmapCache bitmapCache;
@@ -124,7 +123,7 @@ public class ImageManager {
             bitmapCache = null;
         }
 
-        this.resizer = new ResizeJobGenerator(bitmapCache);
+        this.resizer = new ImageResizer(bitmapCache);
         this.mainHandler = mainHandler;
         this.executor = executor;
     }
","12 import com.bumptech.photos.imagemanager.cache.LruPhotoCache;
13 import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;
14 import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
48     private final ImageResizer resizer;
126         this.resizer = new ImageResizer(bitmapCache);
12 import com.bumptech.photos.cache.LruPhotoCache;
13 import com.bumptech.photos.cache.PhotoDiskCache;
14 import com.bumptech.photos.cache.SizedBitmapCache;
15 import com.bumptech.photos.resize.ResizeJobGenerator;
49     private final ResizeJobGenerator resizer;
127         this.resizer = new ResizeJobGenerator(bitmapCache);",No
src\com\bumptech\photos\cache\LruPhotoCache.java,src\com\bumptech\photos\imagemanager\cache\LruPhotoCache.java,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,34822333800db30671f408890ea38870d8f8a127,Move cache into imagemanager,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.cache;
+package com.bumptech.photos.imagemanager.cache;
 
 import android.app.ActivityManager;
 import android.content.Context;
","5 package com.bumptech.photos.imagemanager.cache;
5 package com.bumptech.photos.cache;",No
src\com\bumptech\photos\cache\PhotoDiskCache.java,src\com\bumptech\photos\imagemanager\cache\PhotoDiskCache.java,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,34822333800db30671f408890ea38870d8f8a127,Move cache into imagemanager,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.cache;
+package com.bumptech.photos.imagemanager.cache;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
","1 package com.bumptech.photos.imagemanager.cache;
1 package com.bumptech.photos.cache;",No
src\com\bumptech\photos\cache\SizedBitmapCache.java,src\com\bumptech\photos\imagemanager\cache\SizedBitmapCache.java,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,34822333800db30671f408890ea38870d8f8a127,Move cache into imagemanager,"@@ -2,9 +2,10 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.cache;
+package com.bumptech.photos.imagemanager.cache;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.util.Log;
 
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -19,7 +20,7 @@ import java.util.Queue;
  * To change this template use File | Settings | File Templates.
  */
 public class SizedBitmapCache {
-    private static final int MAX_PER_SIZE = 10;
+    private static final int MAX_PER_SIZE = 20;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
 
     public void put(Bitmap bitmap) {
@@ -33,14 +34,17 @@ public class SizedBitmapCache {
         if (available.size() < MAX_PER_SIZE) {
             available.add(bitmap);
         }
+        //Log.d(""SBC: put key="" + sizeKey + "" available="" + available.size());
     }
 
     public Bitmap get(int width, int height) {
         final String sizeKey = getSizeKey(width, height);
         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
         if (available == null || available.size() == 0) {
+            Log.d(""SBC: missing bitmap for key= "" + sizeKey);
             return null;
         } else {
+            //Log.d(""SBC:  get key="" + sizeKey + "" available="" + (available.size() - 1));
             return available.remove();
         }
     }
","5 package com.bumptech.photos.imagemanager.cache;
8 import com.bumptech.photos.util.Log;
23     private static final int MAX_PER_SIZE = 20;
37         //Log.d(""SBC: put key="" + sizeKey + "" available="" + available.size());
44             Log.d(""SBC: missing bitmap for key= "" + sizeKey);
47             //Log.d(""SBC:  get key="" + sizeKey + "" available="" + (available.size() - 1));
5 package com.bumptech.photos.cache;
22     private static final int MAX_PER_SIZE = 10;",No
src\com\bumptech\photos\imagemanager\ImageResizer.java,src\com\bumptech\photos\imagemanager\ImageResizer.java,defb867d7525e08463f6a2783c5edb34439282cd,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,Combine Photo and ImageResizer,"@@ -8,10 +8,10 @@ import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import android.media.ExifInterface;
 import android.os.Build;
 import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
 import com.bumptech.photos.util.Log;
-import com.bumptech.photos.util.Photo;
 
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
@@ -193,7 +193,7 @@ public class ImageResizer {
             Log.d(""PSR: file not found loading bitmap at: "" + path);
             e.printStackTrace();
         }
-        return result == null ? null : Photo.orientImage(path, result);
+        return result == null ? null : orientImage(path, result);
     }
 
     public static Bitmap load(InputStream is) {
@@ -247,7 +247,7 @@ public class ImageResizer {
     //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
     //streams in to near, but not exactly at the desired width and height.
     public static Bitmap streamIn(String path, int width, int height) {
-        int orientation = Photo.getOrientation(path);
+        int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
             //Swap width and height for initial downsample calculation if its oriented so.
             //The image will then be rotated back to normal.
@@ -278,7 +278,7 @@ public class ImageResizer {
             }
             result = BitmapFactory.decodeStream(is, null, decodeBitmapOptions);
             if (orientation != 0) {
-                result = Photo.rotateImage(result, orientation);
+                result = rotateImage(result, orientation);
             }
             is.close();
         } catch (Exception e){
@@ -289,4 +289,74 @@ public class ImageResizer {
         }
         return result;
     }
+        /**
+     * Returns a matrix with rotation set based on Exif orientation tag.
+     * If the orientation is undefined or 0 null is returned.
+     *
+     * @param pathToOriginal Path to original image file that may have exif data.
+     * @return  A rotation in degrees based on exif orientation
+     */
+    public static int getOrientation(String pathToOriginal) {
+        int degreesToRotate = 0;
+        try{
+            ExifInterface exif = new ExifInterface(pathToOriginal);
+            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
+            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
+                degreesToRotate = 90;
+            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
+                degreesToRotate = 180;
+            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
+                degreesToRotate = 270;
+            }
+        } catch (IOException e){
+            Log.w(""IOException for image with filePath="" + pathToOriginal);
+        } catch (Exception e) {
+            Log.w(""Exception when trying to get image orientation matrix"");
+            e.printStackTrace();
+        }
+        return degreesToRotate;
+    }
+
+    /**
+     * This is an expensive operation that copies the image in place with the pixels rotated.
+     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
+     *
+     * @param pathToOriginal Path to original image file that may have exif data.
+     * @param imageToOrient Image Bitmap to orient.
+     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
+     */
+    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
+        int degreesToRotate = getOrientation(pathToOriginal);
+        return rotateImage(imageToOrient, degreesToRotate);
+    }
+
+    /**
+     * This is an expensive operation that copies the image in place with the pixels rotated.
+     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
+     *
+     * @param imageToOrient Image Bitmap to orient.
+     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
+     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
+     */
+    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
+        try{
+            if(degreesToRotate != 0) {
+                Matrix matrix = new Matrix();
+                matrix.setRotate(degreesToRotate);
+                imageToOrient = Bitmap.createBitmap(
+                        imageToOrient,
+                        0,
+                        0,
+                        imageToOrient.getWidth(),
+                        imageToOrient.getHeight(),
+                        matrix,
+                        true);
+            }
+        } catch (Exception e) {
+            Log.w(""Exception when trying to orient image"");
+            e.printStackTrace();
+        }
+        return imageToOrient;
+    }
+
 }
","11 import android.media.ExifInterface;
196         return result == null ? null : orientImage(path, result);
250         int orientation = getOrientation(path);
281                 result = rotateImage(result, orientation);
292         /**
293      * Returns a matrix with rotation set based on Exif orientation tag.
294      * If the orientation is undefined or 0 null is returned.
295      *
296      * @param pathToOriginal Path to original image file that may have exif data.
297      * @return  A rotation in degrees based on exif orientation
298      */
299     public static int getOrientation(String pathToOriginal) {
300         int degreesToRotate = 0;
301         try{
302             ExifInterface exif = new ExifInterface(pathToOriginal);
303             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
304             if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
305                 degreesToRotate = 90;
306             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
307                 degreesToRotate = 180;
308             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
309                 degreesToRotate = 270;
310             }
311         } catch (IOException e){
312             Log.w(""IOException for image with filePath="" + pathToOriginal);
313         } catch (Exception e) {
314             Log.w(""Exception when trying to get image orientation matrix"");
315             e.printStackTrace();
316         }
317         return degreesToRotate;
318     }
319 
320     /**
321      * This is an expensive operation that copies the image in place with the pixels rotated.
322      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
323      *
324      * @param pathToOriginal Path to original image file that may have exif data.
325      * @param imageToOrient Image Bitmap to orient.
326      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
327      */
328     public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
329         int degreesToRotate = getOrientation(pathToOriginal);
330         return rotateImage(imageToOrient, degreesToRotate);
331     }
332 
333     /**
334      * This is an expensive operation that copies the image in place with the pixels rotated.
335      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
336      *
337      * @param imageToOrient Image Bitmap to orient.
338      * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
339      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
340      */
341     public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
342         try{
343             if(degreesToRotate != 0) {
344                 Matrix matrix = new Matrix();
345                 matrix.setRotate(degreesToRotate);
346                 imageToOrient = Bitmap.createBitmap(
347                         imageToOrient,
348                         0,
349                         0,
350                         imageToOrient.getWidth(),
351                         imageToOrient.getHeight(),
352                         matrix,
353                         true);
354             }
355         } catch (Exception e) {
356             Log.w(""Exception when trying to orient image"");
357             e.printStackTrace();
358         }
359         return imageToOrient;
360     }
361 
14 import com.bumptech.photos.util.Photo;
196         return result == null ? null : Photo.orientImage(path, result);
250         int orientation = Photo.getOrientation(path);
281                 result = Photo.rotateImage(result, orientation);",No
src\com\bumptech\photos\util\Photo.java,,defb867d7525e08463f6a2783c5edb34439282cd,2dbc7d62bd55ba0932cc45d4f97f2a945ee76c44,Combine Photo and ImageResizer,"@@ -1,83 +0,0 @@
-/* * Copyright (c) 2011. Bump Technologies Inc.
-*/
-
-package com.bumptech.photos.util;
-
-import android.graphics.Bitmap;
-import android.graphics.Matrix;
-import android.media.ExifInterface;
-
-import java.io.IOException;
-
-public class Photo {
-
-    /**
-     * Returns a matrix with rotation set based on Exif orientation tag.
-     * If the orientation is undefined or 0 null is returned.
-     *
-     * @param pathToOriginal Path to original image file that may have exif data.
-     * @return  A rotation in degrees based on exif orientation
-     */
-    public static int getOrientation(String pathToOriginal) {
-        int degreesToRotate = 0;
-        try{
-            ExifInterface exif = new ExifInterface(pathToOriginal);
-            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
-            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
-                degreesToRotate = 90;
-            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
-                degreesToRotate = 180;
-            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
-                degreesToRotate = 270;
-            }
-        } catch (IOException e){
-            Log.w(""IOException for image with filePath="" + pathToOriginal);
-        } catch (Exception e) {
-            Log.w(""Exception when trying to get image orientation matrix"");
-            e.printStackTrace();
-        }
-        return degreesToRotate;
-    }
-
-    /**
-     * This is an expensive operation that copies the image in place with the pixels rotated.
-     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
-     *
-     * @param pathToOriginal Path to original image file that may have exif data.
-     * @param imageToOrient Image Bitmap to orient.
-     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
-     */
-    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
-        int degreesToRotate = Photo.getOrientation(pathToOriginal);
-        return rotateImage(imageToOrient, degreesToRotate);
-    }
-
-    /**
-     * This is an expensive operation that copies the image in place with the pixels rotated.
-     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
-     *
-     * @param imageToOrient Image Bitmap to orient.
-     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
-     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
-     */
-    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
-        try{
-            if(degreesToRotate != 0) {
-                Matrix matrix = new Matrix();
-                matrix.setRotate(degreesToRotate);
-                imageToOrient = Bitmap.createBitmap(
-                        imageToOrient,
-                        0,
-                        0,
-                        imageToOrient.getWidth(),
-                        imageToOrient.getHeight(),
-                        matrix,
-                        true);
-            }
-        } catch (Exception e) {
-            Log.w(""Exception when trying to orient image"");
-            e.printStackTrace();
-        }
-        return imageToOrient;
-    }
-}
","1 /* * Copyright (c) 2011. Bump Technologies Inc.
2 */
3 
4 package com.bumptech.photos.util;
5 
6 import android.graphics.Bitmap;
7 import android.graphics.Matrix;
8 import android.media.ExifInterface;
9 
10 import java.io.IOException;
11 
12 public class Photo {
13 
14     /**
15      * Returns a matrix with rotation set based on Exif orientation tag.
16      * If the orientation is undefined or 0 null is returned.
17      *
18      * @param pathToOriginal Path to original image file that may have exif data.
19      * @return  A rotation in degrees based on exif orientation
20      */
21     public static int getOrientation(String pathToOriginal) {
22         int degreesToRotate = 0;
23         try{
24             ExifInterface exif = new ExifInterface(pathToOriginal);
25             int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
26             if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
27                 degreesToRotate = 90;
28             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
29                 degreesToRotate = 180;
30             } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
31                 degreesToRotate = 270;
32             }
33         } catch (IOException e){
34             Log.w(""IOException for image with filePath="" + pathToOriginal);
35         } catch (Exception e) {
36             Log.w(""Exception when trying to get image orientation matrix"");
37             e.printStackTrace();
38         }
39         return degreesToRotate;
40     }
41 
42     /**
43      * This is an expensive operation that copies the image in place with the pixels rotated.
44      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
45      *
46      * @param pathToOriginal Path to original image file that may have exif data.
47      * @param imageToOrient Image Bitmap to orient.
48      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
49      */
50     public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
51         int degreesToRotate = Photo.getOrientation(pathToOriginal);
52         return rotateImage(imageToOrient, degreesToRotate);
53     }
54 
55     /**
56      * This is an expensive operation that copies the image in place with the pixels rotated.
57      * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
58      *
59      * @param imageToOrient Image Bitmap to orient.
60      * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
61      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
62      */
63     public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
64         try{
65             if(degreesToRotate != 0) {
66                 Matrix matrix = new Matrix();
67                 matrix.setRotate(degreesToRotate);
68                 imageToOrient = Bitmap.createBitmap(
69                         imageToOrient,
70                         0,
71                         0,
72                         imageToOrient.getWidth(),
73                         imageToOrient.getHeight(),
74                         matrix,
75                         true);
76             }
77         } catch (Exception e) {
78             Log.w(""Exception when trying to orient image"");
79             e.printStackTrace();
80         }
81         return imageToOrient;
82     }
83 }",No
src\com\bumptech\photos\imagemanager\loader\Approximate.java,src\com\bumptech\photos\imagemanager\loader\Approximate.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -15,7 +15,7 @@ import com.bumptech.photos.imagemanager.ImageManager;
  * Time: 10:58 PM
  * To change this template use File | Settings | File Templates.
  */
-public class Approximate<T> extends PhotoManagerLoader<T> {
+public class Approximate<T> extends ImageManagerLoader<T> {
 
     public Approximate(ImageManager imageManager) {
         super(imageManager);
","18 public class Approximate<T> extends ImageManagerLoader<T> {
18 public class Approximate<T> extends PhotoManagerLoader<T> {",No
src\com\bumptech\photos\imagemanager\loader\AsIs.java,src\com\bumptech\photos\imagemanager\loader\AsIs.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -11,7 +11,7 @@ import com.bumptech.photos.imagemanager.ImageManager;
  * Time: 4:56 PM
  * To change this template use File | Settings | File Templates.
  */
-public class AsIs<T> extends PhotoManagerLoader<T> {
+public class AsIs<T> extends ImageManagerLoader<T> {
 
     public AsIs(ImageManager imageManager) {
         super(imageManager);
","14 public class AsIs<T> extends ImageManagerLoader<T> {
14 public class AsIs<T> extends PhotoManagerLoader<T> {",No
src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -15,7 +15,7 @@ import com.bumptech.photos.imagemanager.ImageManager;
  * Time: 10:54 PM
  * To change this template use File | Settings | File Templates.
  */
-public class CenterCrop<T> extends PhotoManagerLoader<T> {
+public class CenterCrop<T> extends ImageManagerLoader<T> {
 
     public CenterCrop(ImageManager imageManager) {
         super(imageManager);
","18 public class CenterCrop<T> extends ImageManagerLoader<T> {
18 public class CenterCrop<T> extends PhotoManagerLoader<T> {",No
src\com\bumptech\photos\imagemanager\loader\Exact.java,src\com\bumptech\photos\imagemanager\loader\Exact.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -15,7 +15,7 @@ import com.bumptech.photos.imagemanager.ImageManager;
  * Time: 10:57 PM
  * To change this template use File | Settings | File Templates.
  */
-public class Exact<T> extends PhotoManagerLoader<T> {
+public class Exact<T> extends ImageManagerLoader<T> {
 
     public Exact(ImageManager imageManager) {
         super(imageManager);
","18 public class Exact<T> extends ImageManagerLoader<T> {
18 public class Exact<T> extends PhotoManagerLoader<T> {",No
src\com\bumptech\photos\imagemanager\loader\FitCenter.java,src\com\bumptech\photos\imagemanager\loader\FitCenter.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -15,7 +15,7 @@ import com.bumptech.photos.imagemanager.ImageManager;
  * Time: 10:56 PM
  * To change this template use File | Settings | File Templates.
  */
-public class FitCenter<T> extends PhotoManagerLoader<T> {
+public class FitCenter<T> extends ImageManagerLoader<T> {
 
     public FitCenter(ImageManager imageManager) {
         super(imageManager);
","18 public class FitCenter<T> extends ImageManagerLoader<T> {
18 public class FitCenter<T> extends PhotoManagerLoader<T> {",No
src\com\bumptech\photos\imagemanager\loader\PhotoManagerLoader.java,src\com\bumptech\photos\imagemanager\loader\ImageManagerLoader.java,04361f593621bb747f9f6e7e74228c9d8890c99b,defb867d7525e08463f6a2783c5edb34439282cd,PhotoManagerLoader->ImageManagerLoader,"@@ -11,13 +11,13 @@ import com.bumptech.photos.loader.image.BaseImageLoader;
  * Time: 2:51 PM
  * To change this template use File | Settings | File Templates.
  */
-public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
+public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
 
     protected final ImageManager imageManager;
     private Bitmap acquired;
     private Object loadToken;
 
-    public PhotoManagerLoader(ImageManager imageManager) {
+    public ImageManagerLoader(ImageManager imageManager) {
         this.imageManager = imageManager;
     }
     @Override
","14 public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
20     public ImageManagerLoader(ImageManager imageManager) {
14 public abstract class PhotoManagerLoader<T> extends BaseImageLoader<T> {
20     public PhotoManagerLoader(ImageManager imageManager) {",No
src\com\bumptech\photos\loader\path\SimplePathLoader.java,src\com\bumptech\photos\loader\path\DirectPathLoader.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -11,7 +11,7 @@ package com.bumptech.photos.loader.path;
  * Time: 8:52 PM
  * To change this template use File | Settings | File Templates.
  */
-public class SimplePathLoader extends BasePathLoader<String> {
+public class DirectPathLoader extends BasePathLoader<String> {
     @Override
     protected void doFetchPath(String model, int width, int height, PathReadyCallback cb) {
         cb.onPathReady(model);
","14 public class DirectPathLoader extends BasePathLoader<String> {
14 public class SimplePathLoader extends BasePathLoader<String> {",No
src\com\bumptech\photos\imagemanager\HandlerExecutor.java,src\com\bumptech\photos\resize\HandlerExecutor.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,7 +2,7 @@
  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager;
+package com.bumptech.photos.resize;
 
 import android.os.Handler;
 import android.os.HandlerThread;
","5 package com.bumptech.photos.resize;
5 package com.bumptech.photos.imagemanager;",No
src\com\bumptech\photos\imagemanager\ImageManager.java,src\com\bumptech\photos\resize\ImageManager.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,16 +2,16 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager;
+package com.bumptech.photos.resize;
 
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
-import com.bumptech.photos.imagemanager.cache.LruPhotoCache;
-import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;
-import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
+import com.bumptech.photos.resize.cache.LruPhotoCache;
+import com.bumptech.photos.resize.cache.PhotoDiskCache;
+import com.bumptech.photos.resize.cache.SizedBitmapCache;
 
 import java.io.File;
 import java.io.InputStream;
","5 package com.bumptech.photos.resize;
12 import com.bumptech.photos.resize.cache.LruPhotoCache;
13 import com.bumptech.photos.resize.cache.PhotoDiskCache;
14 import com.bumptech.photos.resize.cache.SizedBitmapCache;
5 package com.bumptech.photos.imagemanager;
12 import com.bumptech.photos.imagemanager.cache.LruPhotoCache;
13 import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;
14 import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;",No
src\com\bumptech\photos\imagemanager\ImageResizer.java,src\com\bumptech\photos\resize\ImageResizer.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
  */
-package com.bumptech.photos.imagemanager;
+package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -10,7 +10,7 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
-import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;
+import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.util.Log;
 
 import java.io.BufferedInputStream;
","4 package com.bumptech.photos.resize;
13 import com.bumptech.photos.resize.cache.SizedBitmapCache;
4 package com.bumptech.photos.imagemanager;
13 import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;",No
src\com\bumptech\photos\imagemanager\LoadedCallback.java,src\com\bumptech\photos\resize\LoadedCallback.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager;
+package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
 
","5 package com.bumptech.photos.resize;
5 package com.bumptech.photos.imagemanager;",No
src\com\bumptech\photos\imagemanager\cache\LruPhotoCache.java,src\com\bumptech\photos\resize\cache\LruPhotoCache.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.cache;
+package com.bumptech.photos.resize.cache;
 
 import android.app.ActivityManager;
 import android.content.Context;
","5 package com.bumptech.photos.resize.cache;
5 package com.bumptech.photos.imagemanager.cache;",No
src\com\bumptech\photos\imagemanager\cache\PhotoDiskCache.java,src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.imagemanager.cache;
+package com.bumptech.photos.resize.cache;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
","1 package com.bumptech.photos.resize.cache;
1 package com.bumptech.photos.imagemanager.cache;",No
src\com\bumptech\photos\imagemanager\cache\SizedBitmapCache.java,src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.cache;
+package com.bumptech.photos.resize.cache;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
","5 package com.bumptech.photos.resize.cache;
5 package com.bumptech.photos.imagemanager.cache;",No
src\com\bumptech\photos\imagemanager\loader\Approximate.java,src\com\bumptech\photos\resize\loader\Approximate.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,11 +2,11 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.LoadedCallback;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.photos.resize.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.resize.LoadedCallback;
9 import com.bumptech.photos.resize.ImageManager;
5 package com.bumptech.photos.imagemanager.loader;
8 import com.bumptech.photos.imagemanager.LoadedCallback;
9 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\imagemanager\loader\AsIs.java,src\com\bumptech\photos\resize\loader\AsIs.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -1,8 +1,8 @@
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.LoadedCallback;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.photos.resize.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
","1 package com.bumptech.photos.resize.loader;
4 import com.bumptech.photos.resize.LoadedCallback;
5 import com.bumptech.photos.resize.ImageManager;
1 package com.bumptech.photos.imagemanager.loader;
4 import com.bumptech.photos.imagemanager.LoadedCallback;
5 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\imagemanager\loader\CenterCrop.java,src\com\bumptech\photos\resize\loader\CenterCrop.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,11 +2,11 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.LoadedCallback;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.photos.resize.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.resize.LoadedCallback;
9 import com.bumptech.photos.resize.ImageManager;
5 package com.bumptech.photos.imagemanager.loader;
8 import com.bumptech.photos.imagemanager.LoadedCallback;
9 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\imagemanager\loader\Exact.java,src\com\bumptech\photos\resize\loader\Exact.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,11 +2,11 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.LoadedCallback;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.photos.resize.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.resize.LoadedCallback;
9 import com.bumptech.photos.resize.ImageManager;
5 package com.bumptech.photos.imagemanager.loader;
8 import com.bumptech.photos.imagemanager.LoadedCallback;
9 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\imagemanager\loader\FitCenter.java,src\com\bumptech\photos\resize\loader\FitCenter.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -2,11 +2,11 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.LoadedCallback;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.photos.resize.ImageManager;
 
 /**
  * Created with IntelliJ IDEA.
","5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.resize.LoadedCallback;
9 import com.bumptech.photos.resize.ImageManager;
5 package com.bumptech.photos.imagemanager.loader;
8 import com.bumptech.photos.imagemanager.LoadedCallback;
9 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\imagemanager\loader\ImageManagerLoader.java,src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,f17bc80dbaba84a68879230e3fbc2ddbc707814c,04361f593621bb747f9f6e7e74228c9d8890c99b,imagemanager package->resize package,"@@ -1,7 +1,7 @@
-package com.bumptech.photos.imagemanager.loader;
+package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.imagemanager.ImageManager;
+import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.loader.image.BaseImageLoader;
 
 /**
","1 package com.bumptech.photos.resize.loader;
4 import com.bumptech.photos.resize.ImageManager;
1 package com.bumptech.photos.imagemanager.loader;
4 import com.bumptech.photos.imagemanager.ImageManager;",No
src\com\bumptech\photos\loader\path\DirectPathLoader.java,src\com\bumptech\photos\loader\path\DirectPathLoader.java,720184018b3784a07b8af2c1fb136bf18a200256,f17bc80dbaba84a68879230e3fbc2ddbc707814c,Update direct path loader to be simpler,"@@ -11,9 +11,16 @@ package com.bumptech.photos.loader.path;
  * Time: 8:52 PM
  * To change this template use File | Settings | File Templates.
  */
-public class DirectPathLoader extends BasePathLoader<String> {
+public abstract class DirectPathLoader<T> implements PathLoader<T> {
+
     @Override
-    protected void doFetchPath(String model, int width, int height, PathReadyCallback cb) {
-        cb.onPathReady(model);
+    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
+        cb.onPathReady(getPath(model, width, height));
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
     }
+
+    protected abstract String getPath(T model, int width, int height);
+
+    @Override
+    public final void clear() { }
 }
","14 public abstract class DirectPathLoader<T> implements PathLoader<T> {
15 
17     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
18         cb.onPathReady(getPath(model, width, height));
19         return null;  //To change body of implemented methods use File | Settings | File Templates.
21 
22     protected abstract String getPath(T model, int width, int height);
23 
24     @Override
25     public final void clear() { }
14 public class DirectPathLoader extends BasePathLoader<String> {
16     protected void doFetchPath(String model, int width, int height, PathReadyCallback cb) {
17         cb.onPathReady(model);",No
src\com\bumptech\photos\loader\image\BaseImageLoader.java,src\com\bumptech\photos\loader\image\BaseImageLoader.java,7af125c04ac080c1c1609e5d96aef54062998c09,720184018b3784a07b8af2c1fb136bf18a200256,"Pass path and model in to loader lifcycle methods

Makes it possible to do more intelligent things
specific to underlying data after a load succeeds
or fails","@@ -14,7 +14,7 @@ import java.lang.ref.WeakReference;
 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
     @Override
     public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
-        doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb));
+        doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb, path, model));
         return cb;
     }
 
@@ -23,25 +23,30 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
 
     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
 
-    protected void onImageReady(Bitmap image, boolean isUsed) { }
+    protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) { }
 
-    protected void onImageLoadFailed(Exception e) { }
+    protected void onImageLoadFailed(String path, T model, Exception e) { }
 
 
     protected class InternalImageReadyCallback implements ImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
+        private final String path;
+        private final WeakReference<T> modelRef;
 
-        public InternalImageReadyCallback(ImageReadyCallback cb) {
+        public InternalImageReadyCallback(ImageReadyCallback cb, String path, T model) {
             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
+            this.modelRef = new WeakReference<T>(model);
+            this.path = path;
         }
 
         @Override
         public final boolean onImageReady(Bitmap image) {
             final ImageReadyCallback cb = cbRef.get();
+            final T model = modelRef.get();
             boolean result = false;
-            if (cb != null) {
+            if (cb != null && modelRef != null) {
                 result = cb.onImageReady(image);
-                BaseImageLoader.this.onImageReady(image, result);
+                BaseImageLoader.this.onImageReady(path, model, image, result);
             }
             return result;
         }
@@ -49,9 +54,10 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
         @Override
         public void onError(Exception e) {
             final ImageReadyCallback cb = cbRef.get();
-            if (cb != null) {
+            final T model = modelRef.get();
+            if (cb != null && model != null) {
                 cb.onError(e);
-                BaseImageLoader.this.onImageLoadFailed(e);
+                BaseImageLoader.this.onImageLoadFailed(path, model, e);
             }
         }
     }
","17         doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb, path, model));
26     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) { }
28     protected void onImageLoadFailed(String path, T model, Exception e) { }
33         private final String path;
34         private final WeakReference<T> modelRef;
36         public InternalImageReadyCallback(ImageReadyCallback cb, String path, T model) {
38             this.modelRef = new WeakReference<T>(model);
39             this.path = path;
45             final T model = modelRef.get();
47             if (cb != null && modelRef != null) {
49                 BaseImageLoader.this.onImageReady(path, model, image, result);
57             final T model = modelRef.get();
58             if (cb != null && model != null) {
60                 BaseImageLoader.this.onImageLoadFailed(path, model, e);
17         doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb));
26     protected void onImageReady(Bitmap image, boolean isUsed) { }
28     protected void onImageLoadFailed(Exception e) { }
34         public InternalImageReadyCallback(ImageReadyCallback cb) {
42             if (cb != null) {
44                 BaseImageLoader.this.onImageReady(image, result);
52             if (cb != null) {
54                 BaseImageLoader.this.onImageLoadFailed(e);",No
src\com\bumptech\photos\loader\path\BasePathLoader.java,src\com\bumptech\photos\loader\path\BasePathLoader.java,7af125c04ac080c1c1609e5d96aef54062998c09,720184018b3784a07b8af2c1fb136bf18a200256,"Pass path and model in to loader lifcycle methods

Makes it possible to do more intelligent things
specific to underlying data after a load succeeds
or fails","@@ -12,7 +12,7 @@ import java.lang.ref.WeakReference;
 public abstract class BasePathLoader<T> implements PathLoader<T> {
     @Override
     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
-        doFetchPath(model, width, height, new InternalPathReadyCallback(cb));
+        doFetchPath(model, width, height, new InternalPathReadyCallback(cb, model));
         return cb;
     }
 
@@ -21,25 +21,28 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
 
     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
 
-    protected void onPathReady(String path, boolean isUsed) { }
+    protected void onPathReady(String path, T model, boolean isUsed) { }
 
-    protected void onPathFetchFailed(Exception e) { }
+    protected void onPathFetchFailed(T model, Exception e) { }
 
 
     protected class InternalPathReadyCallback implements PathReadyCallback{
         private final WeakReference<PathReadyCallback> cbRef;
+        private final WeakReference<T> modelRef;
 
-        public InternalPathReadyCallback(PathReadyCallback cb) {
+        public InternalPathReadyCallback(PathReadyCallback cb, T model) {
             this.cbRef = new WeakReference<PathReadyCallback>(cb);
+            this.modelRef = new WeakReference<T>(model);
         }
 
         @Override
         public final boolean onPathReady(String path) {
             final PathReadyCallback cb = cbRef.get();
+            final T model = modelRef.get();
             boolean result = false;
-            if (cb != null) {
+            if (cb != null && model != null) {
                 result = cb.onPathReady(path);
-                BasePathLoader.this.onPathReady(path, result);
+                BasePathLoader.this.onPathReady(path, model, result);
             }
             return result;
         }
@@ -47,9 +50,10 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
         @Override
         public final void onError(Exception e) {
             final PathReadyCallback cb = cbRef.get();
-            if (cb != null) {
+            final T model = modelRef.get();
+            if (cb != null && model != null) {
                 cb.onError(e);
-                BasePathLoader.this.onPathFetchFailed(e);
+                BasePathLoader.this.onPathFetchFailed(model, e);
             }
         }
     }
","15         doFetchPath(model, width, height, new InternalPathReadyCallback(cb, model));
24     protected void onPathReady(String path, T model, boolean isUsed) { }
26     protected void onPathFetchFailed(T model, Exception e) { }
31         private final WeakReference<T> modelRef;
33         public InternalPathReadyCallback(PathReadyCallback cb, T model) {
35             this.modelRef = new WeakReference<T>(model);
41             final T model = modelRef.get();
43             if (cb != null && model != null) {
45                 BasePathLoader.this.onPathReady(path, model, result);
53             final T model = modelRef.get();
54             if (cb != null && model != null) {
56                 BasePathLoader.this.onPathFetchFailed(model, e);
15         doFetchPath(model, width, height, new InternalPathReadyCallback(cb));
24     protected void onPathReady(String path, boolean isUsed) { }
26     protected void onPathFetchFailed(Exception e) { }
32         public InternalPathReadyCallback(PathReadyCallback cb) {
40             if (cb != null) {
42                 BasePathLoader.this.onPathReady(path, result);
50             if (cb != null) {
52                 BasePathLoader.this.onPathFetchFailed(e);",No
src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,7af125c04ac080c1c1609e5d96aef54062998c09,720184018b3784a07b8af2c1fb136bf18a200256,"Pass path and model in to loader lifcycle methods

Makes it possible to do more intelligent things
specific to underlying data after a load succeeds
or fails","@@ -29,7 +29,7 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
 
     @Override
-    protected void onImageReady(Bitmap image, boolean isUsed) {
+    protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {
         if (isUsed) {
             releaseAcquired();
             imageManager.acquireBitmap(image);
","32     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {
32     protected void onImageReady(Bitmap image, boolean isUsed) {",No
src\com\bumptech\photos\resize\ImageResizer.java,src\com\bumptech\photos\resize\ImageResizer.java,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,7af125c04ac080c1c1609e5d96aef54062998c09,"remove recycle calls

Sometimes the recycled bitmap is actually returned
and displayed -> an exception","@@ -138,7 +138,6 @@ public class ImageResizer {
         if (toCrop.getWidth() > width) {
             int extraWidth = toCrop.getWidth() - width;
             cropped = Bitmap.createBitmap(toCrop, extraWidth / 2, 0, width, toCrop.getHeight());
-            toCrop.recycle();
         }
         return cropped;
     }
@@ -150,7 +149,6 @@ public class ImageResizer {
         if (toCrop.getHeight() > height){
             int extraHeight = toCrop.getHeight() - height;
             cropped = Bitmap.createBitmap(toCrop, 0, extraHeight / 2, toCrop.getWidth(), height);
-            toCrop.recycle();
         }
         return cropped;
     }
@@ -161,7 +159,6 @@ public class ImageResizer {
         float widthPercent = ((float) width/toShrink.getWidth());
         int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
-        toShrink.recycle();
         return shrunk;
     }
 
@@ -169,7 +166,6 @@ public class ImageResizer {
         float heightPercent = ((float) height/toShrink.getHeight());
         int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
-        toShrink.recycle();
         return shrunk;
     }
 
","141             toCrop.recycle();
153             toCrop.recycle();
164         toShrink.recycle();
172         toShrink.recycle();",No
src\com\bumptech\photos\loader\image\BaseImageLoader.java,src\com\bumptech\photos\loader\image\BaseImageLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -4,12 +4,12 @@ import android.graphics.Bitmap;
 
 import java.lang.ref.WeakReference;
 
+
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/1/13
- * Time: 2:45 PM
- * To change this template use File | Settings | File Templates.
+ * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
+ * subclasses with a weak reference to the calling object.
+ *
+ * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
  */
 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
     @Override
@@ -21,13 +21,45 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
     @Override
     public void clear() { }
 
+    /**
+     * The method where subclasses should actually begin any long running load for the given path and model. It is
+     * safe to strongly reference the given callback since that callback only weakly references the object that created
+     * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
+     * image is ready.
+     *
+     * @see ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
+     *
+     * @param path The path to the image or null if the required information is contained in the model
+     * @param model The object that represents or contains an image that can be displayed
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
+     */
     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
 
+    /**
+     * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
+     * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
+     * an image is displayed. See {@link com.bumptech.photos.presenter.ImageSetCallback} instead to make a visual change
+     * when a load completes.
+     *
+     * @param path The path to the loaded image
+     * @param model The model representing the loaded image
+     * @param image The loaded image
+     * @param isUsed True iff the requesting object is going to display the image
+     */
     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) { }
 
+    /**
+     * A lifecycle method called after the requesting object is notified that this loader failed to loada Bitmap. Should
+     * be used to cleanup or update any data related to the failed load.
+     *
+     * @param path The path to the image this loader failed to load
+     * @param model The model representing the image this loader failed to load
+     * @param e The exception that caused the failure, or null
+     */
     protected void onImageLoadFailed(String path, T model, Exception e) { }
 
-
     protected class InternalImageReadyCallback implements ImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
         private final String path;
","7 
9  * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
10  * subclasses with a weak reference to the calling object.
11  *
12  * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
24     /**
25      * The method where subclasses should actually begin any long running load for the given path and model. It is
26      * safe to strongly reference the given callback since that callback only weakly references the object that created
27      * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
28      * image is ready.
29      *
30      * @see ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
31      *
32      * @param path The path to the image or null if the required information is contained in the model
33      * @param model The object that represents or contains an image that can be displayed
34      * @param width The width of the view where the image will be displayed
35      * @param height The height of the view where the image will be displayed
36      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
37      */
40     /**
41      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
42      * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
43      * an image is displayed. See {@link com.bumptech.photos.presenter.ImageSetCallback} instead to make a visual change
44      * when a load completes.
45      *
46      * @param path The path to the loaded image
47      * @param model The model representing the loaded image
48      * @param image The loaded image
49      * @param isUsed True iff the requesting object is going to display the image
50      */
53     /**
54      * A lifecycle method called after the requesting object is notified that this loader failed to loada Bitmap. Should
55      * be used to cleanup or update any data related to the failed load.
56      *
57      * @param path The path to the image this loader failed to load
58      * @param model The model representing the image this loader failed to load
59      * @param e The exception that caused the failure, or null
60      */
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 1/1/13
11  * Time: 2:45 PM
12  * To change this template use File | Settings | File Templates.
30 ",No
src\com\bumptech\photos\loader\image\ImageLoader.java,src\com\bumptech\photos\loader\image\ImageLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -3,30 +3,51 @@ package com.bumptech.photos.loader.image;
 import android.graphics.Bitmap;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/1/13
- * Time: 2:21 PM
- * To change this template use File | Settings | File Templates.
+ * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given path and/or
+ * model
+ *
+ * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
  */
 public interface ImageLoader<T> {
 
+    /**
+     * An interface defining a callback that will be passed to an {@link ImageLoader} and that should be called by the
+     * {@link ImageLoader} when a load completes either successfully or because of a failure
+     */
     public interface ImageReadyCallback {
+
+        /**
+         * The method a loader should call when a load completes successfully
+         *
+         * @param image The requested image
+         * @return True iff the loaded image was used by the class that requested it from the {@link ImageLoader}
+         */
         public boolean onImageReady(Bitmap image);
+
+        /**
+         * The method a loader should call when a load fails
+         *
+         * @param e The exception that caused the load to fail, or null
+         */
         public void onError(Exception e);
     }
 
     /**
      * Load the image at the given path represented by the given model
      *
-     * @param path - the path to the image or null if the required information is contained in the model
-     * @param model - the object taht represents or contains an image that can be displayed
-     * @param width - the width of the view where the image will be displayed
-     * @param height - the height of the view where the image will be displayed
-     * @param cb - the callback to call when the bitmap is loaded into memory
-     * @return A reference to the fetch (if needed because of a weak reference) or null
+     * @param path The path to the image or null if the required information is contained in the model
+     * @param model The object that represents or contains an image that can be displayed
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
+     *
+     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
      */
     public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
 
+    /**
+     * Called when the current image load does not need to continue and any corresponding cleanup to save cpu
+     * or memory can be done. Will not be called if a load completes successfully.
+     */
     public void clear();
 }
","6  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given path and/or
7  * model
8  *
9  * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
13     /**
14      * An interface defining a callback that will be passed to an {@link ImageLoader} and that should be called by the
15      * {@link ImageLoader} when a load completes either successfully or because of a failure
16      */
18 
19         /**
20          * The method a loader should call when a load completes successfully
21          *
22          * @param image The requested image
23          * @return True iff the loaded image was used by the class that requested it from the {@link ImageLoader}
24          */
26 
27         /**
28          * The method a loader should call when a load fails
29          *
30          * @param e The exception that caused the load to fail, or null
31          */
38      * @param path The path to the image or null if the required information is contained in the model
39      * @param model The object that represents or contains an image that can be displayed
40      * @param width The width of the view where the image will be displayed
41      * @param height The height of the view where the image will be displayed
42      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
43      *
44      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
48     /**
49      * Called when the current image load does not need to continue and any corresponding cleanup to save cpu
50      * or memory can be done. Will not be called if a load completes successfully.
51      */
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 1/1/13
9  * Time: 2:21 PM
10  * To change this template use File | Settings | File Templates.
22      * @param path - the path to the image or null if the required information is contained in the model
23      * @param model - the object taht represents or contains an image that can be displayed
24      * @param width - the width of the view where the image will be displayed
25      * @param height - the height of the view where the image will be displayed
26      * @param cb - the callback to call when the bitmap is loaded into memory
27      * @return A reference to the fetch (if needed because of a weak reference) or null",No
src\com\bumptech\photos\loader\path\BasePathLoader.java,src\com\bumptech\photos\loader\path\BasePathLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -3,11 +3,10 @@ package com.bumptech.photos.loader.path;
 import java.lang.ref.WeakReference;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/1/13
- * Time: 3:04 PM
- * To change this template use File | Settings | File Templates.
+ * A base class for {@link PathLoader that provides some lifecycle methods and prevents memory leaks by only providing
+ * subclasses with a weak reference to the callinb object.}
+ *
+ * @param <T> The type of the model this loader must be able to load a path for
  */
 public abstract class BasePathLoader<T> implements PathLoader<T> {
     @Override
@@ -19,13 +18,40 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
     @Override
     public void clear() { }
 
+    /**
+     * The method where subclasses should actually begin any long running load to fetch the path from the given model.
+     * It is safe to strongly reference the given callback since that callback only weakly references the object that
+     * created it. Once a load completes or fails the given callback should be called to signal to the calling object
+     * that the path is ready.
+     *
+     * @see com.bumptech.photos.loader.image.ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
+     *
+     * @param model The object that represents or contains a path to an image to be displayed
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
+     */
     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
 
+    /**
+     * A lifecycle method called after the requesting object is notified that this loader has loaded a path. Should be
+     * used to cleanup or update any data related ot the completed load.
+     *
+     * @param path The retrieved path to the image
+     * @param model The model representing the image
+     * @param isUsed True iff the requesting object is going to load the image at the given path
+     */
     protected void onPathReady(String path, T model, boolean isUsed) { }
 
+    /**
+     * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
+     * SHould be used to cleanup or update any data related to the failed load.
+     *
+     * @param model The model representing the image this loader failed to fetch a path for
+     * @param e The exception that caused the failure, or null
+     */
     protected void onPathFetchFailed(T model, Exception e) { }
 
-
     protected class InternalPathReadyCallback implements PathReadyCallback{
         private final WeakReference<PathReadyCallback> cbRef;
         private final WeakReference<T> modelRef;
","6  * A base class for {@link PathLoader that provides some lifecycle methods and prevents memory leaks by only providing
7  * subclasses with a weak reference to the callinb object.}
8  *
9  * @param <T> The type of the model this loader must be able to load a path for
21     /**
22      * The method where subclasses should actually begin any long running load to fetch the path from the given model.
23      * It is safe to strongly reference the given callback since that callback only weakly references the object that
24      * created it. Once a load completes or fails the given callback should be called to signal to the calling object
25      * that the path is ready.
26      *
27      * @see com.bumptech.photos.loader.image.ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
28      *
29      * @param model The object that represents or contains a path to an image to be displayed
30      * @param width The width of the view where the image will be displayed
31      * @param height The height of the view where the image will be displayed
32      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
33      */
36     /**
37      * A lifecycle method called after the requesting object is notified that this loader has loaded a path. Should be
38      * used to cleanup or update any data related ot the completed load.
39      *
40      * @param path The retrieved path to the image
41      * @param model The model representing the image
42      * @param isUsed True iff the requesting object is going to load the image at the given path
43      */
46     /**
47      * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
48      * SHould be used to cleanup or update any data related to the failed load.
49      *
50      * @param model The model representing the image this loader failed to fetch a path for
51      * @param e The exception that caused the failure, or null
52      */
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 1/1/13
9  * Time: 3:04 PM
10  * To change this template use File | Settings | File Templates.
28 ",No
src\com\bumptech\photos\loader\path\DirectPathLoader.java,src\com\bumptech\photos\loader\path\DirectPathLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -5,11 +5,9 @@
 package com.bumptech.photos.loader.path;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 8:52 PM
- * To change this template use File | Settings | File Templates.
+ * A simple synchronous implementation of a {@link PathLoader}
+ *
+ * @param <T> The type of the model that contains a path
  */
 public abstract class DirectPathLoader<T> implements PathLoader<T> {
 
@@ -19,6 +17,15 @@ public abstract class DirectPathLoader<T> implements PathLoader<T> {
         return null;  //To change body of implemented methods use File | Settings | File Templates.
     }
 
+    /**
+     * A method to be implemented by subclasses that should return a path for a given model (or null if the model
+     * contains some other mechanism to load the image directly)
+     *
+     * @param model The object containing the path
+     * @param width The width of the {@link android.widget.ImageView} that will be displaying the image
+     * @param height The height of the {@link android.widget.ImageView} that will be displaying the image
+     * @return The path where the image is located, or null
+     */
     protected abstract String getPath(T model, int width, int height);
 
     @Override
","8  * A simple synchronous implementation of a {@link PathLoader}
9  *
10  * @param <T> The type of the model that contains a path
20     /**
21      * A method to be implemented by subclasses that should return a path for a given model (or null if the model
22      * contains some other mechanism to load the image directly)
23      *
24      * @param model The object containing the path
25      * @param width The width of the {@link android.widget.ImageView} that will be displaying the image
26      * @param height The height of the {@link android.widget.ImageView} that will be displaying the image
27      * @return The path where the image is located, or null
28      */
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:52 PM
12  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\loader\path\PathLoader.java,src\com\bumptech\photos\loader\path\PathLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -5,20 +5,49 @@
 package com.bumptech.photos.loader.path;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 8:51 PM
- * To change this template use File | Settings | File Templates.
+ * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a path for a given model
+ *
+ * @param <T> The type of the model this loader must be able to fetch paths for
  */
 public interface PathLoader<T> {
 
+    /**
+     * An interface defining a callback that will be passed to a {@link PathLoader} and that should be called by the
+     * {@link PathLoader} when a load completes either successfully or because of a failure
+     */
     public interface PathReadyCallback {
+
+        /**
+         * The method a loader should call when a load completes successfully
+         *
+         * @param path The requested path
+         * @return True iff the loaded path was used by the class that requested it from the {@link PathLoader}
+         */
         public boolean onPathReady(String path);
+
+        /**
+         * The method a loader should call when a load fails
+         *
+         * @param e The exception that caused the load to fail, or null
+         */
         public void onError(Exception e);
     }
 
+    /**
+     * Load the path represented by the given model
+     *
+     * @param model The object that represents or contains the path to an image.
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @param cb The callback to call when the path is loaded or when a load fails
+     *
+     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
+     */
     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
 
+    /**
+     * Called when the current path load does not need to conintue and any corresponding cleanup to save cpu or memory
+     * can be done. Will not be called if a load completes successfully.
+     */
     public void clear();
 }
","8  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a path for a given model
9  *
10  * @param <T> The type of the model this loader must be able to fetch paths for
14     /**
15      * An interface defining a callback that will be passed to a {@link PathLoader} and that should be called by the
16      * {@link PathLoader} when a load completes either successfully or because of a failure
17      */
19 
20         /**
21          * The method a loader should call when a load completes successfully
22          *
23          * @param path The requested path
24          * @return True iff the loaded path was used by the class that requested it from the {@link PathLoader}
25          */
27 
28         /**
29          * The method a loader should call when a load fails
30          *
31          * @param e The exception that caused the load to fail, or null
32          */
36     /**
37      * Load the path represented by the given model
38      *
39      * @param model The object that represents or contains the path to an image.
40      * @param width The width of the view where the image will be displayed
41      * @param height The height of the view where the image will be displayed
42      * @param cb The callback to call when the path is loaded or when a load fails
43      *
44      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
45      */
48     /**
49      * Called when the current path load does not need to conintue and any corresponding cleanup to save cpu or memory
50      * can be done. Will not be called if a load completes successfully.
51      */
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/25/12
11  * Time: 8:51 PM
12  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\presenter\ImagePresenter.java,src\com\bumptech\photos\presenter\ImagePresenter.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -17,23 +17,40 @@ import com.bumptech.photos.loader.image.ImageLoader;
 import java.lang.ref.WeakReference;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:05 PM
- * To change this template use File | Settings | File Templates.
+ * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and loading bitmaps correctly
+ * when views are being recycled. Uses {@link PathLoader} to download
+ * an image or retrieve a path for a given model and {@link ImageLoader} to load
+ * a bitmap from a given path and/or model. Also determines the actual width and height of the wrapped
+ * {@link android.widget.ImageView} and passes that information to the provided
+ * {@link PathLoader} and {@link ImageLoader}.
+ *
+ * @param <T> The type of the model that contains information necessary to display an image. Can be as simple
+ *            as a String containing a path or a complex data type.
  */
 public class ImagePresenter<T> {
 
+    /**
+     * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
+     * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
+     * are required.
+     *
+     * @param <T> The type of the model that the presenter this builder will produce requires to load a path and an
+     *           image from that path.
+     */
     public static class Builder<T> {
         private ImageView imageView;
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
         private ImageSetCallback imageSetCallback;
-        private AssetPresenterCoordinator coordinator;
+        private ImagePresenterCoordinator coordinator;
         private ImageLoader<T> imageLoader;
         private PathLoader<T> pathLoader;
 
+        /**
+         * Builds an ImagePresenter
+         *
+         * @return A new ImagePresenter
+         */
         public ImagePresenter<T> build(){
             assert imageView != null : ""cannot create presenter without an image view"";
             assert imageLoader != null : ""cannot create presenter without an image loader"";
@@ -42,21 +59,49 @@ public class ImagePresenter<T> {
             return new ImagePresenter<T>(this);
         }
 
+        /**
+         * Required sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
+         *
+         * @param imageView The {@link android.widget.ImageView} to wrap
+         * @return This Builder object
+         */
         public Builder<T> setImageView(ImageView imageView) {
             this.imageView = imageView;
             return this;
         }
 
+        /**
+         * Required sets the {@link com.bumptech.photos.loader.path.PathLoader} the presenter will use to download an
+         * image or otherwise retrieve a path for a given T model
+         *
+         * @param pathLoader The {@link com.bumptech.photos.loader.path.PathLoader} to use to retrieve a path
+         * @return This Builder
+         */
         public Builder<T> setPathLoader(PathLoader<T> pathLoader) {
             this.pathLoader = pathLoader;
             return this;
         }
 
+        /**
+         * Required Sets the {@link com.bumptech.photos.loader.image.ImageLoader} the presenter will use to load a
+         * Bitmap from the given path and/or model
+         *
+         * @param imageLoader The {@link com.bumptech.photos.loader.image.ImageLoader} to use to load an image
+         * @return This Builder object
+         */
         public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
             this.imageLoader = imageLoader;
             return this;
         }
 
+        /**
+         * Optional Sets a resource that will be displayed during loads and whenever
+         * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
+         * {@link Builder ImagePresenter.Builder#setPlaceholderDrawable(android.graphics.drawable.Drawable)}, not both.
+         *
+         * @param resourceId The id of the resource to show
+         * @return This Builder object
+         */
         public Builder<T> setPlaceholderResource(int resourceId) {
             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
 
@@ -64,6 +109,14 @@ public class ImagePresenter<T> {
             return this;
         }
 
+        /**
+         * Optional Sets a drawable that will be displayed during loads and whenever
+         * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
+         * {@link Builder ImagePresenter.Builder#setPlaceholderResource(int)}, not both.
+         *
+         * @param placeholderDrawable The drawable to show
+         * @return This Builder object
+         */
         public Builder<T> setPlaceholderDrawable(Drawable placeholderDrawable) {
             assert placeholderDrawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
 
@@ -71,12 +124,27 @@ public class ImagePresenter<T> {
             return this;
         }
 
+        /**
+         * Optional Sets a callback that will be called after an image is loaded by
+         * {@link com.bumptech.photos.loader.image.ImageLoader} and immediately before
+         * {@link android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)} is called by the presenter
+         *
+         * @param cb The callback to call
+         * @return This Builder object
+         */
         public Builder<T> setImageSetCallback(ImageSetCallback cb) {
             this.imageSetCallback = cb;
             return this;
         }
 
-        public Builder<T> setAssetPresenterCoordinator(AssetPresenterCoordinator<T> coordinator) {
+        /**
+         * Optional Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
+         * valid loads. See {@link com.bumptech.photos.presenter.ThumbImagePresenter}.
+         *
+         * @param coordinator The coordinator to set
+         * @return This Builder object
+         */
+        public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator<T> coordinator) {
             this.coordinator = coordinator;
             return this;
         }
@@ -92,7 +160,7 @@ public class ImagePresenter<T> {
     private final ImageLoader<T> imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
-    private final AssetPresenterCoordinator coordinator;
+    private final ImagePresenterCoordinator coordinator;
     protected final ImageView imageView;
 
     private int height = 0;
@@ -122,8 +190,27 @@ public class ImagePresenter<T> {
     };
     private Runnable pendingLoad = null;
 
-    public interface AssetPresenterCoordinator<T> {
+    /**
+     * An interface used to coordinate multiple {@link ImagePresenter} objects acting on the same view
+     *
+     * @param <T> The type of the {@link ImagePresenter} objects the implementation will be acting on
+     */
+    public interface ImagePresenterCoordinator<T> {
+
+        /**
+         * Determines if a presenter can display a loaded bitmap
+         *
+         * @param presenter The presenter requesting permission to display a bitmap
+         * @return True iff the presenter can display a bitmap
+         */
         public boolean canSetImage(ImagePresenter<T> presenter);
+
+        /**
+         * Determines if a presenter can display a placeholder
+         *
+         * @param presenter The presenter requesting permission to display a placeholder
+         * @return True iff the presenter can display a placeholder
+         */
         public boolean canSetPlaceholder(ImagePresenter<T> presenter);
     }
 
@@ -141,11 +228,29 @@ public class ImagePresenter<T> {
         imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
     }
 
+    /**
+     * A method to get the wrapped {@link android.widget.ImageView}. Note that setting any image or drawable on the view
+     * directly may or may not be overridden at any point by the wrapper presenter.
+     *
+     * @return The {@link android.widget.ImageView} this {@link ImagePresenter} object wraps
+     */
     public ImageView getImageView() {
         return imageView;
     }
 
-    public void setAssetModel(final T model) {
+    /**
+     * Sets a model to load an image from. Each subsequent call will override all previous calls and will prevent any
+     * bitmaps that are loaded from previous calls from being displayed even if the load completes successfully. Any
+     * image being displayed at the time of this call will be replaced either by the placeholder or by the new image
+     * if the load completes synchronously (ie it was in an in memory cache)
+     *
+     * <p>Note that a load will not begin before the ImagePresenter has determined the width and height of the wrapped
+     * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until
+     * then the current load is stored. Subsequent calls will replace the stored load</p>
+     *
+     * @param model The model containing the information required to load a path and/or bitmap
+     */
+    public void setModel(final T model) {
         if (model == null || model.equals(currentModel)) return;
 
         loadedFromCache = true;
@@ -174,12 +279,24 @@ public class ImagePresenter<T> {
         }
     }
 
+
+    /**
+     * Sets the placeholder as the current image for the {@link android.widget.ImageView}. Does not cancel any previous
+     * loads, so the placeholder could be replaced with a loaded bitmap at any time. To cancel a load and display a
+     * placeholder call {@link com.bumptech.photos.presenter.ImagePresenter#clear()}.
+     */
     public void resetPlaceHolder() {
         if (!canSetPlaceholder()) return;
 
         imageView.setImageDrawable(placeholderDrawable);
     }
 
+    /**
+     * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from
+     * being displayed and clears this presenter's {@link com.bumptech.photos.loader.image.ImageLoader} and
+     * this presenter's {@link com.bumptech.photos.loader.path.PathLoader}. Also displays the current placeholder if
+     * one is set
+     */
     public void clear() {
         currentCount++;
         resetPlaceHolder();
@@ -189,10 +306,22 @@ public class ImagePresenter<T> {
         imageLoader.clear();
     }
 
+    /**
+     * Returns the current calculated width of the wrapped view. Will be 0 if the presenter has not yet calcualted a
+     * width. May change at any time
+     *
+     * @return The width of the wrapped {@link android.widget.ImageView}
+     */
     public int getWidth() {
         return width;
     }
 
+    /**
+     * Returns the current calculated height of the wrapped view. Will be 0 if the presenter has not yet calculated a
+     * height. May change at any time.
+     *
+     * @return The width of the wrapped {@link android.widget.ImageView }
+     */
     public int getHeight() {
         return height;
     }
@@ -245,6 +374,13 @@ public class ImagePresenter<T> {
         imageView.post(getDimens);
     }
 
+    /**
+     * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
+     *
+     * @return True iff the wrapped {@link android.widget.ImageView} is displaying an image loaded by this
+     *          {@link ImagePresenter}. False if the wrapped {@link android.widget.ImageView} is displaying a
+     *          placeholder set by this presenter.
+     */
     protected boolean isImageSet() {
         return isImageSet;
     }
","20  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and loading bitmaps correctly
21  * when views are being recycled. Uses {@link PathLoader} to download
22  * an image or retrieve a path for a given model and {@link ImageLoader} to load
23  * a bitmap from a given path and/or model. Also determines the actual width and height of the wrapped
24  * {@link android.widget.ImageView} and passes that information to the provided
25  * {@link PathLoader} and {@link ImageLoader}.
26  *
27  * @param <T> The type of the model that contains information necessary to display an image. Can be as simple
28  *            as a String containing a path or a complex data type.
32     /**
33      * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
34      * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
35      * are required.
36      *
37      * @param <T> The type of the model that the presenter this builder will produce requires to load a path and an
38      *           image from that path.
39      */
45         private ImagePresenterCoordinator coordinator;
49         /**
50          * Builds an ImagePresenter
51          *
52          * @return A new ImagePresenter
53          */
62         /**
63          * Required sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
64          *
65          * @param imageView The {@link android.widget.ImageView} to wrap
66          * @return This Builder object
67          */
73         /**
74          * Required sets the {@link com.bumptech.photos.loader.path.PathLoader} the presenter will use to download an
75          * image or otherwise retrieve a path for a given T model
76          *
77          * @param pathLoader The {@link com.bumptech.photos.loader.path.PathLoader} to use to retrieve a path
78          * @return This Builder
79          */
85         /**
86          * Required Sets the {@link com.bumptech.photos.loader.image.ImageLoader} the presenter will use to load a
87          * Bitmap from the given path and/or model
88          *
89          * @param imageLoader The {@link com.bumptech.photos.loader.image.ImageLoader} to use to load an image
90          * @return This Builder object
91          */
97         /**
98          * Optional Sets a resource that will be displayed during loads and whenever
99          * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
100          * {@link Builder ImagePresenter.Builder#setPlaceholderDrawable(android.graphics.drawable.Drawable)}, not both.
101          *
102          * @param resourceId The id of the resource to show
103          * @return This Builder object
104          */
112         /**
113          * Optional Sets a drawable that will be displayed during loads and whenever
114          * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
115          * {@link Builder ImagePresenter.Builder#setPlaceholderResource(int)}, not both.
116          *
117          * @param placeholderDrawable The drawable to show
118          * @return This Builder object
119          */
127         /**
128          * Optional Sets a callback that will be called after an image is loaded by
129          * {@link com.bumptech.photos.loader.image.ImageLoader} and immediately before
130          * {@link android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)} is called by the presenter
131          *
132          * @param cb The callback to call
133          * @return This Builder object
134          */
140         /**
141          * Optional Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
142          * valid loads. See {@link com.bumptech.photos.presenter.ThumbImagePresenter}.
143          *
144          * @param coordinator The coordinator to set
145          * @return This Builder object
146          */
147         public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator<T> coordinator) {
163     private final ImagePresenterCoordinator coordinator;
193     /**
194      * An interface used to coordinate multiple {@link ImagePresenter} objects acting on the same view
195      *
196      * @param <T> The type of the {@link ImagePresenter} objects the implementation will be acting on
197      */
198     public interface ImagePresenterCoordinator<T> {
199 
200         /**
201          * Determines if a presenter can display a loaded bitmap
202          *
203          * @param presenter The presenter requesting permission to display a bitmap
204          * @return True iff the presenter can display a bitmap
205          */
207 
208         /**
209          * Determines if a presenter can display a placeholder
210          *
211          * @param presenter The presenter requesting permission to display a placeholder
212          * @return True iff the presenter can display a placeholder
213          */
231     /**
232      * A method to get the wrapped {@link android.widget.ImageView}. Note that setting any image or drawable on the view
233      * directly may or may not be overridden at any point by the wrapper presenter.
234      *
235      * @return The {@link android.widget.ImageView} this {@link ImagePresenter} object wraps
236      */
241     /**
242      * Sets a model to load an image from. Each subsequent call will override all previous calls and will prevent any
243      * bitmaps that are loaded from previous calls from being displayed even if the load completes successfully. Any
244      * image being displayed at the time of this call will be replaced either by the placeholder or by the new image
245      * if the load completes synchronously (ie it was in an in memory cache)
246      *
247      * <p>Note that a load will not begin before the ImagePresenter has determined the width and height of the wrapped
248      * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until
249      * then the current load is stored. Subsequent calls will replace the stored load</p>
250      *
251      * @param model The model containing the information required to load a path and/or bitmap
252      */
253     public void setModel(final T model) {
282 
283     /**
284      * Sets the placeholder as the current image for the {@link android.widget.ImageView}. Does not cancel any previous
285      * loads, so the placeholder could be replaced with a loaded bitmap at any time. To cancel a load and display a
286      * placeholder call {@link com.bumptech.photos.presenter.ImagePresenter#clear()}.
287      */
294     /**
295      * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from
296      * being displayed and clears this presenter's {@link com.bumptech.photos.loader.image.ImageLoader} and
297      * this presenter's {@link com.bumptech.photos.loader.path.PathLoader}. Also displays the current placeholder if
298      * one is set
299      */
309     /**
310      * Returns the current calculated width of the wrapped view. Will be 0 if the presenter has not yet calcualted a
311      * width. May change at any time
312      *
313      * @return The width of the wrapped {@link android.widget.ImageView}
314      */
319     /**
320      * Returns the current calculated height of the wrapped view. Will be 0 if the presenter has not yet calculated a
321      * height. May change at any time.
322      *
323      * @return The width of the wrapped {@link android.widget.ImageView }
324      */
377     /**
378      * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
379      *
380      * @return True iff the wrapped {@link android.widget.ImageView} is displaying an image loaded by this
381      *          {@link ImagePresenter}. False if the wrapped {@link android.widget.ImageView} is displaying a
382      *          placeholder set by this presenter.
383      */
20  * Created with IntelliJ IDEA.
21  * User: sam
22  * Date: 12/25/12
23  * Time: 10:05 PM
24  * To change this template use File | Settings | File Templates.
33         private AssetPresenterCoordinator coordinator;
79         public Builder<T> setAssetPresenterCoordinator(AssetPresenterCoordinator<T> coordinator) {
95     private final AssetPresenterCoordinator coordinator;
125     public interface AssetPresenterCoordinator<T> {
148     public void setAssetModel(final T model) {",No
src\com\bumptech\photos\presenter\ImageSetCallback.java,src\com\bumptech\photos\presenter\ImageSetCallback.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -7,12 +7,16 @@ package com.bumptech.photos.presenter;
 import android.widget.ImageView;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:04 PM
- * To change this template use File | Settings | File Templates.
+ * A callback interface used to perform some action when an {@link ImagePresenter} sets an
+ * {@link android.widget.ImageView} object's bitmap
  */
 public interface ImageSetCallback {
+
+    /**
+     * The method called when a bitmap is set
+     *
+     * @param view The view that will display the bitmap
+     * @param fromCache True iff the bitmap was loaded synchronously.
+     */
     public void onImageSet(ImageView view, boolean fromCache);
 }
","10  * A callback interface used to perform some action when an {@link ImagePresenter} sets an
11  * {@link android.widget.ImageView} object's bitmap
14 
15     /**
16      * The method called when a bitmap is set
17      *
18      * @param view The view that will display the bitmap
19      * @param fromCache True iff the bitmap was loaded synchronously.
20      */
10  * Created with IntelliJ IDEA.
11  * User: sam
12  * Date: 12/25/12
13  * Time: 10:04 PM
14  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\presenter\ThumbImagePresenter.java,src\com\bumptech\photos\presenter\ThumbImagePresenter.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -8,14 +8,24 @@ import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/28/12
- * Time: 12:49 PM
- * To change this template use File | Settings | File Templates.
+ *Wraps a pair of {@link ImagePresenter} objects and uses them to load and display an image and a thumbnail for that
+ * image. The image load is started first. If the image load does not return synchronously (ie if the image is not
+ * cached), then the thumbnail load is started. If the thumbnail load does not return synchronously, the placeholder
+ * image is shown. If the thumbnail load completes before the image load (expected in most cases), the thumbnail is
+ * shown until the image load completes. If the image load completes first, the thumbnail will never be shown.
+ *
  */
-public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoordinator<T> {
+public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoordinator<T> {
 
+    /**
+     * A builder for a {@link ThumbImagePresenter}. Has a few convenience methods to avoid identical calls on both
+     * the full and thumb presenter. {@link Builder ThumbImagePresenter.Builder#setFullPresenterBuilder},
+     * {@link Builder ThumbImagePresenter.Builder#setThumbPresenterBuilder}, and
+     * {@link Builder ThumbImagePresenter.Builder#setImageView} are required.
+     *
+     * @param <T> The type of the model that the full and thumb presenters require to load a path and an image for that
+     *           path
+     */
     public static class Builder<T> {
         private ImagePresenter.Builder<T> fullPresenterBuilder;
         private ImagePresenter.Builder<T> thumbPresenterBuilder;
@@ -31,21 +41,41 @@ public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoor
             return new ThumbImagePresenter<T>(this);
         }
 
+        /**
+         * Required - sets the {@link ImagePresenter} that will be used to load the full image
+         *
+         * @param builder A builder that will produce an ImagePresenter. At least {@link ImagePresenter.Builder ImagePresenter.Builder#setPathLoader},
+         *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
+         * @return This builder object
+         */
         public Builder<T> setFullPresenterBuilder(ImagePresenter.Builder<T> builder) {
             this.fullPresenterBuilder = builder;
             return this;
         }
 
+        /**
+         * Required - sets the {@link ImagePresenter} that will be used to load the thumbnail
+         *
+         * @param builder A builder that will produce an ImagePresenter. At least {@link ImagePresenter.Builder ImagePresenter.Builder#setPathLoader},
+         *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
+         * @return This builder object
+         */
         public Builder<T> setThumbPresenterBuilder(ImagePresenter.Builder<T> builder) {
             this.thumbPresenterBuilder = builder;
             return this;
         }
 
+        /**
+         * @see ImagePresenter.Builder ImagePresenter.Builder#setImageView
+         */
         public Builder<T> setImageView(ImageView imageView) {
             this.imageView = imageView;
             return this;
         }
 
+        /**
+         * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderDrawable
+         */
         public Builder<T> setPlaceholderDrawable(Drawable drawable) {
             assert drawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
 
@@ -53,6 +83,9 @@ public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoor
             return this;
         }
 
+        /**
+         * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderResource
+         */
         public Builder<T> setPlaceholderResource(int resourceId) {
             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
 
@@ -66,31 +99,47 @@ public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoor
 
     private ThumbImagePresenter(Builder<T> builder) {
         fullPresenter = builder.fullPresenterBuilder
-                .setAssetPresenterCoordinator(this)
+                .setImagePresenterCoordinator(this)
                 .setImageView(builder.imageView)
                 .setPlaceholderResource(0)
                 .setPlaceholderDrawable(builder.placeholderDrawable == null ?
                         builder.imageView.getResources().getDrawable(builder.placeholderResourceId) : builder.placeholderDrawable)
                 .build();
         thumbPresenter = builder.thumbPresenterBuilder
-                .setAssetPresenterCoordinator(this)
+                .setImagePresenterCoordinator(this)
                 .setImageView(builder.imageView)
                 .setPlaceholderDrawable(null)
                 .setPlaceholderResource(0)
                 .build();
     }
 
-    public void setAssetModels(T fullModel, T thumbModel) {
-        fullPresenter.setAssetModel(fullModel);
+    /**
+     * Sets models to load the full and thumb image. If the load for fullModel finishes before the one for thumbModel
+     * then only the full image will be shown
+     *
+     * @see ImagePresenter#setModel(Object)
+     */
+    public void setModels(T fullModel, T thumbModel) {
+        fullPresenter.setModel(fullModel);
         if (!fullPresenter.isImageSet()) {
-            thumbPresenter.setAssetModel(thumbModel);
+            thumbPresenter.setModel(thumbModel);
         }
     }
 
+    /**
+     * Get the {@link android.widget.ImageView} this object is acting on
+     *
+     * @see ImagePresenter#getImageView()
+     */
     public ImageView getImageView() {
         return fullPresenter.getImageView();
     }
 
+    /**
+     * Calls the corresponding method on both image presenters
+     *
+     * @see ImagePresenter#clear()
+     */
     public void clear(){
         fullPresenter.clear();
         thumbPresenter.clear();
@@ -106,6 +155,11 @@ public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoor
         return presenter == fullPresenter;
     }
 
+    /**
+     * Show the placeholder if one is set, otherwise clear the view
+     *
+     * @see ImagePresenter#resetPlaceHolder()
+     */
     public void resetPlaceholder() {
         fullPresenter.resetPlaceHolder();
     }
","11  *Wraps a pair of {@link ImagePresenter} objects and uses them to load and display an image and a thumbnail for that
12  * image. The image load is started first. If the image load does not return synchronously (ie if the image is not
13  * cached), then the thumbnail load is started. If the thumbnail load does not return synchronously, the placeholder
14  * image is shown. If the thumbnail load completes before the image load (expected in most cases), the thumbnail is
15  * shown until the image load completes. If the image load completes first, the thumbnail will never be shown.
16  *
18 public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoordinator<T> {
20     /**
21      * A builder for a {@link ThumbImagePresenter}. Has a few convenience methods to avoid identical calls on both
22      * the full and thumb presenter. {@link Builder ThumbImagePresenter.Builder#setFullPresenterBuilder},
23      * {@link Builder ThumbImagePresenter.Builder#setThumbPresenterBuilder}, and
24      * {@link Builder ThumbImagePresenter.Builder#setImageView} are required.
25      *
26      * @param <T> The type of the model that the full and thumb presenters require to load a path and an image for that
27      *           path
28      */
44         /**
45          * Required - sets the {@link ImagePresenter} that will be used to load the full image
46          *
47          * @param builder A builder that will produce an ImagePresenter. At least {@link ImagePresenter.Builder ImagePresenter.Builder#setPathLoader},
48          *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
49          * @return This builder object
50          */
56         /**
57          * Required - sets the {@link ImagePresenter} that will be used to load the thumbnail
58          *
59          * @param builder A builder that will produce an ImagePresenter. At least {@link ImagePresenter.Builder ImagePresenter.Builder#setPathLoader},
60          *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
61          * @return This builder object
62          */
68         /**
69          * @see ImagePresenter.Builder ImagePresenter.Builder#setImageView
70          */
76         /**
77          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderDrawable
78          */
86         /**
87          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderResource
88          */
102                 .setImagePresenterCoordinator(this)
109                 .setImagePresenterCoordinator(this)
116     /**
117      * Sets models to load the full and thumb image. If the load for fullModel finishes before the one for thumbModel
118      * then only the full image will be shown
119      *
120      * @see ImagePresenter#setModel(Object)
121      */
122     public void setModels(T fullModel, T thumbModel) {
123         fullPresenter.setModel(fullModel);
125             thumbPresenter.setModel(thumbModel);
129     /**
130      * Get the {@link android.widget.ImageView} this object is acting on
131      *
132      * @see ImagePresenter#getImageView()
133      */
138     /**
139      * Calls the corresponding method on both image presenters
140      *
141      * @see ImagePresenter#clear()
142      */
158     /**
159      * Show the placeholder if one is set, otherwise clear the view
160      *
161      * @see ImagePresenter#resetPlaceHolder()
162      */
11  * Created with IntelliJ IDEA.
12  * User: sam
13  * Date: 12/28/12
14  * Time: 12:49 PM
15  * To change this template use File | Settings | File Templates.
17 public class ThumbImagePresenter<T> implements ImagePresenter.AssetPresenterCoordinator<T> {
69                 .setAssetPresenterCoordinator(this)
76                 .setAssetPresenterCoordinator(this)
83     public void setAssetModels(T fullModel, T thumbModel) {
84         fullPresenter.setAssetModel(fullModel);
86             thumbPresenter.setAssetModel(thumbModel);",No
src\com\bumptech\photos\resize\HandlerExecutor.java,src\com\bumptech\photos\resize\HandlerExecutor.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -11,16 +11,15 @@ import android.os.SystemClock;
 import java.util.concurrent.Executor;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/2/13
- * Time: 1:49 PM
- * To change this template use File | Settings | File Templates.
+ * A simple Executor implemented using an Android {@link android.os.Handler}
  */
 public class HandlerExecutor implements Executor {
     private final Handler worker;
     private final Object token;
 
+    /**
+     * Create a new executor with a new HandlerThread called ""HandlerExecutor""
+     */
     public HandlerExecutor() {
         HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
         workerThread.start();
@@ -28,6 +27,11 @@ public class HandlerExecutor implements Executor {
         token = hashCode();
     }
 
+    /**
+     * Create a new executor that uses the given Handler's thread
+     *
+     * @param bgHandler The handler to post Runnables to
+     */
     public HandlerExecutor(Handler bgHandler) {
         this.worker = bgHandler;
         token = hashCode();
","14  * A simple Executor implemented using an Android {@link android.os.Handler}
20     /**
21      * Create a new executor with a new HandlerThread called ""HandlerExecutor""
22      */
30     /**
31      * Create a new executor that uses the given Handler's thread
32      *
33      * @param bgHandler The handler to post Runnables to
34      */
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 1/2/13
17  * Time: 1:49 PM
18  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\ImageManager.java,src\com\bumptech\photos\resize\ImageManager.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -20,24 +20,65 @@ import java.util.Map;
 import java.util.concurrent.Executor;
 
 /**
- * Created by IntelliJ IDEA.
- * User: sam
- * Date: 2/9/12
- * Time: 5:02 PM
- * To change this template use File | Settings | File Templates.
+ * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
+ * sdk version, uses a  combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
+ * load and resize  * operations performed and to maximize the number of times Bitmaps are recycled as opposed to
+ * allocated.
+ *
+ * If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible. Note
+ * that Bitmap recycling is only available on Honeycomb and up.
  */
 public class ImageManager {
     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
+    private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
 
+    /**
+     * A class for setting options for an ImageManager
+     *
+     * Boolean use options for the caches superseed sizes, and invalid * sizes (<= 0) are equivalent to setting the
+     * corresponding use option to false.
+     */
     public static class Options {
+        /**
+         * @see com.jakewharton.DiskLruCache#open(java.io.File, int, int, long)
+         */
         public int appVersion = 0;
 
+        /**
+         * If true caches bitmaps in memory.
+         *
+         * Defaults to true
+         */
         public boolean useMemoryCache = true;
+
+        /**
+         * The maximum memory cache size. This should be decreased on devices where recycling Bitmaps is possible and
+         * enabled because the Bitmap cache used to recycle Bitmaps will take a substantial amount of memory.
+         *
+         * Defaults to 1/8th of the total application memory
+         */
         public int maxMemorySize;
 
+        /**
+         * If true, caches resized bitmaps on disk.
+         */
         public boolean useDiskCache = true;
-        public int maxDiskCacheSize = 10 * 1024 * 1024;
 
+        /**
+         * The maximum disk cache size.
+         *
+         * Defaults to 30mb
+         */
+        public int maxDiskCacheSize;
+
+        /**
+         * If true, will attempt to recycle Bitmaps and all loaded Bitmaps will be mutable. If true and a memory cache
+         * is used, the memory cache size should be decreased since the Bitmap cache used to recycle Bitmaps will
+         * take a substantial amount of memory.
+         *
+         * Defaults to true if Android version is 3.0 or greater and will always be false, regardless of this attribute
+         * otherwise.
+         */
         public boolean recycleBitmaps = true;
     }
 
@@ -59,7 +100,15 @@ public class ImageManager {
         AS_IS
     }
 
+    /**
+     * Try to get the external cache directory if available and default to the internal. Use a default name for the
+     * cache directory if no name is provided
+     */
     public static File getPhotoCacheDir(Context context) {
+        return getPhotoCacheDir(context, DISK_CACHE_DIR);
+    }
+
+    public static File getPhotoCacheDir(Context context, String cacheName) {
         final String cachePath;
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
                 !Environment.isExternalStorageRemovable()) {
@@ -68,42 +117,101 @@ public class ImageManager {
             cachePath = context.getCacheDir().getPath();
         }
 
-        File result = new File(cachePath + File.separatorChar + DISK_CACHE_DIR);
+        File result = new File(cachePath + File.separatorChar + cacheName);
         if (!result.exists()) {
             result.mkdir();
         }
         return result;
     }
 
+    /**
+     * Create an ImageManager using the default options. Note that this will create a single background thread to use
+     * to resize and load images from disk. Must be created in the UI thread!
+     *
+     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
+     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
+     *                in Activities.
+     */
     public ImageManager(Context context) {
         this(context, new Options());
     }
 
+    /**
+     * Create an ImageManager using the given options. Note that this will create a single background thread to use
+     * to resize and load images from disk. Must be created in the UI thread!
+     *
+     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
+     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
+     *                in Activities.
+     * @param options The specified Options
+     */
     public ImageManager(Context context, Options options) {
         this(context, new HandlerExecutor(), options);
     }
 
+    /**
+     * Create an ImageManager using the given options and that performs image loads and resize operations using the
+     * given Executor. Must be created in the UI thread!
+     *
+     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
+     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
+     *                in Activities.
+     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     *                 UI thread!
+     * @param options The specified options
+     */
     public ImageManager(Context context, Executor executor, Options options) {
         this(context, executor, new Handler(), options);
     }
 
+    /**
+     * Create an ImageManager using the given options and that performs image loads and resize operations using the
+     * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
+     *
+     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
+     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
+     *                in Activities.
+     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     *                 UI thread!
+     * @param mainHandler A Handler to the UI thread.
+     * @param options The specified options
+     */
     public ImageManager(Context context, Executor executor, Handler mainHandler, Options options) {
         this(context, getPhotoCacheDir(context), executor, mainHandler, options);
     }
 
+    /**
+     * Create an ImageManager using the given options and that performs image loads and resize operations using the
+     * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
+     *
+     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
+     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
+     *                in Activities.
+     * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
+     *                     already exist
+     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     *                 UI thread!
+     * @param mainHandler A Handler to the UI thread.
+     * @param options The specified options
+     */
     public ImageManager(Context context, File diskCacheDir, Executor executor, Handler mainHandler, Options options) {
         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
+
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
         }
 
-        if (diskCacheDir == null || !options.useDiskCache || options.maxDiskCacheSize <= 0) {
+        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
+            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
+        }
+
+        if (diskCacheDir == null || !options.useDiskCache) {
             diskCache = null;
         } else {
             diskCache = new PhotoDiskCache(diskCacheDir, options.maxDiskCacheSize, options.appVersion);
         }
 
-        if (!options.useMemoryCache || options.maxMemorySize <= 0) {
+        if (!options.useMemoryCache) {
             memoryCache = null;
         } else {
             memoryCache = new LruPhotoCache(options.maxMemorySize);
@@ -129,9 +237,10 @@ public class ImageManager {
     }
 
     /**
-     * Loads the image for the given id
-     * @param path - the path id to the image
-     * @param cb - the callback called when the load completes
+     * Loads the image at the given path at its original dimensions.
+     *
+     * @param path The path id to the image
+     * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
     public Object getImage(final String path, final LoadedCallback cb){
@@ -145,11 +254,12 @@ public class ImageManager {
     }
 
     /**
-     * Loads the image for the given id assuming its width and height are exactly those given
-     * @param path - the path to the image
-     * @param width - the width of the image on disk
-     * @param height - the height of the image on disk
-     * @param cb - the callback called when the load completes
+     * Loads the image for the given path assuming its width and height are exactly those given.
+     *
+     * @param path The path to the image
+     * @param width The width of the image on disk
+     * @param height The height of the image on disk
+     * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
@@ -163,11 +273,12 @@ public class ImageManager {
     }
 
     /**
-     * Loads the image for the given id to nearly the given width and height maintaining the original proportions
-     * @param path - the id of the image
-     * @param width - the desired width in pixels
-     * @param height - the desired height of the slice
-     * @param cb - the callback called when the task finishes
+     * Loads the image for the given path to nearly the given width and height maintaining the original proportions.
+     *
+     * @param path The id of the image
+     * @param width The desired width in pixels
+     * @param height The desired height of the slice
+     * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
@@ -181,12 +292,13 @@ public class ImageManager {
     }
 
     /**
-     * Loads the image for the given id, resizes it to be exactly width pixels wide keeping proportions,
-     * and then returns a section from the center of image exactly height pixels tall
-     * @param path - the id of the image
-     * @param width - the desired width in pixels
-     * @param height - the desired height of the slice
-     * @param cb - the callback called when the task finishes
+     * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
+     * and then returns a section from the center of image exactly height pixels tall.
+     *
+     * @param path The id of the image
+     * @param width The desired width in pixels
+     * @param height The desired height of the slice
+     * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
@@ -202,10 +314,11 @@ public class ImageManager {
     /**
      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
      * an area of width*height.
-     * @param path - the id of the image
-     * @param width - the width of the space
-     * @param height - the height of the space
-     * @param cb - the callback called when the task finishes
+     *
+     * @param path The id of the image
+     * @param width The width of the space
+     * @param height The height of the space
+     * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
@@ -218,6 +331,60 @@ public class ImageManager {
         });
     }
 
+    /**
+     * Notify the ImageManager that a bitmap it loaded is not going to be displayed and can go into a queue to be
+     * reused. Does nothing if recycling is disabled or impossible.
+     *
+     * @param b The rejected Bitmap
+     */
+    public void rejectBitmap(Bitmap b) {
+        if (!isBitmapRecyclingEnabled) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
+        if (currentCount == null || currentCount == 0) {
+            bitmapReferenceCounter.remove(b.hashCode());
+            bitmapCache.put(b);
+        }
+    }
+
+    /**
+     * Notify the ImageManager that a Bitmap it loaded is going to be used and increment the reference counter for that
+     * Bitmap. Though it won't cause a memory leak, we expect releaseBitmap to be called for this Bitmap at some point.
+     * If release is not called, then we will never be able to recycle the Bitmap. Does nothing if recycling is disabled
+     * or impossible.
+     *
+     * @param b The acquired Bitmap
+     */
+    public void acquireBitmap(Bitmap b) {
+        if (!isBitmapRecyclingEnabled) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
+        if (currentCount == null) {
+            currentCount = 0;
+        }
+        bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
+    }
+
+    /**
+     * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
+     * that Bitmap. This will cause an exception if acquire was not called first, or if each call to release does not
+     * come after a call to acquire. If the reference count drops to zero, places the Bitmap into a queue to be
+     * recycled. Does nothing if recycling is disabled or impossible.
+     *
+     * @param b The releasedBitmap
+     */
+    public void releaseBitmap(Bitmap b) {
+        if (!isBitmapRecyclingEnabled) return;
+
+        Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
+        if (currentCount == 0) {
+            bitmapReferenceCounter.remove(b.hashCode());
+            bitmapCache.put(b);
+        } else {
+            bitmapReferenceCounter.put(b.hashCode(), currentCount);
+        }
+    }
+
     private Object runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
         final Object token = cb;
         if (!returnFromCache(key, cb)) {
@@ -291,6 +458,7 @@ public class ImageManager {
         protected abstract Bitmap resizeIfNotFound();
     }
 
+
     private InputStream getFromDiskCache(String key) {
         InputStream result = null;
         if (diskCache != null) {
@@ -319,38 +487,6 @@ public class ImageManager {
         }
     }
 
-    public void rejectBitmap(Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
-        if (currentCount == null || currentCount == 0) {
-            bitmapReferenceCounter.remove(b.hashCode());
-            bitmapCache.put(b);
-        }
-    }
-
-    public void acquireBitmap(Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
-        if (currentCount == null) {
-            currentCount = 0;
-        }
-        bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
-    }
-
-    public void releaseBitmap(Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
-        if (currentCount == 0) {
-            bitmapReferenceCounter.remove(b.hashCode());
-            bitmapCache.put(b);
-        } else {
-            bitmapReferenceCounter.put(b.hashCode(), currentCount);
-        }
-    }
-
     private static String getKey(String path, int width, int height, ResizeType type){
         return path + width + ""_"" + height + type.name();
     }
","23  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
24  * sdk version, uses a  combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
25  * load and resize  * operations performed and to maximize the number of times Bitmaps are recycled as opposed to
26  * allocated.
27  *
28  * If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible. Note
29  * that Bitmap recycling is only available on Honeycomb and up.
33     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
35     /**
36      * A class for setting options for an ImageManager
37      *
38      * Boolean use options for the caches superseed sizes, and invalid * sizes (<= 0) are equivalent to setting the
39      * corresponding use option to false.
40      */
42         /**
43          * @see com.jakewharton.DiskLruCache#open(java.io.File, int, int, long)
44          */
47         /**
48          * If true caches bitmaps in memory.
49          *
50          * Defaults to true
51          */
53 
54         /**
55          * The maximum memory cache size. This should be decreased on devices where recycling Bitmaps is possible and
56          * enabled because the Bitmap cache used to recycle Bitmaps will take a substantial amount of memory.
57          *
58          * Defaults to 1/8th of the total application memory
59          */
62         /**
63          * If true, caches resized bitmaps on disk.
64          */
67         /**
68          * The maximum disk cache size.
69          *
70          * Defaults to 30mb
71          */
72         public int maxDiskCacheSize;
73 
74         /**
75          * If true, will attempt to recycle Bitmaps and all loaded Bitmaps will be mutable. If true and a memory cache
76          * is used, the memory cache size should be decreased since the Bitmap cache used to recycle Bitmaps will
77          * take a substantial amount of memory.
78          *
79          * Defaults to true if Android version is 3.0 or greater and will always be false, regardless of this attribute
80          * otherwise.
81          */
103     /**
104      * Try to get the external cache directory if available and default to the internal. Use a default name for the
105      * cache directory if no name is provided
106      */
108         return getPhotoCacheDir(context, DISK_CACHE_DIR);
109     }
110 
111     public static File getPhotoCacheDir(Context context, String cacheName) {
120         File result = new File(cachePath + File.separatorChar + cacheName);
127     /**
128      * Create an ImageManager using the default options. Note that this will create a single background thread to use
129      * to resize and load images from disk. Must be created in the UI thread!
130      *
131      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
132      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
133      *                in Activities.
134      */
139     /**
140      * Create an ImageManager using the given options. Note that this will create a single background thread to use
141      * to resize and load images from disk. Must be created in the UI thread!
142      *
143      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
144      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
145      *                in Activities.
146      * @param options The specified Options
147      */
152     /**
153      * Create an ImageManager using the given options and that performs image loads and resize operations using the
154      * given Executor. Must be created in the UI thread!
155      *
156      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
157      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
158      *                in Activities.
159      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
160      *                 UI thread!
161      * @param options The specified options
162      */
167     /**
168      * Create an ImageManager using the given options and that performs image loads and resize operations using the
169      * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
170      *
171      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
172      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
173      *                in Activities.
174      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
175      *                 UI thread!
176      * @param mainHandler A Handler to the UI thread.
177      * @param options The specified options
178      */
183     /**
184      * Create an ImageManager using the given options and that performs image loads and resize operations using the
185      * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
186      *
187      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
188      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
189      *                in Activities.
190      * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
191      *                     already exist
192      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
193      *                 UI thread!
194      * @param mainHandler A Handler to the UI thread.
195      * @param options The specified options
196      */
199 
204         if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
205             options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
206         }
207 
208         if (diskCacheDir == null || !options.useDiskCache) {
214         if (!options.useMemoryCache) {
240      * Loads the image at the given path at its original dimensions.
241      *
242      * @param path The path id to the image
243      * @param cb The callback called when the load completes
257      * Loads the image for the given path assuming its width and height are exactly those given.
258      *
259      * @param path The path to the image
260      * @param width The width of the image on disk
261      * @param height The height of the image on disk
262      * @param cb The callback called when the load completes
276      * Loads the image for the given path to nearly the given width and height maintaining the original proportions.
277      *
278      * @param path The id of the image
279      * @param width The desired width in pixels
280      * @param height The desired height of the slice
281      * @param cb The callback called when the task finishes
295      * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
296      * and then returns a section from the center of image exactly height pixels tall.
297      *
298      * @param path The id of the image
299      * @param width The desired width in pixels
300      * @param height The desired height of the slice
301      * @param cb The callback called when the task finishes
317      *
318      * @param path The id of the image
319      * @param width The width of the space
320      * @param height The height of the space
321      * @param cb The callback called when the task finishes
334     /**
335      * Notify the ImageManager that a bitmap it loaded is not going to be displayed and can go into a queue to be
336      * reused. Does nothing if recycling is disabled or impossible.
337      *
338      * @param b The rejected Bitmap
339      */
340     public void rejectBitmap(Bitmap b) {
341         if (!isBitmapRecyclingEnabled) return;
342 
343         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
344         if (currentCount == null || currentCount == 0) {
345             bitmapReferenceCounter.remove(b.hashCode());
346             bitmapCache.put(b);
347         }
348     }
349 
350     /**
351      * Notify the ImageManager that a Bitmap it loaded is going to be used and increment the reference counter for that
352      * Bitmap. Though it won't cause a memory leak, we expect releaseBitmap to be called for this Bitmap at some point.
353      * If release is not called, then we will never be able to recycle the Bitmap. Does nothing if recycling is disabled
354      * or impossible.
355      *
356      * @param b The acquired Bitmap
357      */
358     public void acquireBitmap(Bitmap b) {
359         if (!isBitmapRecyclingEnabled) return;
360 
361         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
362         if (currentCount == null) {
363             currentCount = 0;
364         }
365         bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
366     }
367 
368     /**
369      * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
370      * that Bitmap. This will cause an exception if acquire was not called first, or if each call to release does not
371      * come after a call to acquire. If the reference count drops to zero, places the Bitmap into a queue to be
372      * recycled. Does nothing if recycling is disabled or impossible.
373      *
374      * @param b The releasedBitmap
375      */
376     public void releaseBitmap(Bitmap b) {
377         if (!isBitmapRecyclingEnabled) return;
378 
379         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
380         if (currentCount == 0) {
381             bitmapReferenceCounter.remove(b.hashCode());
382             bitmapCache.put(b);
383         } else {
384             bitmapReferenceCounter.put(b.hashCode(), currentCount);
385         }
386     }
387 
461 
23  * Created by IntelliJ IDEA.
24  * User: sam
25  * Date: 2/9/12
26  * Time: 5:02 PM
27  * To change this template use File | Settings | File Templates.
39         public int maxDiskCacheSize = 10 * 1024 * 1024;
71         File result = new File(cachePath + File.separatorChar + DISK_CACHE_DIR);
100         if (diskCacheDir == null || !options.useDiskCache || options.maxDiskCacheSize <= 0) {
106         if (!options.useMemoryCache || options.maxMemorySize <= 0) {
132      * Loads the image for the given id
133      * @param path - the path id to the image
134      * @param cb - the callback called when the load completes
148      * Loads the image for the given id assuming its width and height are exactly those given
149      * @param path - the path to the image
150      * @param width - the width of the image on disk
151      * @param height - the height of the image on disk
152      * @param cb - the callback called when the load completes
166      * Loads the image for the given id to nearly the given width and height maintaining the original proportions
167      * @param path - the id of the image
168      * @param width - the desired width in pixels
169      * @param height - the desired height of the slice
170      * @param cb - the callback called when the task finishes
184      * Loads the image for the given id, resizes it to be exactly width pixels wide keeping proportions,
185      * and then returns a section from the center of image exactly height pixels tall
186      * @param path - the id of the image
187      * @param width - the desired width in pixels
188      * @param height - the desired height of the slice
189      * @param cb - the callback called when the task finishes
205      * @param path - the id of the image
206      * @param width - the width of the space
207      * @param height - the height of the space
208      * @param cb - the callback called when the task finishes
322     public void rejectBitmap(Bitmap b) {
323         if (!isBitmapRecyclingEnabled) return;
324 
325         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
326         if (currentCount == null || currentCount == 0) {
327             bitmapReferenceCounter.remove(b.hashCode());
328             bitmapCache.put(b);
329         }
330     }
331 
332     public void acquireBitmap(Bitmap b) {
333         if (!isBitmapRecyclingEnabled) return;
334 
335         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
336         if (currentCount == null) {
337             currentCount = 0;
338         }
339         bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
340     }
341 
342     public void releaseBitmap(Bitmap b) {
343         if (!isBitmapRecyclingEnabled) return;
344 
345         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
346         if (currentCount == 0) {
347             bitmapReferenceCounter.remove(b.hashCode());
348             bitmapCache.put(b);
349         } else {
350             bitmapReferenceCounter.put(b.hashCode(), currentCount);
351         }
352     }
353 ",No
src\com\bumptech\photos\resize\ImageResizer.java,src\com\bumptech\photos\resize\ImageResizer.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -20,21 +20,36 @@ import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * @author sam
- *
+ * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
-
     private final SizedBitmapCache bitmapCache;
 
+    /**
+     * Creates a new resizer that will not recycle Bitmaps
+     */
     public ImageResizer() {
         this(null);
     }
 
+    /**
+     * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
+     *
+     * @param bitmapCache The cache to try to recycle {@link android.graphics.Bitmap}s from
+     */
     public ImageResizer(SizedBitmapCache bitmapCache){
         this.bitmapCache = bitmapCache;
     }
 
+    /**
+     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
+     * and then crop the image down so that it fills the given dimensions
+     *
+     * @param path The path where the image is located
+     * @param width The width the final image will fill
+     * @param height The height the final image will fill
+     * @return The resized image
+     */
     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
         final Bitmap streamed = streamIn(path, width, height);
 
@@ -45,15 +60,43 @@ public class ImageResizer {
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
+    /**
+     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
+     * and then shrink the image down, again maintaining the original proportions, so that it fits entirely within the
+     * given dimensions.
+     *
+     * @param path The path where the image is located
+     * @param width The width the final image will fit within
+     * @param height The height the final image will fit within
+     * @return The resized image
+     */
     public Bitmap fitInSpace(final String path, final int width, final int height){
         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
+    /**
+     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions
+     *
+     * @param path The path where the image is located
+     * @param width The target width
+     * @param height The target height
+     * @return The resized image
+     */
     public Bitmap loadApproximate(final String path, final int width, final int height){
         return streamIn(path, width, height);
     }
 
+    /**
+     * Load the image represented by the given InputStreams at its original size. Use the first InputStream to
+     * try to determine the proportions of the image so that we can try to retrieve a recycled Bitmap of the correct
+     * size. Use the second InputStream to actually load the image into a Bitmap. Note both InputStreams must represent
+     * the same image and this method will close both InputStreams.
+     *
+     * @param is1 The InputStream used to get the dimensions of the image
+     * @param is2 The InputStream used to load the image into memory
+     * @return The loaded image
+     */
     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
         int[] dimens = new int[] {-1, -1};
         try {
@@ -62,7 +105,7 @@ public class ImageResizer {
             try {
                 is1.close();
             } catch (IOException e) {
-                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                e.printStackTrace();
             }
         }
         Bitmap resized = null;
@@ -72,16 +115,37 @@ public class ImageResizer {
             try {
                 is2.close();
             } catch (IOException e) {
-                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                e.printStackTrace();
             }
         }
         return resized;
     }
 
+    /**
+     * Load the image at the given path at its original size. Assume that the dimensions of the image at the given path
+     * will match the given dimensions and use the given dimensions to retrieve a recycled Bitmap of the correct size.
+     * Note this method will throw an exception if the dimensions of the image at the given path do not exactly match
+     * the given dimensions and there is a bitmap of the given dimensions available to be recycled.
+     *
+     * The dimensions are given to avoid opening an InputStream specifically to determine the size of the image at the
+     * given path and should be used when the dimensions of the image are known.
+     *
+     * @param path The path where the image is stored
+     * @param width The width of the image at the given path
+     * @param height The height of the image at the given path
+     * @return The loaded image
+     */
     public Bitmap loadAsIs(final String path, final int width, final int height) {
         return load(path, getRecycled(width, height));
     }
 
+    /**
+     * Load the image at the given path at its original size. Will create a second InputStream to first try to determine
+     * the size of the image to attempt to retrieve a recycled Bitmap.
+     *
+     * @param path The path where the image is stored
+     * @return The loaded image
+     */
     public Bitmap loadAsIs(final String path){
         int[] dimens = getDimensions(path);
         return load(path, getRecycled(dimens));
@@ -99,10 +163,31 @@ public class ImageResizer {
         return result;
     }
 
+    /**
+     * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
+     * the original proportions of the image
+     *
+     * @param toCrop The Bitmap to crop
+     * @param width The width of the final Bitmap
+     * @param height The height of the final Bitmap
+     * @return The resized image
+     */
     public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
         return centerCrop(null, toCrop, width, height);
     }
 
+    /**
+     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
+     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
+     * as well.
+     *
+     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
+     *                 into
+     * @param toCrop The Bitmap to resize
+     * @param width The width of the final Bitmap
+     * @param height The height of the final Bitmap
+     * @return The resized Bitmap (will be recycled if recycled is not null)
+     */
     public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
         if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
             return toCrop;
@@ -133,6 +218,14 @@ public class ImageResizer {
         return result;
     }
 
+    /**
+     * An expensive operation to crop the given Bitmap to the given width by removing equal amounts from either side
+     * so that the center of image remains
+     *
+     * @param toCrop The Bitmap to crop
+     * @param width The width to crop the Bitmap to
+     * @return A new Bitmap cropped to the given width, or toCrop if toCrop's width is equivalent to the given width
+     */
     public static Bitmap cropToWidth(Bitmap toCrop, int width) {
         Bitmap cropped = toCrop;
         if (toCrop.getWidth() > width) {
@@ -144,6 +237,15 @@ public class ImageResizer {
 
     //crops a section height pixels tall in the center of the image with equal
     //amounts discarded above and below
+
+    /**
+     * An expensive operation to crop the given Bitmap to the given height by removing equal amounts from the top and
+     * bottom so that the center of the image remains
+     *
+     * @param toCrop The Bitmap to crop
+     * @param height The height to crop the Bitmap to
+     * @return A new Bitmap cropped to the given height, or toCrop if toCrop's height is equivalent to the given height
+     */
     public static Bitmap cropToHeight(Bitmap toCrop, int height){
         Bitmap cropped = toCrop;
         if (toCrop.getHeight() > height){
@@ -154,21 +256,54 @@ public class ImageResizer {
     }
 
     //shrinks to the given width, shrinking the height to maintain the original image proportions
+
+    /**
+     * An expensive operation to resize the given image, maintaining the original proportions, so that its width
+     * matches the given width
+     *
+     * @param toShrink The Bitmap to shrink
+     * @param width The width of the final Bitmap
+     * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
+     */
     public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
-        //get exactly the right width
+        Bitmap shrunk = toShrink;
         float widthPercent = ((float) width/toShrink.getWidth());
+        if (widthPercent != 1) {
             int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
-        Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
+            shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
+        }
         return shrunk;
     }
 
+    /**
+     * An expensive operation to resize the given image, maintaining the original proportions, so that its height
+     * matches the given height
+     *
+     * @param toShrink The Bitmap to shrink
+     * @param height The height of the final Bitmap
+     * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
+     *          height
+     */
     public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
+        Bitmap shrunk = toShrink;
         float heightPercent = ((float) height/toShrink.getHeight());
+        if (heightPercent != 1) {
             int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
-        Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
+            shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
+        }
         return shrunk;
     }
 
+    /**
+     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
+     * the original proportions
+     *
+     * @param toFit The Bitmap to shrink
+     * @param width The width the final image will fit within
+     * @param height The height the final image will fit within
+     * @return A new Bitmap shrunk to fit within the given dimesions, or toFit if toFit's width or height matches the
+     * given dimensions and toFit fits within the given dimensions
+     */
     public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
         if (height > width){
             return shrinkToWidth(toFit, width);
@@ -177,10 +312,28 @@ public class ImageResizer {
         }
     }
 
+    /**
+     * An expensive operation to load the image at the given path
+     *
+     * @param path The path where the image is stored
+     * @return A Bitmap representing the image at the given path
+     */
     public static Bitmap load(String path) {
         return load(path, null);
     }
 
+    /**
+     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
+     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
+     * of memory.
+     *
+     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
+     * is provided.
+     *
+     * @param path The path where the image is stored
+     * @param recycle A Bitmap we can load the image into, or null
+     * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
+     */
     public static Bitmap load(String path, Bitmap recycle) {
         Bitmap result = null;
         try {
@@ -192,10 +345,28 @@ public class ImageResizer {
         return result == null ? null : orientImage(path, result);
     }
 
+    /**
+     * An expensive operation to load the image from the given InputStream
+     *
+     * @param is The input stream representing the image data
+     * @return A Bitmap representing the image at the given path
+     */
     public static Bitmap load(InputStream is) {
         return load(is, null);
     }
 
+    /**
+     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
+     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
+     * of memory.
+     *
+     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
+     * is provided.
+     *
+     * @param is The InputStream representing the image data
+     * @param recycle A Bitmap we can load the image into, or null
+     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
+     */
     public static Bitmap load(InputStream is, Bitmap recycle){
         final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
         decodeBitmapOptions.inSampleSize = 1;
@@ -220,6 +391,12 @@ public class ImageResizer {
         return result;
     }
 
+    /**
+     * A method for getting the dimensions of an image at the given path
+     *
+     * @param path The path wher ethe image is stored
+     * @return an array containing the dimensions of the image in the form {width, height}
+     */
     public static int[] getDimensions(String path) {
         int[] dimens = new int[]{-1, -1};
         try {
@@ -234,14 +411,31 @@ public class ImageResizer {
         return dimens;
     }
 
+     /**
+     * A method for getting the dimensions of an image from the given InputStream
+     *
+     * @param is The InputStream representing the image
+     * @return an array containing the dimensions of the image in the form {width, height}
+     */
      public static int[] getDimension(InputStream is) {
         final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
         decodeBoundsOptions.inJustDecodeBounds = true;
         BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
-    //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
-    //streams in to near, but not exactly at the desired width and height.
+
+
+    /**
+     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
+     * rotate the image according to the orientation in the images EXIF data if available.
+     *
+     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
+     *
+     * @param path The path where the image is stored
+     * @param width The target width
+     * @param height The target height
+     * @return A Bitmap containing the image
+     */
     public static Bitmap streamIn(String path, int width, int height) {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
@@ -285,6 +479,7 @@ public class ImageResizer {
         }
         return result;
     }
+
    /**
      * Returns a matrix with rotation set based on Exif orientation tag.
      * If the orientation is undefined or 0 null is returned.
","23  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
28     /**
29      * Creates a new resizer that will not recycle Bitmaps
30      */
35     /**
36      * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
37      *
38      * @param bitmapCache The cache to try to recycle {@link android.graphics.Bitmap}s from
39      */
44     /**
45      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
46      * and then crop the image down so that it fills the given dimensions
47      *
48      * @param path The path where the image is located
49      * @param width The width the final image will fill
50      * @param height The height the final image will fill
51      * @return The resized image
52      */
63     /**
64      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
65      * and then shrink the image down, again maintaining the original proportions, so that it fits entirely within the
66      * given dimensions.
67      *
68      * @param path The path where the image is located
69      * @param width The width the final image will fit within
70      * @param height The height the final image will fit within
71      * @return The resized image
72      */
78     /**
79      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions
80      *
81      * @param path The path where the image is located
82      * @param width The target width
83      * @param height The target height
84      * @return The resized image
85      */
90     /**
91      * Load the image represented by the given InputStreams at its original size. Use the first InputStream to
92      * try to determine the proportions of the image so that we can try to retrieve a recycled Bitmap of the correct
93      * size. Use the second InputStream to actually load the image into a Bitmap. Note both InputStreams must represent
94      * the same image and this method will close both InputStreams.
95      *
96      * @param is1 The InputStream used to get the dimensions of the image
97      * @param is2 The InputStream used to load the image into memory
98      * @return The loaded image
99      */
108                 e.printStackTrace();
118                 e.printStackTrace();
124     /**
125      * Load the image at the given path at its original size. Assume that the dimensions of the image at the given path
126      * will match the given dimensions and use the given dimensions to retrieve a recycled Bitmap of the correct size.
127      * Note this method will throw an exception if the dimensions of the image at the given path do not exactly match
128      * the given dimensions and there is a bitmap of the given dimensions available to be recycled.
129      *
130      * The dimensions are given to avoid opening an InputStream specifically to determine the size of the image at the
131      * given path and should be used when the dimensions of the image are known.
132      *
133      * @param path The path where the image is stored
134      * @param width The width of the image at the given path
135      * @param height The height of the image at the given path
136      * @return The loaded image
137      */
142     /**
143      * Load the image at the given path at its original size. Will create a second InputStream to first try to determine
144      * the size of the image to attempt to retrieve a recycled Bitmap.
145      *
146      * @param path The path where the image is stored
147      * @return The loaded image
148      */
166     /**
167      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
168      * the original proportions of the image
169      *
170      * @param toCrop The Bitmap to crop
171      * @param width The width of the final Bitmap
172      * @param height The height of the final Bitmap
173      * @return The resized image
174      */
179     /**
180      * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
181      * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
182      * as well.
183      *
184      * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
185      *                 into
186      * @param toCrop The Bitmap to resize
187      * @param width The width of the final Bitmap
188      * @param height The height of the final Bitmap
189      * @return The resized Bitmap (will be recycled if recycled is not null)
190      */
221     /**
222      * An expensive operation to crop the given Bitmap to the given width by removing equal amounts from either side
223      * so that the center of image remains
224      *
225      * @param toCrop The Bitmap to crop
226      * @param width The width to crop the Bitmap to
227      * @return A new Bitmap cropped to the given width, or toCrop if toCrop's width is equivalent to the given width
228      */
240 
241     /**
242      * An expensive operation to crop the given Bitmap to the given height by removing equal amounts from the top and
243      * bottom so that the center of the image remains
244      *
245      * @param toCrop The Bitmap to crop
246      * @param height The height to crop the Bitmap to
247      * @return A new Bitmap cropped to the given height, or toCrop if toCrop's height is equivalent to the given height
248      */
259 
260     /**
261      * An expensive operation to resize the given image, maintaining the original proportions, so that its width
262      * matches the given width
263      *
264      * @param toShrink The Bitmap to shrink
265      * @param width The width of the final Bitmap
266      * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
267      */
269         Bitmap shrunk = toShrink;
271         if (widthPercent != 1) {
273             shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
274         }
278     /**
279      * An expensive operation to resize the given image, maintaining the original proportions, so that its height
280      * matches the given height
281      *
282      * @param toShrink The Bitmap to shrink
283      * @param height The height of the final Bitmap
284      * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
285      *          height
286      */
288         Bitmap shrunk = toShrink;
290         if (heightPercent != 1) {
292             shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
293         }
297     /**
298      * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
299      * the original proportions
300      *
301      * @param toFit The Bitmap to shrink
302      * @param width The width the final image will fit within
303      * @param height The height the final image will fit within
304      * @return A new Bitmap shrunk to fit within the given dimesions, or toFit if toFit's width or height matches the
305      * given dimensions and toFit fits within the given dimensions
306      */
315     /**
316      * An expensive operation to load the image at the given path
317      *
318      * @param path The path where the image is stored
319      * @return A Bitmap representing the image at the given path
320      */
325     /**
326      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
327      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
328      * of memory.
329      *
330      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
331      * is provided.
332      *
333      * @param path The path where the image is stored
334      * @param recycle A Bitmap we can load the image into, or null
335      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
336      */
348     /**
349      * An expensive operation to load the image from the given InputStream
350      *
351      * @param is The input stream representing the image data
352      * @return A Bitmap representing the image at the given path
353      */
358     /**
359      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
360      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
361      * of memory.
362      *
363      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
364      * is provided.
365      *
366      * @param is The InputStream representing the image data
367      * @param recycle A Bitmap we can load the image into, or null
368      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
369      */
394     /**
395      * A method for getting the dimensions of an image at the given path
396      *
397      * @param path The path wher ethe image is stored
398      * @return an array containing the dimensions of the image in the form {width, height}
399      */
414      /**
415      * A method for getting the dimensions of an image from the given InputStream
416      *
417      * @param is The InputStream representing the image
418      * @return an array containing the dimensions of the image in the form {width, height}
419      */
426 
427 
428     /**
429      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
430      * rotate the image according to the orientation in the images EXIF data if available.
431      *
432      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
433      *
434      * @param path The path where the image is stored
435      * @param width The target width
436      * @param height The target height
437      * @return A Bitmap containing the image
438      */
482 
23  * @author sam
24  *
27 
65                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
75                 e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
158         //get exactly the right width
161         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
168         Bitmap shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
243     //from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
244     //streams in to near, but not exactly at the desired width and height.",No
src\com\bumptech\photos\resize\cache\LruPhotoCache.java,src\com\bumptech\photos\resize\cache\LruPhotoCache.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -10,11 +10,9 @@ import android.graphics.Bitmap;
 import android.support.v4.util.LruCache;
 
 /**
- * Created by IntelliJ IDEA.
- * User: sam
- * Date: 2/9/12
- * Time: 5:57 PM
- * To change this template use File | Settings | File Templates.
+ * A thin wrapper around the LruCache provided in the Android support libraries.
+ *
+ * @see android.support.v4.util.LruCache
  */
 public class LruPhotoCache{
     private static final float SIZE_RATIO = 1f/8f;
","13  * A thin wrapper around the LruCache provided in the Android support libraries.
14  *
15  * @see android.support.v4.util.LruCache
13  * Created by IntelliJ IDEA.
14  * User: sam
15  * Date: 2/9/12
16  * Time: 5:57 PM
17  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -14,11 +14,9 @@ import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
 /**
- * Created by IntelliJ IDEA.
- * User: sam
- * Date: 10/20/12
- * Time: 1:25 PM
- * To change this template use File | Settings | File Templates.
+ * A thin wrapper around Jake Wharton's disk cache library.
+ *
+ * @see com.jakewharton.DiskLruCache
  */
 public class PhotoDiskCache {
     private final static int VALUE_COUNT = 1; //values per cache entry
@@ -83,12 +81,12 @@ public class PhotoDiskCache {
 
         } catch (IOException e) {
             Log.d(""DLRU: IOException? key="" + key);
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            e.printStackTrace();
             try {
                 cache.remove(safeKey);
             } catch (IOException e1) {
                 Log.d(""DLRU: error removing bitmap key="" + key);
-                e1.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                e1.printStackTrace();
             }
         }
 
@@ -103,7 +101,7 @@ public class PhotoDiskCache {
             digest.update(bytes, 0, bytes.length);
             hash = new BigInteger(1, digest.digest()).toString(16);
         } catch (NoSuchAlgorithmException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+            e.printStackTrace();
         }
         return hash;
     }
","17  * A thin wrapper around Jake Wharton's disk cache library.
18  *
19  * @see com.jakewharton.DiskLruCache
84             e.printStackTrace();
89                 e1.printStackTrace();
104             e.printStackTrace();
17  * Created by IntelliJ IDEA.
18  * User: sam
19  * Date: 10/20/12
20  * Time: 1:25 PM
21  * To change this template use File | Settings | File Templates.
86             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
91                 e1.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
106             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -13,11 +13,7 @@ import java.util.Map;
 import java.util.Queue;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 4:31 PM
- * To change this template use File | Settings | File Templates.
+ * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
 public class SizedBitmapCache {
     private static final int MAX_PER_SIZE = 20;
","16  * A cache of Bitmaps made available by size used to manage recycled bitmaps
16  * Created with IntelliJ IDEA.
17  * User: sam
18  * Date: 12/25/12
19  * Time: 4:31 PM
20  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\Approximate.java,src\com\bumptech\photos\resize\loader\Approximate.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -9,11 +9,11 @@ import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:58 PM
- * To change this template use File | Settings | File Templates.
+ * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
+ * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
+ * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
+ *
+ * @see ImageManager#getImageApproximate(String, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
 public class Approximate<T> extends ImageManagerLoader<T> {
 
","12  * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
13  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
14  * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
15  *
16  * @see ImageManager#getImageApproximate(String, int, int, com.bumptech.photos.resize.LoadedCallback)
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:58 PM
16  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\AsIs.java,src\com\bumptech\photos\resize\loader\AsIs.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -5,11 +5,12 @@ import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/31/12
- * Time: 4:56 PM
- * To change this template use File | Settings | File Templates.
+ * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
+ * when an image is roughly the same size as the view that will display it and you want to use some external process
+ * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
+ * other implementations
+ *
+ * @see ImageManager#getImage(String, com.bumptech.photos.resize.LoadedCallback)
  */
 public class AsIs<T> extends ImageManagerLoader<T> {
 
","8  * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
9  * when an image is roughly the same size as the view that will display it and you want to use some external process
10  * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
11  * other implementations
12  *
13  * @see ImageManager#getImage(String, com.bumptech.photos.resize.LoadedCallback)
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 12/31/12
11  * Time: 4:56 PM
12  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\CenterCrop.java,src\com\bumptech\photos\resize\loader\CenterCrop.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -9,11 +9,9 @@ import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:54 PM
- * To change this template use File | Settings | File Templates.
+ * An ImageLoader implementation that loads and crops in image down to the given width and height.
+ *
+ * @see ImageManager#centerCrop(String, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
 public class CenterCrop<T> extends ImageManagerLoader<T> {
 
","12  * An ImageLoader implementation that loads and crops in image down to the given width and height.
13  *
14  * @see ImageManager#centerCrop(String, int, int, com.bumptech.photos.resize.LoadedCallback)
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:54 PM
16  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\Exact.java,src\com\bumptech\photos\resize\loader\Exact.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -9,11 +9,12 @@ import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:57 PM
- * To change this template use File | Settings | File Templates.
+ * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
+ * will exactly match the width and height of the view that will display it. Less expensive than other implementations,
+ * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
+ * resize).
+ *
+ * @see ImageManager#getImageExact(String, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
 public class Exact<T> extends ImageManagerLoader<T> {
 
","12  * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
13  * will exactly match the width and height of the view that will display it. Less expensive than other implementations,
14  * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
15  * resize).
16  *
17  * @see ImageManager#getImageExact(String, int, int, com.bumptech.photos.resize.LoadedCallback)
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:57 PM
16  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\FitCenter.java,src\com\bumptech\photos\resize\loader\FitCenter.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -9,11 +9,10 @@ import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 12/25/12
- * Time: 10:56 PM
- * To change this template use File | Settings | File Templates.
+ * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
+ * proportions
+ *
+ * @see ImageManager#fitCenter(String, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
 public class FitCenter<T> extends ImageManagerLoader<T> {
 
","12  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
13  * proportions
14  *
15  * @see ImageManager#fitCenter(String, int, int, com.bumptech.photos.resize.LoadedCallback)
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 12/25/12
15  * Time: 10:56 PM
16  * To change this template use File | Settings | File Templates.",No
src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,06371e3cdb68be5ea7e8e2f9c2e6e2a3831dc8d6,"Lots of documentation and a few name changes

Removes Asset from everywhere...","@@ -5,11 +5,8 @@ import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.loader.image.BaseImageLoader;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/1/13
- * Time: 2:51 PM
- * To change this template use File | Settings | File Templates.
+ * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
+ * purposes.
  */
 public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
 
","8  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
9  * purposes.
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 1/1/13
11  * Time: 2:51 PM
12  * To change this template use File | Settings | File Templates.",No
.gitignore,.gitignore,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,"@@ -1,6 +1,8 @@
-bin/*
-gen/*
-local.properties
+library/bin/*
+library/gen/*
+library/local.properties
 *.iml
 .idea/*
+*.DS_Store
+*.swp
 proguard-project.txt
","1 library/bin/*
2 library/gen/*
3 library/local.properties
6 *.DS_Store
7 *.swp
1 bin/*
2 gen/*
3 local.properties",No
AndroidManifest.xml,library\AndroidManifest.xml,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
ant.properties,library\ant.properties,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
build.xml,library\build.xml,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
libs\android-support-v4.jar,library\libs\android-support-v4.jar,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
libs\disklrucache-1.2.1.jar,library\libs\disklrucache-1.2.1.jar,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
project.properties,library\project.properties,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
res\layout\main.xml,library\res\layout\main.xml,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
res\values\strings.xml,library\res\values\strings.xml,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\loader\image\BaseImageLoader.java,library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\loader\image\ImageLoader.java,library\src\com\bumptech\photos\loader\image\ImageLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\loader\path\BasePathLoader.java,library\src\com\bumptech\photos\loader\path\BasePathLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\loader\path\DirectPathLoader.java,library\src\com\bumptech\photos\loader\path\DirectPathLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\loader\path\PathLoader.java,library\src\com\bumptech\photos\loader\path\PathLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\presenter\ImageSetCallback.java,library\src\com\bumptech\photos\presenter\ImageSetCallback.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\presenter\ThumbImagePresenter.java,library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\HandlerExecutor.java,library\src\com\bumptech\photos\resize\HandlerExecutor.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\LoadedCallback.java,library\src\com\bumptech\photos\resize\LoadedCallback.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\photos\resize\loader\Approximate.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\photos\resize\loader\AsIs.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\photos\resize\loader\CenterCrop.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\photos\resize\loader\Exact.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\photos\resize\loader\FitCenter.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
src\com\bumptech\photos\util\Log.java,library\src\com\bumptech\photos\util\Log.java,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,9da7a0a7c35af75a6c477f1fc4a6ede27aa41e2b,Move source into library folder,,,Yes
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,a3a23a8d53117ce1792523f5e6fde126b6efb48c,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,"Recycle inTempStorage and buffered input streams

Drastically reduces the number of GC_FOR_ALLOCs
when the number of resize operations is high (as 
in a grid view of photos with lots of columns). 
Also resuses more code and refactors out some
methods","@@ -13,16 +13,18 @@ import android.os.Build;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.util.Log;
 
-import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.LinkedList;
+import java.util.Queue;
 
 /**
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
+    private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final SizedBitmapCache bitmapCache;
 
     /**
@@ -51,7 +53,10 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
-        final Bitmap streamed = streamIn(path, width, height);
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        final Bitmap streamed = streamIn(path, width, height, tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
 
         if (streamed.getWidth() == width && streamed.getHeight() == height) {
             return streamed;
@@ -71,7 +76,10 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap fitInSpace(final String path, final int width, final int height){
-        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height, tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
         return fitInSpace(streamed, width, height);
     }
 
@@ -84,7 +92,12 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap loadApproximate(final String path, final int width, final int height){
-        return streamIn(path, width, height);
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        final Bitmap result = streamIn(path, width, height, tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
+
+        return result;
     }
 
     /**
@@ -99,8 +112,10 @@ public class ImageResizer {
      */
     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
         int[] dimens = new int[] {-1, -1};
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
         try {
-            dimens = getDimension(is1);
+            dimens = getDimension(is1, tempStorage, bufStorage);
         } finally {
             try {
                 is1.close();
@@ -108,17 +123,17 @@ public class ImageResizer {
                 e.printStackTrace();
             }
         }
-        Bitmap resized = null;
-        try {
-            resized = load(is2, getRecycled(dimens));
-        } finally {
-            try {
-                is2.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
+        releaseTempBytes(tempStorage, bufStorage);
+
+        return loadAsIs(is2, getRecycled(dimens));
     }
-        return resized;
+
+    public Bitmap loadAsIs(final InputStream is, final Bitmap recycled) {
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        final Bitmap result = load(is, recycled, tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
+        return result;
     }
 
     /**
@@ -136,7 +151,11 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(final String path, final int width, final int height) {
-        return load(path, getRecycled(width, height));
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        final Bitmap result = load(path, getRecycled(width, height), tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
+        return result;
     }
 
     /**
@@ -147,8 +166,12 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(final String path){
-        int[] dimens = getDimensions(path);
-        return load(path, getRecycled(dimens));
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        int[] dimens = getDimensions(path, tempStorage, bufStorage);
+        final Bitmap result = load(path, getRecycled(dimens), tempStorage, bufStorage);
+        releaseTempBytes(tempStorage, bufStorage);
+        return result;
     }
 
     private Bitmap getRecycled(int[] dimens) {
@@ -163,6 +186,28 @@ public class ImageResizer {
         return result;
     }
 
+
+    private byte[] getTempBytes() {
+        final byte[] result;
+        if (tempQueue.size() > 0) {
+            result = tempQueue.remove();
+        } else {
+            Log.d(""IR: created temp bytes"");
+            result = new byte[16 * 1024];
+        }
+        return result;
+    }
+
+    private void releaseTempBytes(byte[]... byteArrays) {
+        for (byte[] bytes : byteArrays) {
+            releaseTempBytes(bytes);
+        }
+    }
+
+    private void releaseTempBytes(byte[] bytes) {
+        tempQueue.add(bytes);
+    }
+
     /**
      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
      * the original proportions of the image
@@ -235,9 +280,6 @@ public class ImageResizer {
         return cropped;
     }
 
-    //crops a section height pixels tall in the center of the image with equal
-    //amounts discarded above and below
-
     /**
      * An expensive operation to crop the given Bitmap to the given height by removing equal amounts from the top and
      * bottom so that the center of the image remains
@@ -312,14 +354,15 @@ public class ImageResizer {
         }
     }
 
+
     /**
      * An expensive operation to load the image at the given path
      *
      * @param path The path where the image is stored
      * @return A Bitmap representing the image at the given path
      */
-    public static Bitmap load(String path) {
-        return load(path, null);
+    public static Bitmap load(String path, byte[] tempStorage, byte[] bufStorage) {
+        return load(path, null, tempStorage, bufStorage);
     }
 
     /**
@@ -334,10 +377,10 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
      */
-    public static Bitmap load(String path, Bitmap recycle) {
+    public static Bitmap load(String path, Bitmap recycle, byte[] tempStorage, byte[] bufStorage) {
         Bitmap result = null;
         try {
-            result = load(new FileInputStream(path), recycle);
+            result = load(new FileInputStream(path), recycle, tempStorage, bufStorage);
         } catch (FileNotFoundException e) {
             Log.d(""PSR: file not found loading bitmap at: "" + path);
             e.printStackTrace();
@@ -351,8 +394,8 @@ public class ImageResizer {
      * @param is The input stream representing the image data
      * @return A Bitmap representing the image at the given path
      */
-    public static Bitmap load(InputStream is) {
-        return load(is, null);
+    public static Bitmap load(InputStream is, byte[] tempSpace, byte[] bufSpace) {
+        return load(is, null, tempSpace, bufSpace);
     }
 
     /**
@@ -367,28 +410,9 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
      */
-    public static Bitmap load(InputStream is, Bitmap recycle){
-        final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
-        decodeBitmapOptions.inSampleSize = 1;
-        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
-        decodeBitmapOptions.inDither = false;
-        if (Build.VERSION.SDK_INT >= 11) {
-            decodeBitmapOptions.inMutable = true; //required or next attempt to recycle will fail
-            if (recycle != null) {
-                decodeBitmapOptions.inBitmap = recycle; //we can load photo without a bitmap to recycle,
-                                                        //its just less efficient
-            }
-        }
-        InputStream stream;
-        Bitmap result = null;
-        try {
-            stream = new BufferedInputStream(is);
-            result = BitmapFactory.decodeStream(stream, null, decodeBitmapOptions);
-            stream.close();
-        } catch (IOException e) {
-            Log.d(""PSR: io exception: "" + e + "" loading bitmap"");
-        }
-        return result;
+    public static Bitmap load(InputStream is, Bitmap recycle, byte[] tempSpace, byte[] bufSpace){
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle, tempSpace);
+        return decodeStream(is, decodeBitmapOptions, bufSpace);
     }
 
     /**
@@ -397,18 +421,11 @@ public class ImageResizer {
      * @param path The path wher ethe image is stored
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    public static int[] getDimensions(String path) {
-        int[] dimens = new int[]{-1, -1};
-        try {
-            InputStream is = new BufferedInputStream(new FileInputStream(path));
-            dimens = getDimension(is);
-            is.close();
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
-        } catch (IOException e) {
-            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
-        }
-        return dimens;
+    public static int[] getDimensions(String path, byte[] tempStorage, byte[] bufStorage) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempStorage);
+        decodeBoundsOptions.inJustDecodeBounds = true;
+        decodeStream(path, decodeBoundsOptions, bufStorage);
+        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
      /**
@@ -417,14 +434,13 @@ public class ImageResizer {
      * @param is The InputStream representing the image
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-     public static int[] getDimension(InputStream is) {
-        final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
+    public static int[] getDimension(InputStream is, byte[] tempSpace, byte[] bufSpace) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempSpace);
         decodeBoundsOptions.inJustDecodeBounds = true;
-        BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
+        decodeStream(is, decodeBoundsOptions, bufSpace);
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
-
     /**
      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
      * rotate the image according to the orientation in the images EXIF data if available.
@@ -436,7 +452,7 @@ public class ImageResizer {
      * @param height The target height
      * @return A Bitmap containing the image
      */
-    public static Bitmap streamIn(String path, int width, int height) {
+    public static Bitmap streamIn(String path, int width, int height, byte[] tempSpace, byte[] bufSpace) {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
             //Swap width and height for initial downsample calculation if its oriented so.
@@ -447,36 +463,22 @@ public class ImageResizer {
         }
 
         Bitmap result = null;
-        try {
-            final int[] dimens = getDimensions(path);
+        final int[] dimens = getDimensions(path, tempSpace, bufSpace);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
         int sampleSize = Math.min(originalHeight / height, originalWidth / width);
 
-            final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
-            // For further memory savings, you may want to consider using this option
-            decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
-            decodeBitmapOptions.inDither = false;
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(tempSpace);
+        decodeBitmapOptions.inSampleSize = sampleSize;
 
-            InputStream is = new BufferedInputStream(new FileInputStream(path), 16384);
+        result = decodeStream(path, decodeBitmapOptions, bufSpace);
 
-            decodeBitmapOptions.inSampleSize = sampleSize;
-            if (Build.VERSION.SDK_INT > 11) {
-                decodeBitmapOptions.inMutable = true;
-            }
-            result = BitmapFactory.decodeStream(is, null, decodeBitmapOptions);
         if (orientation != 0) {
             result = rotateImage(result, orientation);
         }
-            is.close();
-        } catch (Exception e){
-            Log.d(""PSR: error decoding image: "" + e);
-        } catch (OutOfMemoryError e){
-            Log.d(""PSR: not enough memory to resize image at "" + path);
-            Log.d(e.toString());
-        }
+
         return result;
     }
 
@@ -550,4 +552,56 @@ public class ImageResizer {
         return imageToOrient;
    }
 
+   private static Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
+       InputStream is = null;
+       Bitmap result = null;
+       try {
+           is = new FileInputStream(path);
+           result = decodeStream(is, decodeBitmapOptions, bufSpace);
+       } catch (FileNotFoundException e) {
+           e.printStackTrace();
+       } finally {
+           if (is !=null) {
+               try {
+                   is.close();
+               } catch (IOException e) {
+                   e.printStackTrace();
+               }
+           }
+       }
+       return result;
+   }
+
+   private static Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
+       ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufSpace);
+       Bitmap result = null;
+       try {
+           result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
+       } finally {
+           try {
+               bis.close();
+           } catch (IOException e) {
+               e.printStackTrace();
+           }
+       }
+       return result;
+   }
+
+   private static BitmapFactory.Options getDefaultOptions(byte[] tempStorage) {
+      return getDefaultOptions(null, tempStorage);
+   }
+
+   private static BitmapFactory.Options getDefaultOptions(Bitmap recycle, byte[] tempStorage) {
+       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
+       decodeBitmapOptions.inDither = false;
+       decodeBitmapOptions.inScaled = false;
+       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
+       decodeBitmapOptions.inTempStorage = tempStorage;
+       decodeBitmapOptions.inSampleSize = 1;
+       if (Build.VERSION.SDK_INT >= 11)  {
+           decodeBitmapOptions.inMutable = true;
+           decodeBitmapOptions.inBitmap = recycle;
+       }
+       return decodeBitmapOptions;
+    }
 }
","20 import java.util.LinkedList;
21 import java.util.Queue;
27     private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
56         byte[] tempStorage = getTempBytes();
57         byte[] bufStorage = getTempBytes();
58         final Bitmap streamed = streamIn(path, width, height, tempStorage, bufStorage);
59         releaseTempBytes(tempStorage, bufStorage);
79         byte[] tempStorage = getTempBytes();
80         byte[] bufStorage = getTempBytes();
81         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height, tempStorage, bufStorage);
82         releaseTempBytes(tempStorage, bufStorage);
95         byte[] tempStorage = getTempBytes();
96         byte[] bufStorage = getTempBytes();
97         final Bitmap result = streamIn(path, width, height, tempStorage, bufStorage);
98         releaseTempBytes(tempStorage, bufStorage);
99 
100         return result;
115         byte[] tempStorage = getTempBytes();
116         byte[] bufStorage = getTempBytes();
118             dimens = getDimension(is1, tempStorage, bufStorage);
126         releaseTempBytes(tempStorage, bufStorage);
127 
128         return loadAsIs(is2, getRecycled(dimens));
130 
131     public Bitmap loadAsIs(final InputStream is, final Bitmap recycled) {
132         byte[] tempStorage = getTempBytes();
133         byte[] bufStorage = getTempBytes();
134         final Bitmap result = load(is, recycled, tempStorage, bufStorage);
135         releaseTempBytes(tempStorage, bufStorage);
136         return result;
154         byte[] tempStorage = getTempBytes();
155         byte[] bufStorage = getTempBytes();
156         final Bitmap result = load(path, getRecycled(width, height), tempStorage, bufStorage);
157         releaseTempBytes(tempStorage, bufStorage);
158         return result;
169         byte[] tempStorage = getTempBytes();
170         byte[] bufStorage = getTempBytes();
171         int[] dimens = getDimensions(path, tempStorage, bufStorage);
172         final Bitmap result = load(path, getRecycled(dimens), tempStorage, bufStorage);
173         releaseTempBytes(tempStorage, bufStorage);
174         return result;
189 
190     private byte[] getTempBytes() {
191         final byte[] result;
192         if (tempQueue.size() > 0) {
193             result = tempQueue.remove();
194         } else {
195             Log.d(""IR: created temp bytes"");
196             result = new byte[16 * 1024];
197         }
198         return result;
199     }
200 
201     private void releaseTempBytes(byte[]... byteArrays) {
202         for (byte[] bytes : byteArrays) {
203             releaseTempBytes(bytes);
204         }
205     }
206 
207     private void releaseTempBytes(byte[] bytes) {
208         tempQueue.add(bytes);
209     }
210 
357 
364     public static Bitmap load(String path, byte[] tempStorage, byte[] bufStorage) {
365         return load(path, null, tempStorage, bufStorage);
380     public static Bitmap load(String path, Bitmap recycle, byte[] tempStorage, byte[] bufStorage) {
383             result = load(new FileInputStream(path), recycle, tempStorage, bufStorage);
397     public static Bitmap load(InputStream is, byte[] tempSpace, byte[] bufSpace) {
398         return load(is, null, tempSpace, bufSpace);
413     public static Bitmap load(InputStream is, Bitmap recycle, byte[] tempSpace, byte[] bufSpace){
414         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle, tempSpace);
415         return decodeStream(is, decodeBitmapOptions, bufSpace);
424     public static int[] getDimensions(String path, byte[] tempStorage, byte[] bufStorage) {
425         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempStorage);
426         decodeBoundsOptions.inJustDecodeBounds = true;
427         decodeStream(path, decodeBoundsOptions, bufStorage);
428         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
437     public static int[] getDimension(InputStream is, byte[] tempSpace, byte[] bufSpace) {
438         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempSpace);
440         decodeStream(is, decodeBoundsOptions, bufSpace);
455     public static Bitmap streamIn(String path, int width, int height, byte[] tempSpace, byte[] bufSpace) {
466         final int[] dimens = getDimensions(path, tempSpace, bufSpace);
473         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(tempSpace);
475 
476         result = decodeStream(path, decodeBitmapOptions, bufSpace);
477 
481 
555    private static Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
556        InputStream is = null;
557        Bitmap result = null;
558        try {
559            is = new FileInputStream(path);
560            result = decodeStream(is, decodeBitmapOptions, bufSpace);
561        } catch (FileNotFoundException e) {
562            e.printStackTrace();
563        } finally {
564            if (is !=null) {
565                try {
566                    is.close();
567                } catch (IOException e) {
568                    e.printStackTrace();
569                }
570            }
571        }
572        return result;
573    }
574 
575    private static Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
576        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufSpace);
577        Bitmap result = null;
578        try {
579            result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
580        } finally {
581            try {
582                bis.close();
583            } catch (IOException e) {
584                e.printStackTrace();
585            }
586        }
587        return result;
588    }
589 
590    private static BitmapFactory.Options getDefaultOptions(byte[] tempStorage) {
591       return getDefaultOptions(null, tempStorage);
592    }
593 
594    private static BitmapFactory.Options getDefaultOptions(Bitmap recycle, byte[] tempStorage) {
595        BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
596        decodeBitmapOptions.inDither = false;
597        decodeBitmapOptions.inScaled = false;
598        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
599        decodeBitmapOptions.inTempStorage = tempStorage;
600        decodeBitmapOptions.inSampleSize = 1;
601        if (Build.VERSION.SDK_INT >= 11)  {
602            decodeBitmapOptions.inMutable = true;
603            decodeBitmapOptions.inBitmap = recycle;
604        }
605        return decodeBitmapOptions;
606     }
16 import java.io.BufferedInputStream;
54         final Bitmap streamed = streamIn(path, width, height);
74         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
87         return streamIn(path, width, height);
103             dimens = getDimension(is1);
111         Bitmap resized = null;
112         try {
113             resized = load(is2, getRecycled(dimens));
114         } finally {
115             try {
116                 is2.close();
117             } catch (IOException e) {
118                 e.printStackTrace();
120         }
121         return resized;
139         return load(path, getRecycled(width, height));
150         int[] dimens = getDimensions(path);
151         return load(path, getRecycled(dimens));
238     //crops a section height pixels tall in the center of the image with equal
239     //amounts discarded above and below
240 
321     public static Bitmap load(String path) {
322         return load(path, null);
337     public static Bitmap load(String path, Bitmap recycle) {
340             result = load(new FileInputStream(path), recycle);
354     public static Bitmap load(InputStream is) {
355         return load(is, null);
370     public static Bitmap load(InputStream is, Bitmap recycle){
371         final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
372         decodeBitmapOptions.inSampleSize = 1;
373         decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
374         decodeBitmapOptions.inDither = false;
375         if (Build.VERSION.SDK_INT >= 11) {
376             decodeBitmapOptions.inMutable = true; //required or next attempt to recycle will fail
377             if (recycle != null) {
378                 decodeBitmapOptions.inBitmap = recycle; //we can load photo without a bitmap to recycle,
379                                                         //its just less efficient
380             }
381         }
382         InputStream stream;
383         Bitmap result = null;
384         try {
385             stream = new BufferedInputStream(is);
386             result = BitmapFactory.decodeStream(stream, null, decodeBitmapOptions);
387             stream.close();
388         } catch (IOException e) {
389             Log.d(""PSR: io exception: "" + e + "" loading bitmap"");
390         }
391         return result;
400     public static int[] getDimensions(String path) {
401         int[] dimens = new int[]{-1, -1};
402         try {
403             InputStream is = new BufferedInputStream(new FileInputStream(path));
404             dimens = getDimension(is);
405             is.close();
406         } catch (FileNotFoundException e) {
407             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
408         } catch (IOException e) {
409             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
410         }
411         return dimens;
420      public static int[] getDimension(InputStream is) {
421         final BitmapFactory.Options decodeBoundsOptions = new BitmapFactory.Options();
423         BitmapFactory.decodeStream(is, null, decodeBoundsOptions); //doesn't load, just sets the decodeBounds
427 
439     public static Bitmap streamIn(String path, int width, int height) {
450         try {
451             final int[] dimens = getDimensions(path);
458             final BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
459             // For further memory savings, you may want to consider using this option
460             decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565; // Uses 2-bytes instead of default 4 per pixel
461             decodeBitmapOptions.inDither = false;
462 
463             InputStream is = new BufferedInputStream(new FileInputStream(path), 16384);
464 
466             if (Build.VERSION.SDK_INT > 11) {
467                 decodeBitmapOptions.inMutable = true;
468             }
469             result = BitmapFactory.decodeStream(is, null, decodeBitmapOptions);
473             is.close();
474         } catch (Exception e){
475             Log.d(""PSR: error decoding image: "" + e);
476         } catch (OutOfMemoryError e){
477             Log.d(""PSR: not enough memory to resize image at "" + path);
478             Log.d(e.toString());
479         }",No
,library\src\com\bumptech\photos\resize\ReycleableBufferedInputStream.java,a3a23a8d53117ce1792523f5e6fde126b6efb48c,25df36450c0cb82c37aafb2f4df527d0e1e1fdea,"Recycle inTempStorage and buffered input streams

Drastically reduces the number of GC_FOR_ALLOCs
when the number of resize operations is high (as 
in a grid view of photos with lots of columns). 
Also resuses more code and refactors out some
methods","@@ -0,0 +1,413 @@
+package com.bumptech.photos.resize;
+
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the &quot;License&quot;); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Wraps an existing {@link InputStream} and &lt;em&gt;buffers&lt;/em&gt; the input.
+ * Expensive interaction with the underlying input stream is minimized, since
+ * most (smaller) requests can be satisfied by accessing the buffer alone. The
+ * drawback is that some extra space is required to hold the buffer and that
+ * copying takes place when filling that buffer, but this is usually outweighed
+ * by the performance benefits.
+ *
+ * &lt;p/&gt;A typical application pattern for the class looks like this:&lt;p/&gt;
+ *
+ * &lt;pre&gt;
+ * BufferedInputStream buf = new BufferedInputStream(new FileInputStream(&amp;quot;file.java&amp;quot;));
+ * &lt;/pre&gt;
+ *
+ */
+public class ReycleableBufferedInputStream extends FilterInputStream {
+    /**
+     * The buffer containing the current bytes read from the target InputStream.
+     */
+    protected volatile byte[] buf;
+
+    /**
+     * The total number of bytes inside the byte array {@code buf}.
+     */
+    protected int count;
+
+    /**
+     * The current limit, which when passed, invalidates the current mark.
+     */
+    protected int marklimit;
+
+    /**
+     * The currently marked position. -1 indicates no mark has been set or the
+     * mark has been invalidated.
+     */
+    protected int markpos = -1;
+
+    /**
+     * The current position within the byte array {@code buf}.
+     */
+    protected int pos;
+
+    /**
+     * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer
+     * of 8192 bytes.
+     *
+     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
+     * {@code BufferedInputStream}. All read operations on such a stream will
+     * fail with an IOException.
+     *
+     * @param in the {@code InputStream} the buffer reads from.
+     */
+    public ReycleableBufferedInputStream(InputStream in) {
+        this(in, 8192);
+    }
+
+    /**
+     * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes
+     * of buffer.
+     *
+     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
+     * {@code BufferedInputStream}. All read operations on such a stream will
+     * fail with an IOException.
+     *
+     * @param in the {@code InputStream} the buffer reads from.
+     * @param size the size of buffer in bytes.
+     * @throws IllegalArgumentException if {@code size &lt;= 0}.
+     */
+    public ReycleableBufferedInputStream(InputStream in, int size) {
+        this(in, new byte[size]);
+    }
+
+    public ReycleableBufferedInputStream(InputStream in, byte[] buffer) {
+        super(in);
+        if (buffer == null || buffer.length == 0) {
+            throw new IllegalArgumentException(""buffer is null or empty"");
+        }
+        buf = buffer;
+    }
+
+    /**
+     * Returns an estimated number of bytes that can be read or skipped without blocking for more
+     * input. This method returns the number of bytes available in the buffer
+     * plus those available in the source stream, but see {@link InputStream#available} for
+     * important caveats.
+     *
+     * @return the estimated number of bytes available
+     * @throws IOException if this stream is closed or an error occurs
+     */
+    @Override
+    public synchronized int available() throws IOException {
+        InputStream localIn = in; // &#39;in&#39; could be invalidated by close()
+        if (buf == null || localIn == null) {
+            throw streamClosed();
+        }
+        return count - pos + localIn.available();
+    }
+
+    private IOException streamClosed() throws IOException {
+        throw new IOException(""BufferedInputStream is closed"");
+    }
+
+    /**
+     * Closes this stream. The source stream is closed and any resources
+     * associated with it are released.
+     *
+     * @throws IOException
+     *             if an error occurs while closing this stream.
+     */
+    @Override
+    public void close() throws IOException {
+        buf = null;
+        InputStream localIn = in;
+        in = null;
+        if (localIn != null) {
+            localIn.close();
+        }
+    }
+
+    private int fillbuf(InputStream localIn, byte[] localBuf)
+            throws IOException {
+        if (markpos == -1 || (pos - markpos >= marklimit)) {
+            /* Mark position not set or exceeded readlimit */
+            int result = localIn.read(localBuf);
+            if (result > 0) {
+                markpos = -1;
+                pos = 0;
+                count = result == -1 ? 0 : result;
+            }
+            return result;
+        }
+        if (markpos == 0 && marklimit > localBuf.length) {
+            /* Increase buffer size to accommodate the readlimit */
+            int newLength = localBuf.length * 2;
+            if (newLength > marklimit) {
+                newLength = marklimit;
+            }
+            byte[] newbuf = new byte[newLength];
+            System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
+            // Reassign buf, which will invalidate any local references
+            // FIXME: what if buf was null?
+            localBuf = buf = newbuf;
+        } else if (markpos > 0) {
+            System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length
+                    - markpos);
+        }
+        /* Set the new position and mark position */
+        pos -= markpos;
+        count = markpos = 0;
+        int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
+        count = bytesread <= 0 ? pos : pos + bytesread;
+        return bytesread;
+    }
+
+    /**
+     * Sets a mark position in this stream. The parameter {@code readlimit}
+     * indicates how many bytes can be read before a mark is invalidated.
+     * Calling {@code reset()} will reposition the stream back to the marked
+     * position if {@code readlimit} has not been surpassed. The underlying
+     * buffer may be increased in size to allow {@code readlimit} number of
+     * bytes to be supported.
+     *
+     * @param readlimit
+     *            the number of bytes that can be read before the mark is
+     *            invalidated.
+     * @see #reset()
+     */
+    @Override
+    public synchronized void mark(int readlimit) {
+        marklimit = readlimit;
+        markpos = pos;
+    }
+
+    /**
+     * Indicates whether {@code BufferedInputStream} supports the {@code mark()}
+     * and {@code reset()} methods.
+     *
+     * @return {@code true} for BufferedInputStreams.
+     * @see #mark(int)
+     * @see #reset()
+     */
+    @Override
+    public boolean markSupported() {
+        return true;
+    }
+
+    /**
+     * Reads a single byte from this stream and returns it as an integer in the
+     * range from 0 to 255. Returns -1 if the end of the source string has been
+     * reached. If the internal buffer does not contain any available bytes then
+     * it is filled from the source stream and the first byte is returned.
+     *
+     * @return the byte read or -1 if the end of the source stream has been
+     *         reached.
+     * @throws IOException
+     *             if this stream is closed or another IOException occurs.
+     */
+    @Override
+    public synchronized int read() throws IOException {
+        // Use local refs since buf and in may be invalidated by an
+        // unsynchronized close()
+        byte[] localBuf = buf;
+        InputStream localIn = in;
+        if (localBuf == null || localIn == null) {
+            throw streamClosed();
+        }
+
+        /* Are there buffered bytes available? */
+        if (pos >= count && fillbuf(localIn, localBuf) == -1) {
+            return -1; /* no, fill buffer */
+        }
+        // localBuf may have been invalidated by fillbuf
+        if (localBuf != buf) {
+            localBuf = buf;
+            if (localBuf == null) {
+                throw streamClosed();
+            }
+        }
+
+        /* Did filling the buffer fail with -1 (EOF)? */
+        if (count - pos > 0) {
+            return localBuf[pos++] & 0xFF;
+        }
+        return -1;
+    }
+
+    /**
+     * Reads at most {@code byteCount} bytes from this stream and stores them in
+     * byte array {@code buffer} starting at offset {@code offset}. Returns the
+     * number of bytes actually read or -1 if no bytes were read and the end of
+     * the stream was encountered. If all the buffered bytes have been used, a
+     * mark has not been set and the requested number of bytes is larger than
+     * the receiver&#39;s buffer size, this implementation bypasses the buffer and
+     * simply places the results directly into {@code buffer}.
+     *
+     * @param buffer
+     *            the byte array in which to store the bytes read.
+     * @return the number of bytes actually read or -1 if end of stream.
+     * @throws IndexOutOfBoundsException
+     *             if {@code offset &lt; 0} or {@code byteCount &lt; 0}, or if
+     *             {@code offset + byteCount} is greater than the size of
+     *             {@code buffer}.
+     * @throws IOException
+     *             if the stream is already closed or another IOException
+     *             occurs.
+     */
+    @Override
+    public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+        // Use local ref since buf may be invalidated by an unsynchronized
+        // close()
+        byte[] localBuf = buf;
+        if (localBuf == null) {
+            throw streamClosed();
+        }
+        //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
+        if (byteCount == 0) {
+            return 0;
+        }
+        InputStream localIn = in;
+        if (localIn == null) {
+            throw streamClosed();
+        }
+
+        int required;
+        if (pos < count) {
+            /* There are bytes available in the buffer. */
+            int copylength = count - pos >= byteCount ? byteCount : count - pos;
+            System.arraycopy(localBuf, pos, buffer, offset, copylength);
+            pos += copylength;
+            if (copylength == byteCount || localIn.available() == 0) {
+                return copylength;
+            }
+            offset += copylength;
+            required = byteCount - copylength;
+        } else {
+            required = byteCount;
+        }
+
+        while (true) {
+            int read;
+            /*
+             * If we&#39;re not marked and the required size is greater than the
+             * buffer, simply read the bytes directly bypassing the buffer.
+             */
+            if (markpos == -1 && required >= localBuf.length) {
+                read = localIn.read(buffer, offset, required);
+                if (read == -1) {
+                    return required == byteCount ? -1 : byteCount - required;
+                }
+            } else {
+                if (fillbuf(localIn, localBuf) == -1) {
+                    return required == byteCount ? -1 : byteCount - required;
+                }
+                // localBuf may have been invalidated by fillbuf
+                if (localBuf != buf) {
+                    localBuf = buf;
+                    if (localBuf == null) {
+                        throw streamClosed();
+                    }
+                }
+
+                read = count - pos >= required ? required : count - pos;
+                System.arraycopy(localBuf, pos, buffer, offset, read);
+                pos += read;
+            }
+            required -= read;
+            if (required == 0) {
+                return byteCount;
+            }
+            if (localIn.available() == 0) {
+                return byteCount - required;
+            }
+            offset += read;
+        }
+    }
+
+    /**
+     * Resets this stream to the last marked location.
+     *
+     * @throws IOException
+     *             if this stream is closed, no mark has been set or the mark is
+     *             no longer valid because more than {@code readlimit} bytes
+     *             have been read since setting the mark.
+     * @see #mark(int)
+     */
+    @Override
+    public synchronized void reset() throws IOException {
+        if (buf == null) {
+            throw new IOException(""Stream is closed"");
+        }
+        if (-1 == markpos) {
+            throw new IOException(""Mark has been invalidated."");
+        }
+        pos = markpos;
+    }
+
+    /**
+     * Skips {@code byteCount} bytes in this stream. Subsequent calls to
+     * {@code read} will not return these bytes unless {@code reset} is
+     * used.
+     *
+     * @param byteCount
+     *            the number of bytes to skip. {@code skip} does nothing and
+     *            returns 0 if {@code byteCount} is less than zero.
+     * @return the number of bytes actually skipped.
+     * @throws IOException
+     *             if this stream is closed or another IOException occurs.
+     */
+    @Override
+    public synchronized long skip(long byteCount) throws IOException {
+        // Use local refs since buf and in may be invalidated by an
+        // unsynchronized close()
+        byte[] localBuf = buf;
+        InputStream localIn = in;
+        if (localBuf == null) {
+            throw streamClosed();
+        }
+        if (byteCount < 1) {
+            return 0;
+        }
+        if (localIn == null) {
+            throw streamClosed();
+        }
+
+        if (count - pos >= byteCount) {
+            pos += byteCount;
+            return byteCount;
+        }
+        long read = count - pos;
+        pos = count;
+
+        if (markpos != -1) {
+            if (byteCount <= marklimit) {
+                if (fillbuf(localIn, localBuf) == -1) {
+                    return read;
+                }
+                if (count - pos >= byteCount - read) {
+                    pos += byteCount - read;
+                    return byteCount;
+                }
+                // Couldn&#39;t get all the bytes, skip what we read
+                read += (count - pos);
+                pos = count;
+                return read;
+            }
+        }
+        return read + localIn.skip(byteCount - read);
+    }
+}
","1 package com.bumptech.photos.resize;
2 
3 /*
4  *  Licensed to the Apache Software Foundation (ASF) under one or more
5  *  contributor license agreements.  See the NOTICE file distributed with
6  *  this work for additional information regarding copyright ownership.
7  *  The ASF licenses this file to You under the Apache License, Version 2.0
8  *  (the &quot;License&quot;); you may not use this file except in compliance with
9  *  the License.  You may obtain a copy of the License at
10  *
11  *     http://www.apache.org/licenses/LICENSE-2.0
12  *
13  *  Unless required by applicable law or agreed to in writing, software
14  *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
15  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
16  *  See the License for the specific language governing permissions and
17  *  limitations under the License.
18  */
19 
20 
21 import java.io.FilterInputStream;
22 import java.io.IOException;
23 import java.io.InputStream;
24 
25 /**
26  * Wraps an existing {@link InputStream} and &lt;em&gt;buffers&lt;/em&gt; the input.
27  * Expensive interaction with the underlying input stream is minimized, since
28  * most (smaller) requests can be satisfied by accessing the buffer alone. The
29  * drawback is that some extra space is required to hold the buffer and that
30  * copying takes place when filling that buffer, but this is usually outweighed
31  * by the performance benefits.
32  *
33  * &lt;p/&gt;A typical application pattern for the class looks like this:&lt;p/&gt;
34  *
35  * &lt;pre&gt;
36  * BufferedInputStream buf = new BufferedInputStream(new FileInputStream(&amp;quot;file.java&amp;quot;));
37  * &lt;/pre&gt;
38  *
39  */
40 public class ReycleableBufferedInputStream extends FilterInputStream {
41     /**
42      * The buffer containing the current bytes read from the target InputStream.
43      */
44     protected volatile byte[] buf;
45 
46     /**
47      * The total number of bytes inside the byte array {@code buf}.
48      */
49     protected int count;
50 
51     /**
52      * The current limit, which when passed, invalidates the current mark.
53      */
54     protected int marklimit;
55 
56     /**
57      * The currently marked position. -1 indicates no mark has been set or the
58      * mark has been invalidated.
59      */
60     protected int markpos = -1;
61 
62     /**
63      * The current position within the byte array {@code buf}.
64      */
65     protected int pos;
66 
67     /**
68      * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer
69      * of 8192 bytes.
70      *
71      * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
72      * {@code BufferedInputStream}. All read operations on such a stream will
73      * fail with an IOException.
74      *
75      * @param in the {@code InputStream} the buffer reads from.
76      */
77     public ReycleableBufferedInputStream(InputStream in) {
78         this(in, 8192);
79     }
80 
81     /**
82      * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes
83      * of buffer.
84      *
85      * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
86      * {@code BufferedInputStream}. All read operations on such a stream will
87      * fail with an IOException.
88      *
89      * @param in the {@code InputStream} the buffer reads from.
90      * @param size the size of buffer in bytes.
91      * @throws IllegalArgumentException if {@code size &lt;= 0}.
92      */
93     public ReycleableBufferedInputStream(InputStream in, int size) {
94         this(in, new byte[size]);
95     }
96 
97     public ReycleableBufferedInputStream(InputStream in, byte[] buffer) {
98         super(in);
99         if (buffer == null || buffer.length == 0) {
100             throw new IllegalArgumentException(""buffer is null or empty"");
101         }
102         buf = buffer;
103     }
104 
105     /**
106      * Returns an estimated number of bytes that can be read or skipped without blocking for more
107      * input. This method returns the number of bytes available in the buffer
108      * plus those available in the source stream, but see {@link InputStream#available} for
109      * important caveats.
110      *
111      * @return the estimated number of bytes available
112      * @throws IOException if this stream is closed or an error occurs
113      */
114     @Override
115     public synchronized int available() throws IOException {
116         InputStream localIn = in; // &#39;in&#39; could be invalidated by close()
117         if (buf == null || localIn == null) {
118             throw streamClosed();
119         }
120         return count - pos + localIn.available();
121     }
122 
123     private IOException streamClosed() throws IOException {
124         throw new IOException(""BufferedInputStream is closed"");
125     }
126 
127     /**
128      * Closes this stream. The source stream is closed and any resources
129      * associated with it are released.
130      *
131      * @throws IOException
132      *             if an error occurs while closing this stream.
133      */
134     @Override
135     public void close() throws IOException {
136         buf = null;
137         InputStream localIn = in;
138         in = null;
139         if (localIn != null) {
140             localIn.close();
141         }
142     }
143 
144     private int fillbuf(InputStream localIn, byte[] localBuf)
145             throws IOException {
146         if (markpos == -1 || (pos - markpos >= marklimit)) {
147             /* Mark position not set or exceeded readlimit */
148             int result = localIn.read(localBuf);
149             if (result > 0) {
150                 markpos = -1;
151                 pos = 0;
152                 count = result == -1 ? 0 : result;
153             }
154             return result;
155         }
156         if (markpos == 0 && marklimit > localBuf.length) {
157             /* Increase buffer size to accommodate the readlimit */
158             int newLength = localBuf.length * 2;
159             if (newLength > marklimit) {
160                 newLength = marklimit;
161             }
162             byte[] newbuf = new byte[newLength];
163             System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
164             // Reassign buf, which will invalidate any local references
165             // FIXME: what if buf was null?
166             localBuf = buf = newbuf;
167         } else if (markpos > 0) {
168             System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length
169                     - markpos);
170         }
171         /* Set the new position and mark position */
172         pos -= markpos;
173         count = markpos = 0;
174         int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
175         count = bytesread <= 0 ? pos : pos + bytesread;
176         return bytesread;
177     }
178 
179     /**
180      * Sets a mark position in this stream. The parameter {@code readlimit}
181      * indicates how many bytes can be read before a mark is invalidated.
182      * Calling {@code reset()} will reposition the stream back to the marked
183      * position if {@code readlimit} has not been surpassed. The underlying
184      * buffer may be increased in size to allow {@code readlimit} number of
185      * bytes to be supported.
186      *
187      * @param readlimit
188      *            the number of bytes that can be read before the mark is
189      *            invalidated.
190      * @see #reset()
191      */
192     @Override
193     public synchronized void mark(int readlimit) {
194         marklimit = readlimit;
195         markpos = pos;
196     }
197 
198     /**
199      * Indicates whether {@code BufferedInputStream} supports the {@code mark()}
200      * and {@code reset()} methods.
201      *
202      * @return {@code true} for BufferedInputStreams.
203      * @see #mark(int)
204      * @see #reset()
205      */
206     @Override
207     public boolean markSupported() {
208         return true;
209     }
210 
211     /**
212      * Reads a single byte from this stream and returns it as an integer in the
213      * range from 0 to 255. Returns -1 if the end of the source string has been
214      * reached. If the internal buffer does not contain any available bytes then
215      * it is filled from the source stream and the first byte is returned.
216      *
217      * @return the byte read or -1 if the end of the source stream has been
218      *         reached.
219      * @throws IOException
220      *             if this stream is closed or another IOException occurs.
221      */
222     @Override
223     public synchronized int read() throws IOException {
224         // Use local refs since buf and in may be invalidated by an
225         // unsynchronized close()
226         byte[] localBuf = buf;
227         InputStream localIn = in;
228         if (localBuf == null || localIn == null) {
229             throw streamClosed();
230         }
231 
232         /* Are there buffered bytes available? */
233         if (pos >= count && fillbuf(localIn, localBuf) == -1) {
234             return -1; /* no, fill buffer */
235         }
236         // localBuf may have been invalidated by fillbuf
237         if (localBuf != buf) {
238             localBuf = buf;
239             if (localBuf == null) {
240                 throw streamClosed();
241             }
242         }
243 
244         /* Did filling the buffer fail with -1 (EOF)? */
245         if (count - pos > 0) {
246             return localBuf[pos++] & 0xFF;
247         }
248         return -1;
249     }
250 
251     /**
252      * Reads at most {@code byteCount} bytes from this stream and stores them in
253      * byte array {@code buffer} starting at offset {@code offset}. Returns the
254      * number of bytes actually read or -1 if no bytes were read and the end of
255      * the stream was encountered. If all the buffered bytes have been used, a
256      * mark has not been set and the requested number of bytes is larger than
257      * the receiver&#39;s buffer size, this implementation bypasses the buffer and
258      * simply places the results directly into {@code buffer}.
259      *
260      * @param buffer
261      *            the byte array in which to store the bytes read.
262      * @return the number of bytes actually read or -1 if end of stream.
263      * @throws IndexOutOfBoundsException
264      *             if {@code offset &lt; 0} or {@code byteCount &lt; 0}, or if
265      *             {@code offset + byteCount} is greater than the size of
266      *             {@code buffer}.
267      * @throws IOException
268      *             if the stream is already closed or another IOException
269      *             occurs.
270      */
271     @Override
272     public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
273         // Use local ref since buf may be invalidated by an unsynchronized
274         // close()
275         byte[] localBuf = buf;
276         if (localBuf == null) {
277             throw streamClosed();
278         }
279         //Arrays.checkOffsetAndCount(buffer.length, offset, byteCount);
280         if (byteCount == 0) {
281             return 0;
282         }
283         InputStream localIn = in;
284         if (localIn == null) {
285             throw streamClosed();
286         }
287 
288         int required;
289         if (pos < count) {
290             /* There are bytes available in the buffer. */
291             int copylength = count - pos >= byteCount ? byteCount : count - pos;
292             System.arraycopy(localBuf, pos, buffer, offset, copylength);
293             pos += copylength;
294             if (copylength == byteCount || localIn.available() == 0) {
295                 return copylength;
296             }
297             offset += copylength;
298             required = byteCount - copylength;
299         } else {
300             required = byteCount;
301         }
302 
303         while (true) {
304             int read;
305             /*
306              * If we&#39;re not marked and the required size is greater than the
307              * buffer, simply read the bytes directly bypassing the buffer.
308              */
309             if (markpos == -1 && required >= localBuf.length) {
310                 read = localIn.read(buffer, offset, required);
311                 if (read == -1) {
312                     return required == byteCount ? -1 : byteCount - required;
313                 }
314             } else {
315                 if (fillbuf(localIn, localBuf) == -1) {
316                     return required == byteCount ? -1 : byteCount - required;
317                 }
318                 // localBuf may have been invalidated by fillbuf
319                 if (localBuf != buf) {
320                     localBuf = buf;
321                     if (localBuf == null) {
322                         throw streamClosed();
323                     }
324                 }
325 
326                 read = count - pos >= required ? required : count - pos;
327                 System.arraycopy(localBuf, pos, buffer, offset, read);
328                 pos += read;
329             }
330             required -= read;
331             if (required == 0) {
332                 return byteCount;
333             }
334             if (localIn.available() == 0) {
335                 return byteCount - required;
336             }
337             offset += read;
338         }
339     }
340 
341     /**
342      * Resets this stream to the last marked location.
343      *
344      * @throws IOException
345      *             if this stream is closed, no mark has been set or the mark is
346      *             no longer valid because more than {@code readlimit} bytes
347      *             have been read since setting the mark.
348      * @see #mark(int)
349      */
350     @Override
351     public synchronized void reset() throws IOException {
352         if (buf == null) {
353             throw new IOException(""Stream is closed"");
354         }
355         if (-1 == markpos) {
356             throw new IOException(""Mark has been invalidated."");
357         }
358         pos = markpos;
359     }
360 
361     /**
362      * Skips {@code byteCount} bytes in this stream. Subsequent calls to
363      * {@code read} will not return these bytes unless {@code reset} is
364      * used.
365      *
366      * @param byteCount
367      *            the number of bytes to skip. {@code skip} does nothing and
368      *            returns 0 if {@code byteCount} is less than zero.
369      * @return the number of bytes actually skipped.
370      * @throws IOException
371      *             if this stream is closed or another IOException occurs.
372      */
373     @Override
374     public synchronized long skip(long byteCount) throws IOException {
375         // Use local refs since buf and in may be invalidated by an
376         // unsynchronized close()
377         byte[] localBuf = buf;
378         InputStream localIn = in;
379         if (localBuf == null) {
380             throw streamClosed();
381         }
382         if (byteCount < 1) {
383             return 0;
384         }
385         if (localIn == null) {
386             throw streamClosed();
387         }
388 
389         if (count - pos >= byteCount) {
390             pos += byteCount;
391             return byteCount;
392         }
393         long read = count - pos;
394         pos = count;
395 
396         if (markpos != -1) {
397             if (byteCount <= marklimit) {
398                 if (fillbuf(localIn, localBuf) == -1) {
399                     return read;
400                 }
401                 if (count - pos >= byteCount - read) {
402                     pos += byteCount - read;
403                     return byteCount;
404                 }
405                 // Couldn&#39;t get all the bytes, skip what we read
406                 read += (count - pos);
407                 pos = count;
408                 return read;
409             }
410         }
411         return read + localIn.skip(byteCount - read);
412     }
413 }",No
library\AndroidManifest.xml,library\AndroidManifest.xml,79c7d1f55e62dfb9588a0aa1c60f462c83eecef9,a3a23a8d53117ce1792523f5e6fde126b6efb48c,and sdk min and target to library,"@@ -12,4 +12,5 @@
       </intent-filter>
     </activity>
   </application>
+  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
 </manifest>
","15   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,b362a3df8471b8d8716b5747690b492e8fb2a984,79c7d1f55e62dfb9588a0aa1c60f462c83eecef9,"Add start/stop to disk cache

If you open an already open disk cache you corrupt
the journal which wipes the cache. This is an
effort to avoid that behavior.","@@ -331,6 +331,18 @@ public class ImageManager {
         });
     }
 
+    public void pause() {
+        if (diskCache != null) {
+            diskCache.stop();
+        }
+    }
+
+    public void resume() {
+        if (diskCache != null) {
+            diskCache.start();
+        }
+    }
+
     /**
      * Notify the ImageManager that a bitmap it loaded is not going to be displayed and can go into a queue to be
      * reused. Does nothing if recycling is disabled or impossible.
","334     public void pause() {
335         if (diskCache != null) {
336             diskCache.stop();
337         }
338     }
339 
340     public void resume() {
341         if (diskCache != null) {
342             diskCache.start();
343         }
344     }
345 ",No
library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,b362a3df8471b8d8716b5747690b492e8fb2a984,79c7d1f55e62dfb9588a0aa1c60f462c83eecef9,"Add start/stop to disk cache

If you open an already open disk cache you corrupt
the journal which wipes the cache. This is an
effort to avoid that behavior.","@@ -21,8 +21,20 @@ import java.security.NoSuchAlgorithmException;
 public class PhotoDiskCache {
     private final static int VALUE_COUNT = 1; //values per cache entry
     private DiskLruCache cache;
+    private final File directory;
+    private final long maxSize;
+    private final int appVersion;
 
     public PhotoDiskCache(File directory, long maxSize, int appVersion) {
+        this.directory = directory;
+        this.maxSize = maxSize;
+        this.appVersion = appVersion;
+        start();
+    }
+
+    public void start() {
+        if (cache != null && !cache.isClosed()) return;
+
         try {
             cache = DiskLruCache.open(directory, appVersion, VALUE_COUNT, maxSize);
         } catch (IOException e) {
@@ -30,7 +42,22 @@ public class PhotoDiskCache {
         }
     }
 
+    public void stop() {
+        if (cache == null) return;
+
+        try {
+            cache.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
     public void put(final String key, final Bitmap bitmap) {
+        if (cache.isClosed()) {
+            Log.d(""DLRU: put while cache is closed!"");
+            return;
+        }
+
         if (bitmap == null) return;
         final String safeKey = sha1Hash(key);
 
@@ -67,6 +94,10 @@ public class PhotoDiskCache {
     }
 
     public InputStream get(final String key) {
+        if (cache.isClosed()) {
+            Log.d(""DLRU: get while cache is closed key="" + key);
+            return null;
+        }
         //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
         final String safeKey = sha1Hash(key);
         InputStream result = null;
@@ -80,7 +111,6 @@ public class PhotoDiskCache {
             }
 
         } catch (IOException e) {
-            Log.d(""DLRU: IOException? key="" + key);
             e.printStackTrace();
             try {
                 cache.remove(safeKey);
","24     private final File directory;
25     private final long maxSize;
26     private final int appVersion;
29         this.directory = directory;
30         this.maxSize = maxSize;
31         this.appVersion = appVersion;
32         start();
33     }
34 
35     public void start() {
36         if (cache != null && !cache.isClosed()) return;
37 
45     public void stop() {
46         if (cache == null) return;
47 
48         try {
49             cache.close();
50         } catch (IOException e) {
51             e.printStackTrace();
52         }
53     }
54 
56         if (cache.isClosed()) {
57             Log.d(""DLRU: put while cache is closed!"");
58             return;
59         }
60 
97         if (cache.isClosed()) {
98             Log.d(""DLRU: get while cache is closed key="" + key);
99             return null;
100         }
83             Log.d(""DLRU: IOException? key="" + key);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,5a6c20ad694ddc0aa7ed76745eb61ea6f45889ae,b362a3df8471b8d8716b5747690b492e8fb2a984,Add an option to set max # of recycled bitmaps,"@@ -80,6 +80,17 @@ public class ImageManager {
          * otherwise.
          */
         public boolean recycleBitmaps = true;
+
+        /**
+         * The maximum number of recycled bitmaps of any requested size to keep around. Only used if recycleBitmaps
+         * is true. A higher number means loads are more likely to be able to reuse a bitmap but also that this object
+         * will use more memory. Increase this if there are few varieties of bitmaps that will be scrolled rapidly (ie
+         * a GridView of images with lots of columns), and decrease it if there are a lot of different sizes of bitmaps
+         * and limited memory is available.
+         *
+         * Defaults to 20
+         */
+        public int maxPerSize = 0;
     }
 
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
@@ -226,7 +237,7 @@ public class ImageManager {
                     }
                 });
             }
-            bitmapCache = new SizedBitmapCache();
+            bitmapCache = new SizedBitmapCache(options.maxPerSize);
         } else {
             bitmapCache = null;
         }
","83 
84         /**
85          * The maximum number of recycled bitmaps of any requested size to keep around. Only used if recycleBitmaps
86          * is true. A higher number means loads are more likely to be able to reuse a bitmap but also that this object
87          * will use more memory. Increase this if there are few varieties of bitmaps that will be scrolled rapidly (ie
88          * a GridView of images with lots of columns), and decrease it if there are a lot of different sizes of bitmaps
89          * and limited memory is available.
90          *
91          * Defaults to 20
92          */
93         public int maxPerSize = 0;
240             bitmapCache = new SizedBitmapCache(options.maxPerSize);
229             bitmapCache = new SizedBitmapCache();",No
library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,5a6c20ad694ddc0aa7ed76745eb61ea6f45889ae,b362a3df8471b8d8716b5747690b492e8fb2a984,Add an option to set max # of recycled bitmaps,"@@ -16,8 +16,13 @@ import java.util.Queue;
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
 public class SizedBitmapCache {
-    private static final int MAX_PER_SIZE = 20;
+    private static final int DEFAULT_MAX_PER_SIZE = 20;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
+    private final int maxPerSize;
+
+    public SizedBitmapCache(int maxPerSize) {
+        this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
+    }
 
     public void put(Bitmap bitmap) {
         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
@@ -27,7 +32,7 @@ public class SizedBitmapCache {
             availableBitmaps.put(sizeKey, available);
         }
 
-        if (available.size() < MAX_PER_SIZE) {
+        if (available.size() < maxPerSize) {
             available.add(bitmap);
         }
         //Log.d(""SBC: put key="" + sizeKey + "" available="" + available.size());
","19     private static final int DEFAULT_MAX_PER_SIZE = 20;
21     private final int maxPerSize;
22 
23     public SizedBitmapCache(int maxPerSize) {
24         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
25     }
35         if (available.size() < maxPerSize) {
19     private static final int MAX_PER_SIZE = 20;
30         if (available.size() < MAX_PER_SIZE) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,1ba9a837563245b9b1e21c3cf7c696661bdb11b3,5a6c20ad694ddc0aa7ed76745eb61ea6f45889ae,"Fix a bitmap recycling issue

Doesn't really speed anything up past the first
load anyway...","@@ -462,6 +462,10 @@ public class ImageManager {
             }
 
             if (result != null) {
+                if (!isInDiskCache && useDiskCache) {
+                    putInDiskCache(key, result);
+                }
+
                 final Bitmap finalResult = result;
                 mainHandler.post(new Runnable() {
                     @Override
@@ -470,11 +474,8 @@ public class ImageManager {
                         putInMemoryCache(key, finalResult);
                         cb.onLoadCompleted(finalResult);
                     }
+
                 });
-                //this is time consuming so do it after posting the result
-                if (!isInDiskCache && useDiskCache) {
-                    putInDiskCache(key, result);
-                }
             }
         }
 
","465                 if (!isInDiskCache && useDiskCache) {
466                     putInDiskCache(key, result);
467                 }
468 
477 
474                 //this is time consuming so do it after posting the result
475                 if (!isInDiskCache && useDiskCache) {
476                     putInDiskCache(key, result);
477                 }",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,2b84d41f0cff5e824d6aad39893b2d5f6155396c,1ba9a837563245b9b1e21c3cf7c696661bdb11b3,"Remove lots of static methods from ImageResizer

Allows us to pass around fewer method arguments","@@ -53,10 +53,7 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        final Bitmap streamed = streamIn(path, width, height, tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
+        final Bitmap streamed = streamIn(path, width, height);
 
         if (streamed.getWidth() == width && streamed.getHeight() == height) {
             return streamed;
@@ -76,10 +73,7 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap fitInSpace(final String path, final int width, final int height){
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height, tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
+        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
@@ -92,12 +86,7 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap loadApproximate(final String path, final int width, final int height){
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        final Bitmap result = streamIn(path, width, height, tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
-
-        return result;
+        return streamIn(path, width, height);
     }
 
     /**
@@ -112,10 +101,8 @@ public class ImageResizer {
      */
     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
         int[] dimens = new int[] {-1, -1};
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
         try {
-            dimens = getDimension(is1, tempStorage, bufStorage);
+            dimens = getDimension(is1);
         } finally {
             try {
                 is1.close();
@@ -123,17 +110,7 @@ public class ImageResizer {
                 e.printStackTrace();
             }
         }
-        releaseTempBytes(tempStorage, bufStorage);
-
-        return loadAsIs(is2, getRecycled(dimens));
-    }
-
-    public Bitmap loadAsIs(final InputStream is, final Bitmap recycled) {
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        final Bitmap result = load(is, recycled, tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
-        return result;
+        return load(is2, getRecycled(dimens));
     }
 
     /**
@@ -151,11 +128,7 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(final String path, final int width, final int height) {
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        final Bitmap result = load(path, getRecycled(width, height), tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
-        return result;
+        return load(path, getRecycled(width, height));
     }
 
     /**
@@ -166,12 +139,8 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(final String path){
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        int[] dimens = getDimensions(path, tempStorage, bufStorage);
-        final Bitmap result = load(path, getRecycled(dimens), tempStorage, bufStorage);
-        releaseTempBytes(tempStorage, bufStorage);
-        return result;
+        final int[] dimens = getDimensions(path);
+        return load(path, getRecycled(dimens));
     }
 
     private Bitmap getRecycled(int[] dimens) {
@@ -186,7 +155,6 @@ public class ImageResizer {
         return result;
     }
 
-
     private byte[] getTempBytes() {
         final byte[] result;
         if (tempQueue.size() > 0) {
@@ -361,8 +329,8 @@ public class ImageResizer {
      * @param path The path where the image is stored
      * @return A Bitmap representing the image at the given path
      */
-    public static Bitmap load(String path, byte[] tempStorage, byte[] bufStorage) {
-        return load(path, null, tempStorage, bufStorage);
+    public Bitmap load(String path) {
+        return load(path, null);
     }
 
     /**
@@ -377,10 +345,10 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
      */
-    public static Bitmap load(String path, Bitmap recycle, byte[] tempStorage, byte[] bufStorage) {
+    public Bitmap load(String path, Bitmap recycle) {
         Bitmap result = null;
         try {
-            result = load(new FileInputStream(path), recycle, tempStorage, bufStorage);
+            result = load(new FileInputStream(path), recycle);
         } catch (FileNotFoundException e) {
             Log.d(""PSR: file not found loading bitmap at: "" + path);
             e.printStackTrace();
@@ -394,8 +362,8 @@ public class ImageResizer {
      * @param is The input stream representing the image data
      * @return A Bitmap representing the image at the given path
      */
-    public static Bitmap load(InputStream is, byte[] tempSpace, byte[] bufSpace) {
-        return load(is, null, tempSpace, bufSpace);
+    public Bitmap load(InputStream is) {
+        return load(is, null);
     }
 
     /**
@@ -410,9 +378,9 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
      */
-    public static Bitmap load(InputStream is, Bitmap recycle, byte[] tempSpace, byte[] bufSpace){
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle, tempSpace);
-        return decodeStream(is, decodeBitmapOptions, bufSpace);
+    public Bitmap load(InputStream is, Bitmap recycle){
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
+        return decodeStream(is, decodeBitmapOptions);
     }
 
     /**
@@ -421,10 +389,10 @@ public class ImageResizer {
      * @param path The path where the image is stored
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    public static int[] getDimensions(String path, byte[] tempStorage, byte[] bufStorage) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempStorage);
+    public int[] getDimensions(String path) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(path, decodeBoundsOptions, bufStorage);
+        decodeStream(path, decodeBoundsOptions);
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
@@ -434,10 +402,10 @@ public class ImageResizer {
      * @param is The InputStream representing the image
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    public static int[] getDimension(InputStream is, byte[] tempSpace, byte[] bufSpace) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempSpace);
+    public int[] getDimension(InputStream is) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(is, decodeBoundsOptions, bufSpace);
+        decodeStream(is, decodeBoundsOptions);
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
@@ -452,7 +420,7 @@ public class ImageResizer {
      * @param height The target height
      * @return A Bitmap containing the image
      */
-    public static Bitmap streamIn(String path, int width, int height, byte[] tempSpace, byte[] bufSpace) {
+    public Bitmap streamIn(String path, int width, int height) {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
             //Swap width and height for initial downsample calculation if its oriented so.
@@ -462,18 +430,17 @@ public class ImageResizer {
             height = w;
         }
 
-        Bitmap result = null;
-        final int[] dimens = getDimensions(path, tempSpace, bufSpace);
+        final int[] dimens = getDimensions(path);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
         int sampleSize = Math.min(originalHeight / height, originalWidth / width);
 
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(tempSpace);
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
-        result = decodeStream(path, decodeBitmapOptions, bufSpace);
+        Bitmap result = decodeStream(path, decodeBitmapOptions);
 
         if (orientation != 0) {
             result = rotateImage(result, orientation);
@@ -552,12 +519,12 @@ public class ImageResizer {
         return imageToOrient;
    }
 
-   private static Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
+   private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
        InputStream is = null;
        Bitmap result = null;
        try {
            is = new FileInputStream(path);
-           result = decodeStream(is, decodeBitmapOptions, bufSpace);
+           result = decodeStream(is, decodeBitmapOptions);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
@@ -572,8 +539,11 @@ public class ImageResizer {
        return result;
    }
 
-   private static Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
-       ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufSpace);
+   private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
+       byte[] tempStorage = getTempBytes();
+       byte[] bufStorage = getTempBytes();
+       ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
+       decodeBitmapOptions.inTempStorage = tempStorage;
        Bitmap result = null;
        try {
            result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
@@ -583,20 +553,20 @@ public class ImageResizer {
            } catch (IOException e) {
                e.printStackTrace();
            }
+           releaseTempBytes(tempStorage, bufStorage);
        }
        return result;
    }
 
-   private static BitmapFactory.Options getDefaultOptions(byte[] tempStorage) {
-      return getDefaultOptions(null, tempStorage);
+   private static BitmapFactory.Options getDefaultOptions() {
+      return getDefaultOptions(null);
    }
 
-   private static BitmapFactory.Options getDefaultOptions(Bitmap recycle, byte[] tempStorage) {
+   private static BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
        BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
        decodeBitmapOptions.inDither = false;
        decodeBitmapOptions.inScaled = false;
        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
-       decodeBitmapOptions.inTempStorage = tempStorage;
        decodeBitmapOptions.inSampleSize = 1;
        if (Build.VERSION.SDK_INT >= 11)  {
            decodeBitmapOptions.inMutable = true;
","56         final Bitmap streamed = streamIn(path, width, height);
76         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
89         return streamIn(path, width, height);
105             dimens = getDimension(is1);
113         return load(is2, getRecycled(dimens));
131         return load(path, getRecycled(width, height));
142         final int[] dimens = getDimensions(path);
143         return load(path, getRecycled(dimens));
332     public Bitmap load(String path) {
333         return load(path, null);
348     public Bitmap load(String path, Bitmap recycle) {
351             result = load(new FileInputStream(path), recycle);
365     public Bitmap load(InputStream is) {
366         return load(is, null);
381     public Bitmap load(InputStream is, Bitmap recycle){
382         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
383         return decodeStream(is, decodeBitmapOptions);
392     public int[] getDimensions(String path) {
393         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
395         decodeStream(path, decodeBoundsOptions);
405     public int[] getDimension(InputStream is) {
406         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
408         decodeStream(is, decodeBoundsOptions);
423     public Bitmap streamIn(String path, int width, int height) {
433         final int[] dimens = getDimensions(path);
440         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
443         Bitmap result = decodeStream(path, decodeBitmapOptions);
522    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
527            result = decodeStream(is, decodeBitmapOptions);
542    private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
543        byte[] tempStorage = getTempBytes();
544        byte[] bufStorage = getTempBytes();
545        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
546        decodeBitmapOptions.inTempStorage = tempStorage;
556            releaseTempBytes(tempStorage, bufStorage);
561    private static BitmapFactory.Options getDefaultOptions() {
562       return getDefaultOptions(null);
565    private static BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
56         byte[] tempStorage = getTempBytes();
57         byte[] bufStorage = getTempBytes();
58         final Bitmap streamed = streamIn(path, width, height, tempStorage, bufStorage);
59         releaseTempBytes(tempStorage, bufStorage);
79         byte[] tempStorage = getTempBytes();
80         byte[] bufStorage = getTempBytes();
81         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height, tempStorage, bufStorage);
82         releaseTempBytes(tempStorage, bufStorage);
95         byte[] tempStorage = getTempBytes();
96         byte[] bufStorage = getTempBytes();
97         final Bitmap result = streamIn(path, width, height, tempStorage, bufStorage);
98         releaseTempBytes(tempStorage, bufStorage);
99 
100         return result;
115         byte[] tempStorage = getTempBytes();
116         byte[] bufStorage = getTempBytes();
118             dimens = getDimension(is1, tempStorage, bufStorage);
126         releaseTempBytes(tempStorage, bufStorage);
127 
128         return loadAsIs(is2, getRecycled(dimens));
129     }
130 
131     public Bitmap loadAsIs(final InputStream is, final Bitmap recycled) {
132         byte[] tempStorage = getTempBytes();
133         byte[] bufStorage = getTempBytes();
134         final Bitmap result = load(is, recycled, tempStorage, bufStorage);
135         releaseTempBytes(tempStorage, bufStorage);
136         return result;
154         byte[] tempStorage = getTempBytes();
155         byte[] bufStorage = getTempBytes();
156         final Bitmap result = load(path, getRecycled(width, height), tempStorage, bufStorage);
157         releaseTempBytes(tempStorage, bufStorage);
158         return result;
169         byte[] tempStorage = getTempBytes();
170         byte[] bufStorage = getTempBytes();
171         int[] dimens = getDimensions(path, tempStorage, bufStorage);
172         final Bitmap result = load(path, getRecycled(dimens), tempStorage, bufStorage);
173         releaseTempBytes(tempStorage, bufStorage);
174         return result;
189 
364     public static Bitmap load(String path, byte[] tempStorage, byte[] bufStorage) {
365         return load(path, null, tempStorage, bufStorage);
380     public static Bitmap load(String path, Bitmap recycle, byte[] tempStorage, byte[] bufStorage) {
383             result = load(new FileInputStream(path), recycle, tempStorage, bufStorage);
397     public static Bitmap load(InputStream is, byte[] tempSpace, byte[] bufSpace) {
398         return load(is, null, tempSpace, bufSpace);
413     public static Bitmap load(InputStream is, Bitmap recycle, byte[] tempSpace, byte[] bufSpace){
414         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle, tempSpace);
415         return decodeStream(is, decodeBitmapOptions, bufSpace);
424     public static int[] getDimensions(String path, byte[] tempStorage, byte[] bufStorage) {
425         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempStorage);
427         decodeStream(path, decodeBoundsOptions, bufStorage);
437     public static int[] getDimension(InputStream is, byte[] tempSpace, byte[] bufSpace) {
438         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions(tempSpace);
440         decodeStream(is, decodeBoundsOptions, bufSpace);
455     public static Bitmap streamIn(String path, int width, int height, byte[] tempSpace, byte[] bufSpace) {
465         Bitmap result = null;
466         final int[] dimens = getDimensions(path, tempSpace, bufSpace);
473         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(tempSpace);
476         result = decodeStream(path, decodeBitmapOptions, bufSpace);
555    private static Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
560            result = decodeStream(is, decodeBitmapOptions, bufSpace);
575    private static Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions, byte[] bufSpace) {
576        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufSpace);
590    private static BitmapFactory.Options getDefaultOptions(byte[] tempStorage) {
591       return getDefaultOptions(null, tempStorage);
594    private static BitmapFactory.Options getDefaultOptions(Bitmap recycle, byte[] tempStorage) {
599        decodeBitmapOptions.inTempStorage = tempStorage;",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,d8e2236aa4acb272a849db727c9091bb4be92417,2b84d41f0cff5e824d6aad39893b2d5f6155396c,Add ability to set default options for resizer,"@@ -6,6 +6,7 @@ package com.bumptech.photos.resize;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
@@ -91,6 +92,14 @@ public class ImageManager {
          * Defaults to 20
          */
         public int maxPerSize = 0;
+
+        /**
+         * Options for loading bitmaps. Some of these fields will be overwritten, including inSampleSize, inBitmap,
+         * and maybe inMutable depending on how recycleBitmaps is set.
+         *
+         * Config and dither for example can be set
+         */
+        public BitmapFactory.Options bitmapDecodeOptions = ImageResizer.getDefaultOptions();
     }
 
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
@@ -239,10 +248,11 @@ public class ImageManager {
             }
             bitmapCache = new SizedBitmapCache(options.maxPerSize);
         } else {
+            options.bitmapDecodeOptions.inMutable = false;
             bitmapCache = null;
         }
 
-        this.resizer = new ImageResizer(bitmapCache);
+        this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
         this.mainHandler = mainHandler;
         this.executor = executor;
     }
","9 import android.graphics.BitmapFactory;
95 
96         /**
97          * Options for loading bitmaps. Some of these fields will be overwritten, including inSampleSize, inBitmap,
98          * and maybe inMutable depending on how recycleBitmaps is set.
99          *
100          * Config and dither for example can be set
101          */
102         public BitmapFactory.Options bitmapDecodeOptions = ImageResizer.getDefaultOptions();
251             options.bitmapDecodeOptions.inMutable = false;
255         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
245         this.resizer = new ImageResizer(bitmapCache);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,d8e2236aa4acb272a849db727c9091bb4be92417,2b84d41f0cff5e824d6aad39893b2d5f6155396c,Add ability to set default options for resizer,"@@ -25,13 +25,34 @@ import java.util.Queue;
  */
 public class ImageResizer {
     private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
-    private final SizedBitmapCache bitmapCache;
+    private SizedBitmapCache bitmapCache = null;
+    private final BitmapFactory.Options defaultOptions;
+
+    public static BitmapFactory.Options getDefaultOptions() {
+       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
+       decodeBitmapOptions.inDither = false;
+       decodeBitmapOptions.inScaled = false;
+       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
+       decodeBitmapOptions.inSampleSize = 1;
+       if (Build.VERSION.SDK_INT >= 11)  {
+           decodeBitmapOptions.inMutable = true;
+       }
+       return decodeBitmapOptions;
+    }
 
     /**
      * Creates a new resizer that will not recycle Bitmaps
      */
     public ImageResizer() {
-        this(null);
+        this(null, null);
+    }
+
+    public ImageResizer(SizedBitmapCache bitmapCache) {
+        this(bitmapCache, null);
+    }
+
+    public ImageResizer(BitmapFactory.Options options) {
+        this(null, options);
     }
 
     /**
@@ -39,8 +60,13 @@ public class ImageResizer {
      *
      * @param bitmapCache The cache to try to recycle {@link android.graphics.Bitmap}s from
      */
-    public ImageResizer(SizedBitmapCache bitmapCache){
+    public ImageResizer(SizedBitmapCache bitmapCache, BitmapFactory.Options defaultOptions){
         this.bitmapCache = bitmapCache;
+        if (defaultOptions == null) {
+            this.defaultOptions = getDefaultOptions();
+        } else {
+            this.defaultOptions = defaultOptions;
+        }
     }
 
     /**
@@ -143,6 +169,13 @@ public class ImageResizer {
         return load(path, getRecycled(dimens));
     }
 
+    private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
+        BitmapFactory.Options result = new BitmapFactory.Options();
+        copyOptions(defaultOptions, result);
+        result.inBitmap = recycle;
+        return result;
+    }
+
     private Bitmap getRecycled(int[] dimens) {
         return getRecycled(dimens[0], dimens[1]);
     }
@@ -176,6 +209,21 @@ public class ImageResizer {
         tempQueue.add(bytes);
     }
 
+    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
+        to.inDensity = from.inDensity;
+        to.inDither = from.inDither;
+        to.inInputShareable = from.inInputShareable;
+        to.inMutable = from.inMutable;
+        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
+        to.inPreferredConfig = from.inPreferredConfig;
+        to.inPurgeable = from.inPurgeable;
+        to.inSampleSize = from.inSampleSize;
+        to.inScaled = from.inScaled;
+        to.inScreenDensity = from.inScreenDensity;
+        to.inTargetDensity = from.inTargetDensity;
+
+    }
+
     /**
      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
      * the original proportions of the image
","28     private SizedBitmapCache bitmapCache = null;
29     private final BitmapFactory.Options defaultOptions;
30 
31     public static BitmapFactory.Options getDefaultOptions() {
32        BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
33        decodeBitmapOptions.inDither = false;
34        decodeBitmapOptions.inScaled = false;
35        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
36        decodeBitmapOptions.inSampleSize = 1;
37        if (Build.VERSION.SDK_INT >= 11)  {
38            decodeBitmapOptions.inMutable = true;
39        }
40        return decodeBitmapOptions;
41     }
47         this(null, null);
48     }
49 
50     public ImageResizer(SizedBitmapCache bitmapCache) {
51         this(bitmapCache, null);
52     }
53 
54     public ImageResizer(BitmapFactory.Options options) {
55         this(null, options);
63     public ImageResizer(SizedBitmapCache bitmapCache, BitmapFactory.Options defaultOptions){
65         if (defaultOptions == null) {
66             this.defaultOptions = getDefaultOptions();
67         } else {
68             this.defaultOptions = defaultOptions;
69         }
172     private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
173         BitmapFactory.Options result = new BitmapFactory.Options();
174         copyOptions(defaultOptions, result);
175         result.inBitmap = recycle;
176         return result;
177     }
178 
212     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
213         to.inDensity = from.inDensity;
214         to.inDither = from.inDither;
215         to.inInputShareable = from.inInputShareable;
216         to.inMutable = from.inMutable;
217         to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
218         to.inPreferredConfig = from.inPreferredConfig;
219         to.inPurgeable = from.inPurgeable;
220         to.inSampleSize = from.inSampleSize;
221         to.inScaled = from.inScaled;
222         to.inScreenDensity = from.inScreenDensity;
223         to.inTargetDensity = from.inTargetDensity;
224 
225     }
226 
28     private final SizedBitmapCache bitmapCache;
34         this(null);
42     public ImageResizer(SizedBitmapCache bitmapCache){",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,60d4a53813e96d3945c17e06954de35128570288,d8e2236aa4acb272a849db727c9091bb4be92417,More static code cleanup in resizer,"@@ -69,6 +69,8 @@ public class ImageResizer {
         }
     }
 
+
+
     /**
      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
      * and then crop the image down so that it fills the given dimensions
@@ -79,7 +81,7 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
-        final Bitmap streamed = streamIn(path, width, height);
+        final Bitmap streamed = loadApproximate(path, width, height);
 
         if (streamed.getWidth() == width && streamed.getHeight() == height) {
             return streamed;
@@ -99,20 +101,48 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap fitInSpace(final String path, final int width, final int height){
-        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
+        final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
     /**
-     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions
+     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
+     * rotate the image according to the orientation in the images EXIF data if available.
      *
-     * @param path The path where the image is located
+     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
+     *
+     * @param path The path where the image is stored
      * @param width The target width
      * @param height The target height
-     * @return The resized image
+     * @return A Bitmap containing the image
      */
-    public Bitmap loadApproximate(final String path, final int width, final int height){
-        return streamIn(path, width, height);
+    public Bitmap loadApproximate(String path, int width, int height) {
+        int orientation = getOrientation(path);
+        if(orientation == 90 || orientation == 270) {
+            //Swap width and height for initial downsample calculation if its oriented so.
+            //The image will then be rotated back to normal.
+            int w = width;
+            width = height;
+            height = w;
+        }
+
+        final int[] dimens = getDimensions(path);
+        final int originalWidth = dimens[0];
+        final int originalHeight = dimens[1];
+
+        // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
+        int sampleSize = Math.min(originalHeight / height, originalWidth / width);
+
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
+        decodeBitmapOptions.inSampleSize = sampleSize;
+
+        Bitmap result = decodeStream(path, decodeBitmapOptions);
+
+        if (orientation != 0) {
+            result = rotateImage(result, orientation);
+        }
+
+        return result;
     }
 
     /**
@@ -169,6 +199,106 @@ public class ImageResizer {
         return load(path, getRecycled(dimens));
     }
 
+    /**
+     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
+     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
+     * of memory.
+     *
+     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
+     * is provided.
+     *
+     * @param path The path where the image is stored
+     * @param recycle A Bitmap we can load the image into, or null
+     * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
+     */
+    private Bitmap load(String path, Bitmap recycle) {
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
+        final Bitmap result = decodeStream(path, decodeBitmapOptions);
+        return result == null ? null : orientImage(path, result);
+    }
+
+    /**
+     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
+     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
+     * of memory.
+     *
+     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
+     * is provided.
+     *
+     * @param is The InputStream representing the image data
+     * @param recycle A Bitmap we can load the image into, or null
+     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
+     */
+    private Bitmap load(InputStream is, Bitmap recycle){
+        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
+        return decodeStream(is, decodeBitmapOptions);
+    }
+
+    /**
+     * A method for getting the dimensions of an image at the given path
+     *
+     * @param path The path where the image is stored
+     * @return an array containing the dimensions of the image in the form {width, height}
+     */
+    private int[] getDimensions(String path) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
+        decodeBoundsOptions.inJustDecodeBounds = true;
+        decodeStream(path, decodeBoundsOptions);
+        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
+    }
+
+     /**
+     * A method for getting the dimensions of an image from the given InputStream
+     *
+     * @param is The InputStream representing the image
+     * @return an array containing the dimensions of the image in the form {width, height}
+     */
+    private int[] getDimension(InputStream is) {
+        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
+        decodeBoundsOptions.inJustDecodeBounds = true;
+        decodeStream(is, decodeBoundsOptions);
+        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
+    }
+
+    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
+        InputStream is = null;
+        Bitmap result = null;
+        try {
+            is = new FileInputStream(path);
+            result = decodeStream(is, decodeBitmapOptions);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } finally {
+            if (is !=null) {
+                try {
+                    is.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return result;
+    }
+
+    private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
+        byte[] tempStorage = getTempBytes();
+        byte[] bufStorage = getTempBytes();
+        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
+        decodeBitmapOptions.inTempStorage = tempStorage;
+        Bitmap result = null;
+        try {
+            result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
+        } finally {
+            try {
+                bis.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            releaseTempBytes(tempStorage, bufStorage);
+        }
+        return result;
+    }
+
     private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
         BitmapFactory.Options result = new BitmapFactory.Options();
         copyOptions(defaultOptions, result);
@@ -224,6 +354,7 @@ public class ImageResizer {
 
     }
 
+
     /**
      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
      * the original proportions of the image
@@ -370,133 +501,6 @@ public class ImageResizer {
         }
     }
 
-
-    /**
-     * An expensive operation to load the image at the given path
-     *
-     * @param path The path where the image is stored
-     * @return A Bitmap representing the image at the given path
-     */
-    public Bitmap load(String path) {
-        return load(path, null);
-    }
-
-    /**
-     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
-     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
-     * of memory.
-     *
-     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
-     * is provided.
-     *
-     * @param path The path where the image is stored
-     * @param recycle A Bitmap we can load the image into, or null
-     * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
-     */
-    public Bitmap load(String path, Bitmap recycle) {
-        Bitmap result = null;
-        try {
-            result = load(new FileInputStream(path), recycle);
-        } catch (FileNotFoundException e) {
-            Log.d(""PSR: file not found loading bitmap at: "" + path);
-            e.printStackTrace();
-        }
-        return result == null ? null : orientImage(path, result);
-    }
-
-    /**
-     * An expensive operation to load the image from the given InputStream
-     *
-     * @param is The input stream representing the image data
-     * @return A Bitmap representing the image at the given path
-     */
-    public Bitmap load(InputStream is) {
-        return load(is, null);
-    }
-
-    /**
-     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
-     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
-     * of memory.
-     *
-     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
-     * is provided.
-     *
-     * @param is The InputStream representing the image data
-     * @param recycle A Bitmap we can load the image into, or null
-     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
-     */
-    public Bitmap load(InputStream is, Bitmap recycle){
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
-        return decodeStream(is, decodeBitmapOptions);
-    }
-
-    /**
-     * A method for getting the dimensions of an image at the given path
-     *
-     * @param path The path where the image is stored
-     * @return an array containing the dimensions of the image in the form {width, height}
-     */
-    public int[] getDimensions(String path) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
-        decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(path, decodeBoundsOptions);
-        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
-    }
-
-     /**
-     * A method for getting the dimensions of an image from the given InputStream
-     *
-     * @param is The InputStream representing the image
-     * @return an array containing the dimensions of the image in the form {width, height}
-     */
-    public int[] getDimension(InputStream is) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
-        decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(is, decodeBoundsOptions);
-        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
-    }
-
-    /**
-     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
-     * rotate the image according to the orientation in the images EXIF data if available.
-     *
-     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
-     *
-     * @param path The path where the image is stored
-     * @param width The target width
-     * @param height The target height
-     * @return A Bitmap containing the image
-     */
-    public Bitmap streamIn(String path, int width, int height) {
-        int orientation = getOrientation(path);
-        if(orientation == 90 || orientation == 270) {
-            //Swap width and height for initial downsample calculation if its oriented so.
-            //The image will then be rotated back to normal.
-            int w = width;
-            width = height;
-            height = w;
-        }
-
-        final int[] dimens = getDimensions(path);
-        final int originalWidth = dimens[0];
-        final int originalHeight = dimens[1];
-
-        // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-        int sampleSize = Math.min(originalHeight / height, originalWidth / width);
-
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
-        decodeBitmapOptions.inSampleSize = sampleSize;
-
-        Bitmap result = decodeStream(path, decodeBitmapOptions);
-
-        if (orientation != 0) {
-            result = rotateImage(result, orientation);
-        }
-
-        return result;
-    }
-
    /**
      * Returns a matrix with rotation set based on Exif orientation tag.
      * If the orientation is undefined or 0 null is returned.
@@ -567,59 +571,7 @@ public class ImageResizer {
         return imageToOrient;
    }
 
-   private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
-       InputStream is = null;
-       Bitmap result = null;
-       try {
-           is = new FileInputStream(path);
-           result = decodeStream(is, decodeBitmapOptions);
-       } catch (FileNotFoundException e) {
-           e.printStackTrace();
-       } finally {
-           if (is !=null) {
-               try {
-                   is.close();
-               } catch (IOException e) {
-                   e.printStackTrace();
-               }
-           }
-       }
-       return result;
-   }
 
-   private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
-       byte[] tempStorage = getTempBytes();
-       byte[] bufStorage = getTempBytes();
-       ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
-       decodeBitmapOptions.inTempStorage = tempStorage;
-       Bitmap result = null;
-       try {
-           result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
-       } finally {
-           try {
-               bis.close();
-           } catch (IOException e) {
-               e.printStackTrace();
-           }
-           releaseTempBytes(tempStorage, bufStorage);
-       }
-       return result;
-   }
 
-   private static BitmapFactory.Options getDefaultOptions() {
-      return getDefaultOptions(null);
-   }
 
-   private static BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
-       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
-       decodeBitmapOptions.inDither = false;
-       decodeBitmapOptions.inScaled = false;
-       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
-       decodeBitmapOptions.inSampleSize = 1;
-       if (Build.VERSION.SDK_INT >= 11)  {
-           decodeBitmapOptions.inMutable = true;
-           decodeBitmapOptions.inBitmap = recycle;
-       }
-       return decodeBitmapOptions;
-    }
 }
","72 
73 
84         final Bitmap streamed = loadApproximate(path, width, height);
104         final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
109      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
110      * rotate the image according to the orientation in the images EXIF data if available.
112      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
113      *
114      * @param path The path where the image is stored
117      * @return A Bitmap containing the image
119     public Bitmap loadApproximate(String path, int width, int height) {
120         int orientation = getOrientation(path);
121         if(orientation == 90 || orientation == 270) {
122             //Swap width and height for initial downsample calculation if its oriented so.
123             //The image will then be rotated back to normal.
124             int w = width;
125             width = height;
126             height = w;
127         }
128 
129         final int[] dimens = getDimensions(path);
130         final int originalWidth = dimens[0];
131         final int originalHeight = dimens[1];
132 
133         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
134         int sampleSize = Math.min(originalHeight / height, originalWidth / width);
135 
136         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
137         decodeBitmapOptions.inSampleSize = sampleSize;
138 
139         Bitmap result = decodeStream(path, decodeBitmapOptions);
140 
141         if (orientation != 0) {
142             result = rotateImage(result, orientation);
143         }
144 
145         return result;
202     /**
203      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
204      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
205      * of memory.
206      *
207      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
208      * is provided.
209      *
210      * @param path The path where the image is stored
211      * @param recycle A Bitmap we can load the image into, or null
212      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
213      */
214     private Bitmap load(String path, Bitmap recycle) {
215         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
216         final Bitmap result = decodeStream(path, decodeBitmapOptions);
217         return result == null ? null : orientImage(path, result);
218     }
219 
220     /**
221      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
222      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
223      * of memory.
224      *
225      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
226      * is provided.
227      *
228      * @param is The InputStream representing the image data
229      * @param recycle A Bitmap we can load the image into, or null
230      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
231      */
232     private Bitmap load(InputStream is, Bitmap recycle){
233         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
234         return decodeStream(is, decodeBitmapOptions);
235     }
236 
237     /**
238      * A method for getting the dimensions of an image at the given path
239      *
240      * @param path The path where the image is stored
241      * @return an array containing the dimensions of the image in the form {width, height}
242      */
243     private int[] getDimensions(String path) {
244         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
245         decodeBoundsOptions.inJustDecodeBounds = true;
246         decodeStream(path, decodeBoundsOptions);
247         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
248     }
249 
250      /**
251      * A method for getting the dimensions of an image from the given InputStream
252      *
253      * @param is The InputStream representing the image
254      * @return an array containing the dimensions of the image in the form {width, height}
255      */
256     private int[] getDimension(InputStream is) {
257         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
258         decodeBoundsOptions.inJustDecodeBounds = true;
259         decodeStream(is, decodeBoundsOptions);
260         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
261     }
262 
263     private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
264         InputStream is = null;
265         Bitmap result = null;
266         try {
267             is = new FileInputStream(path);
268             result = decodeStream(is, decodeBitmapOptions);
269         } catch (FileNotFoundException e) {
270             e.printStackTrace();
271         } finally {
272             if (is !=null) {
273                 try {
274                     is.close();
275                 } catch (IOException e) {
276                     e.printStackTrace();
277                 }
278             }
279         }
280         return result;
281     }
282 
283     private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
284         byte[] tempStorage = getTempBytes();
285         byte[] bufStorage = getTempBytes();
286         ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
287         decodeBitmapOptions.inTempStorage = tempStorage;
288         Bitmap result = null;
289         try {
290             result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
291         } finally {
292             try {
293                 bis.close();
294             } catch (IOException e) {
295                 e.printStackTrace();
296             }
297             releaseTempBytes(tempStorage, bufStorage);
298         }
299         return result;
300     }
301 
357 
82         final Bitmap streamed = streamIn(path, width, height);
102         final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);
107      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions
109      * @param path The path where the image is located
112      * @return The resized image
114     public Bitmap loadApproximate(final String path, final int width, final int height){
115         return streamIn(path, width, height);
373 
374     /**
375      * An expensive operation to load the image at the given path
376      *
377      * @param path The path where the image is stored
378      * @return A Bitmap representing the image at the given path
379      */
380     public Bitmap load(String path) {
381         return load(path, null);
382     }
383 
384     /**
385      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
386      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
387      * of memory.
388      *
389      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
390      * is provided.
391      *
392      * @param path The path where the image is stored
393      * @param recycle A Bitmap we can load the image into, or null
394      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
395      */
396     public Bitmap load(String path, Bitmap recycle) {
397         Bitmap result = null;
398         try {
399             result = load(new FileInputStream(path), recycle);
400         } catch (FileNotFoundException e) {
401             Log.d(""PSR: file not found loading bitmap at: "" + path);
402             e.printStackTrace();
403         }
404         return result == null ? null : orientImage(path, result);
405     }
406 
407     /**
408      * An expensive operation to load the image from the given InputStream
409      *
410      * @param is The input stream representing the image data
411      * @return A Bitmap representing the image at the given path
412      */
413     public Bitmap load(InputStream is) {
414         return load(is, null);
415     }
416 
417     /**
418      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
419      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
420      * of memory.
421      *
422      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
423      * is provided.
424      *
425      * @param is The InputStream representing the image data
426      * @param recycle A Bitmap we can load the image into, or null
427      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
428      */
429     public Bitmap load(InputStream is, Bitmap recycle){
430         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
431         return decodeStream(is, decodeBitmapOptions);
432     }
433 
434     /**
435      * A method for getting the dimensions of an image at the given path
436      *
437      * @param path The path where the image is stored
438      * @return an array containing the dimensions of the image in the form {width, height}
439      */
440     public int[] getDimensions(String path) {
441         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
442         decodeBoundsOptions.inJustDecodeBounds = true;
443         decodeStream(path, decodeBoundsOptions);
444         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
445     }
446 
447      /**
448      * A method for getting the dimensions of an image from the given InputStream
449      *
450      * @param is The InputStream representing the image
451      * @return an array containing the dimensions of the image in the form {width, height}
452      */
453     public int[] getDimension(InputStream is) {
454         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
455         decodeBoundsOptions.inJustDecodeBounds = true;
456         decodeStream(is, decodeBoundsOptions);
457         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
458     }
459 
460     /**
461      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
462      * rotate the image according to the orientation in the images EXIF data if available.
463      *
464      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
465      *
466      * @param path The path where the image is stored
467      * @param width The target width
468      * @param height The target height
469      * @return A Bitmap containing the image
470      */
471     public Bitmap streamIn(String path, int width, int height) {
472         int orientation = getOrientation(path);
473         if(orientation == 90 || orientation == 270) {
474             //Swap width and height for initial downsample calculation if its oriented so.
475             //The image will then be rotated back to normal.
476             int w = width;
477             width = height;
478             height = w;
479         }
480 
481         final int[] dimens = getDimensions(path);
482         final int originalWidth = dimens[0];
483         final int originalHeight = dimens[1];
484 
485         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
486         int sampleSize = Math.min(originalHeight / height, originalWidth / width);
487 
488         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
489         decodeBitmapOptions.inSampleSize = sampleSize;
490 
491         Bitmap result = decodeStream(path, decodeBitmapOptions);
492 
493         if (orientation != 0) {
494             result = rotateImage(result, orientation);
495         }
496 
497         return result;
498     }
499 
570    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
571        InputStream is = null;
572        Bitmap result = null;
573        try {
574            is = new FileInputStream(path);
575            result = decodeStream(is, decodeBitmapOptions);
576        } catch (FileNotFoundException e) {
577            e.printStackTrace();
578        } finally {
579            if (is !=null) {
580                try {
581                    is.close();
582                } catch (IOException e) {
583                    e.printStackTrace();
584                }
585            }
586        }
587        return result;
588    }
590    private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
591        byte[] tempStorage = getTempBytes();
592        byte[] bufStorage = getTempBytes();
593        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
594        decodeBitmapOptions.inTempStorage = tempStorage;
595        Bitmap result = null;
596        try {
597            result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
598        } finally {
599            try {
600                bis.close();
601            } catch (IOException e) {
602                e.printStackTrace();
603            }
604            releaseTempBytes(tempStorage, bufStorage);
605        }
606        return result;
607    }
609    private static BitmapFactory.Options getDefaultOptions() {
610       return getDefaultOptions(null);
611    }
613    private static BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
614        BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
615        decodeBitmapOptions.inDither = false;
616        decodeBitmapOptions.inScaled = false;
617        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
618        decodeBitmapOptions.inSampleSize = 1;
619        if (Build.VERSION.SDK_INT >= 11)  {
620            decodeBitmapOptions.inMutable = true;
621            decodeBitmapOptions.inBitmap = recycle;
622        }
623        return decodeBitmapOptions;
624     }",No
.gitignore,.gitignore,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -6,3 +6,7 @@ library/local.properties
 *.DS_Store
 *.swp
 proguard-project.txt
+samples/flickr/.idea/*
+samples/flickr/gen/**/*
+samples/flickr/out/**/*
+samples/flickr/local.properties
","9 samples/flickr/.idea/*
10 samples/flickr/gen/**/*
11 samples/flickr/out/**/*
12 samples/flickr/local.properties",No
,samples\flickr\AndroidManifest.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,23 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<manifest xmlns:android=""http://schemas.android.com/apk/res/android""
+      package=""com.bumptech.flickr""
+      android:versionCode=""1""
+      android:versionName=""1.0"">
+    <application android:label=""@string/app_name"" android:icon=""@drawable/ic_launcher""
+      android:hardwareAccelerated=""true"">
+
+        <activity android:name=""MyActivity""
+                  android:label=""@string/app_name""
+          android:launchMode=""singleTask""
+          android:screenOrientation=""portrait"">
+            <intent-filter>
+                <action android:name=""android.intent.action.MAIN"" />
+                <category android:name=""android.intent.category.LAUNCHER"" />
+            </intent-filter>
+        </activity>
+    </application>
+
+  <uses-permission android:name=""android.permission.INTERNET"" />
+  <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
+  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
+</manifest>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
3       package=""com.bumptech.flickr""
4       android:versionCode=""1""
5       android:versionName=""1.0"">
6     <application android:label=""@string/app_name"" android:icon=""@drawable/ic_launcher""
7       android:hardwareAccelerated=""true"">
8 
9         <activity android:name=""MyActivity""
10                   android:label=""@string/app_name""
11           android:launchMode=""singleTask""
12           android:screenOrientation=""portrait"">
13             <intent-filter>
14                 <action android:name=""android.intent.action.MAIN"" />
15                 <category android:name=""android.intent.category.LAUNCHER"" />
16             </intent-filter>
17         </activity>
18     </application>
19 
20   <uses-permission android:name=""android.permission.INTERNET"" />
21   <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
22   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
23 </manifest>",No
,samples\flickr\ant.properties,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
","1 # This file is used to override default values used by the Ant build system.
2 #
3 # This file must be checked into Version Control Systems, as it is
4 # integral to the build system of your project.
5 
6 # This file is only used by the Ant script.
7 
8 # You can use this to override default values such as
9 #  'source.dir' for the location of your java source folder and
10 #  'out.dir' for the location of your output folder.
11 
12 # You can also use it define how the release builds are signed by declaring
13 # the following properties:
14 #  'key.store' for the location of your keystore and
15 #  'key.alias' for the name of the key to use.
16 # The password will be asked during the build when you use the 'release' target.
17 ",No
,samples\flickr\build.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,92 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project name=""flickr"" default=""help"">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file=""local.properties"" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file=""ant.properties"" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment=""env"" />
+    <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
+        <isset property=""env.ANDROID_HOME"" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile=""project.properties"" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
+            unless=""sdk.dir""
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file=""custom_rules.xml"" optional=""true"" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as ""android update project""
+    -->
+    <!-- version-tag: 1 -->
+    <import file=""${sdk.dir}/tools/ant/build.xml"" />
+
+</project>
","1 <?xml version=""1.0"" encoding=""UTF-8""?>
2 <project name=""flickr"" default=""help"">
3 
4     <!-- The local.properties file is created and updated by the 'android' tool.
5          It contains the path to the SDK. It should *NOT* be checked into
6          Version Control Systems. -->
7     <property file=""local.properties"" />
8 
9     <!-- The ant.properties file can be created by you. It is only edited by the
10          'android' tool to add properties to it.
11          This is the place to change some Ant specific build properties.
12          Here are some properties you may want to change/update:
13 
14          source.dir
15              The name of the source directory. Default is 'src'.
16          out.dir
17              The name of the output directory. Default is 'bin'.
18 
19          For other overridable properties, look at the beginning of the rules
20          files in the SDK, at tools/ant/build.xml
21 
22          Properties related to the SDK location or the project target should
23          be updated using the 'android' tool with the 'update' action.
24 
25          This file is an integral part of the build system for your
26          application and should be checked into Version Control Systems.
27 
28          -->
29     <property file=""ant.properties"" />
30 
31     <!-- if sdk.dir was not set from one of the property file, then
32          get it from the ANDROID_HOME env var.
33          This must be done before we load project.properties since
34          the proguard config can use sdk.dir -->
35     <property environment=""env"" />
36     <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
37         <isset property=""env.ANDROID_HOME"" />
38     </condition>
39 
40     <!-- The project.properties file is created and updated by the 'android'
41          tool, as well as ADT.
42 
43          This contains project specific properties such as project target, and library
44          dependencies. Lower level build properties are stored in ant.properties
45          (or in .classpath for Eclipse projects).
46 
47          This file is an integral part of the build system for your
48          application and should be checked into Version Control Systems. -->
49     <loadproperties srcFile=""project.properties"" />
50 
51     <!-- quick check on sdk.dir -->
52     <fail
53             message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
54             unless=""sdk.dir""
55     />
56 
57     <!--
58         Import per project custom build rules if present at the root of the project.
59         This is the place to put custom intermediary targets such as:
60             -pre-build
61             -pre-compile
62             -post-compile (This is typically used for code obfuscation.
63                            Compiled code location: ${out.classes.absolute.dir}
64                            If this is not done in place, override ${out.dex.input.absolute.dir})
65             -post-package
66             -post-build
67             -pre-clean
68     -->
69     <import file=""custom_rules.xml"" optional=""true"" />
70 
71     <!-- Import the actual build file.
72 
73          To customize existing targets, there are two options:
74          - Customize only one target:
75              - copy/paste the target into this file, *before* the
76                <import> task.
77              - customize it to your needs.
78          - Customize the whole content of build.xml
79              - copy/paste the content of the rules files (minus the top node)
80                into this file, replacing the <import> task.
81              - customize to your needs.
82 
83          ***********************
84          ****** IMPORTANT ******
85          ***********************
86          In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
87          in order to avoid having your file be overridden by tools such as ""android update project""
88     -->
89     <!-- version-tag: 1 -->
90     <import file=""${sdk.dir}/tools/ant/build.xml"" />
91 
92 </project>",No
,samples\flickr\project.properties,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# ""ant.properties"", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
+android.library.reference.1=../../library
","1 # This file is automatically generated by Android Tools.
2 # Do not modify this file -- YOUR CHANGES WILL BE ERASED!
3 #
4 # This file must be checked in Version Control Systems.
5 #
6 # To customize properties used by the Ant build system edit
7 # ""ant.properties"", and override values to adapt the script to your
8 # project structure.
9 #
10 # To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
11 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
12 
13 # Project target.
14 target=android-16
15 android.library.reference.1=../../library",No
,samples\flickr\res\anim\fade_in.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,8 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<alpha xmlns:android=""http://schemas.android.com/apk/res/android""
+	android:interpolator=""@android:anim/linear_interpolator""
+	android:fromAlpha=""0.0""
+	android:toAlpha=""1.0""
+	android:duration=""150""
+/>
+
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <alpha xmlns:android=""http://schemas.android.com/apk/res/android""
3 	android:interpolator=""@android:anim/linear_interpolator""
4 	android:fromAlpha=""0.0""
5 	android:toAlpha=""1.0""
6 	android:duration=""150""
7 />
8 ",No
samples\flickr\res\drawable-hdpi\ic_launcher.png,samples\flickr\res\drawable-hdpi\ic_launcher.png,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"Binary files /dev/null and b/samples/flickr/res/drawable-hdpi/ic_launcher.png differ
",,No
samples\flickr\res\drawable-ldpi\ic_launcher.png,samples\flickr\res\drawable-ldpi\ic_launcher.png,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"Binary files /dev/null and b/samples/flickr/res/drawable-ldpi/ic_launcher.png differ
",,No
samples\flickr\res\drawable-mdpi\ic_launcher.png,samples\flickr\res\drawable-mdpi\ic_launcher.png,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"Binary files /dev/null and b/samples/flickr/res/drawable-mdpi/ic_launcher.png differ
",,No
samples\flickr\res\drawable-xhdpi\ic_launcher.png,samples\flickr\res\drawable-xhdpi\ic_launcher.png,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"Binary files /dev/null and b/samples/flickr/res/drawable-xhdpi/ic_launcher.png differ
",,No
,samples\flickr\res\layout\main.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,23 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
+    android:orientation=""vertical""
+    android:layout_width=""fill_parent""
+    android:layout_height=""fill_parent"" >
+  <TextView
+    android:layout_width=""fill_parent""
+    android:layout_height=""wrap_content""
+    android:text=""Hello World, MyActivity"" />
+  <GridView
+    android:id=""@+id/images""
+    android:columnWidth=""@dimen/photo_side""
+    android:cacheColorHint=""#00000000""
+    android:fadingEdge=""none""
+    android:scrollingCache=""false""
+    android:numColumns=""auto_fit""
+    android:horizontalSpacing=""15dp""
+    android:verticalSpacing=""15dp""
+    android:layout_width=""fill_parent""
+    android:layout_height=""0dp""
+    android:layout_weight=""1""/>
+</LinearLayout>
+
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
3     android:orientation=""vertical""
4     android:layout_width=""fill_parent""
5     android:layout_height=""fill_parent"" >
6   <TextView
7     android:layout_width=""fill_parent""
8     android:layout_height=""wrap_content""
9     android:text=""Hello World, MyActivity"" />
10   <GridView
11     android:id=""@+id/images""
12     android:columnWidth=""@dimen/photo_side""
13     android:cacheColorHint=""#00000000""
14     android:fadingEdge=""none""
15     android:scrollingCache=""false""
16     android:numColumns=""auto_fit""
17     android:horizontalSpacing=""15dp""
18     android:verticalSpacing=""15dp""
19     android:layout_width=""fill_parent""
20     android:layout_height=""0dp""
21     android:layout_weight=""1""/>
22 </LinearLayout>
23 ",No
,samples\flickr\res\layout\photo_grid_square.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,6 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+
+<ImageView xmlns:android=""http://schemas.android.com/apk/res/android""
+    android:scaleType=""center""
+    android:layout_width=""@dimen/photo_side""
+    android:layout_height=""@dimen/photo_side""/>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 
3 <ImageView xmlns:android=""http://schemas.android.com/apk/res/android""
4     android:scaleType=""center""
5     android:layout_width=""@dimen/photo_side""
6     android:layout_height=""@dimen/photo_side""/>",No
,samples\flickr\res\values\dimens.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<resources>
+  <dimen name=""photo_side"">110dp</dimen>
+</resources>
\ No newline at end of file
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <dimen name=""photo_side"">110dp</dimen>
4 </resources>",No
,samples\flickr\res\values\strings.xml,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<resources>
+    <string name=""app_name"">MyActivity</string>
+</resources>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3     <string name=""app_name"">MyActivity</string>
4 </resources>",Yes
,samples\flickr\src\com\bumptech\flickr\FlickPathLoader.java,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,34 @@
+package com.bumptech.flickr;
+
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.photos.loader.path.BasePathLoader;
+
+import java.io.File;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/6/13
+ * Time: 11:55 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FlickPathLoader extends BasePathLoader<Photo> {
+    private final Api flickrApi;
+    private final File cacheDir;
+
+    public FlickPathLoader(Api flickApi, File cacheDir) {
+        this.flickrApi = flickApi;
+        this.cacheDir = cacheDir;
+    }
+
+    @Override
+    protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
+        flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
+            @Override
+            public void onDownloadComplete(String path) {
+                cb.onPathReady(path);
+            }
+        });
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import com.bumptech.flickr.api.Api;
4 import com.bumptech.flickr.api.Photo;
5 import com.bumptech.photos.loader.path.BasePathLoader;
6 
7 import java.io.File;
8 
9 /**
10  * Created with IntelliJ IDEA.
11  * User: sam
12  * Date: 1/6/13
13  * Time: 11:55 AM
14  * To change this template use File | Settings | File Templates.
15  */
16 public class FlickPathLoader extends BasePathLoader<Photo> {
17     private final Api flickrApi;
18     private final File cacheDir;
19 
20     public FlickPathLoader(Api flickApi, File cacheDir) {
21         this.flickrApi = flickApi;
22         this.cacheDir = cacheDir;
23     }
24 
25     @Override
26     protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
27         flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
28             @Override
29             public void onDownloadComplete(String path) {
30                 cb.onPathReady(path);
31             }
32         });
33     }
34 }",No
,samples\flickr\src\com\bumptech\flickr\MyActivity.java,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,124 @@
+package com.bumptech.flickr;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.BaseAdapter;
+import android.widget.GridView;
+import android.widget.ImageView;
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.photos.presenter.ImagePresenter;
+import com.bumptech.photos.presenter.ImageSetCallback;
+import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.loader.CenterCrop;
+import com.bumptech.photos.util.Log;
+
+import java.io.File;
+import java.util.List;
+
+public class MyActivity extends Activity {
+    private Api flickerApi;
+    private ImageManager imageManager;
+    private File cacheDir;
+
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+        String cacheName = ""flickr_cache"";
+        cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
+        if (!cacheDir.exists()) {
+            cacheDir.mkdir();
+        }
+
+        ImageManager.Options options = new ImageManager.Options();
+        options.maxMemorySize = 2 * 1024 * 1024;
+        options.maxPerSize = 40;
+        imageManager = new ImageManager(this, options);
+
+        flickerApi = new Api();
+        final GridView images = (GridView) findViewById(R.id.images);
+
+        flickerApi.search(""cat"", new Api.SearchCallback() {
+            @Override
+            public void onSearchCompleted(List<Photo> photos) {
+                Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
+                images.setAdapter(new PhotoAdapter(photos));
+            }
+        });
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        imageManager.resume();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        imageManager.pause();
+    }
+
+    private class PhotoAdapter extends BaseAdapter {
+
+        private final List<Photo> photos;
+        private final LayoutInflater inflater;
+
+        public PhotoAdapter(List<Photo> photos) {
+            this.photos = photos;
+            this.inflater = getLayoutInflater();
+        }
+
+        @Override
+        public int getCount() {
+            return photos.size();
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return photos.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;
+        }
+
+        @Override
+        public View getView(int position, View view, ViewGroup container) {
+            final ImagePresenter<Photo> presenter;
+            if (view == null) {
+                Log.d(""MyActivity: inflate"");
+                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
+                final Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.this, R.anim.fade_in);
+                presenter = new ImagePresenter.Builder<Photo>()
+                        .setImageView(imageView)
+                        .setPathLoader(new FlickPathLoader(flickerApi, cacheDir))
+                        .setImageLoader(new CenterCrop<Photo>(imageManager))
+                        .setImageSetCallback(new ImageSetCallback() {
+                            @Override
+                            public void onImageSet(ImageView view, boolean fromCache) {
+                                view.clearAnimation();
+                                if (!fromCache)
+                                    view.startAnimation(fadeIn);
+                            }
+                        })
+                        .build();
+                imageView.setTag(presenter);
+                view = imageView;
+            } else {
+                presenter = (ImagePresenter<Photo>) view.getTag();
+            }
+
+            presenter.setModel(photos.get(position));
+            return view;
+        }
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import android.app.Activity;
4 import android.os.Bundle;
5 import android.view.LayoutInflater;
6 import android.view.View;
7 import android.view.ViewGroup;
8 import android.view.animation.Animation;
9 import android.view.animation.AnimationUtils;
10 import android.widget.BaseAdapter;
11 import android.widget.GridView;
12 import android.widget.ImageView;
13 import com.bumptech.flickr.api.Api;
14 import com.bumptech.flickr.api.Photo;
15 import com.bumptech.photos.presenter.ImagePresenter;
16 import com.bumptech.photos.presenter.ImageSetCallback;
17 import com.bumptech.photos.resize.ImageManager;
18 import com.bumptech.photos.resize.loader.CenterCrop;
19 import com.bumptech.photos.util.Log;
20 
21 import java.io.File;
22 import java.util.List;
23 
24 public class MyActivity extends Activity {
25     private Api flickerApi;
26     private ImageManager imageManager;
27     private File cacheDir;
28 
29     /** Called when the activity is first created. */
30     @Override
31     public void onCreate(Bundle savedInstanceState) {
32         super.onCreate(savedInstanceState);
33         setContentView(R.layout.main);
34         String cacheName = ""flickr_cache"";
35         cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
36         if (!cacheDir.exists()) {
37             cacheDir.mkdir();
38         }
39 
40         ImageManager.Options options = new ImageManager.Options();
41         options.maxMemorySize = 2 * 1024 * 1024;
42         options.maxPerSize = 40;
43         imageManager = new ImageManager(this, options);
44 
45         flickerApi = new Api();
46         final GridView images = (GridView) findViewById(R.id.images);
47 
48         flickerApi.search(""cat"", new Api.SearchCallback() {
49             @Override
50             public void onSearchCompleted(List<Photo> photos) {
51                 Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
52                 images.setAdapter(new PhotoAdapter(photos));
53             }
54         });
55     }
56 
57     @Override
58     protected void onResume() {
59         super.onResume();
60         imageManager.resume();
61     }
62 
63     @Override
64     protected void onPause() {
65         super.onPause();
66         imageManager.pause();
67     }
68 
69     private class PhotoAdapter extends BaseAdapter {
70 
71         private final List<Photo> photos;
72         private final LayoutInflater inflater;
73 
74         public PhotoAdapter(List<Photo> photos) {
75             this.photos = photos;
76             this.inflater = getLayoutInflater();
77         }
78 
79         @Override
80         public int getCount() {
81             return photos.size();
82         }
83 
84         @Override
85         public Object getItem(int i) {
86             return photos.get(i);
87         }
88 
89         @Override
90         public long getItemId(int i) {
91             return 0;
92         }
93 
94         @Override
95         public View getView(int position, View view, ViewGroup container) {
96             final ImagePresenter<Photo> presenter;
97             if (view == null) {
98                 Log.d(""MyActivity: inflate"");
99                 ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
100                 final Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.this, R.anim.fade_in);
101                 presenter = new ImagePresenter.Builder<Photo>()
102                         .setImageView(imageView)
103                         .setPathLoader(new FlickPathLoader(flickerApi, cacheDir))
104                         .setImageLoader(new CenterCrop<Photo>(imageManager))
105                         .setImageSetCallback(new ImageSetCallback() {
106                             @Override
107                             public void onImageSet(ImageView view, boolean fromCache) {
108                                 view.clearAnimation();
109                                 if (!fromCache)
110                                     view.startAnimation(fadeIn);
111                             }
112                         })
113                         .build();
114                 imageView.setTag(presenter);
115                 view = imageView;
116             } else {
117                 presenter = (ImagePresenter<Photo>) view.getTag();
118             }
119 
120             presenter.setModel(photos.get(position));
121             return view;
122         }
123     }
124 }",No
,samples\flickr\src\com\bumptech\flickr\api\Api.java,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,88 @@
+package com.bumptech.flickr.api;
+
+import com.bumptech.photos.util.Log;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/6/13
+ * Time: 10:18 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Api {
+    private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
+    private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
+    private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s.jpg"";
+    private final Downloader downloader;
+
+    public interface SearchCallback {
+        public void onSearchCompleted(List<Photo> photos);
+    }
+
+    public interface PhotoCallback {
+        public void onDownloadComplete(String path);
+    }
+
+    public Api() {
+        this.downloader = Downloader.get();
+    }
+
+    private static String getUrlForMethod(String method) {
+        return String.format(SIGNED_API_URL, method);
+    }
+
+    private static String getSearchUrl(String text) {
+        return getUrlForMethod(""flickr.photos.search"") + ""&text="" + text + ""&per_page=500"";
+    }
+
+    private static String getPhotoUrl(Photo photo) {
+        return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
+    }
+
+    public void search(String text, final SearchCallback cb) {
+        Log.d(""API: searching"");
+        downloader.download(getSearchUrl(text), new Downloader.MemoryCallback() {
+            @Override
+            public void onDownloadReady(byte[] data) {
+                try {
+                    String stringResults = new String(data, ""UTF-8"");
+                    //cut out initial flickJsonApi(
+                    JSONObject searchResults = new JSONObject(stringResults.substring(14, stringResults.length()-1));
+                    JSONArray photos = searchResults.getJSONObject(""photos"").getJSONArray(""photo"");
+                    List<Photo> results = new ArrayList<Photo>(photos.length());
+                    for (int i = 0; i < photos.length(); i++) {
+                        results.add(new Photo(photos.getJSONObject(i)));
+                    }
+                    cb.onSearchCompleted(results);
+                } catch (JSONException e) {
+                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                } catch (UnsupportedEncodingException e) {
+                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                }
+            }
+        });
+    }
+
+    public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
+        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret);
+        if (out.exists()) {
+            cb.onDownloadComplete(out.getPath());
+        } else {
+            Log.d(""API: missing photo, downloading"");
+            downloader.download(getPhotoUrl(photo), out, new Downloader.DiskCallback() {
+                @Override
+                public void onDownloadReady(String path) {
+                    cb.onDownloadComplete(path);
+                }
+            });
+        }
+    }
+}
","1 package com.bumptech.flickr.api;
2 
3 import com.bumptech.photos.util.Log;
4 import org.json.JSONArray;
5 import org.json.JSONException;
6 import org.json.JSONObject;
7 
8 import java.io.File;
9 import java.io.UnsupportedEncodingException;
10 import java.util.ArrayList;
11 import java.util.List;
12 
13 /**
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 1/6/13
17  * Time: 10:18 AM
18  * To change this template use File | Settings | File Templates.
19  */
20 public class Api {
21     private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
22     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
23     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s.jpg"";
24     private final Downloader downloader;
25 
26     public interface SearchCallback {
27         public void onSearchCompleted(List<Photo> photos);
28     }
29 
30     public interface PhotoCallback {
31         public void onDownloadComplete(String path);
32     }
33 
34     public Api() {
35         this.downloader = Downloader.get();
36     }
37 
38     private static String getUrlForMethod(String method) {
39         return String.format(SIGNED_API_URL, method);
40     }
41 
42     private static String getSearchUrl(String text) {
43         return getUrlForMethod(""flickr.photos.search"") + ""&text="" + text + ""&per_page=500"";
44     }
45 
46     private static String getPhotoUrl(Photo photo) {
47         return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
48     }
49 
50     public void search(String text, final SearchCallback cb) {
51         Log.d(""API: searching"");
52         downloader.download(getSearchUrl(text), new Downloader.MemoryCallback() {
53             @Override
54             public void onDownloadReady(byte[] data) {
55                 try {
56                     String stringResults = new String(data, ""UTF-8"");
57                     //cut out initial flickJsonApi(
58                     JSONObject searchResults = new JSONObject(stringResults.substring(14, stringResults.length()-1));
59                     JSONArray photos = searchResults.getJSONObject(""photos"").getJSONArray(""photo"");
60                     List<Photo> results = new ArrayList<Photo>(photos.length());
61                     for (int i = 0; i < photos.length(); i++) {
62                         results.add(new Photo(photos.getJSONObject(i)));
63                     }
64                     cb.onSearchCompleted(results);
65                 } catch (JSONException e) {
66                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
67                 } catch (UnsupportedEncodingException e) {
68                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
69                 }
70             }
71         });
72     }
73 
74     public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
75         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret);
76         if (out.exists()) {
77             cb.onDownloadComplete(out.getPath());
78         } else {
79             Log.d(""API: missing photo, downloading"");
80             downloader.download(getPhotoUrl(photo), out, new Downloader.DiskCallback() {
81                 @Override
82                 public void onDownloadReady(String path) {
83                     cb.onDownloadComplete(path);
84                 }
85             });
86         }
87     }
88 }",No
,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,157 @@
+package com.bumptech.flickr.api;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import com.bumptech.photos.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/6/13
+ * Time: 10:36 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Downloader {
+    private static Downloader DOWNLOADER;
+    private final Handler mainHandler;
+    private final ExecutorService executor;
+
+    static Downloader get() {
+        if (DOWNLOADER == null) {
+            DOWNLOADER = new Downloader();
+        }
+        return DOWNLOADER;
+    }
+
+    public interface MemoryCallback {
+        public void onDownloadReady(byte[] data);
+    }
+
+    public interface DiskCallback {
+        public void onDownloadReady(String path);
+    }
+
+    protected Downloader() {
+        HandlerThread workerThread = new HandlerThread(""downloader_thread"");
+        workerThread.start();
+        executor = Executors.newFixedThreadPool(6);
+        mainHandler = new Handler();
+    }
+
+    private void post(Runnable runnable) {
+        executor.execute(runnable);
+    }
+
+    public void download(String url, MemoryCallback cb) {
+        post(new DownloadWorker(url, cb));
+    }
+
+    public void download(String url, File out, DiskCallback cb) {
+        post(new DiskDownloadWorker(url, out, cb));
+    }
+
+    private class DiskDownloadWorker implements Runnable {
+        private final String url;
+        private final DiskCallback cb;
+        private final File output;
+
+        public DiskDownloadWorker(String url, File output, DiskCallback cb) {
+            this.url = url;
+            this.output = output;
+            this.cb = cb;
+        }
+
+        @Override
+        public void run() {
+            Log.d(""Downloader: run"");
+            HttpURLConnection urlConnection = null;
+            try {
+                final URL targetUrl = new URL(url);
+                urlConnection = (HttpURLConnection) targetUrl.openConnection();
+                InputStream in = new BufferedInputStream(urlConnection.getInputStream());
+                OutputStream out = new FileOutputStream(output);
+                writeToOutput(in, out);
+                out.close();
+                in.close();
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        cb.onDownloadReady(output.getPath());
+                    }
+                });
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                if (urlConnection != null) {
+                    urlConnection.disconnect();
+                }
+            }
+        }
+
+        private void writeToOutput(InputStream in, OutputStream out) throws IOException {
+            byte[] buffer = new byte[1024];
+            int bytesRead;
+            while (((bytesRead = in.read(buffer)) != -1)) {
+                out.write(buffer, 0, bytesRead);
+            }
+        }
+    }
+
+    private class DownloadWorker implements Runnable {
+
+        private final String url;
+        private final MemoryCallback cb;
+
+        public DownloadWorker(String url, MemoryCallback cb) {
+            this.url = url;
+            this.cb = cb;
+        }
+
+        @Override
+        public void run() {
+            HttpURLConnection urlConnection = null;
+            try {
+                final URL targetUrl = new URL(url);
+                urlConnection = (HttpURLConnection) targetUrl.openConnection();
+                InputStream in = new BufferedInputStream(urlConnection.getInputStream());
+                final List<Byte> data = new ArrayList<Byte>(1024);
+                byte[] buffer = new byte[1024];
+                int bytesRead;
+                while (((bytesRead = in.read(buffer)) != -1)) {
+                    for (int i = 0; i < bytesRead; i++) {
+                        data.add(buffer[i]);
+                    }
+                }
+                final byte[] result = new byte[data.size()];
+                for (int i = 0; i < data.size(); i++) {
+                    result[i] = data.get(i);
+                }
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        cb.onDownloadReady(result);
+                    }
+                });
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                if (urlConnection != null) {
+                    urlConnection.disconnect();
+                }
+            }
+        }
+    }
+}
","1 package com.bumptech.flickr.api;
2 
3 import android.os.Handler;
4 import android.os.HandlerThread;
5 import com.bumptech.photos.util.Log;
6 
7 import java.io.BufferedInputStream;
8 import java.io.File;
9 import java.io.FileOutputStream;
10 import java.io.IOException;
11 import java.io.InputStream;
12 import java.io.OutputStream;
13 import java.net.HttpURLConnection;
14 import java.net.URL;
15 import java.util.ArrayList;
16 import java.util.List;
17 import java.util.concurrent.ExecutorService;
18 import java.util.concurrent.Executors;
19 
20 /**
21  * Created with IntelliJ IDEA.
22  * User: sam
23  * Date: 1/6/13
24  * Time: 10:36 AM
25  * To change this template use File | Settings | File Templates.
26  */
27 public class Downloader {
28     private static Downloader DOWNLOADER;
29     private final Handler mainHandler;
30     private final ExecutorService executor;
31 
32     static Downloader get() {
33         if (DOWNLOADER == null) {
34             DOWNLOADER = new Downloader();
35         }
36         return DOWNLOADER;
37     }
38 
39     public interface MemoryCallback {
40         public void onDownloadReady(byte[] data);
41     }
42 
43     public interface DiskCallback {
44         public void onDownloadReady(String path);
45     }
46 
47     protected Downloader() {
48         HandlerThread workerThread = new HandlerThread(""downloader_thread"");
49         workerThread.start();
50         executor = Executors.newFixedThreadPool(6);
51         mainHandler = new Handler();
52     }
53 
54     private void post(Runnable runnable) {
55         executor.execute(runnable);
56     }
57 
58     public void download(String url, MemoryCallback cb) {
59         post(new DownloadWorker(url, cb));
60     }
61 
62     public void download(String url, File out, DiskCallback cb) {
63         post(new DiskDownloadWorker(url, out, cb));
64     }
65 
66     private class DiskDownloadWorker implements Runnable {
67         private final String url;
68         private final DiskCallback cb;
69         private final File output;
70 
71         public DiskDownloadWorker(String url, File output, DiskCallback cb) {
72             this.url = url;
73             this.output = output;
74             this.cb = cb;
75         }
76 
77         @Override
78         public void run() {
79             Log.d(""Downloader: run"");
80             HttpURLConnection urlConnection = null;
81             try {
82                 final URL targetUrl = new URL(url);
83                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
84                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
85                 OutputStream out = new FileOutputStream(output);
86                 writeToOutput(in, out);
87                 out.close();
88                 in.close();
89                 mainHandler.post(new Runnable() {
90                     @Override
91                     public void run() {
92                         cb.onDownloadReady(output.getPath());
93                     }
94                 });
95             } catch (IOException e) {
96                 e.printStackTrace();
97             } finally {
98                 if (urlConnection != null) {
99                     urlConnection.disconnect();
100                 }
101             }
102         }
103 
104         private void writeToOutput(InputStream in, OutputStream out) throws IOException {
105             byte[] buffer = new byte[1024];
106             int bytesRead;
107             while (((bytesRead = in.read(buffer)) != -1)) {
108                 out.write(buffer, 0, bytesRead);
109             }
110         }
111     }
112 
113     private class DownloadWorker implements Runnable {
114 
115         private final String url;
116         private final MemoryCallback cb;
117 
118         public DownloadWorker(String url, MemoryCallback cb) {
119             this.url = url;
120             this.cb = cb;
121         }
122 
123         @Override
124         public void run() {
125             HttpURLConnection urlConnection = null;
126             try {
127                 final URL targetUrl = new URL(url);
128                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
129                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
130                 final List<Byte> data = new ArrayList<Byte>(1024);
131                 byte[] buffer = new byte[1024];
132                 int bytesRead;
133                 while (((bytesRead = in.read(buffer)) != -1)) {
134                     for (int i = 0; i < bytesRead; i++) {
135                         data.add(buffer[i]);
136                     }
137                 }
138                 final byte[] result = new byte[data.size()];
139                 for (int i = 0; i < data.size(); i++) {
140                     result[i] = data.get(i);
141                 }
142                 mainHandler.post(new Runnable() {
143                     @Override
144                     public void run() {
145                         cb.onDownloadReady(result);
146                     }
147                 });
148             } catch (IOException e) {
149                 e.printStackTrace();
150             } finally {
151                 if (urlConnection != null) {
152                     urlConnection.disconnect();
153                 }
154             }
155         }
156     }
157 }",No
,samples\flickr\src\com\bumptech\flickr\api\Photo.java,51c51e7fa4d247864f3debfff8aaff4078aaac7b,60d4a53813e96d3945c17e06954de35128570288,Initial commit of flickr sample,"@@ -0,0 +1,30 @@
+package com.bumptech.flickr.api;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/6/13
+ * Time: 10:55 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Photo {
+    public final String id;
+    public final String owner;
+    public final String title;
+    public final String server;
+    public final String farm;
+    public final String secret;
+
+    public Photo(JSONObject jsonPhoto) throws JSONException {
+        this.id = jsonPhoto.getString(""id"");
+        this.owner = jsonPhoto.getString(""owner"");
+        this.title = jsonPhoto.optString(""title"", """");
+        this.server = jsonPhoto.getString(""server"");
+        this.farm = jsonPhoto.getString(""farm"");
+        this.secret = jsonPhoto.getString(""secret"");
+    }
+
+}
","1 package com.bumptech.flickr.api;
2 
3 import org.json.JSONException;
4 import org.json.JSONObject;
5 
6 /**
7  * Created with IntelliJ IDEA.
8  * User: sam
9  * Date: 1/6/13
10  * Time: 10:55 AM
11  * To change this template use File | Settings | File Templates.
12  */
13 public class Photo {
14     public final String id;
15     public final String owner;
16     public final String title;
17     public final String server;
18     public final String farm;
19     public final String secret;
20 
21     public Photo(JSONObject jsonPhoto) throws JSONException {
22         this.id = jsonPhoto.getString(""id"");
23         this.owner = jsonPhoto.getString(""owner"");
24         this.title = jsonPhoto.optString(""title"", """");
25         this.server = jsonPhoto.getString(""server"");
26         this.farm = jsonPhoto.getString(""farm"");
27         this.secret = jsonPhoto.getString(""secret"");
28     }
29 
30 }",No
library\src\com\bumptech\photos\resize\HandlerExecutor.java,library\src\com\bumptech\photos\resize\HandlerExecutor.java,b15698d662f5c20bafd6958decc05f168b792a8b,51c51e7fa4d247864f3debfff8aaff4078aaac7b,"Change handler executor to post at front of queue

Better performance when scrolling","@@ -6,7 +6,6 @@ package com.bumptech.photos.resize;
 
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.SystemClock;
 
 import java.util.concurrent.Executor;
 
@@ -15,7 +14,6 @@ import java.util.concurrent.Executor;
  */
 public class HandlerExecutor implements Executor {
     private final Handler worker;
-    private final Object token;
 
     /**
      * Create a new executor with a new HandlerThread called ""HandlerExecutor""
@@ -24,7 +22,6 @@ public class HandlerExecutor implements Executor {
         HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
         workerThread.start();
         this.worker = new Handler(workerThread.getLooper());
-        token = hashCode();
     }
 
     /**
@@ -34,11 +31,10 @@ public class HandlerExecutor implements Executor {
      */
     public HandlerExecutor(Handler bgHandler) {
         this.worker = bgHandler;
-        token = hashCode();
     }
 
     @Override
     public void execute(Runnable runnable) {
-        worker.postAtTime(runnable,  token, SystemClock.uptimeMillis());
+        worker.postAtFrontOfQueue(runnable);
     }
 }
","38         worker.postAtFrontOfQueue(runnable);
9 import android.os.SystemClock;
18     private final Object token;
27         token = hashCode();
37         token = hashCode();
42         worker.postAtTime(runnable,  token, SystemClock.uptimeMillis());",No
samples\flickr\res\layout\main.xml,samples\flickr\res\layout\main.xml,a02a4a4d0b3a4e1518f8b40e260095c22edd8ebe,b15698d662f5c20bafd6958decc05f168b792a8b,Add searching UI,"@@ -1,12 +1,36 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
-<LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
+<FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android""
+  android:layout_width=""fill_parent""
+  android:layout_height=""fill_parent"">
+  <LinearLayout
     android:orientation=""vertical""
     android:layout_width=""fill_parent""
     android:layout_height=""fill_parent"">
-  <TextView
+    <LinearLayout
       android:layout_width=""fill_parent""
       android:layout_height=""wrap_content""
-    android:text=""Hello World, MyActivity"" />
+      android:layout_margin=""10dp""
+      android:orientation=""horizontal"">
+      <EditText
+        android:id=""@+id/search_text""
+        android:layout_width=""0dp""
+        android:layout_height=""wrap_content""
+        android:layout_marginRight=""10dp""
+        android:layout_weight=""1""
+        android:cursorVisible=""true""
+        android:textCursorDrawable=""@null""
+        android:textSize=""16sp""
+        android:singleLine=""true""
+        android:inputType=""text""
+        android:imeOptions=""actionSearch"" />
+        <!-- android:background=""@drawable/stretch_field_comments"" /> -->
+      <Button
+        android:id=""@+id/search""
+        android:layout_width=""wrap_content""
+        android:minWidth=""50dp""
+        android:layout_height=""40dp""
+        android:text=""@string/search"" />
+    </LinearLayout>
     <GridView
       android:id=""@+id/images""
       android:columnWidth=""@dimen/photo_side""
@@ -18,6 +42,30 @@
       android:verticalSpacing=""15dp""
       android:layout_width=""fill_parent""
       android:layout_height=""0dp""
+      android:layout_marginLeft=""10dp""
+      android:layout_marginRight=""10dp""
       android:layout_weight=""1""/>
   </LinearLayout>
+  <LinearLayout
+    android:id=""@+id/searching""
+    android:layout_width=""wrap_content""
+    android:layout_height=""wrap_content""
+    android:visibility=""invisible""
+    android:layout_gravity=""center""
+    android:gravity=""center""
+    android:orientation=""vertical"">
+    <TextView
+      android:id=""@+id/search_term""
+      android:layout_width=""wrap_content""
+      android:layout_height=""wrap_content""
+      android:gravity=""center""
+      android:textSize=""16sp""
+      android:layout_marginBottom=""10dp""/>
+    <ProgressBar
+      android:layout_width=""wrap_content""
+      android:layout_height=""wrap_content""
+      android:indeterminate=""true"" />
+    </LinearLayout>
+
+</FrameLayout>
 
","2 <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android""
3   android:layout_width=""fill_parent""
4   android:layout_height=""fill_parent"">
5   <LinearLayout
9     <LinearLayout
12       android:layout_margin=""10dp""
13       android:orientation=""horizontal"">
14       <EditText
15         android:id=""@+id/search_text""
16         android:layout_width=""0dp""
17         android:layout_height=""wrap_content""
18         android:layout_marginRight=""10dp""
19         android:layout_weight=""1""
20         android:cursorVisible=""true""
21         android:textCursorDrawable=""@null""
22         android:textSize=""16sp""
23         android:singleLine=""true""
24         android:inputType=""text""
25         android:imeOptions=""actionSearch"" />
26         <!-- android:background=""@drawable/stretch_field_comments"" /> -->
27       <Button
28         android:id=""@+id/search""
29         android:layout_width=""wrap_content""
30         android:minWidth=""50dp""
31         android:layout_height=""40dp""
32         android:text=""@string/search"" />
33     </LinearLayout>
45       android:layout_marginLeft=""10dp""
46       android:layout_marginRight=""10dp""
49   <LinearLayout
50     android:id=""@+id/searching""
51     android:layout_width=""wrap_content""
52     android:layout_height=""wrap_content""
53     android:visibility=""invisible""
54     android:layout_gravity=""center""
55     android:gravity=""center""
56     android:orientation=""vertical"">
57     <TextView
58       android:id=""@+id/search_term""
59       android:layout_width=""wrap_content""
60       android:layout_height=""wrap_content""
61       android:gravity=""center""
62       android:textSize=""16sp""
63       android:layout_marginBottom=""10dp""/>
64     <ProgressBar
65       android:layout_width=""wrap_content""
66       android:layout_height=""wrap_content""
67       android:indeterminate=""true"" />
68     </LinearLayout>
69 
70 </FrameLayout>
2 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
6   <TextView
9     android:text=""Hello World, MyActivity"" />",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,a02a4a4d0b3a4e1518f8b40e260095c22edd8ebe,b15698d662f5c20bafd6958decc05f168b792a8b,Add searching UI,"@@ -1,4 +1,6 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <resources>
     <string name=""app_name"">MyActivity</string>
+    <string name=""search"">Search</string>
+    <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
 </resources>
","4     <string name=""search"">Search</string>
5     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>",No
samples\flickr\src\com\bumptech\flickr\MyActivity.java,samples\flickr\src\com\bumptech\flickr\MyActivity.java,a02a4a4d0b3a4e1518f8b40e260095c22edd8ebe,b15698d662f5c20bafd6958decc05f168b792a8b,Add searching UI,"@@ -8,8 +8,11 @@ import android.view.ViewGroup;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.BaseAdapter;
+import android.widget.Button;
+import android.widget.EditText;
 import android.widget.GridView;
 import android.widget.ImageView;
+import android.widget.TextView;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.photos.presenter.ImagePresenter;
@@ -25,6 +28,7 @@ public class MyActivity extends Activity {
     private Api flickerApi;
     private ImageManager imageManager;
     private File cacheDir;
+    private int searchCount = 0;
 
     /** Called when the activity is first created. */
     @Override
@@ -38,21 +42,44 @@ public class MyActivity extends Activity {
         }
 
         ImageManager.Options options = new ImageManager.Options();
-        options.maxMemorySize = 2 * 1024 * 1024;
         options.maxPerSize = 40;
         imageManager = new ImageManager(this, options);
-
         flickerApi = new Api();
+
         final GridView images = (GridView) findViewById(R.id.images);
 
-        flickerApi.search(""cat"", new Api.SearchCallback() {
+        final View searching = findViewById(R.id.searching);
+        final TextView searchTerm = (TextView) findViewById(R.id.search_term);
+
+        final EditText searchText = (EditText) findViewById(R.id.search_text);
+        final Button search = (Button) findViewById(R.id.search);
+        search.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                final String searchString = searchText.getText().toString();
+                searchText.getText().clear();
+
+                if ("""".equals(searchString.trim())) return;
+
+                final int currentSearch = ++searchCount;
+
+                images.setAdapter(null);
+                searching.setVisibility(View.VISIBLE);
+                searchTerm.setText(getString(R.string.searching_for, searchString));
+
+                flickerApi.search(searchString, new Api.SearchCallback() {
                     @Override
                     public void onSearchCompleted(List<Photo> photos) {
+                        if (currentSearch != searchCount) return;
+
                         Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
+                        searching.setVisibility(View.INVISIBLE);
                         images.setAdapter(new PhotoAdapter(photos));
                     }
                 });
             }
+        });
+    }
 
     @Override
     protected void onResume() {
","11 import android.widget.Button;
12 import android.widget.EditText;
15 import android.widget.TextView;
31     private int searchCount = 0;
48 
51         final View searching = findViewById(R.id.searching);
52         final TextView searchTerm = (TextView) findViewById(R.id.search_term);
53 
54         final EditText searchText = (EditText) findViewById(R.id.search_text);
55         final Button search = (Button) findViewById(R.id.search);
56         search.setOnClickListener(new View.OnClickListener() {
57             @Override
58             public void onClick(View view) {
59                 final String searchString = searchText.getText().toString();
60                 searchText.getText().clear();
61 
62                 if ("""".equals(searchString.trim())) return;
63 
64                 final int currentSearch = ++searchCount;
65 
66                 images.setAdapter(null);
67                 searching.setVisibility(View.VISIBLE);
68                 searchTerm.setText(getString(R.string.searching_for, searchString));
69 
70                 flickerApi.search(searchString, new Api.SearchCallback() {
73                         if (currentSearch != searchCount) return;
74 
76                         searching.setVisibility(View.INVISIBLE);
81         });
82     }
41         options.maxMemorySize = 2 * 1024 * 1024;
44 
48         flickerApi.search(""cat"", new Api.SearchCallback() {",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,77fac9940dba5b079addfc155bde4f493c8cd8df,a02a4a4d0b3a4e1518f8b40e260095c22edd8ebe,Random changes to make HttpUrlConn faster...,"@@ -45,6 +45,7 @@ public class Downloader {
     }
 
     protected Downloader() {
+        System.setProperty(""http.keepAlive"", ""false"");
         HandlerThread workerThread = new HandlerThread(""downloader_thread"");
         workerThread.start();
         executor = Executors.newFixedThreadPool(6);
@@ -126,6 +127,12 @@ public class Downloader {
             try {
                 final URL targetUrl = new URL(url);
                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
+                urlConnection.setDoInput(true);
+                urlConnection.setDoOutput(false);
+                urlConnection.setUseCaches(false);
+                urlConnection.setRequestProperty(""Connection"", ""close"");
+
+                urlConnection.connect();
                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
                 final List<Byte> data = new ArrayList<Byte>(1024);
                 byte[] buffer = new byte[1024];
","48         System.setProperty(""http.keepAlive"", ""false"");
130                 urlConnection.setDoInput(true);
131                 urlConnection.setDoOutput(false);
132                 urlConnection.setUseCaches(false);
133                 urlConnection.setRequestProperty(""Connection"", ""close"");
134 
135                 urlConnection.connect();",No
samples\flickr\src\com\bumptech\flickr\FlickPathLoader.java,samples\flickr\src\com\bumptech\flickr\FlickPathLoader.java,5a82c4f602293960de89aa1065b2e4cfb84aafb3,77fac9940dba5b079addfc155bde4f493c8cd8df,"Add size based image downloading

Download smallest size available that is still
larger than our target area.","@@ -24,7 +24,7 @@ public class FlickPathLoader extends BasePathLoader<Photo> {
 
     @Override
     protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
-        flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
+        flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
                 cb.onPathReady(path);
","27         flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {
27         flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,5a82c4f602293960de89aa1065b2e4cfb84aafb3,77fac9940dba5b079addfc155bde4f493c8cd8df,"Add size based image downloading

Download smallest size available that is still
larger than our target area.","@@ -8,7 +8,9 @@ import org.json.JSONObject;
 import java.io.File;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Created with IntelliJ IDEA.
@@ -20,9 +22,33 @@ import java.util.List;
 public class Api {
     private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
-    private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s.jpg"";
+    private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
     private final Downloader downloader;
 
+    private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
+        put(75, ""s"");
+        put(100, ""t"");
+        put(150, ""q"");
+        put(240, ""m"");
+        put(320, ""n"");
+        put(500, ""-"");
+        put(640, ""z"");
+        put(1024, ""b"");
+        put(Integer.MAX_VALUE, ""o"");
+    }};
+
+    private static String getSizeKey(int width, int height) {
+        final int largestEdge = width > height ? width : height;
+
+        final String result = EDGE_TO_SIZE_KEY.get(Integer.MAX_VALUE);
+        for (int edge : EDGE_TO_SIZE_KEY.keySet()) {
+            if (largestEdge <= edge) {
+                return EDGE_TO_SIZE_KEY.get(edge);
+            }
+        }
+        return result;
+    }
+
     public interface SearchCallback {
         public void onSearchCompleted(List<Photo> photos);
     }
@@ -43,8 +69,9 @@ public class Api {
         return getUrlForMethod(""flickr.photos.search"") + ""&text="" + text + ""&per_page=500"";
     }
 
-    private static String getPhotoUrl(Photo photo) {
-        return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
+    private static String getPhotoUrl(Photo photo, int width, int height) {
+        String sizeKey = getSizeKey(width, height);
+        return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret, sizeKey);
     }
 
     public void search(String text, final SearchCallback cb) {
@@ -71,13 +98,13 @@ public class Api {
         });
     }
 
-    public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
-        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret);
+    public void downloadPhoto(Photo photo, int width, int height, File cacheDir, final PhotoCallback cb) {
+        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + width + height);
         if (out.exists()) {
             cb.onDownloadComplete(out.getPath());
         } else {
             Log.d(""API: missing photo, downloading"");
-            downloader.download(getPhotoUrl(photo), out, new Downloader.DiskCallback() {
+            downloader.download(getPhotoUrl(photo, width, height), out, new Downloader.DiskCallback() {
                 @Override
                 public void onDownloadReady(String path) {
                     cb.onDownloadComplete(path);
","11 import java.util.HashMap;
13 import java.util.Map;
25     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
28     private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
29         put(75, ""s"");
30         put(100, ""t"");
31         put(150, ""q"");
32         put(240, ""m"");
33         put(320, ""n"");
34         put(500, ""-"");
35         put(640, ""z"");
36         put(1024, ""b"");
37         put(Integer.MAX_VALUE, ""o"");
38     }};
39 
40     private static String getSizeKey(int width, int height) {
41         final int largestEdge = width > height ? width : height;
42 
43         final String result = EDGE_TO_SIZE_KEY.get(Integer.MAX_VALUE);
44         for (int edge : EDGE_TO_SIZE_KEY.keySet()) {
45             if (largestEdge <= edge) {
46                 return EDGE_TO_SIZE_KEY.get(edge);
47             }
48         }
49         return result;
50     }
51 
72     private static String getPhotoUrl(Photo photo, int width, int height) {
73         String sizeKey = getSizeKey(width, height);
74         return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret, sizeKey);
101     public void downloadPhoto(Photo photo, int width, int height, File cacheDir, final PhotoCallback cb) {
102         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + width + height);
107             downloader.download(getPhotoUrl(photo, width, height), out, new Downloader.DiskCallback() {
23     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s.jpg"";
46     private static String getPhotoUrl(Photo photo) {
47         return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
74     public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
75         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret);
80             downloader.download(getPhotoUrl(photo), out, new Downloader.DiskCallback() {",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,5a82c4f602293960de89aa1065b2e4cfb84aafb3,DownloadWorker->MemoryDownloadWorker,"@@ -2,7 +2,6 @@ package com.bumptech.flickr.api;
 
 import android.os.Handler;
 import android.os.HandlerThread;
-import com.bumptech.photos.util.Log;
 
 import java.io.BufferedInputStream;
 import java.io.File;
@@ -57,7 +56,7 @@ public class Downloader {
     }
 
     public void download(String url, MemoryCallback cb) {
-        post(new DownloadWorker(url, cb));
+        post(new MemoryDownloadWorker(url, cb));
     }
 
     public void download(String url, File out, DiskCallback cb) {
@@ -77,7 +76,6 @@ public class Downloader {
 
         @Override
         public void run() {
-            Log.d(""Downloader: run"");
             HttpURLConnection urlConnection = null;
             try {
                 final URL targetUrl = new URL(url);
@@ -111,12 +109,12 @@ public class Downloader {
         }
     }
 
-    private class DownloadWorker implements Runnable {
+    private class MemoryDownloadWorker implements Runnable {
 
         private final String url;
         private final MemoryCallback cb;
 
-        public DownloadWorker(String url, MemoryCallback cb) {
+        public MemoryDownloadWorker(String url, MemoryCallback cb) {
             this.url = url;
             this.cb = cb;
         }
","59         post(new MemoryDownloadWorker(url, cb));
112     private class MemoryDownloadWorker implements Runnable {
117         public MemoryDownloadWorker(String url, MemoryCallback cb) {
5 import com.bumptech.photos.util.Log;
60         post(new DownloadWorker(url, cb));
80             Log.d(""Downloader: run"");
114     private class DownloadWorker implements Runnable {
119         public DownloadWorker(String url, MemoryCallback cb) {",No
.gitmodules,.gitmodules,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -0,0 +1,3 @@
+[submodule ""samples/flickr/ActionBarSherlock""]
+	path = samples/flickr/ActionBarSherlock
+	url = https://github.com/JakeWharton/ActionBarSherlock.git
","1 [submodule ""samples/flickr/ActionBarSherlock""]
2 	path = samples/flickr/ActionBarSherlock
3 	url = https://github.com/JakeWharton/ActionBarSherlock.git",Yes
,samples\flickr\ActionBarSherlock,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -0,0 +1 @@
+Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1
",1 Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1,Yes
samples\flickr\AndroidManifest.xml,samples\flickr\AndroidManifest.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -4,7 +4,8 @@
       android:versionCode=""1""
       android:versionName=""1.0"">
     <application android:label=""@string/app_name"" android:icon=""@drawable/ic_launcher""
-      android:hardwareAccelerated=""true"">
+      android:hardwareAccelerated=""true""
+      android:theme=""@style/Theme.Sherlock"">
 
         <activity android:name=""MyActivity""
                   android:label=""@string/app_name""
","7       android:hardwareAccelerated=""true""
8       android:theme=""@style/Theme.Sherlock"">
7       android:hardwareAccelerated=""true"">",No
samples\flickr\libs\android-support-v4.jar,samples\flickr\libs\android-support-v4.jar,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","Binary files /dev/null and b/samples/flickr/libs/android-support-v4.jar differ
",,No
samples\flickr\project.properties,samples\flickr\project.properties,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -13,3 +13,4 @@
 # Project target.
 target=android-16
 android.library.reference.1=../../library
+android.library.reference.2=ActionBarSherlock/library
",16 android.library.reference.2=ActionBarSherlock/library,No
,samples\flickr\res\layout\grid_fragment.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -0,0 +1,13 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<GridView xmlns:android=""http://schemas.android.com/apk/res/android""
+  android:id=""@+id/images""
+  android:cacheColorHint=""#00000000""
+  android:fadingEdge=""none""
+  android:scrollingCache=""false""
+  android:numColumns=""auto_fit""
+  android:horizontalSpacing=""15dp""
+  android:verticalSpacing=""15dp""
+  android:layout_width=""fill_parent""
+  android:layout_height=""fill_parent""
+  android:layout_marginLeft=""10dp""
+  android:layout_marginRight=""10dp""/>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <GridView xmlns:android=""http://schemas.android.com/apk/res/android""
3   android:id=""@+id/images""
4   android:cacheColorHint=""#00000000""
5   android:fadingEdge=""none""
6   android:scrollingCache=""false""
7   android:numColumns=""auto_fit""
8   android:horizontalSpacing=""15dp""
9   android:verticalSpacing=""15dp""
10   android:layout_width=""fill_parent""
11   android:layout_height=""fill_parent""
12   android:layout_marginLeft=""10dp""
13   android:layout_marginRight=""10dp""/>",Yes
samples\flickr\res\layout\main.xml,samples\flickr\res\layout\main.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -1,7 +1,5 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
-<FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android""
-  android:layout_width=""fill_parent""
-  android:layout_height=""fill_parent"">
+<merge xmlns:android=""http://schemas.android.com/apk/res/android"">
   <LinearLayout
     android:orientation=""vertical""
     android:layout_width=""fill_parent""
@@ -31,25 +29,19 @@
         android:layout_height=""40dp""
         android:text=""@string/search"" />
     </LinearLayout>
-    <GridView
-      android:id=""@+id/images""
-      android:columnWidth=""@dimen/photo_side""
-      android:cacheColorHint=""#00000000""
-      android:fadingEdge=""none""
-      android:scrollingCache=""false""
-      android:numColumns=""auto_fit""
-      android:horizontalSpacing=""15dp""
-      android:verticalSpacing=""15dp""
+    <FrameLayout
       android:layout_width=""fill_parent""
       android:layout_height=""0dp""
-      android:layout_marginLeft=""10dp""
-      android:layout_marginRight=""10dp""
-      android:layout_weight=""1""/>
-  </LinearLayout>
+      android:layout_weight=""1"">
+      <FrameLayout
+        android:id=""@+id/fragment_container""
+        android:layout_width=""fill_parent""
+        android:layout_height=""fill_parent"" />
       <LinearLayout
         android:id=""@+id/searching""
-    android:layout_width=""wrap_content""
-    android:layout_height=""wrap_content""
+        android:layout_width=""fill_parent""
+        android:layout_height=""fill_parent""
+        android:background=""@color/translucent_black""
         android:visibility=""invisible""
         android:layout_gravity=""center""
         android:gravity=""center""
@@ -66,6 +58,7 @@
           android:layout_height=""wrap_content""
           android:indeterminate=""true"" />
       </LinearLayout>
-
     </FrameLayout>
+  </LinearLayout>
+</merge>
 
","2 <merge xmlns:android=""http://schemas.android.com/apk/res/android"">
32     <FrameLayout
35       android:layout_weight=""1"">
36       <FrameLayout
37         android:id=""@+id/fragment_container""
38         android:layout_width=""fill_parent""
39         android:layout_height=""fill_parent"" />
42         android:layout_width=""fill_parent""
43         android:layout_height=""fill_parent""
44         android:background=""@color/translucent_black""
62   </LinearLayout>
63 </merge>
2 <FrameLayout xmlns:android=""http://schemas.android.com/apk/res/android""
3   android:layout_width=""fill_parent""
4   android:layout_height=""fill_parent"">
34     <GridView
35       android:id=""@+id/images""
36       android:columnWidth=""@dimen/photo_side""
37       android:cacheColorHint=""#00000000""
38       android:fadingEdge=""none""
39       android:scrollingCache=""false""
40       android:numColumns=""auto_fit""
41       android:horizontalSpacing=""15dp""
42       android:verticalSpacing=""15dp""
45       android:layout_marginLeft=""10dp""
46       android:layout_marginRight=""10dp""
47       android:layout_weight=""1""/>
48   </LinearLayout>
51     android:layout_width=""wrap_content""
52     android:layout_height=""wrap_content""
69 ",No
samples\flickr\res\layout\photo_grid_square.xml,samples\flickr\res\layout\photo_grid_square.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -2,5 +2,5 @@
 
 <ImageView xmlns:android=""http://schemas.android.com/apk/res/android""
     android:scaleType=""center""
-    android:layout_width=""@dimen/photo_side""
-    android:layout_height=""@dimen/photo_side""/>
+    android:layout_width=""fill_parent""
+    android:layout_height=""fill_parent""/>
","5     android:layout_width=""fill_parent""
6     android:layout_height=""fill_parent""/>
5     android:layout_width=""@dimen/photo_side""
6     android:layout_height=""@dimen/photo_side""/>",No
,samples\flickr\res\values\colors.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<resources>
+  <color name=""translucent_black"">#B0000000</color>
+</resources>
\ No newline at end of file
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <color name=""translucent_black"">#B0000000</color>
4 </resources>",No
samples\flickr\res\values\dimens.xml,samples\flickr\res\values\dimens.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -1,4 +1,5 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <resources>
-  <dimen name=""photo_side"">110dp</dimen>
+  <dimen name=""medium_photo_side"">110dp</dimen>
+  <dimen name=""small_photo_side"">55dp</dimen>
 </resources>
\ No newline at end of file
","3   <dimen name=""medium_photo_side"">110dp</dimen>
4   <dimen name=""small_photo_side"">55dp</dimen>
3   <dimen name=""photo_side"">110dp</dimen>",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -3,4 +3,6 @@
     <string name=""app_name"">MyActivity</string>
     <string name=""search"">Search</string>
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
+  <string name=""small"">Small</string>
+  <string name=""medium"">Medium</string>
 </resources>
","6   <string name=""small"">Small</string>
7   <string name=""medium"">Medium</string>",No
,samples\flickr\src\com\bumptech\flickr\GridFragment.java,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -0,0 +1,130 @@
+package com.bumptech.flickr;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.BaseAdapter;
+import android.widget.GridView;
+import android.widget.ImageView;
+import com.actionbarsherlock.app.SherlockFragment;
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.photos.presenter.ImagePresenter;
+import com.bumptech.photos.presenter.ImageSetCallback;
+import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.loader.CenterCrop;
+import com.bumptech.photos.util.Log;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/10/13
+ * Time: 9:48 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class GridFragment extends SherlockFragment{
+    private PhotoAdapter adapter;
+    private List<Photo> currentPhotos;
+    private Api api;
+    private ImageManager imageManager;
+    private File cacheDir;
+    private int photoSize;
+
+    public void setup(Api api, ImageManager imageManager, File cacheDir, int photoSize) {
+        this.api = api;
+        this.imageManager = imageManager;
+        this.cacheDir = cacheDir;
+        this.photoSize = photoSize;
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        final View result = inflater.inflate(R.layout.grid_fragment, container, false);
+        GridView grid = (GridView) result.findViewById(R.id.images);
+        grid.setColumnWidth(photoSize);
+        adapter = new PhotoAdapter();
+        grid.setAdapter(adapter);
+        if (currentPhotos != null)
+            adapter.setPhotos(currentPhotos);
+
+        return result;
+    }
+
+    public void setPhotos(List<Photo> photos) {
+        currentPhotos = photos;
+        if (adapter != null)
+            adapter.setPhotos(currentPhotos);
+    }
+
+    private class PhotoAdapter extends BaseAdapter {
+
+        private List<Photo> photos = new ArrayList<Photo>(0);
+        private final LayoutInflater inflater;
+
+        public PhotoAdapter() {
+            this.inflater = LayoutInflater.from(getActivity());
+        }
+
+        public void setPhotos(List<Photo> photos) {
+            this.photos = photos;
+            notifyDataSetChanged();
+        }
+
+        @Override
+        public int getCount() {
+            return photos.size();
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return photos.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;
+        }
+
+        @Override
+        public View getView(int position, View view, ViewGroup container) {
+            final ImagePresenter<Photo> presenter;
+            if (view == null) {
+                Log.d(""MyActivity: inflate"");
+                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
+                ViewGroup.LayoutParams params = imageView.getLayoutParams();
+                params.width = photoSize;
+                params.height = photoSize;
+
+                final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
+                presenter = new ImagePresenter.Builder<Photo>()
+                        .setImageView(imageView)
+                        .setPathLoader(new FlickPathLoader(api, cacheDir))
+                        .setImageLoader(new CenterCrop<Photo>(imageManager))
+                        .setImageSetCallback(new ImageSetCallback() {
+                            @Override
+                            public void onImageSet(ImageView view, boolean fromCache) {
+                                view.clearAnimation();
+                                if (!fromCache)
+                                    view.startAnimation(fadeIn);
+                            }
+                        })
+                        .build();
+                imageView.setTag(presenter);
+                view = imageView;
+            } else {
+                presenter = (ImagePresenter<Photo>) view.getTag();
+            }
+
+            presenter.setModel(photos.get(position));
+            return view;
+        }
+    }
+
+}
","1 package com.bumptech.flickr;
2 
3 import android.os.Bundle;
4 import android.view.LayoutInflater;
5 import android.view.View;
6 import android.view.ViewGroup;
7 import android.view.animation.Animation;
8 import android.view.animation.AnimationUtils;
9 import android.widget.BaseAdapter;
10 import android.widget.GridView;
11 import android.widget.ImageView;
12 import com.actionbarsherlock.app.SherlockFragment;
13 import com.bumptech.flickr.api.Api;
14 import com.bumptech.flickr.api.Photo;
15 import com.bumptech.photos.presenter.ImagePresenter;
16 import com.bumptech.photos.presenter.ImageSetCallback;
17 import com.bumptech.photos.resize.ImageManager;
18 import com.bumptech.photos.resize.loader.CenterCrop;
19 import com.bumptech.photos.util.Log;
20 
21 import java.io.File;
22 import java.util.ArrayList;
23 import java.util.List;
24 
25 /**
26  * Created with IntelliJ IDEA.
27  * User: sam
28  * Date: 1/10/13
29  * Time: 9:48 AM
30  * To change this template use File | Settings | File Templates.
31  */
32 public class GridFragment extends SherlockFragment{
33     private PhotoAdapter adapter;
34     private List<Photo> currentPhotos;
35     private Api api;
36     private ImageManager imageManager;
37     private File cacheDir;
38     private int photoSize;
39 
40     public void setup(Api api, ImageManager imageManager, File cacheDir, int photoSize) {
41         this.api = api;
42         this.imageManager = imageManager;
43         this.cacheDir = cacheDir;
44         this.photoSize = photoSize;
45     }
46 
47     @Override
48     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
49         final View result = inflater.inflate(R.layout.grid_fragment, container, false);
50         GridView grid = (GridView) result.findViewById(R.id.images);
51         grid.setColumnWidth(photoSize);
52         adapter = new PhotoAdapter();
53         grid.setAdapter(adapter);
54         if (currentPhotos != null)
55             adapter.setPhotos(currentPhotos);
56 
57         return result;
58     }
59 
60     public void setPhotos(List<Photo> photos) {
61         currentPhotos = photos;
62         if (adapter != null)
63             adapter.setPhotos(currentPhotos);
64     }
65 
66     private class PhotoAdapter extends BaseAdapter {
67 
68         private List<Photo> photos = new ArrayList<Photo>(0);
69         private final LayoutInflater inflater;
70 
71         public PhotoAdapter() {
72             this.inflater = LayoutInflater.from(getActivity());
73         }
74 
75         public void setPhotos(List<Photo> photos) {
76             this.photos = photos;
77             notifyDataSetChanged();
78         }
79 
80         @Override
81         public int getCount() {
82             return photos.size();
83         }
84 
85         @Override
86         public Object getItem(int i) {
87             return photos.get(i);
88         }
89 
90         @Override
91         public long getItemId(int i) {
92             return 0;
93         }
94 
95         @Override
96         public View getView(int position, View view, ViewGroup container) {
97             final ImagePresenter<Photo> presenter;
98             if (view == null) {
99                 Log.d(""MyActivity: inflate"");
100                 ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
101                 ViewGroup.LayoutParams params = imageView.getLayoutParams();
102                 params.width = photoSize;
103                 params.height = photoSize;
104 
105                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
106                 presenter = new ImagePresenter.Builder<Photo>()
107                         .setImageView(imageView)
108                         .setPathLoader(new FlickPathLoader(api, cacheDir))
109                         .setImageLoader(new CenterCrop<Photo>(imageManager))
110                         .setImageSetCallback(new ImageSetCallback() {
111                             @Override
112                             public void onImageSet(ImageView view, boolean fromCache) {
113                                 view.clearAnimation();
114                                 if (!fromCache)
115                                     view.startAnimation(fadeIn);
116                             }
117                         })
118                         .build();
119                 imageView.setTag(presenter);
120                 view = imageView;
121             } else {
122                 presenter = (ImagePresenter<Photo>) view.getTag();
123             }
124 
125             presenter.setModel(photos.get(position));
126             return view;
127         }
128     }
129 
130 }",No
samples\flickr\src\com\bumptech\flickr\MyActivity.java,samples\flickr\src\com\bumptech\flickr\MyActivity.java,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -1,34 +1,30 @@
 package com.bumptech.flickr;
 
-import android.app.Activity;
+import android.content.res.Resources;
 import android.os.Bundle;
-import android.view.LayoutInflater;
+import android.support.v4.app.FragmentTransaction;
 import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.widget.BaseAdapter;
 import android.widget.Button;
 import android.widget.EditText;
-import android.widget.GridView;
-import android.widget.ImageView;
 import android.widget.TextView;
+import com.actionbarsherlock.app.ActionBar;
+import com.actionbarsherlock.app.SherlockFragment;
+import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.presenter.ImagePresenter;
-import com.bumptech.photos.presenter.ImageSetCallback;
 import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.loader.CenterCrop;
 import com.bumptech.photos.util.Log;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.List;
 
-public class MyActivity extends Activity {
+public class MyActivity extends SherlockFragmentActivity {
     private Api flickerApi;
     private ImageManager imageManager;
     private File cacheDir;
     private int searchCount = 0;
+    private List<Photo> currentPhotos = new ArrayList<Photo>(0);
 
     /** Called when the activity is first created. */
     @Override
@@ -43,11 +39,10 @@ public class MyActivity extends Activity {
 
         ImageManager.Options options = new ImageManager.Options();
         options.maxPerSize = 40;
+        options.maxDiskCacheSize = 50 * 1024 * 1024;
         imageManager = new ImageManager(this, options);
         flickerApi = new Api();
 
-        final GridView images = (GridView) findViewById(R.id.images);
-
         final View searching = findViewById(R.id.searching);
         final TextView searchTerm = (TextView) findViewById(R.id.search_term);
 
@@ -63,7 +58,6 @@ public class MyActivity extends Activity {
 
                 final int currentSearch = ++searchCount;
 
-                images.setAdapter(null);
                 searching.setVisibility(View.VISIBLE);
                 searchTerm.setText(getString(R.string.searching_for, searchString));
 
@@ -74,11 +68,36 @@ public class MyActivity extends Activity {
 
                         Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
                         searching.setVisibility(View.INVISIBLE);
-                        images.setAdapter(new PhotoAdapter(photos));
+
+                        currentPhotos = photos;
+                        getSupportActionBar().getSelectedTab().select(); //reselect
                     }
                 });
             }
         });
+
+        final ActionBar actionBar = getSupportActionBar();
+        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
+        final GridFragment medium = new GridFragment();
+        final Resources res = getResources();
+        medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
+        GridFragment small = new GridFragment();
+        small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
+        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener<GridFragment>(""small"", small) {
+            @Override
+            protected void refreshFragment(GridFragment fragment) {
+                if (currentPhotos != null)
+                    fragment.setPhotos(currentPhotos);
+            }
+        }));
+        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener<GridFragment>(""medium"", medium) {
+            @Override
+            protected void refreshFragment(GridFragment fragment) {
+                if (currentPhotos != null)
+                    fragment.setPhotos(currentPhotos);
+            }
+        }));
+
     }
 
     @Override
@@ -93,59 +112,39 @@ public class MyActivity extends Activity {
         imageManager.pause();
     }
 
-    private class PhotoAdapter extends BaseAdapter {
+    private abstract class TabListener<T extends SherlockFragment> implements ActionBar.TabListener {
+        private final String tag;
+        private final T fragment;
+        private boolean added = false;
 
-        private final List<Photo> photos;
-        private final LayoutInflater inflater;
-
-        public PhotoAdapter(List<Photo> photos) {
-            this.photos = photos;
-            this.inflater = getLayoutInflater();
+        public TabListener(String tag, T fragment) {
+            this.tag = tag;
+            this.fragment = fragment;
         }
 
         @Override
-        public int getCount() {
-            return photos.size();
+        public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
+            if (!added) {
+                ft.add(R.id.fragment_container, fragment, tag);
+                added = true;
+            } else {
+                ft.attach(fragment);
             }
-
-        @Override
-        public Object getItem(int i) {
-            return photos.get(i);
+            refreshFragment(fragment);
         }
 
         @Override
-        public long getItemId(int i) {
-            return 0;
+        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
+            if (fragment != null) {
+                ft.detach(fragment);
+            }
         }
 
         @Override
-        public View getView(int position, View view, ViewGroup container) {
-            final ImagePresenter<Photo> presenter;
-            if (view == null) {
-                Log.d(""MyActivity: inflate"");
-                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
-                final Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.this, R.anim.fade_in);
-                presenter = new ImagePresenter.Builder<Photo>()
-                        .setImageView(imageView)
-                        .setPathLoader(new FlickPathLoader(flickerApi, cacheDir))
-                        .setImageLoader(new CenterCrop<Photo>(imageManager))
-                        .setImageSetCallback(new ImageSetCallback() {
-                            @Override
-                            public void onImageSet(ImageView view, boolean fromCache) {
-                                view.clearAnimation();
-                                if (!fromCache)
-                                    view.startAnimation(fadeIn);
-                            }
-                        })
-                        .build();
-                imageView.setTag(presenter);
-                view = imageView;
-            } else {
-                presenter = (ImagePresenter<Photo>) view.getTag();
+        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
+            refreshFragment(fragment);
         }
 
-            presenter.setModel(photos.get(position));
-            return view;
-        }
+        protected abstract void refreshFragment(T fragment);
     }
 }
","3 import android.content.res.Resources;
5 import android.support.v4.app.FragmentTransaction;
10 import com.actionbarsherlock.app.ActionBar;
11 import com.actionbarsherlock.app.SherlockFragment;
12 import com.actionbarsherlock.app.SherlockFragmentActivity;
19 import java.util.ArrayList;
22 public class MyActivity extends SherlockFragmentActivity {
27     private List<Photo> currentPhotos = new ArrayList<Photo>(0);
42         options.maxDiskCacheSize = 50 * 1024 * 1024;
71 
72                         currentPhotos = photos;
73                         getSupportActionBar().getSelectedTab().select(); //reselect
78 
79         final ActionBar actionBar = getSupportActionBar();
80         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
81         final GridFragment medium = new GridFragment();
82         final Resources res = getResources();
83         medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
84         GridFragment small = new GridFragment();
85         small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
86         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener<GridFragment>(""small"", small) {
87             @Override
88             protected void refreshFragment(GridFragment fragment) {
89                 if (currentPhotos != null)
90                     fragment.setPhotos(currentPhotos);
91             }
92         }));
93         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener<GridFragment>(""medium"", medium) {
94             @Override
95             protected void refreshFragment(GridFragment fragment) {
96                 if (currentPhotos != null)
97                     fragment.setPhotos(currentPhotos);
98             }
99         }));
100 
115     private abstract class TabListener<T extends SherlockFragment> implements ActionBar.TabListener {
116         private final String tag;
117         private final T fragment;
118         private boolean added = false;
120         public TabListener(String tag, T fragment) {
121             this.tag = tag;
122             this.fragment = fragment;
126         public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
127             if (!added) {
128                 ft.add(R.id.fragment_container, fragment, tag);
129                 added = true;
131                 ft.attach(fragment);
132             }
133             refreshFragment(fragment);
136         @Override
137         public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
138             if (fragment != null) {
139                 ft.detach(fragment);
142 
143         @Override
144         public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
145             refreshFragment(fragment);
146         }
147 
148         protected abstract void refreshFragment(T fragment);
149     }
3 import android.app.Activity;
5 import android.view.LayoutInflater;
7 import android.view.ViewGroup;
8 import android.view.animation.Animation;
9 import android.view.animation.AnimationUtils;
10 import android.widget.BaseAdapter;
13 import android.widget.GridView;
14 import android.widget.ImageView;
18 import com.bumptech.photos.presenter.ImagePresenter;
19 import com.bumptech.photos.presenter.ImageSetCallback;
21 import com.bumptech.photos.resize.loader.CenterCrop;
27 public class MyActivity extends Activity {
49         final GridView images = (GridView) findViewById(R.id.images);
50 
66                 images.setAdapter(null);
77                         images.setAdapter(new PhotoAdapter(photos));
96     private class PhotoAdapter extends BaseAdapter {
98         private final List<Photo> photos;
99         private final LayoutInflater inflater;
100 
101         public PhotoAdapter(List<Photo> photos) {
102             this.photos = photos;
103             this.inflater = getLayoutInflater();
107         public int getCount() {
108             return photos.size();
109         }
110 
111         @Override
112         public Object getItem(int i) {
113             return photos.get(i);
114         }
115 
116         @Override
117         public long getItemId(int i) {
118             return 0;
119         }
120 
121         @Override
122         public View getView(int position, View view, ViewGroup container) {
123             final ImagePresenter<Photo> presenter;
124             if (view == null) {
125                 Log.d(""MyActivity: inflate"");
126                 ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
127                 final Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.this, R.anim.fade_in);
128                 presenter = new ImagePresenter.Builder<Photo>()
129                         .setImageView(imageView)
130                         .setPathLoader(new FlickPathLoader(flickerApi, cacheDir))
131                         .setImageLoader(new CenterCrop<Photo>(imageManager))
132                         .setImageSetCallback(new ImageSetCallback() {
133                             @Override
134                             public void onImageSet(ImageView view, boolean fromCache) {
135                                 view.clearAnimation();
136                                 if (!fromCache)
137                                     view.startAnimation(fadeIn);
138                             }
139                         })
140                         .build();
141                 imageView.setTag(presenter);
142                 view = imageView;
144                 presenter = (ImagePresenter<Photo>) view.getTag();
147             presenter.setModel(photos.get(position));
148             return view;",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,ae8259eaee73dc4f96b0bd06e6e959687e37420b,df5ba684898ad99c7b4c7b6dd4f11ba6656cddfa,"Create Fragment layout with tabs for sizes

Adds android support and ActionBarSherlock as
dependencies","@@ -80,6 +80,13 @@ public class Downloader {
             try {
                 final URL targetUrl = new URL(url);
                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
+                urlConnection = (HttpURLConnection) targetUrl.openConnection();
+                urlConnection.setDoInput(true);
+                urlConnection.setDoOutput(false);
+                urlConnection.setUseCaches(false);
+                urlConnection.setRequestProperty(""Connection"", ""close"");
+
+                urlConnection.connect();
                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
                 OutputStream out = new FileOutputStream(output);
                 writeToOutput(in, out);
","83                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
84                 urlConnection.setDoInput(true);
85                 urlConnection.setDoOutput(false);
86                 urlConnection.setUseCaches(false);
87                 urlConnection.setRequestProperty(""Connection"", ""close"");
88 
89                 urlConnection.connect();",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,a36330e9cbe39da17d9f6687c259b222b5716593,ae8259eaee73dc4f96b0bd06e6e959687e37420b,2.x fixes,"@@ -248,6 +248,7 @@ public class ImageManager {
             }
             bitmapCache = new SizedBitmapCache(options.maxPerSize);
         } else {
+            if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
             bitmapCache = null;
         }
",251             if (CAN_RECYCLE),No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,a36330e9cbe39da17d9f6687c259b222b5716593,ae8259eaee73dc4f96b0bd06e6e959687e37420b,2.x fixes,"@@ -24,6 +24,7 @@ import java.util.Queue;
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
+    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private SizedBitmapCache bitmapCache = null;
     private final BitmapFactory.Options defaultOptions;
@@ -34,7 +35,7 @@ public class ImageResizer {
        decodeBitmapOptions.inScaled = false;
        decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
        decodeBitmapOptions.inSampleSize = 1;
-       if (Build.VERSION.SDK_INT >= 11)  {
+       if (CAN_RECYCLE)  {
            decodeBitmapOptions.inMutable = true;
        }
        return decodeBitmapOptions;
@@ -302,6 +303,7 @@ public class ImageResizer {
     private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
         BitmapFactory.Options result = new BitmapFactory.Options();
         copyOptions(defaultOptions, result);
+        if (CAN_RECYCLE)
             result.inBitmap = recycle;
         return result;
     }
@@ -343,6 +345,7 @@ public class ImageResizer {
         to.inDensity = from.inDensity;
         to.inDither = from.inDither;
         to.inInputShareable = from.inInputShareable;
+        if (CAN_RECYCLE)
             to.inMutable = from.inMutable;
         to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
         to.inPreferredConfig = from.inPreferredConfig;
","27     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
38        if (CAN_RECYCLE)  {
306         if (CAN_RECYCLE)
348         if (CAN_RECYCLE)
37        if (Build.VERSION.SDK_INT >= 11)  {",No
samples\flickr\res\layout\grid_fragment.xml,samples\flickr\res\layout\grid_fragment.xml,82ab4564086ed271e3d807c18e55d15b9285eab3,a36330e9cbe39da17d9f6687c259b222b5716593,Make tabs swipeable,"@@ -7,6 +7,8 @@
   android:numColumns=""auto_fit""
   android:horizontalSpacing=""15dp""
   android:verticalSpacing=""15dp""
+  android:gravity=""center""
+  android:stretchMode=""spacingWidthUniform""
   android:layout_width=""fill_parent""
   android:layout_height=""fill_parent""
   android:layout_marginLeft=""10dp""
","10   android:gravity=""center""
11   android:stretchMode=""spacingWidthUniform""",No
samples\flickr\res\layout\main.xml,samples\flickr\res\layout\main.xml,82ab4564086ed271e3d807c18e55d15b9285eab3,a36330e9cbe39da17d9f6687c259b222b5716593,Make tabs swipeable,"@@ -33,8 +33,8 @@
       android:layout_width=""fill_parent""
       android:layout_height=""0dp""
       android:layout_weight=""1"">
-      <FrameLayout
-        android:id=""@+id/fragment_container""
+      <android.support.v4.view.ViewPager
+        android:id=""@+id/view_pager""
         android:layout_width=""fill_parent""
         android:layout_height=""fill_parent"" />
       <LinearLayout
","36       <android.support.v4.view.ViewPager
37         android:id=""@+id/view_pager""
36       <FrameLayout
37         android:id=""@+id/fragment_container""",No
samples\flickr\src\com\bumptech\flickr\GridFragment.java,samples\flickr\src\com\bumptech\flickr\GridFragment.java,82ab4564086ed271e3d807c18e55d15b9285eab3,a36330e9cbe39da17d9f6687c259b222b5716593,Make tabs swipeable,"@@ -16,7 +16,6 @@ import com.bumptech.photos.presenter.ImagePresenter;
 import com.bumptech.photos.presenter.ImageSetCallback;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.loader.CenterCrop;
-import com.bumptech.photos.util.Log;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -29,7 +28,7 @@ import java.util.List;
  * Time: 9:48 AM
  * To change this template use File | Settings | File Templates.
  */
-public class GridFragment extends SherlockFragment{
+public class GridFragment extends SherlockFragment implements PhotoViewer{
     private PhotoAdapter adapter;
     private List<Photo> currentPhotos;
     private Api api;
@@ -57,7 +56,8 @@ public class GridFragment extends SherlockFragment{
         return result;
     }
 
-    public void setPhotos(List<Photo> photos) {
+    @Override
+    public void onPhotosUpdated(List<Photo> photos) {
         currentPhotos = photos;
         if (adapter != null)
             adapter.setPhotos(currentPhotos);
@@ -96,7 +96,6 @@ public class GridFragment extends SherlockFragment{
         public View getView(int position, View view, ViewGroup container) {
             final ImagePresenter<Photo> presenter;
             if (view == null) {
-                Log.d(""MyActivity: inflate"");
                 ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
                 ViewGroup.LayoutParams params = imageView.getLayoutParams();
                 params.width = photoSize;
","31 public class GridFragment extends SherlockFragment implements PhotoViewer{
59     @Override
60     public void onPhotosUpdated(List<Photo> photos) {
19 import com.bumptech.photos.util.Log;
32 public class GridFragment extends SherlockFragment{
60     public void setPhotos(List<Photo> photos) {
99                 Log.d(""MyActivity: inflate"");",No
samples\flickr\src\com\bumptech\flickr\MyActivity.java,samples\flickr\src\com\bumptech\flickr\MyActivity.java,82ab4564086ed271e3d807c18e55d15b9285eab3,a36330e9cbe39da17d9f6687c259b222b5716593,Make tabs swipeable,"@@ -2,13 +2,17 @@ package com.bumptech.flickr;
 
 import android.content.res.Resources;
 import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentPagerAdapter;
 import android.support.v4.app.FragmentTransaction;
+import android.support.v4.view.ViewPager;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
 import com.actionbarsherlock.app.ActionBar;
-import com.actionbarsherlock.app.SherlockFragment;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
@@ -24,7 +28,9 @@ public class MyActivity extends SherlockFragmentActivity {
     private ImageManager imageManager;
     private File cacheDir;
     private int searchCount = 0;
+
     private List<Photo> currentPhotos = new ArrayList<Photo>(0);
+    private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
 
     /** Called when the activity is first created. */
     @Override
@@ -41,6 +47,7 @@ public class MyActivity extends SherlockFragmentActivity {
         options.maxPerSize = 40;
         options.maxDiskCacheSize = 50 * 1024 * 1024;
         imageManager = new ImageManager(this, options);
+
         flickerApi = new Api();
 
         final View searching = findViewById(R.id.searching);
@@ -70,31 +77,38 @@ public class MyActivity extends SherlockFragmentActivity {
                         searching.setVisibility(View.INVISIBLE);
 
                         currentPhotos = photos;
-                        getSupportActionBar().getSelectedTab().select(); //reselect
+                        for (PhotoViewer viewer : photoViewers) {
+                            viewer.onPhotosUpdated(photos);
+                        }
                     }
                 });
             }
         });
 
+        ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
+
+        final List<Fragment> fragments = new ArrayList<Fragment>();
         final ActionBar actionBar = getSupportActionBar();
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
-        final GridFragment medium = new GridFragment();
         final Resources res = getResources();
-        medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
+
         GridFragment small = new GridFragment();
         small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
-        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener<GridFragment>(""small"", small) {
-            @Override
-            protected void refreshFragment(GridFragment fragment) {
-                if (currentPhotos != null)
-                    fragment.setPhotos(currentPhotos);
-            }
-        }));
-        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener<GridFragment>(""medium"", medium) {
+        fragments.add(small);
+        photoViewers.add(small);
+
+        final GridFragment medium = new GridFragment();
+        medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
+        fragments.add(medium);
+        photoViewers.add(medium);
+
+        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener2(pager)));
+        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener2(pager)));
+
+        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {
             @Override
-            protected void refreshFragment(GridFragment fragment) {
-                if (currentPhotos != null)
-                    fragment.setPhotos(currentPhotos);
+            public void onPrimaryItemSet(int position) {
+                actionBar.getTabAt(position).select();
             }
         }));
 
@@ -112,39 +126,57 @@ public class MyActivity extends SherlockFragmentActivity {
         imageManager.pause();
     }
 
-    private abstract class TabListener<T extends SherlockFragment> implements ActionBar.TabListener {
-        private final String tag;
-        private final T fragment;
-        private boolean added = false;
+    private static class TabListener2 implements ActionBar.TabListener {
+        private final ViewPager pager;
 
-        public TabListener(String tag, T fragment) {
-            this.tag = tag;
-            this.fragment = fragment;
+        public TabListener2(ViewPager pager) {
+            this.pager = pager;
         }
 
         @Override
         public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
-            if (!added) {
-                ft.add(R.id.fragment_container, fragment, tag);
-                added = true;
-            } else {
-                ft.attach(fragment);
-            }
-            refreshFragment(fragment);
+            pager.setCurrentItem(tab.getPosition());
         }
 
         @Override
-        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
-            if (fragment != null) {
-                ft.detach(fragment);
+        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }
+
+        @Override
+        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
+    }
+
+    private static class FlickrPagerAdapter extends FragmentPagerAdapter {
+        private final PrimaryItemListener listener;
+
+        private interface PrimaryItemListener {
+            public void onPrimaryItemSet(int position);
         }
+        private final List<Fragment> fragments;
+        private int lastPosition = 0;
+
+        public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments, PrimaryItemListener listener) {
+            super(fm);
+            this.fragments = fragments;
+            this.listener = listener;
+        }
+
+        @Override
+        public Fragment getItem(int i) {
+            return fragments.get(i);  //To change body of implemented methods use File | Settings | File Templates.
         }
 
         @Override
-        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
-            refreshFragment(fragment);
+        public int getCount() {
+            return fragments.size();  //To change body of implemented methods use File | Settings | File Templates.
         }
 
-        protected abstract void refreshFragment(T fragment);
+        @Override
+        public void setPrimaryItem(ViewGroup container, int position, Object object) {
+            if (lastPosition != position) {
+                listener.onPrimaryItemSet(position);
+                lastPosition = position;
+            }
+            super.setPrimaryItem(container, position, object);    //To change body of overridden methods use File | Settings | File Templates.
+        }
     }
 }
","5 import android.support.v4.app.Fragment;
6 import android.support.v4.app.FragmentManager;
7 import android.support.v4.app.FragmentPagerAdapter;
9 import android.support.v4.view.ViewPager;
11 import android.view.ViewGroup;
31 
33     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
50 
80                         for (PhotoViewer viewer : photoViewers) {
81                             viewer.onPhotosUpdated(photos);
82                         }
88         ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
89 
90         final List<Fragment> fragments = new ArrayList<Fragment>();
94 
97         fragments.add(small);
98         photoViewers.add(small);
99 
100         final GridFragment medium = new GridFragment();
101         medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
102         fragments.add(medium);
103         photoViewers.add(medium);
104 
105         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener2(pager)));
106         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener2(pager)));
107 
108         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {
110             public void onPrimaryItemSet(int position) {
111                 actionBar.getTabAt(position).select();
129     private static class TabListener2 implements ActionBar.TabListener {
130         private final ViewPager pager;
132         public TabListener2(ViewPager pager) {
133             this.pager = pager;
138             pager.setCurrentItem(tab.getPosition());
142         public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }
143 
144         @Override
145         public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
147 
148     private static class FlickrPagerAdapter extends FragmentPagerAdapter {
149         private final PrimaryItemListener listener;
150 
151         private interface PrimaryItemListener {
152             public void onPrimaryItemSet(int position);
153         }
154         private final List<Fragment> fragments;
155         private int lastPosition = 0;
156 
157         public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments, PrimaryItemListener listener) {
158             super(fm);
159             this.fragments = fragments;
160             this.listener = listener;
164         public Fragment getItem(int i) {
165             return fragments.get(i);  //To change body of implemented methods use File | Settings | File Templates.
168         @Override
169         public int getCount() {
170             return fragments.size();  //To change body of implemented methods use File | Settings | File Templates.
171         }
172 
173         @Override
174         public void setPrimaryItem(ViewGroup container, int position, Object object) {
175             if (lastPosition != position) {
176                 listener.onPrimaryItemSet(position);
177                 lastPosition = position;
178             }
179             super.setPrimaryItem(container, position, object);    //To change body of overridden methods use File | Settings | File Templates.
180         }
11 import com.actionbarsherlock.app.SherlockFragment;
73                         getSupportActionBar().getSelectedTab().select(); //reselect
81         final GridFragment medium = new GridFragment();
83         medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
86         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener<GridFragment>(""small"", small) {
88             protected void refreshFragment(GridFragment fragment) {
89                 if (currentPhotos != null)
90                     fragment.setPhotos(currentPhotos);
91             }
92         }));
93         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener<GridFragment>(""medium"", medium) {
94             @Override
95             protected void refreshFragment(GridFragment fragment) {
96                 if (currentPhotos != null)
97                     fragment.setPhotos(currentPhotos);
115     private abstract class TabListener<T extends SherlockFragment> implements ActionBar.TabListener {
116         private final String tag;
117         private final T fragment;
118         private boolean added = false;
120         public TabListener(String tag, T fragment) {
121             this.tag = tag;
122             this.fragment = fragment;
127             if (!added) {
128                 ft.add(R.id.fragment_container, fragment, tag);
129                 added = true;
130             } else {
131                 ft.attach(fragment);
132             }
133             refreshFragment(fragment);
137         public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) {
138             if (fragment != null) {
139                 ft.detach(fragment);
144         public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) {
145             refreshFragment(fragment);
148         protected abstract void refreshFragment(T fragment);",No
,samples\flickr\src\com\bumptech\flickr\PhotoViewer.java,82ab4564086ed271e3d807c18e55d15b9285eab3,a36330e9cbe39da17d9f6687c259b222b5716593,Make tabs swipeable,"@@ -0,0 +1,16 @@
+package com.bumptech.flickr;
+
+import com.bumptech.flickr.api.Photo;
+
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/10/13
+ * Time: 11:45 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface PhotoViewer {
+    public void onPhotosUpdated(List<Photo> photos);
+}
","1 package com.bumptech.flickr;
2 
3 import com.bumptech.flickr.api.Photo;
4 
5 import java.util.List;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 1/10/13
11  * Time: 11:45 AM
12  * To change this template use File | Settings | File Templates.
13  */
14 public interface PhotoViewer {
15     public void onPhotosUpdated(List<Photo> photos);
16 }",No
samples\flickr\AndroidManifest.xml,samples\flickr\AndroidManifest.xml,4456038ea9cc2ae9b24239252a0efe370e9916de,82ab4564086ed271e3d807c18e55d15b9285eab3,Naming cleanup in flickr sample,"@@ -7,7 +7,7 @@
       android:hardwareAccelerated=""true""
       android:theme=""@style/Theme.Sherlock"">
 
-        <activity android:name=""MyActivity""
+        <activity android:name="".FlickrSearchActivity""
                   android:label=""@string/app_name""
           android:launchMode=""singleTask""
           android:screenOrientation=""portrait"">
","10         <activity android:name="".FlickrSearchActivity""
10         <activity android:name=""MyActivity""",No
samples\flickr\src\com\bumptech\flickr\FlickPathLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,4456038ea9cc2ae9b24239252a0efe370e9916de,82ab4564086ed271e3d807c18e55d15b9285eab3,Naming cleanup in flickr sample,"@@ -13,11 +13,11 @@ import java.io.File;
  * Time: 11:55 AM
  * To change this template use File | Settings | File Templates.
  */
-public class FlickPathLoader extends BasePathLoader<Photo> {
+public class FlickrPathLoader extends BasePathLoader<Photo> {
     private final Api flickrApi;
     private final File cacheDir;
 
-    public FlickPathLoader(Api flickApi, File cacheDir) {
+    public FlickrPathLoader(Api flickApi, File cacheDir) {
         this.flickrApi = flickApi;
         this.cacheDir = cacheDir;
     }
","16 public class FlickrPathLoader extends BasePathLoader<Photo> {
20     public FlickrPathLoader(Api flickApi, File cacheDir) {
16 public class FlickPathLoader extends BasePathLoader<Photo> {
20     public FlickPathLoader(Api flickApi, File cacheDir) {",No
samples\flickr\src\com\bumptech\flickr\GridFragment.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,4456038ea9cc2ae9b24239252a0efe370e9916de,82ab4564086ed271e3d807c18e55d15b9285eab3,Naming cleanup in flickr sample,"@@ -28,7 +28,7 @@ import java.util.List;
  * Time: 9:48 AM
  * To change this template use File | Settings | File Templates.
  */
-public class GridFragment extends SherlockFragment implements PhotoViewer{
+public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
     private PhotoAdapter adapter;
     private List<Photo> currentPhotos;
     private Api api;
@@ -104,7 +104,7 @@ public class GridFragment extends SherlockFragment implements PhotoViewer{
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setPathLoader(new FlickPathLoader(api, cacheDir))
+                        .setPathLoader(new FlickrPathLoader(api, cacheDir))
                         .setImageLoader(new CenterCrop<Photo>(imageManager))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
","31 public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
107                         .setPathLoader(new FlickrPathLoader(api, cacheDir))
31 public class GridFragment extends SherlockFragment implements PhotoViewer{
107                         .setPathLoader(new FlickPathLoader(api, cacheDir))",No
samples\flickr\src\com\bumptech\flickr\MyActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,4456038ea9cc2ae9b24239252a0efe370e9916de,82ab4564086ed271e3d807c18e55d15b9285eab3,Naming cleanup in flickr sample,"@@ -23,7 +23,7 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-public class MyActivity extends SherlockFragmentActivity {
+public class FlickrSearchActivity extends SherlockFragmentActivity {
     private Api flickerApi;
     private ImageManager imageManager;
     private File cacheDir;
@@ -92,12 +92,12 @@ public class MyActivity extends SherlockFragmentActivity {
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
         final Resources res = getResources();
 
-        GridFragment small = new GridFragment();
+        FlickrPhotoGrid small = new FlickrPhotoGrid();
         small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
         fragments.add(small);
         photoViewers.add(small);
 
-        final GridFragment medium = new GridFragment();
+        final FlickrPhotoGrid medium = new FlickrPhotoGrid();
         medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
         fragments.add(medium);
         photoViewers.add(medium);
","26 public class FlickrSearchActivity extends SherlockFragmentActivity {
95         FlickrPhotoGrid small = new FlickrPhotoGrid();
100         final FlickrPhotoGrid medium = new FlickrPhotoGrid();
26 public class MyActivity extends SherlockFragmentActivity {
95         GridFragment small = new GridFragment();
100         final GridFragment medium = new GridFragment();",No
,samples\flickr\res\layout\flick_photo_list.xml,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -0,0 +1,10 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+
+<ListView xmlns:android=""http://schemas.android.com/apk/res/android""
+  android:id=""@+id/flickr_photo_list""
+  android:layout_width=""fill_parent""
+  android:layout_height=""fill_parent""
+  android:cacheColorHint=""#00000000""
+  android:scrollingCache=""false"">
+</ListView>
+
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 
3 <ListView xmlns:android=""http://schemas.android.com/apk/res/android""
4   android:id=""@+id/flickr_photo_list""
5   android:layout_width=""fill_parent""
6   android:layout_height=""fill_parent""
7   android:cacheColorHint=""#00000000""
8   android:scrollingCache=""false"">
9 </ListView>
10 ",No
,samples\flickr\res\layout\flick_photo_list_item.xml,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -0,0 +1,22 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+
+<LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
+  android:orientation=""horizontal""
+  android:layout_width=""fill_parent""
+  android:layout_height=""@dimen/flickr_list_item_height""
+  android:padding=""10dp"">
+  <ImageView
+    android:id=""@+id/photo_view""
+    android:layout_width=""0dp""
+    android:layout_height=""fill_parent""
+    android:layout_weight=""1""
+    android:scaleType=""center"" />
+  <TextView
+    android:id=""@+id/title_view""
+    android:layout_width=""0dp""
+    android:layout_height=""fill_parent""
+    android:layout_weight=""1""
+    android:layout_margin=""10dp""
+    android:gravity=""center""
+    android:textSize=""16sp""/>
+</LinearLayout>
\ No newline at end of file
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 
3 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
4   android:orientation=""horizontal""
5   android:layout_width=""fill_parent""
6   android:layout_height=""@dimen/flickr_list_item_height""
7   android:padding=""10dp"">
8   <ImageView
9     android:id=""@+id/photo_view""
10     android:layout_width=""0dp""
11     android:layout_height=""fill_parent""
12     android:layout_weight=""1""
13     android:scaleType=""center"" />
14   <TextView
15     android:id=""@+id/title_view""
16     android:layout_width=""0dp""
17     android:layout_height=""fill_parent""
18     android:layout_weight=""1""
19     android:layout_margin=""10dp""
20     android:gravity=""center""
21     android:textSize=""16sp""/>
22 </LinearLayout>",No
samples\flickr\res\values\dimens.xml,samples\flickr\res\values\dimens.xml,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -2,4 +2,6 @@
 <resources>
   <dimen name=""medium_photo_side"">110dp</dimen>
   <dimen name=""small_photo_side"">55dp</dimen>
+  <dimen name=""large_photo_side"">150dp</dimen>
+  <dimen name=""flickr_list_item_height"">170dp</dimen>
 </resources>
\ No newline at end of file
","5   <dimen name=""large_photo_side"">150dp</dimen>
6   <dimen name=""flickr_list_item_height"">170dp</dimen>",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -5,4 +5,5 @@
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
   <string name=""small"">Small</string>
   <string name=""medium"">Medium</string>
+  <string name=""list"">List</string>
 </resources>
","8   <string name=""list"">List</string>",No
,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -0,0 +1,134 @@
+package com.bumptech.flickr;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+import com.actionbarsherlock.app.SherlockFragment;
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.photos.presenter.ImagePresenter;
+import com.bumptech.photos.presenter.ImageSetCallback;
+import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.loader.CenterCrop;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/10/13
+ * Time: 12:47 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
+    private FlickrPhotoListAdapter adapter;
+    private Api api;
+    private ImageManager imageManager;
+    private File cacheDir;
+    private List<Photo> currentPhotos;
+
+    public void setup(Api api, ImageManager imageManager, File cacheDir) {
+        this.api = api;
+        this.imageManager = imageManager;
+        this.cacheDir = cacheDir;
+    }
+    @Override
+    public void onPhotosUpdated(List<Photo> photos) {
+        currentPhotos = photos;
+        if (adapter != null)
+            adapter.setPhotos(currentPhotos);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        final View result = inflater.inflate(R.layout.flick_photo_list, container, false);
+        ListView list = (ListView) result.findViewById(R.id.flickr_photo_list);
+        adapter = new FlickrPhotoListAdapter();
+        list.setAdapter(adapter);
+        if (currentPhotos != null)
+            adapter.setPhotos(currentPhotos);
+        return result;
+    }
+
+    private static class ViewHolder {
+        private final ImagePresenter<Photo> presenter;
+        private final TextView titleText;
+
+        public ViewHolder(ImagePresenter<Photo> presenter, TextView titleText) {
+            this.presenter = presenter;
+            this.titleText = titleText;
+        }
+    }
+
+    private class FlickrPhotoListAdapter extends BaseAdapter {
+        private final LayoutInflater inflater;
+        private List<Photo> photos = new ArrayList<Photo>(0);
+
+        public FlickrPhotoListAdapter() {
+            this.inflater = LayoutInflater.from(getActivity());
+        }
+
+        public void setPhotos(List<Photo> photos) {
+            this.photos = photos;
+            notifyDataSetChanged();
+        }
+
+        @Override
+        public int getCount() {
+            return photos.size();
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        @Override
+        public View getView(int position, View view, ViewGroup container) {
+            final ViewHolder viewHolder;
+            if (view == null) {
+                view = inflater.inflate(R.layout.flick_photo_list_item, container, false);
+                ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
+
+                final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
+                ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
+                        .setImageView(imageView)
+                        .setPathLoader(new FlickrPathLoader(api, cacheDir))
+                        .setImageLoader(new CenterCrop<Photo>(imageManager))
+                        .setImageSetCallback(new ImageSetCallback() {
+                            @Override
+                            public void onImageSet(ImageView view, boolean fromCache) {
+                                view.clearAnimation();
+                                if (!fromCache)
+                                    view.startAnimation(fadeIn);
+                            }
+                        })
+                        .build();
+                TextView titleView = (TextView) view.findViewById(R.id.title_view);
+                viewHolder = new ViewHolder(presenter, titleView);
+                view.setTag(viewHolder);
+            } else {
+                viewHolder = (ViewHolder) view.getTag();
+            }
+
+            final Photo current = photos.get(position);
+            viewHolder.presenter.setModel(current);
+            viewHolder.titleText.setText(current.title);
+            return view;
+        }
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import android.os.Bundle;
4 import android.view.LayoutInflater;
5 import android.view.View;
6 import android.view.ViewGroup;
7 import android.view.animation.Animation;
8 import android.view.animation.AnimationUtils;
9 import android.widget.BaseAdapter;
10 import android.widget.ImageView;
11 import android.widget.ListView;
12 import android.widget.TextView;
13 import com.actionbarsherlock.app.SherlockFragment;
14 import com.bumptech.flickr.api.Api;
15 import com.bumptech.flickr.api.Photo;
16 import com.bumptech.photos.presenter.ImagePresenter;
17 import com.bumptech.photos.presenter.ImageSetCallback;
18 import com.bumptech.photos.resize.ImageManager;
19 import com.bumptech.photos.resize.loader.CenterCrop;
20 
21 import java.io.File;
22 import java.util.ArrayList;
23 import java.util.List;
24 
25 /**
26  * Created with IntelliJ IDEA.
27  * User: sam
28  * Date: 1/10/13
29  * Time: 12:47 PM
30  * To change this template use File | Settings | File Templates.
31  */
32 public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
33     private FlickrPhotoListAdapter adapter;
34     private Api api;
35     private ImageManager imageManager;
36     private File cacheDir;
37     private List<Photo> currentPhotos;
38 
39     public void setup(Api api, ImageManager imageManager, File cacheDir) {
40         this.api = api;
41         this.imageManager = imageManager;
42         this.cacheDir = cacheDir;
43     }
44     @Override
45     public void onPhotosUpdated(List<Photo> photos) {
46         currentPhotos = photos;
47         if (adapter != null)
48             adapter.setPhotos(currentPhotos);
49     }
50 
51     @Override
52     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
53         final View result = inflater.inflate(R.layout.flick_photo_list, container, false);
54         ListView list = (ListView) result.findViewById(R.id.flickr_photo_list);
55         adapter = new FlickrPhotoListAdapter();
56         list.setAdapter(adapter);
57         if (currentPhotos != null)
58             adapter.setPhotos(currentPhotos);
59         return result;
60     }
61 
62     private static class ViewHolder {
63         private final ImagePresenter<Photo> presenter;
64         private final TextView titleText;
65 
66         public ViewHolder(ImagePresenter<Photo> presenter, TextView titleText) {
67             this.presenter = presenter;
68             this.titleText = titleText;
69         }
70     }
71 
72     private class FlickrPhotoListAdapter extends BaseAdapter {
73         private final LayoutInflater inflater;
74         private List<Photo> photos = new ArrayList<Photo>(0);
75 
76         public FlickrPhotoListAdapter() {
77             this.inflater = LayoutInflater.from(getActivity());
78         }
79 
80         public void setPhotos(List<Photo> photos) {
81             this.photos = photos;
82             notifyDataSetChanged();
83         }
84 
85         @Override
86         public int getCount() {
87             return photos.size();
88         }
89 
90         @Override
91         public Object getItem(int i) {
92             return null;  //To change body of implemented methods use File | Settings | File Templates.
93         }
94 
95         @Override
96         public long getItemId(int i) {
97             return 0;  //To change body of implemented methods use File | Settings | File Templates.
98         }
99 
100         @Override
101         public View getView(int position, View view, ViewGroup container) {
102             final ViewHolder viewHolder;
103             if (view == null) {
104                 view = inflater.inflate(R.layout.flick_photo_list_item, container, false);
105                 ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
106 
107                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
108                 ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
109                         .setImageView(imageView)
110                         .setPathLoader(new FlickrPathLoader(api, cacheDir))
111                         .setImageLoader(new CenterCrop<Photo>(imageManager))
112                         .setImageSetCallback(new ImageSetCallback() {
113                             @Override
114                             public void onImageSet(ImageView view, boolean fromCache) {
115                                 view.clearAnimation();
116                                 if (!fromCache)
117                                     view.startAnimation(fadeIn);
118                             }
119                         })
120                         .build();
121                 TextView titleView = (TextView) view.findViewById(R.id.title_view);
122                 viewHolder = new ViewHolder(presenter, titleView);
123                 view.setTag(viewHolder);
124             } else {
125                 viewHolder = (ViewHolder) view.getTag();
126             }
127 
128             final Photo current = photos.get(position);
129             viewHolder.presenter.setModel(current);
130             viewHolder.titleText.setText(current.title);
131             return view;
132         }
133     }
134 }",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,aef036f9ab558bb32e1cb81f8623fb2b886f2840,4456038ea9cc2ae9b24239252a0efe370e9916de,Add list of photos + title page,"@@ -102,8 +102,10 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         fragments.add(medium);
         photoViewers.add(medium);
 
-        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener2(pager)));
-        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener2(pager)));
+        FlickrPhotoList list =  new FlickrPhotoList();
+        list.setup(flickerApi, imageManager, cacheDir);
+        fragments.add(list);
+        photoViewers.add(list);
 
         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {
             @Override
@@ -111,6 +113,11 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                 actionBar.getTabAt(position).select();
             }
         }));
+        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener(pager)));
+        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener(pager)));
+        actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
+
+        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments));
 
     }
 
","105         FlickrPhotoList list =  new FlickrPhotoList();
106         list.setup(flickerApi, imageManager, cacheDir);
107         fragments.add(list);
108         photoViewers.add(list);
116         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener(pager)));
117         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener(pager)));
118         actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
119 
120         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments));
105         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener2(pager)));
106         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener2(pager)));",No
samples\flickr\res\layout\grid_fragment.xml,samples\flickr\res\layout\grid_fragment.xml,f0c4c377ac61e6c050f1dca1310d4f680c11e62e,aef036f9ab558bb32e1cb81f8623fb2b886f2840,Center the columns in the grid pages,"@@ -5,11 +5,10 @@
   android:fadingEdge=""none""
   android:scrollingCache=""false""
   android:numColumns=""auto_fit""
-  android:horizontalSpacing=""15dp""
-  android:verticalSpacing=""15dp""
+  android:horizontalSpacing=""10dp""
+  android:verticalSpacing=""10dp""
   android:gravity=""center""
-  android:stretchMode=""spacingWidthUniform""
+  android:layout_gravity=""center""
+  android:stretchMode=""columnWidth""
   android:layout_width=""fill_parent""
-  android:layout_height=""fill_parent""
-  android:layout_marginLeft=""10dp""
-  android:layout_marginRight=""10dp""/>
+  android:layout_height=""fill_parent"" />
","8   android:horizontalSpacing=""10dp""
9   android:verticalSpacing=""10dp""
11   android:layout_gravity=""center""
12   android:stretchMode=""columnWidth""
14   android:layout_height=""fill_parent"" />
8   android:horizontalSpacing=""15dp""
9   android:verticalSpacing=""15dp""
11   android:stretchMode=""spacingWidthUniform""
13   android:layout_height=""fill_parent""
14   android:layout_marginLeft=""10dp""
15   android:layout_marginRight=""10dp""/>",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,f0c4c377ac61e6c050f1dca1310d4f680c11e62e,Code cleanup in search activity,"@@ -8,7 +8,6 @@ import android.support.v4.app.FragmentPagerAdapter;
 import android.support.v4.app.FragmentTransaction;
 import android.support.v4.view.ViewPager;
 import android.view.View;
-import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
@@ -29,7 +28,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     private File cacheDir;
     private int searchCount = 0;
 
-    private List<Photo> currentPhotos = new ArrayList<Photo>(0);
     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
 
     /** Called when the activity is first created. */
@@ -76,7 +74,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                         Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
                         searching.setVisibility(View.INVISIBLE);
 
-                        currentPhotos = photos;
                         for (PhotoViewer viewer : photoViewers) {
                             viewer.onPhotosUpdated(photos);
                         }
@@ -85,12 +82,25 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             }
         });
 
+        final Resources res = getResources();
         ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
+        pager.setPageMargin(50);
+        pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
+            @Override
+            public void onPageScrolled(int i, float v, int i2) { }
+
+            @Override
+            public void onPageSelected(int position) {
+                getSupportActionBar().getTabAt(position).select();
+            }
+
+            @Override
+            public void onPageScrollStateChanged(int i) { }
+        });
 
         final List<Fragment> fragments = new ArrayList<Fragment>();
         final ActionBar actionBar = getSupportActionBar();
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
-        final Resources res = getResources();
 
         FlickrPhotoGrid small = new FlickrPhotoGrid();
         small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
@@ -107,12 +117,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         fragments.add(list);
         photoViewers.add(list);
 
-        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {
-            @Override
-            public void onPrimaryItemSet(int position) {
-                actionBar.getTabAt(position).select();
-            }
-        }));
         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener(pager)));
         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener(pager)));
         actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
@@ -133,10 +137,10 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         imageManager.pause();
     }
 
-    private static class TabListener2 implements ActionBar.TabListener {
+    private static class TabListener implements ActionBar.TabListener {
         private final ViewPager pager;
 
-        public TabListener2(ViewPager pager) {
+        public TabListener(ViewPager pager) {
             this.pager = pager;
         }
 
@@ -153,18 +157,11 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     }
 
     private static class FlickrPagerAdapter extends FragmentPagerAdapter {
-        private final PrimaryItemListener listener;
-
-        private interface PrimaryItemListener {
-            public void onPrimaryItemSet(int position);
-        }
         private final List<Fragment> fragments;
-        private int lastPosition = 0;
 
-        public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments, PrimaryItemListener listener) {
+        public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments){
             super(fm);
             this.fragments = fragments;
-            this.listener = listener;
         }
 
         @Override
@@ -176,14 +173,5 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         public int getCount() {
             return fragments.size();  //To change body of implemented methods use File | Settings | File Templates.
         }
-
-        @Override
-        public void setPrimaryItem(ViewGroup container, int position, Object object) {
-            if (lastPosition != position) {
-                listener.onPrimaryItemSet(position);
-                lastPosition = position;
-            }
-            super.setPrimaryItem(container, position, object);    //To change body of overridden methods use File | Settings | File Templates.
-        }
     }
 }
","85         final Resources res = getResources();
87         pager.setPageMargin(50);
88         pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
89             @Override
90             public void onPageScrolled(int i, float v, int i2) { }
91 
92             @Override
93             public void onPageSelected(int position) {
94                 getSupportActionBar().getTabAt(position).select();
95             }
96 
97             @Override
98             public void onPageScrollStateChanged(int i) { }
99         });
140     private static class TabListener implements ActionBar.TabListener {
143         public TabListener(ViewPager pager) {
162         public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments){
11 import android.view.ViewGroup;
32     private List<Photo> currentPhotos = new ArrayList<Photo>(0);
79                         currentPhotos = photos;
93         final Resources res = getResources();
110         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {
111             @Override
112             public void onPrimaryItemSet(int position) {
113                 actionBar.getTabAt(position).select();
114             }
115         }));
136     private static class TabListener2 implements ActionBar.TabListener {
139         public TabListener2(ViewPager pager) {
156         private final PrimaryItemListener listener;
157 
158         private interface PrimaryItemListener {
159             public void onPrimaryItemSet(int position);
160         }
162         private int lastPosition = 0;
164         public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments, PrimaryItemListener listener) {
167             this.listener = listener;
179 
180         @Override
181         public void setPrimaryItem(ViewGroup container, int position, Object object) {
182             if (lastPosition != position) {
183                 listener.onPrimaryItemSet(position);
184                 lastPosition = position;
185             }
186             super.setPrimaryItem(container, position, object);    //To change body of overridden methods use File | Settings | File Templates.
187         }",No
samples\flickr\res\layout\grid_fragment.xml,samples\flickr\res\layout\flickr_photo_grid.xml,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,,,Yes
samples\flickr\res\layout\photo_grid_square.xml,samples\flickr\res\layout\flickr_photo_grid_item.xml,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,,,Yes
samples\flickr\res\layout\flick_photo_list.xml,samples\flickr\res\layout\flickr_photo_list.xml,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,,,Yes
samples\flickr\res\layout\flick_photo_list_item.xml,samples\flickr\res\layout\flickr_photo_list_item.xml,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,,,Yes
samples\flickr\res\layout\main.xml,samples\flickr\res\layout\flickr_search_activity.xml,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,,,Yes
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,"@@ -45,7 +45,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        final View result = inflater.inflate(R.layout.grid_fragment, container, false);
+        final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
         GridView grid = (GridView) result.findViewById(R.id.images);
         grid.setColumnWidth(photoSize);
         adapter = new PhotoAdapter();
@@ -96,7 +96,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
         public View getView(int position, View view, ViewGroup container) {
             final ImagePresenter<Photo> presenter;
             if (view == null) {
-                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);
+                ImageView imageView = (ImageView) inflater.inflate(R.layout.flickr_photo_grid_item, container, false);
                 ViewGroup.LayoutParams params = imageView.getLayoutParams();
                 params.width = photoSize;
                 params.height = photoSize;
","48         final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
99                 ImageView imageView = (ImageView) inflater.inflate(R.layout.flickr_photo_grid_item, container, false);
48         final View result = inflater.inflate(R.layout.grid_fragment, container, false);
99                 ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, false);",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,"@@ -50,7 +50,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        final View result = inflater.inflate(R.layout.flick_photo_list, container, false);
+        final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
         ListView list = (ListView) result.findViewById(R.id.flickr_photo_list);
         adapter = new FlickrPhotoListAdapter();
         list.setAdapter(adapter);
@@ -101,7 +101,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
         public View getView(int position, View view, ViewGroup container) {
             final ViewHolder viewHolder;
             if (view == null) {
-                view = inflater.inflate(R.layout.flick_photo_list_item, container, false);
+                view = inflater.inflate(R.layout.flickr_photo_list_item, container, false);
                 ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
 
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
","53         final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
104                 view = inflater.inflate(R.layout.flickr_photo_list_item, container, false);
53         final View result = inflater.inflate(R.layout.flick_photo_list, container, false);
104                 view = inflater.inflate(R.layout.flick_photo_list_item, container, false);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,949f090551894cc3330000bfe2ec1ae6086a7cb6,f1f7d28a8386cf7ad4d7ae3ccbaed5ff2f81a98f,Naming cleanup,"@@ -34,7 +34,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
+        setContentView(R.layout.flickr_search_activity);
         String cacheName = ""flickr_cache"";
         cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
         if (!cacheDir.exists()) {
","37         setContentView(R.layout.flickr_search_activity);
37         setContentView(R.layout.main);",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,6630d0b66d2fc7e9db892d90760eb8ceab5bc805,949f090551894cc3330000bfe2ec1ae6086a7cb6,"Doing lots of io on ui thread is bad

who knew...","@@ -9,8 +9,10 @@ import java.io.File;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * Created with IntelliJ IDEA.
@@ -24,6 +26,7 @@ public class Api {
     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
     private final Downloader downloader;
+    private Set<String> downloadedFilesNames = new HashSet<String>();
 
     private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
         put(75, ""s"");
@@ -100,13 +103,15 @@ public class Api {
 
     public void downloadPhoto(Photo photo, int width, int height, File cacheDir, final PhotoCallback cb) {
         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + width + height);
-        if (out.exists()) {
-            cb.onDownloadComplete(out.getPath());
+        final String path = out.getPath();
+        if (downloadedFilesNames.contains(path)) {
+            cb.onDownloadComplete(path);
         } else {
             Log.d(""API: missing photo, downloading"");
             downloader.download(getPhotoUrl(photo, width, height), out, new Downloader.DiskCallback() {
                 @Override
                 public void onDownloadReady(String path) {
+                    downloadedFilesNames.add(path);
                     cb.onDownloadComplete(path);
                 }
             });
","12 import java.util.HashSet;
15 import java.util.Set;
29     private Set<String> downloadedFilesNames = new HashSet<String>();
106         final String path = out.getPath();
107         if (downloadedFilesNames.contains(path)) {
108             cb.onDownloadComplete(path);
114                     downloadedFilesNames.add(path);
103         if (out.exists()) {
104             cb.onDownloadComplete(out.getPath());",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,6630d0b66d2fc7e9db892d90760eb8ceab5bc805,949f090551894cc3330000bfe2ec1ae6086a7cb6,"Doing lots of io on ui thread is bad

who knew...","@@ -76,6 +76,15 @@ public class Downloader {
 
         @Override
         public void run() {
+            if (output.exists()) {
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        cb.onDownloadReady(output.getPath());
+                    }
+                });
+                return;
+            }
             HttpURLConnection urlConnection = null;
             try {
                 final URL targetUrl = new URL(url);
","79             if (output.exists()) {
80                 mainHandler.post(new Runnable() {
81                     @Override
82                     public void run() {
83                         cb.onDownloadReady(output.getPath());
84                     }
85                 });
86                 return;
87             }",No
samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,dd244f81188176cfd4e606a5cdb11c370fdb78ad,6630d0b66d2fc7e9db892d90760eb8ceab5bc805,"Only download photo needed by largest page

This way we only download one image and resize it
three times, rather than downloading (up to) three
images and then resizing each one once.","@@ -24,7 +24,7 @@ public class FlickrPathLoader extends BasePathLoader<Photo> {
 
     @Override
     protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
-        flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {
+        flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
                 cb.onPathReady(path);
","27         flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
27         flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,dd244f81188176cfd4e606a5cdb11c370fdb78ad,6630d0b66d2fc7e9db892d90760eb8ceab5bc805,"Only download photo needed by largest page

This way we only download one image and resize it
three times, rather than downloading (up to) three
images and then resizing each one once.","@@ -46,7 +46,8 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         options.maxDiskCacheSize = 50 * 1024 * 1024;
         imageManager = new ImageManager(this, options);
 
-        flickerApi = new Api();
+        final Resources res = getResources();
+        flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
 
         final View searching = findViewById(R.id.searching);
         final TextView searchTerm = (TextView) findViewById(R.id.search_term);
@@ -82,7 +83,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             }
         });
 
-        final Resources res = getResources();
         ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
         pager.setPageMargin(50);
         pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
","49         final Resources res = getResources();
50         flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
49         flickerApi = new Api();
85         final Resources res = getResources();",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,dd244f81188176cfd4e606a5cdb11c370fdb78ad,6630d0b66d2fc7e9db892d90760eb8ceab5bc805,"Only download photo needed by largest page

This way we only download one image and resize it
three times, rather than downloading (up to) three
images and then resizing each one once.","@@ -39,6 +39,7 @@ public class Api {
         put(1024, ""b"");
         put(Integer.MAX_VALUE, ""o"");
     }};
+    private final String sizeKey;
 
     private static String getSizeKey(int width, int height) {
         final int largestEdge = width > height ? width : height;
@@ -60,8 +61,9 @@ public class Api {
         public void onDownloadComplete(String path);
     }
 
-    public Api() {
+    public Api(int maxPhotoSize) {
         this.downloader = Downloader.get();
+        this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
     }
 
     private static String getUrlForMethod(String method) {
@@ -72,8 +74,7 @@ public class Api {
         return getUrlForMethod(""flickr.photos.search"") + ""&text="" + text + ""&per_page=500"";
     }
 
-    private static String getPhotoUrl(Photo photo, int width, int height) {
-        String sizeKey = getSizeKey(width, height);
+    private static String getPhotoUrl(Photo photo, String sizeKey) {
         return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret, sizeKey);
     }
 
@@ -101,14 +102,14 @@ public class Api {
         });
     }
 
-    public void downloadPhoto(Photo photo, int width, int height, File cacheDir, final PhotoCallback cb) {
-        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + width + height);
+    public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
+        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
         final String path = out.getPath();
         if (downloadedFilesNames.contains(path)) {
             cb.onDownloadComplete(path);
         } else {
             Log.d(""API: missing photo, downloading"");
-            downloader.download(getPhotoUrl(photo, width, height), out, new Downloader.DiskCallback() {
+            downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
                 @Override
                 public void onDownloadReady(String path) {
                     downloadedFilesNames.add(path);
","42     private final String sizeKey;
64     public Api(int maxPhotoSize) {
66         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
77     private static String getPhotoUrl(Photo photo, String sizeKey) {
105     public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
106         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
112             downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
63     public Api() {
75     private static String getPhotoUrl(Photo photo, int width, int height) {
76         String sizeKey = getSizeKey(width, height);
104     public void downloadPhoto(Photo photo, int width, int height, File cacheDir, final PhotoCallback cb) {
105         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + width + height);
111             downloader.download(getPhotoUrl(photo, width, height), out, new Downloader.DiskCallback() {",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,0019cee25261c36372c30a63556d7988d9fde95b,dd244f81188176cfd4e606a5cdb11c370fdb78ad,Respond to ime search button on keyboard,"@@ -7,7 +7,9 @@ import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
 import android.support.v4.app.FragmentTransaction;
 import android.support.v4.view.ViewPager;
+import android.view.KeyEvent;
 import android.view.View;
+import android.view.inputmethod.EditorInfo;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TextView;
@@ -29,6 +31,9 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     private int searchCount = 0;
 
     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
+    private EditText searchText;
+    private View searching;
+    private TextView searchTerm;
 
     /** Called when the activity is first created. */
     @Override
@@ -49,37 +54,26 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         final Resources res = getResources();
         flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
 
-        final View searching = findViewById(R.id.searching);
-        final TextView searchTerm = (TextView) findViewById(R.id.search_term);
+        searching = findViewById(R.id.searching);
+        searchTerm = (TextView) findViewById(R.id.search_term);
 
-        final EditText searchText = (EditText) findViewById(R.id.search_text);
-        final Button search = (Button) findViewById(R.id.search);
-        search.setOnClickListener(new View.OnClickListener() {
+        searchText = (EditText) findViewById(R.id.search_text);
+        searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
             @Override
-            public void onClick(View view) {
-                final String searchString = searchText.getText().toString();
-                searchText.getText().clear();
-
-                if ("""".equals(searchString.trim())) return;
-
-                final int currentSearch = ++searchCount;
-
-                searching.setVisibility(View.VISIBLE);
-                searchTerm.setText(getString(R.string.searching_for, searchString));
-
-                flickerApi.search(searchString, new Api.SearchCallback() {
-                    @Override
-                    public void onSearchCompleted(List<Photo> photos) {
-                        if (currentSearch != searchCount) return;
-
-                        Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
-                        searching.setVisibility(View.INVISIBLE);
-
-                        for (PhotoViewer viewer : photoViewers) {
-                            viewer.onPhotosUpdated(photos);
+            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
+                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
+                    executeSearch();
+                    return true;
                 }
+                return false;  //To change body of implemented methods use File | Settings | File Templates.
             }
         });
+
+        final Button search = (Button) findViewById(R.id.search);
+        search.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                executeSearch();
             }
         });
 
@@ -125,6 +119,33 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
     }
 
+    private void executeSearch() {
+        final String searchString = searchText.getText().toString();
+        searchText.getText().clear();
+
+        if ("""".equals(searchString.trim())) return;
+
+        final int currentSearch = ++searchCount;
+
+        searching.setVisibility(View.VISIBLE);
+        searchTerm.setText(getString(R.string.searching_for, searchString));
+
+        flickerApi.search(searchString, new Api.SearchCallback() {
+            @Override
+            public void onSearchCompleted(List<Photo> photos) {
+                if (currentSearch != searchCount) return;
+
+                Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
+                searching.setVisibility(View.INVISIBLE);
+
+                for (PhotoViewer viewer : photoViewers) {
+                    viewer.onPhotosUpdated(photos);
+                }
+            }
+        });
+
+    }
+
     @Override
     protected void onResume() {
         super.onResume();
","10 import android.view.KeyEvent;
12 import android.view.inputmethod.EditorInfo;
34     private EditText searchText;
35     private View searching;
36     private TextView searchTerm;
57         searching = findViewById(R.id.searching);
58         searchTerm = (TextView) findViewById(R.id.search_term);
59 
60         searchText = (EditText) findViewById(R.id.search_text);
61         searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
62             @Override
63             public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
64                 if (actionId == EditorInfo.IME_ACTION_SEARCH) {
65                     executeSearch();
66                     return true;
67                 }
68                 return false;  //To change body of implemented methods use File | Settings | File Templates.
69             }
70         });
76                 executeSearch();
122     private void executeSearch() {
123         final String searchString = searchText.getText().toString();
124         searchText.getText().clear();
125 
126         if ("""".equals(searchString.trim())) return;
127 
128         final int currentSearch = ++searchCount;
129 
130         searching.setVisibility(View.VISIBLE);
131         searchTerm.setText(getString(R.string.searching_for, searchString));
132 
133         flickerApi.search(searchString, new Api.SearchCallback() {
134             @Override
135             public void onSearchCompleted(List<Photo> photos) {
136                 if (currentSearch != searchCount) return;
137 
138                 Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
139                 searching.setVisibility(View.INVISIBLE);
140 
141                 for (PhotoViewer viewer : photoViewers) {
142                     viewer.onPhotosUpdated(photos);
143                 }
144             }
145         });
146 
147     }
148 
52         final View searching = findViewById(R.id.searching);
53         final TextView searchTerm = (TextView) findViewById(R.id.search_term);
55         final EditText searchText = (EditText) findViewById(R.id.search_text);
60                 final String searchString = searchText.getText().toString();
61                 searchText.getText().clear();
62 
63                 if ("""".equals(searchString.trim())) return;
64 
65                 final int currentSearch = ++searchCount;
66 
67                 searching.setVisibility(View.VISIBLE);
68                 searchTerm.setText(getString(R.string.searching_for, searchString));
69 
70                 flickerApi.search(searchString, new Api.SearchCallback() {
71                     @Override
72                     public void onSearchCompleted(List<Photo> photos) {
73                         if (currentSearch != searchCount) return;
74 
75                         Log.d(""SEARCH: completed, got "" + photos.size() + "" results"");
76                         searching.setVisibility(View.INVISIBLE);
77 
78                         for (PhotoViewer viewer : photoViewers) {
79                             viewer.onPhotosUpdated(photos);
80                         }
81                     }
82                 });",No
samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,a744e2eef3039df0c7b0976d970e368300c92021,0019cee25261c36372c30a63556d7988d9fde95b,Allow pending downloads to be cancelled,"@@ -5,6 +5,7 @@ import com.bumptech.flickr.api.Photo;
 import com.bumptech.photos.loader.path.BasePathLoader;
 
 import java.io.File;
+import java.util.concurrent.Future;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,6 +17,7 @@ import java.io.File;
 public class FlickrPathLoader extends BasePathLoader<Photo> {
     private final Api flickrApi;
     private final File cacheDir;
+    private Future current;
 
     public FlickrPathLoader(Api flickApi, File cacheDir) {
         this.flickrApi = flickApi;
@@ -24,11 +26,21 @@ public class FlickrPathLoader extends BasePathLoader<Photo> {
 
     @Override
     protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
-        flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
+        clear();
+        current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
                 cb.onPathReady(path);
             }
         });
     }
+
+    @Override
+    public void clear() {
+        super.clear();
+        if (current != null) {
+            current.cancel(false);
+            current = null;
+        }
+    }
 }
","8 import java.util.concurrent.Future;
20     private Future current;
29         clear();
30         current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
37 
38     @Override
39     public void clear() {
40         super.clear();
41         if (current != null) {
42             current.cancel(false);
43             current = null;
44         }
45     }
27         flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,a744e2eef3039df0c7b0976d970e368300c92021,0019cee25261c36372c30a63556d7988d9fde95b,Allow pending downloads to be cancelled,"@@ -13,6 +13,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Future;
 
 /**
  * Created with IntelliJ IDEA.
@@ -102,14 +103,15 @@ public class Api {
         });
     }
 
-    public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
+    public Future downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
         final String path = out.getPath();
+        Future result = null;
         if (downloadedFilesNames.contains(path)) {
             cb.onDownloadComplete(path);
         } else {
             Log.d(""API: missing photo, downloading"");
-            downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
+            result = downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
                 @Override
                 public void onDownloadReady(String path) {
                     downloadedFilesNames.add(path);
@@ -117,5 +119,6 @@ public class Api {
                 }
             });
        }
+        return result;
     }
 }
","16 import java.util.concurrent.Future;
106     public Future downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
109         Future result = null;
114             result = downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
122         return result;
105     public void downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
112             downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,a744e2eef3039df0c7b0976d970e368300c92021,0019cee25261c36372c30a63556d7988d9fde95b,Allow pending downloads to be cancelled,"@@ -15,6 +15,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 
 /**
  * Created with IntelliJ IDEA.
@@ -51,16 +52,16 @@ public class Downloader {
         mainHandler = new Handler();
     }
 
-    private void post(Runnable runnable) {
-        executor.execute(runnable);
+    private Future post(Runnable runnable) {
+        return executor.submit(runnable);
     }
 
     public void download(String url, MemoryCallback cb) {
         post(new MemoryDownloadWorker(url, cb));
     }
 
-    public void download(String url, File out, DiskCallback cb) {
-        post(new DiskDownloadWorker(url, out, cb));
+    public Future download(String url, File out, DiskCallback cb) {
+        return post(new DiskDownloadWorker(url, out, cb));
     }
 
     private class DiskDownloadWorker implements Runnable {
","18 import java.util.concurrent.Future;
55     private Future post(Runnable runnable) {
56         return executor.submit(runnable);
63     public Future download(String url, File out, DiskCallback cb) {
64         return post(new DiskDownloadWorker(url, out, cb));
54     private void post(Runnable runnable) {
55         executor.execute(runnable);
62     public void download(String url, File out, DiskCallback cb) {
63         post(new DiskDownloadWorker(url, out, cb));",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -18,7 +18,9 @@ import java.io.File;
 import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
@@ -107,7 +109,7 @@ public class ImageManager {
     private final Handler mainHandler;
     private final LruPhotoCache memoryCache;
     private final ImageResizer resizer;
-    private final Executor executor;
+    private final ExecutorService executor;
     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private final SizedBitmapCache bitmapCache;
     private final PhotoDiskCache diskCache;
@@ -166,7 +168,7 @@ public class ImageManager {
      * @param options The specified Options
      */
     public ImageManager(Context context, Options options) {
-        this(context, new HandlerExecutor(), options);
+        this(context, Executors.newSingleThreadExecutor(), options);
     }
 
     /**
@@ -176,11 +178,11 @@ public class ImageManager {
      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
      *                in Activities.
-     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
      *                 UI thread!
      * @param options The specified options
      */
-    public ImageManager(Context context, Executor executor, Options options) {
+    public ImageManager(Context context, ExecutorService executor, Options options) {
         this(context, executor, new Handler(), options);
     }
 
@@ -191,12 +193,12 @@ public class ImageManager {
      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
      *                in Activities.
-     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
      *                 UI thread!
      * @param mainHandler A Handler to the UI thread.
      * @param options The specified options
      */
-    public ImageManager(Context context, Executor executor, Handler mainHandler, Options options) {
+    public ImageManager(Context context, ExecutorService executor, Handler mainHandler, Options options) {
         this(context, getPhotoCacheDir(context), executor, mainHandler, options);
     }
 
@@ -209,12 +211,12 @@ public class ImageManager {
      *                in Activities.
      * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
      *                     already exist
-     * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
+     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
      *                 UI thread!
      * @param mainHandler A Handler to the UI thread.
      * @param options The specified options
      */
-    public ImageManager(Context context, File diskCacheDir, Executor executor, Handler mainHandler, Options options) {
+    public ImageManager(Context context, File diskCacheDir, ExecutorService executor, Handler mainHandler, Options options) {
         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
 
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
@@ -265,7 +267,7 @@ public class ImageManager {
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImage(final String path, final LoadedCallback cb){
+    public Future getImage(final String path, final LoadedCallback cb){
         final String key = getKey(path, 0, 0, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
@@ -284,7 +286,7 @@ public class ImageManager {
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
+    public Future getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
         final String key = getKey(path, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
@@ -303,7 +305,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
+    public Future getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -323,7 +325,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
+    public Future centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -343,7 +345,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
+    public Future fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -419,12 +421,12 @@ public class ImageManager {
         }
     }
 
-    private Object runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
-        final Object token = cb;
+    private Future runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
+        Future result = null;
         if (!returnFromCache(key, cb)) {
-            executor.execute(job);
+            result = executor.submit(job);
         }
-        return token;
+        return result;
     }
 
     private boolean returnFromCache(String key, LoadedCallback cb) {
","21 import java.util.concurrent.ExecutorService;
22 import java.util.concurrent.Executors;
23 import java.util.concurrent.Future;
112     private final ExecutorService executor;
171         this(context, Executors.newSingleThreadExecutor(), options);
181      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
185     public ImageManager(Context context, ExecutorService executor, Options options) {
196      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
201     public ImageManager(Context context, ExecutorService executor, Handler mainHandler, Options options) {
214      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
219     public ImageManager(Context context, File diskCacheDir, ExecutorService executor, Handler mainHandler, Options options) {
270     public Future getImage(final String path, final LoadedCallback cb){
289     public Future getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
308     public Future getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
328     public Future centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
348     public Future fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
424     private Future runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
425         Future result = null;
427             result = executor.submit(job);
429         return result;
21 import java.util.concurrent.Executor;
110     private final Executor executor;
169         this(context, new HandlerExecutor(), options);
179      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
183     public ImageManager(Context context, Executor executor, Options options) {
194      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
199     public ImageManager(Context context, Executor executor, Handler mainHandler, Options options) {
212      * @param executor The Executor used to perform resize operations and image loads. Must not execute Runnables on the
217     public ImageManager(Context context, File diskCacheDir, Executor executor, Handler mainHandler, Options options) {
268     public Object getImage(final String path, final LoadedCallback cb){
287     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
306     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
326     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
346     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
422     private Object runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
423         final Object token = cb;
425             executor.execute(job);
427         return token;",No
library\src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\photos\resize\loader\Approximate.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -5,8 +5,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+
+import java.util.concurrent.Future;
 
 /**
  * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
@@ -22,7 +24,7 @@ public class Approximate<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","9 import com.bumptech.photos.resize.LoadedCallback;
10 
11 import java.util.concurrent.Future;
27     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
8 import com.bumptech.photos.resize.LoadedCallback;
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\photos\resize\loader\AsIs.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -1,8 +1,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+
+import java.util.concurrent.Future;
 
 /**
  * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
@@ -19,7 +21,7 @@ public class AsIs<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImage(path, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","5 import com.bumptech.photos.resize.LoadedCallback;
6 
7 import java.util.concurrent.Future;
24     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
4 import com.bumptech.photos.resize.LoadedCallback;
22     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\photos\resize\loader\CenterCrop.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -5,8 +5,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+
+import java.util.concurrent.Future;
 
 /**
  * An ImageLoader implementation that loads and crops in image down to the given width and height.
@@ -20,7 +22,7 @@ public class CenterCrop<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.centerCrop(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","9 import com.bumptech.photos.resize.LoadedCallback;
10 
11 import java.util.concurrent.Future;
25     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
8 import com.bumptech.photos.resize.LoadedCallback;
23     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\photos\resize\loader\Exact.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -5,8 +5,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+
+import java.util.concurrent.Future;
 
 /**
  * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
@@ -23,7 +25,7 @@ public class Exact<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImageExact(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","9 import com.bumptech.photos.resize.LoadedCallback;
10 
11 import java.util.concurrent.Future;
28     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
8 import com.bumptech.photos.resize.LoadedCallback;
26     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\photos\resize\loader\FitCenter.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -5,8 +5,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.LoadedCallback;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.LoadedCallback;
+
+import java.util.concurrent.Future;
 
 /**
  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
@@ -21,7 +23,7 @@ public class FitCenter<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.fitCenter(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","9 import com.bumptech.photos.resize.LoadedCallback;
10 
11 import java.util.concurrent.Future;
26     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
8 import com.bumptech.photos.resize.LoadedCallback;
24     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,a744e2eef3039df0c7b0976d970e368300c92021,"Return futures from ImageManager and cancel tasks

Doesn't interrupt threads and cancel tasks being
run, but it does prevent queued tasks from being
run. This means less waiting during scrolling and
less cpu/memory useage.","@@ -1,8 +1,10 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.loader.image.BaseImageLoader;
+import com.bumptech.photos.resize.ImageManager;
+
+import java.util.concurrent.Future;
 
 /**
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
@@ -12,18 +14,18 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
 
     protected final ImageManager imageManager;
     private Bitmap acquired;
-    private Object loadToken;
+    private Future current;
 
     public ImageManagerLoader(ImageManager imageManager) {
         this.imageManager = imageManager;
     }
     @Override
     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
-        releaseAcquired();
-        loadToken = doFetchImage(path, width, height, cb);
+        clear();
+        current = doFetchImage(path, width, height, cb);
     }
 
-    protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
+    protected abstract Future doFetchImage(String path, int width, int height, ImageReadyCallback cb);
 
     @Override
     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {
@@ -39,6 +41,10 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
     @Override
     public void clear() {
         releaseAcquired();
+        if (current != null) {
+            current.cancel(false);
+            current = null;
+        }
     }
 
     private void releaseAcquired() {
","5 import com.bumptech.photos.resize.ImageManager;
6 
7 import java.util.concurrent.Future;
17     private Future current;
24         clear();
25         current = doFetchImage(path, width, height, cb);
28     protected abstract Future doFetchImage(String path, int width, int height, ImageReadyCallback cb);
44         if (current != null) {
45             current.cancel(false);
46             current = null;
47         }
4 import com.bumptech.photos.resize.ImageManager;
15     private Object loadToken;
22         releaseAcquired();
23         loadToken = doFetchImage(path, width, height, cb);
26     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);",No
library\src\com\bumptech\photos\resize\HandlerExecutor.java,,b12f95f1da31e9c6481c216b8b0a804c64424620,159a652a827b1d0f95e1ce6fe5a4a1f219ef16ed,remove unused HandlerExecutor,"@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.resize;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-
-import java.util.concurrent.Executor;
-
-/**
- * A simple Executor implemented using an Android {@link android.os.Handler}
- */
-public class HandlerExecutor implements Executor {
-    private final Handler worker;
-
-    /**
-     * Create a new executor with a new HandlerThread called ""HandlerExecutor""
-     */
-    public HandlerExecutor() {
-        HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
-        workerThread.start();
-        this.worker = new Handler(workerThread.getLooper());
-    }
-
-    /**
-     * Create a new executor that uses the given Handler's thread
-     *
-     * @param bgHandler The handler to post Runnables to
-     */
-    public HandlerExecutor(Handler bgHandler) {
-        this.worker = bgHandler;
-    }
-
-    @Override
-    public void execute(Runnable runnable) {
-        worker.postAtFrontOfQueue(runnable);
-    }
-}
","1 /*
2  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.resize;
6 
7 import android.os.Handler;
8 import android.os.HandlerThread;
9 
10 import java.util.concurrent.Executor;
11 
12 /**
13  * A simple Executor implemented using an Android {@link android.os.Handler}
14  */
15 public class HandlerExecutor implements Executor {
16     private final Handler worker;
17 
18     /**
19      * Create a new executor with a new HandlerThread called ""HandlerExecutor""
20      */
21     public HandlerExecutor() {
22         HandlerThread workerThread = new HandlerThread(""HandlerExecutor"");
23         workerThread.start();
24         this.worker = new Handler(workerThread.getLooper());
25     }
26 
27     /**
28      * Create a new executor that uses the given Handler's thread
29      *
30      * @param bgHandler The handler to post Runnables to
31      */
32     public HandlerExecutor(Handler bgHandler) {
33         this.worker = bgHandler;
34     }
35 
36     @Override
37     public void execute(Runnable runnable) {
38         worker.postAtFrontOfQueue(runnable);
39     }
40 }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -10,6 +10,8 @@ import android.graphics.BitmapFactory;
 import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.PhotoDiskCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
@@ -18,9 +20,6 @@ import java.io.File;
 import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
@@ -107,9 +106,9 @@ public class ImageManager {
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private final Handler mainHandler;
+    private final Handler bgHandler;
     private final LruPhotoCache memoryCache;
     private final ImageResizer resizer;
-    private final ExecutorService executor;
     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private final SizedBitmapCache bitmapCache;
     private final PhotoDiskCache diskCache;
@@ -158,18 +157,6 @@ public class ImageManager {
         this(context, new Options());
     }
 
-    /**
-     * Create an ImageManager using the given options. Note that this will create a single background thread to use
-     * to resize and load images from disk. Must be created in the UI thread!
-     *
-     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
-     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
-     *                in Activities.
-     * @param options The specified Options
-     */
-    public ImageManager(Context context, Options options) {
-        this(context, Executors.newSingleThreadExecutor(), options);
-    }
 
     /**
      * Create an ImageManager using the given options and that performs image loads and resize operations using the
@@ -178,12 +165,10 @@ public class ImageManager {
      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
      *                in Activities.
-     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
-     *                 UI thread!
      * @param options The specified options
      */
-    public ImageManager(Context context, ExecutorService executor, Options options) {
-        this(context, executor, new Handler(), options);
+    public ImageManager(Context context, Options options) {
+        this(context, new Handler(), options);
     }
 
     /**
@@ -193,13 +178,11 @@ public class ImageManager {
      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
      *                in Activities.
-     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
-     *                 UI thread!
      * @param mainHandler A Handler to the UI thread.
      * @param options The specified options
      */
-    public ImageManager(Context context, ExecutorService executor, Handler mainHandler, Options options) {
-        this(context, getPhotoCacheDir(context), executor, mainHandler, options);
+    public ImageManager(Context context, Handler mainHandler, Options options) {
+        this(context, getPhotoCacheDir(context), mainHandler, options);
     }
 
     /**
@@ -211,12 +194,10 @@ public class ImageManager {
      *                in Activities.
      * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
      *                     already exist
-     * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
-     *                 UI thread!
      * @param mainHandler A Handler to the UI thread.
      * @param options The specified options
      */
-    public ImageManager(Context context, File diskCacheDir, ExecutorService executor, Handler mainHandler, Options options) {
+    public ImageManager(Context context, File diskCacheDir, Handler mainHandler, Options options) {
         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
 
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
@@ -255,9 +236,12 @@ public class ImageManager {
             bitmapCache = null;
         }
 
+        HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
+        bgThread.start();
+        bgHandler = new Handler(bgThread.getLooper());
+
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
         this.mainHandler = mainHandler;
-        this.executor = executor;
     }
 
     /**
@@ -267,7 +251,7 @@ public class ImageManager {
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Future getImage(final String path, final LoadedCallback cb){
+    public Object getImage(final String path, final LoadedCallback cb){
         final String key = getKey(path, 0, 0, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
@@ -286,7 +270,7 @@ public class ImageManager {
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Future getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
+    public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
         final String key = getKey(path, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
@@ -305,7 +289,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Future getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
+    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -325,7 +309,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Future centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
+    public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -345,7 +329,7 @@ public class ImageManager {
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Future fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
+    public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
         final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
@@ -421,12 +405,18 @@ public class ImageManager {
         }
     }
 
-    private Future runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
-        Future result = null;
+    public void cancelTask(Object token) {
+        if (token != null)
+            bgHandler.removeCallbacksAndMessages(token);
+    }
+
+
+    private Object runJob(String key,final LoadedCallback cb, final ImageManagerJob job) {
+        final Object token = cb;
         if (!returnFromCache(key, cb)) {
-            result = executor.submit(job);
+            bgHandler.postAtTime(job, token, SystemClock.uptimeMillis());
         }
-        return result;
+        return token;
     }
 
     private boolean returnFromCache(String key, LoadedCallback cb) {
","13 import android.os.HandlerThread;
14 import android.os.SystemClock;
109     private final Handler bgHandler;
170     public ImageManager(Context context, Options options) {
171         this(context, new Handler(), options);
184     public ImageManager(Context context, Handler mainHandler, Options options) {
185         this(context, getPhotoCacheDir(context), mainHandler, options);
200     public ImageManager(Context context, File diskCacheDir, Handler mainHandler, Options options) {
239         HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
240         bgThread.start();
241         bgHandler = new Handler(bgThread.getLooper());
242 
254     public Object getImage(final String path, final LoadedCallback cb){
273     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
292     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
312     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
332     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
408     public void cancelTask(Object token) {
409         if (token != null)
410             bgHandler.removeCallbacksAndMessages(token);
412 
413 
414     private Object runJob(String key,final LoadedCallback cb, final ImageManagerJob job) {
415         final Object token = cb;
416         if (!returnFromCache(key, cb)) {
417             bgHandler.postAtTime(job, token, SystemClock.uptimeMillis());
418         }
419         return token;
21 import java.util.concurrent.ExecutorService;
22 import java.util.concurrent.Executors;
23 import java.util.concurrent.Future;
112     private final ExecutorService executor;
161     /**
162      * Create an ImageManager using the given options. Note that this will create a single background thread to use
163      * to resize and load images from disk. Must be created in the UI thread!
164      *
165      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
166      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
167      *                in Activities.
168      * @param options The specified Options
169      */
170     public ImageManager(Context context, Options options) {
171         this(context, Executors.newSingleThreadExecutor(), options);
172     }
181      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
182      *                 UI thread!
185     public ImageManager(Context context, ExecutorService executor, Options options) {
186         this(context, executor, new Handler(), options);
196      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
197      *                 UI thread!
201     public ImageManager(Context context, ExecutorService executor, Handler mainHandler, Options options) {
202         this(context, getPhotoCacheDir(context), executor, mainHandler, options);
214      * @param executor The ExecutorService used to perform resize operations and image loads. Must not execute Runnables on the
215      *                 UI thread!
219     public ImageManager(Context context, File diskCacheDir, ExecutorService executor, Handler mainHandler, Options options) {
260         this.executor = executor;
270     public Future getImage(final String path, final LoadedCallback cb){
289     public Future getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
308     public Future getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
328     public Future centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
348     public Future fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
424     private Future runJob(String key,final LoadedCallback cb, ImageManagerJob job) {
425         Future result = null;
426         if (!returnFromCache(key, cb)) {
427             result = executor.submit(job);
429         return result;",No
library\src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\photos\resize\loader\Approximate.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -8,8 +8,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
-import java.util.concurrent.Future;
-
 /**
  * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
@@ -24,7 +22,7 @@ public class Approximate<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
11 import java.util.concurrent.Future;
12 
27     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\photos\resize\loader\AsIs.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -4,8 +4,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
-import java.util.concurrent.Future;
-
 /**
  * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
  * when an image is roughly the same size as the view that will display it and you want to use some external process
@@ -21,7 +19,7 @@ public class AsIs<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImage(path, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","22     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
7 import java.util.concurrent.Future;
8 
24     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\photos\resize\loader\CenterCrop.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -8,8 +8,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
-import java.util.concurrent.Future;
-
 /**
  * An ImageLoader implementation that loads and crops in image down to the given width and height.
  *
@@ -22,7 +20,7 @@ public class CenterCrop<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.centerCrop(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","23     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
11 import java.util.concurrent.Future;
12 
25     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\photos\resize\loader\Exact.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -8,8 +8,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
-import java.util.concurrent.Future;
-
 /**
  * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
  * will exactly match the width and height of the view that will display it. Less expensive than other implementations,
@@ -25,7 +23,7 @@ public class Exact<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.getImageExact(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","26     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
11 import java.util.concurrent.Future;
12 
28     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\photos\resize\loader\FitCenter.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -8,8 +8,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
-import java.util.concurrent.Future;
-
 /**
  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
  * proportions
@@ -23,7 +21,7 @@ public class FitCenter<T> extends ImageManagerLoader<T> {
     }
 
     @Override
-    protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
+    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
         return imageManager.fitCenter(path, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
","24     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
11 import java.util.concurrent.Future;
12 
26     protected Future doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {",No
library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,05511c87dfa05b8b39448942c6cff2f508cbf305,b12f95f1da31e9c6481c216b8b0a804c64424620,"Revert to using a single background thread for IM

Using executor services adds locking overhead that
we really don't need.","@@ -4,8 +4,6 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.loader.image.BaseImageLoader;
 import com.bumptech.photos.resize.ImageManager;
 
-import java.util.concurrent.Future;
-
 /**
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
  * purposes.
@@ -14,7 +12,7 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
 
     protected final ImageManager imageManager;
     private Bitmap acquired;
-    private Future current;
+    private Object loadToken;
 
     public ImageManagerLoader(ImageManager imageManager) {
         this.imageManager = imageManager;
@@ -22,10 +20,10 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
     @Override
     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
         clear();
-        current = doFetchImage(path, width, height, cb);
+        loadToken = doFetchImage(path, width, height, cb);
     }
 
-    protected abstract Future doFetchImage(String path, int width, int height, ImageReadyCallback cb);
+    protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
 
     @Override
     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {
@@ -41,9 +39,9 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
     @Override
     public void clear() {
         releaseAcquired();
-        if (current != null) {
-            current.cancel(false);
-            current = null;
+        if (loadToken != null) {
+            imageManager.cancelTask(loadToken);
+            loadToken = null;
         }
     }
 
","15     private Object loadToken;
23         loadToken = doFetchImage(path, width, height, cb);
26     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
42         if (loadToken != null) {
43             imageManager.cancelTask(loadToken);
44             loadToken = null;
7 import java.util.concurrent.Future;
8 
17     private Future current;
25         current = doFetchImage(path, width, height, cb);
28     protected abstract Future doFetchImage(String path, int width, int height, ImageReadyCallback cb);
44         if (current != null) {
45             current.cancel(false);
46             current = null;",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,10d323b2075929551aaa7e274a8708c372d1a475,05511c87dfa05b8b39448942c6cff2f508cbf305,"Only touch bitmap cache on one thread

avoid extra locking","@@ -357,14 +357,20 @@ public class ImageManager {
      *
      * @param b The rejected Bitmap
      */
-    public void rejectBitmap(Bitmap b) {
+    public void rejectBitmap(final Bitmap b) {
         if (!isBitmapRecyclingEnabled) return;
 
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
         if (currentCount == null || currentCount == 0) {
             bitmapReferenceCounter.remove(b.hashCode());
+            //can only put or take from bitmap cache on one thread
+            bgHandler.post(new Runnable() {
+                @Override
+                public void run() {
                     bitmapCache.put(b);
                 }
+            });
+        }
     }
 
     /**
@@ -393,13 +399,19 @@ public class ImageManager {
      *
      * @param b The releasedBitmap
      */
-    public void releaseBitmap(Bitmap b) {
+    public void releaseBitmap(final Bitmap b) {
         if (!isBitmapRecyclingEnabled) return;
 
         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
         if (currentCount == 0) {
             bitmapReferenceCounter.remove(b.hashCode());
+            //can only put or take from bitmap cache on one thread
+            bgHandler.post(new Runnable() {
+                @Override
+                public void run() {
                     bitmapCache.put(b);
+                }
+            });
         } else {
             bitmapReferenceCounter.put(b.hashCode(), currentCount);
         }
","360     public void rejectBitmap(final Bitmap b) {
366             //can only put or take from bitmap cache on one thread
367             bgHandler.post(new Runnable() {
368                 @Override
369                 public void run() {
372             });
373         }
402     public void releaseBitmap(final Bitmap b) {
408             //can only put or take from bitmap cache on one thread
409             bgHandler.post(new Runnable() {
410                 @Override
411                 public void run() {
413                 }
414             });
360     public void rejectBitmap(Bitmap b) {
396     public void releaseBitmap(Bitmap b) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,b1cd831ea27a7d9425afece1ef4b8d141d71da3e,10d323b2075929551aaa7e274a8708c372d1a475,Don't check disk cache if not using disk cache,"@@ -458,26 +458,30 @@ public class ImageManager {
 
         @Override
         public void run() {
-            InputStream is1 = getFromDiskCache(key);
+            final boolean isInDiskCache;
+            InputStream is1 = null;
             InputStream is2 = null;
+            if (useDiskCache) {
+                is1 = getFromDiskCache(key);
+                is2 = null;
                 if (is1 != null) {
                     is2 = getFromDiskCache(key);
                 }
 
-            final boolean isInDiskCache = is1 != null && is2 != null;
-            Bitmap result = null;
-            try {
-                if (isInDiskCache && useDiskCache) {
+                isInDiskCache = is1 != null && is2 != null;
+            } else {
+                isInDiskCache = false;
+            }
+
+            final Bitmap result;
+            if (isInDiskCache) {
                 result = resizer.loadAsIs(is1, is2);
             } else {
                 result = resizeIfNotFound();
             }
-            } catch (Exception e) {
-                cb.onLoadFailed(e);
-            }
 
             if (result != null) {
-                if (!isInDiskCache && useDiskCache) {
+                if (useDiskCache && !isInDiskCache) {
                     putInDiskCache(key, result);
                 }
 
","461             final boolean isInDiskCache;
462             InputStream is1 = null;
464             if (useDiskCache) {
465                 is1 = getFromDiskCache(key);
466                 is2 = null;
471                 isInDiskCache = is1 != null && is2 != null;
472             } else {
473                 isInDiskCache = false;
474             }
475 
476             final Bitmap result;
477             if (isInDiskCache) {
484                 if (useDiskCache && !isInDiskCache) {
461             InputStream is1 = getFromDiskCache(key);
467             final boolean isInDiskCache = is1 != null && is2 != null;
468             Bitmap result = null;
469             try {
470                 if (isInDiskCache && useDiskCache) {
475             } catch (Exception e) {
476                 cb.onLoadFailed(e);
477             }
480                 if (!isInDiskCache && useDiskCache) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,c519db07159591f47d21e3a183540e755ea6c2af,b1cd831ea27a7d9425afece1ef4b8d141d71da3e,Catch resize exception and inform corresponding cb,"@@ -473,12 +473,16 @@ public class ImageManager {
                 isInDiskCache = false;
             }
 
-            final Bitmap result;
+            Bitmap result = null;
+            try {
                 if (isInDiskCache) {
                     result = resizer.loadAsIs(is1, is2);
                 } else {
                     result = resizeIfNotFound();
                 }
+            } catch (Exception e) {
+                cb.onLoadFailed(e);
+            }
 
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
","476             Bitmap result = null;
477             try {
483             } catch (Exception e) {
484                 cb.onLoadFailed(e);
485             }
476             final Bitmap result;",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,1d5dd90f4a8f85ee34fe4249b94018139e57de95,c519db07159591f47d21e3a183540e755ea6c2af,"Increase odds of recycled bitmaps being available

Occasionally loads seemd to be happening before
the corresponding loader's release of its previous
bitmaps which lead to lots more allocing then
we expected","@@ -406,7 +406,7 @@ public class ImageManager {
         if (currentCount == 0) {
             bitmapReferenceCounter.remove(b.hashCode());
             //can only put or take from bitmap cache on one thread
-            bgHandler.post(new Runnable() {
+            bgHandler.postAtFrontOfQueue(new Runnable() {
                 @Override
                 public void run() {
                     bitmapCache.put(b);
","409             bgHandler.postAtFrontOfQueue(new Runnable() {
409             bgHandler.post(new Runnable() {",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,c716627a7b36e6815b815354abbc01cbd61a68bd,1d5dd90f4a8f85ee34fe4249b94018139e57de95,"Fix an Option only available in 10+

We support 9+...","@@ -347,6 +347,7 @@ public class ImageResizer {
         to.inInputShareable = from.inInputShareable;
         if (CAN_RECYCLE)
             to.inMutable = from.inMutable;
+        if (Build.VERSION.SDK_INT >= 10)
             to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
         to.inPreferredConfig = from.inPreferredConfig;
         to.inPurgeable = from.inPurgeable;
",350         if (Build.VERSION.SDK_INT >= 10),No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,55ad7efd3add586976557a7be0bcb9cfd431c13c,c716627a7b36e6815b815354abbc01cbd61a68bd,"Try to resize if disk cache load fails

In case is corrupt for whatever reason we don't
crash or give up entirely","@@ -474,15 +474,22 @@ public class ImageManager {
             }
 
             Bitmap result = null;
-            try {
             if (isInDiskCache) {
+                try {
                     result = resizer.loadAsIs(is1, is2);
-                } else {
-                    result = resizeIfNotFound();
+                } catch (Exception e) {
+                    e.printStackTrace();
                 }
+            }
+
+            if (result == null) {
+                try {
+                    result = resizeIfNotFound();
                 } catch (Exception e) {
+                    e.printStackTrace();
                     cb.onLoadFailed(e);
                 }
+            }
 
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
","478                 try {
481                     e.printStackTrace();
482                 }
483             }
484 
485             if (result == null) {
486                 try {
487                     result = resizeIfNotFound();
488                 } catch (Exception e) {
489                     e.printStackTrace();
492             }
477             try {
480                 } else {
481                     result = resizeIfNotFound();
482                 }",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,9630d3257254d0fbb4750b51aa6bcc78181d521e,55ad7efd3add586976557a7be0bcb9cfd431c13c,Reduce the default memory cache size,"@@ -15,7 +15,7 @@ import android.support.v4.util.LruCache;
  * @see android.support.v4.util.LruCache
  */
 public class LruPhotoCache{
-    private static final float SIZE_RATIO = 1f/8f;
+    private static final float SIZE_RATIO = 1f/10f;
     private final PhotoCache photoCache;
     private PhotoRemovedListener photoRemovedListener;
 
","18     private static final float SIZE_RATIO = 1f/10f;
18     private static final float SIZE_RATIO = 1f/8f;",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,21bd36fa07ee82704a3d7a8788ba2157df855efe,9630d3257254d0fbb4750b51aa6bcc78181d521e,"Actually use options passed to image resizer

Accidently were always using default b/c of a 
naming collision","@@ -134,7 +134,7 @@ public class ImageResizer {
         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
         int sampleSize = Math.min(originalHeight / height, originalWidth / width);
 
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
+        final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
         Bitmap result = decodeStream(path, decodeBitmapOptions);
@@ -213,7 +213,7 @@ public class ImageResizer {
      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
      */
     private Bitmap load(String path, Bitmap recycle) {
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
+        final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
         final Bitmap result = decodeStream(path, decodeBitmapOptions);
         return result == null ? null : orientImage(path, result);
     }
@@ -231,7 +231,7 @@ public class ImageResizer {
      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
      */
     private Bitmap load(InputStream is, Bitmap recycle){
-        final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
+        final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
         return decodeStream(is, decodeBitmapOptions);
     }
 
@@ -242,7 +242,7 @@ public class ImageResizer {
      * @return an array containing the dimensions of the image in the form {width, height}
      */
     private int[] getDimensions(String path) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
+        final BitmapFactory.Options decodeBoundsOptions = getOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
         decodeStream(path, decodeBoundsOptions);
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
@@ -255,7 +255,7 @@ public class ImageResizer {
      * @return an array containing the dimensions of the image in the form {width, height}
      */
     private int[] getDimension(InputStream is) {
-        final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
+        final BitmapFactory.Options decodeBoundsOptions = getOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
         decodeStream(is, decodeBoundsOptions);
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
@@ -300,7 +300,11 @@ public class ImageResizer {
         return result;
     }
 
-    private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {
+    private BitmapFactory.Options getOptions() {
+        return getOptions(null);
+    }
+
+    private BitmapFactory.Options getOptions(Bitmap recycle) {
         BitmapFactory.Options result = new BitmapFactory.Options();
         copyOptions(defaultOptions, result);
         if (CAN_RECYCLE)
","137         final BitmapFactory.Options decodeBitmapOptions = getOptions();
216         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
234         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
245         final BitmapFactory.Options decodeBoundsOptions = getOptions();
258         final BitmapFactory.Options decodeBoundsOptions = getOptions();
303     private BitmapFactory.Options getOptions() {
304         return getOptions(null);
305     }
306 
307     private BitmapFactory.Options getOptions(Bitmap recycle) {
137         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions();
216         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
234         final BitmapFactory.Options decodeBitmapOptions = getDefaultOptions(recycle);
245         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
258         final BitmapFactory.Options decodeBoundsOptions = getDefaultOptions();
303     private BitmapFactory.Options getDefaultOptions(Bitmap recycle) {",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,713a2a87a8117cb5181c3ab95380555e2d65aa0b,21bd36fa07ee82704a3d7a8788ba2157df855efe,"Fix NPEs if a load fails to return an image for
whatever reason","@@ -84,6 +84,8 @@ public class ImageResizer {
     public Bitmap resizeCenterCrop(final String path, final int width, final int height){
         final Bitmap streamed = loadApproximate(path, width, height);
 
+        if (streamed == null) return null;
+
         if (streamed.getWidth() == width && streamed.getHeight() == height) {
             return streamed;
         }
@@ -103,6 +105,9 @@ public class ImageResizer {
      */
     public Bitmap fitInSpace(final String path, final int width, final int height){
         final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
+
+        if (streamed == null) return null;
+
         return fitInSpace(streamed, width, height);
     }
 
","87         if (streamed == null) return null;
88 
108 
109         if (streamed == null) return null;
110 ",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,1060a63023f1e07fd579d0edd94256560f0eab7d,713a2a87a8117cb5181c3ab95380555e2d65aa0b,"Use integer hash rather than string for image keys

String concatenation is a lot slower.","@@ -15,6 +15,7 @@ import android.os.SystemClock;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.PhotoDiskCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
+import com.bumptech.photos.util.Util;
 
 import java.io.File;
 import java.io.InputStream;
@@ -224,7 +225,7 @@ public class ImageManager {
             if (memoryCache != null) {
                 memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
                     @Override
-                    public void onPhotoRemoved(String key, Bitmap bitmap) {
+                    public void onPhotoRemoved(Integer key, Bitmap bitmap) {
                         releaseBitmap(bitmap);
                     }
                 });
@@ -252,7 +253,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImage(final String path, final LoadedCallback cb){
-        final String key = getKey(path, 0, 0, ResizeType.AS_IS);
+        final int key = getKey(path, 0, 0, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
             protected Bitmap resizeIfNotFound() {
@@ -271,7 +272,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
-        final String key = getKey(path, width, height, ResizeType.AS_IS);
+        final int key = getKey(path, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
             protected Bitmap resizeIfNotFound() {
@@ -290,7 +291,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
-        final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
+        final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() {
@@ -310,7 +311,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
-        final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
+        final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() {
@@ -330,7 +331,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
-        final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
+        final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() {
@@ -423,7 +424,7 @@ public class ImageManager {
     }
 
 
-    private Object runJob(String key,final LoadedCallback cb, final ImageManagerJob job) {
+    private Object runJob(int key,final LoadedCallback cb, final ImageManagerJob job) {
         final Object token = cb;
         if (!returnFromCache(key, cb)) {
             bgHandler.postAtTime(job, token, SystemClock.uptimeMillis());
@@ -431,26 +432,25 @@ public class ImageManager {
         return token;
     }
 
-    private boolean returnFromCache(String key, LoadedCallback cb) {
-        boolean found = false;
+    private boolean returnFromCache(int key, LoadedCallback cb) {
         Bitmap inCache = getFromMemoryCache(key);
-        if (inCache != null) {
-            found = true;
+        boolean found = inCache != null;
+        if (found) {
             cb.onLoadCompleted(inCache);
         }
         return found;
     }
 
     private abstract class ImageManagerJob implements Runnable {
-        private final String key;
+        private final int key;
         private final LoadedCallback cb;
         private final boolean useDiskCache;
 
-        public ImageManagerJob(String key, LoadedCallback cb) {
+        public ImageManagerJob(int key, LoadedCallback cb) {
             this(key, cb, true);
         }
 
-        public ImageManagerJob(String key, LoadedCallback cb, boolean useDiskCache) {
+        public ImageManagerJob(int key, LoadedCallback cb, boolean useDiskCache) {
             this.key = key;
             this.cb = cb;
             this.useDiskCache = useDiskCache;
@@ -513,7 +513,7 @@ public class ImageManager {
     }
 
 
-    private InputStream getFromDiskCache(String key) {
+    private InputStream getFromDiskCache(int key) {
         InputStream result = null;
         if (diskCache != null) {
             result = diskCache.get(key);
@@ -521,13 +521,13 @@ public class ImageManager {
         return result;
     }
 
-    private void putInDiskCache(String key, Bitmap value) {
+    private void putInDiskCache(int key, Bitmap value) {
         if (diskCache != null) {
             diskCache.put(key, value);
         }
     }
 
-    private Bitmap getFromMemoryCache(String key) {
+    private Bitmap getFromMemoryCache(int key) {
         Bitmap result = null;
         if (memoryCache != null) {
             result = memoryCache.get(key);
@@ -535,13 +535,13 @@ public class ImageManager {
         return result;
     }
 
-    private void putInMemoryCache(String key, Bitmap bitmap) {
+    private void putInMemoryCache(int key, Bitmap bitmap) {
         if (memoryCache != null) {
             memoryCache.put(key, bitmap);
         }
     }
 
-    private static String getKey(String path, int width, int height, ResizeType type){
-        return path + width + ""_"" + height + type.name();
+    private static int getKey(String path, int width, int height, ResizeType type){
+        return Util.hash(path.hashCode(), width, height, type.hashCode());
     }
 }
","18 import com.bumptech.photos.util.Util;
228                     public void onPhotoRemoved(Integer key, Bitmap bitmap) {
256         final int key = getKey(path, 0, 0, ResizeType.AS_IS);
275         final int key = getKey(path, width, height, ResizeType.AS_IS);
294         final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
314         final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
334         final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
427     private Object runJob(int key,final LoadedCallback cb, final ImageManagerJob job) {
435     private boolean returnFromCache(int key, LoadedCallback cb) {
437         boolean found = inCache != null;
438         if (found) {
445         private final int key;
449         public ImageManagerJob(int key, LoadedCallback cb) {
453         public ImageManagerJob(int key, LoadedCallback cb, boolean useDiskCache) {
516     private InputStream getFromDiskCache(int key) {
524     private void putInDiskCache(int key, Bitmap value) {
530     private Bitmap getFromMemoryCache(int key) {
538     private void putInMemoryCache(int key, Bitmap bitmap) {
544     private static int getKey(String path, int width, int height, ResizeType type){
545         return Util.hash(path.hashCode(), width, height, type.hashCode());
227                     public void onPhotoRemoved(String key, Bitmap bitmap) {
255         final String key = getKey(path, 0, 0, ResizeType.AS_IS);
274         final String key = getKey(path, width, height, ResizeType.AS_IS);
293         final String key = getKey(path, width, height, ResizeType.APPROXIMATE);
313         final String key = getKey(path, width, height, ResizeType.CENTER_CROP);
333         final String key = getKey(path, width, height, ResizeType.FIT_CENTER);
426     private Object runJob(String key,final LoadedCallback cb, final ImageManagerJob job) {
434     private boolean returnFromCache(String key, LoadedCallback cb) {
435         boolean found = false;
437         if (inCache != null) {
438             found = true;
445         private final String key;
449         public ImageManagerJob(String key, LoadedCallback cb) {
453         public ImageManagerJob(String key, LoadedCallback cb, boolean useDiskCache) {
516     private InputStream getFromDiskCache(String key) {
524     private void putInDiskCache(String key, Bitmap value) {
530     private Bitmap getFromMemoryCache(String key) {
538     private void putInMemoryCache(String key, Bitmap bitmap) {
544     private static String getKey(String path, int width, int height, ResizeType type){
545         return path + width + ""_"" + height + type.name();",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,1060a63023f1e07fd579d0edd94256560f0eab7d,713a2a87a8117cb5181c3ab95380555e2d65aa0b,"Use integer hash rather than string for image keys

String concatenation is a lot slower.","@@ -20,7 +20,7 @@ public class LruPhotoCache{
     private PhotoRemovedListener photoRemovedListener;
 
     public interface PhotoRemovedListener {
-        public void onPhotoRemoved(String key, Bitmap bitmap);
+        public void onPhotoRemoved(Integer key, Bitmap bitmap);
     }
 
     /*
@@ -31,7 +31,7 @@ public class LruPhotoCache{
         return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
     }
 
-    private class PhotoCache extends LruCache<String, Bitmap> {
+    private class PhotoCache extends LruCache<Integer, Bitmap> {
 
         private PhotoCache(int maxSize) {
             super(maxSize);
@@ -39,13 +39,13 @@ public class LruPhotoCache{
 
 
         @Override
-        protected int sizeOf(String key, Bitmap value) {
+        protected int sizeOf(Integer key, Bitmap value) {
             //get the size, getByteCount() is API 12+...
             return value.getHeight() * value.getRowBytes();
         }
 
         @Override
-        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
+        protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
             super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
             if (photoRemovedListener != null) {
                 photoRemovedListener.onPhotoRemoved(key, oldValue);
@@ -61,15 +61,15 @@ public class LruPhotoCache{
         this.photoRemovedListener = listener;
     }
 
-    public void put(String key, Bitmap bitmap) {
+    public void put(int key, Bitmap bitmap) {
         photoCache.put(key, bitmap);
     }
 
-    public Bitmap get(String key) {
+    public Bitmap get(int key) {
         return photoCache.get(key);
     }
 
-    public void remove(String key){
+    public void remove(int key){
         photoCache.remove(key);
     }
 
","23         public void onPhotoRemoved(Integer key, Bitmap bitmap);
34     private class PhotoCache extends LruCache<Integer, Bitmap> {
42         protected int sizeOf(Integer key, Bitmap value) {
48         protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
64     public void put(int key, Bitmap bitmap) {
68     public Bitmap get(int key) {
72     public void remove(int key){
23         public void onPhotoRemoved(String key, Bitmap bitmap);
34     private class PhotoCache extends LruCache<String, Bitmap> {
42         protected int sizeOf(String key, Bitmap value) {
48         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
64     public void put(String key, Bitmap bitmap) {
68     public Bitmap get(String key) {
72     public void remove(String key){",No
library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,1060a63023f1e07fd579d0edd94256560f0eab7d,713a2a87a8117cb5181c3ab95380555e2d65aa0b,"Use integer hash rather than string for image keys

String concatenation is a lot slower.","@@ -52,14 +52,14 @@ public class PhotoDiskCache {
         }
     }
 
-    public void put(final String key, final Bitmap bitmap) {
+    public void put(final int key, final Bitmap bitmap) {
         if (cache.isClosed()) {
             Log.d(""DLRU: put while cache is closed!"");
             return;
         }
 
         if (bitmap == null) return;
-        final String safeKey = sha1Hash(key);
+        final String safeKey = sha1Hash(String.valueOf(key));
 
         DiskLruCache.Editor edit = null;
         OutputStream out = null;
@@ -93,13 +93,13 @@ public class PhotoDiskCache {
         }
     }
 
-    public InputStream get(final String key) {
+    public InputStream get(final int key) {
         if (cache.isClosed()) {
             Log.d(""DLRU: get while cache is closed key="" + key);
             return null;
         }
         //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
-        final String safeKey = sha1Hash(key);
+        final String safeKey = sha1Hash(String.valueOf(key));
         InputStream result = null;
         try {
             DiskLruCache.Snapshot snapshot = cache.get(safeKey);
","55     public void put(final int key, final Bitmap bitmap) {
62         final String safeKey = sha1Hash(String.valueOf(key));
96     public InputStream get(final int key) {
102         final String safeKey = sha1Hash(String.valueOf(key));
55     public void put(final String key, final Bitmap bitmap) {
62         final String safeKey = sha1Hash(key);
96     public InputStream get(final String key) {
102         final String safeKey = sha1Hash(key);",No
,library\src\com\bumptech\photos\util\Util.java,1060a63023f1e07fd579d0edd94256560f0eab7d,713a2a87a8117cb5181c3ab95380555e2d65aa0b,"Use integer hash rather than string for image keys

String concatenation is a lot slower.","@@ -0,0 +1,20 @@
+package com.bumptech.photos.util;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/20/13
+ * Time: 9:43 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Util {
+    private static final int PRIME = 31;
+
+    public static int hash(int... hashes) {
+        int result = 1;
+        for (int hash : hashes) {
+            result *= PRIME * hash;
+        }
+        return result;
+    }
+}
","1 package com.bumptech.photos.util;
2 
3 /**
4  * Created with IntelliJ IDEA.
5  * User: sam
6  * Date: 1/20/13
7  * Time: 9:43 PM
8  * To change this template use File | Settings | File Templates.
9  */
10 public class Util {
11     private static final int PRIME = 31;
12 
13     public static int hash(int... hashes) {
14         int result = 1;
15         for (int hash : hashes) {
16             result *= PRIME * hash;
17         }
18         return result;
19     }
20 }",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,1e9842ecc1a712a80f8ef98238adf2fa295d612a,1060a63023f1e07fd579d0edd94256560f0eab7d,Remove a noisy debug log line,"@@ -181,8 +181,8 @@ public class ImagePresenter<T> {
 
             width = imageView.getWidth();
             height = imageView.getHeight();
-            if (pendingLoad != null)
-                Log.d(""IP: getDimens width="" + width + "" height="" + height);
+//            if (pendingLoad != null)
+//                Log.d(""IP: getDimens width="" + width + "" height="" + height);
             if (width != 0 && height != 0) {
                 postPendingLoad();
             }
","184 //            if (pendingLoad != null)
185 //                Log.d(""IP: getDimens width="" + width + "" height="" + height);
184             if (pendingLoad != null)
185                 Log.d(""IP: getDimens width="" + width + "" height="" + height);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,37a81f81e509bacd8ecc1624ea7bfbe9ac89246b,1e9842ecc1a712a80f8ef98238adf2fa295d612a,Fix key for AS_IS images being 0...,"@@ -253,7 +253,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImage(final String path, final LoadedCallback cb){
-        final int key = getKey(path, 0, 0, ResizeType.AS_IS);
+        final int key = getKey(path, -1, -1, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
             protected Bitmap resizeIfNotFound() {
","256         final int key = getKey(path, -1, -1, ResizeType.AS_IS);
256         final int key = getKey(path, 0, 0, ResizeType.AS_IS);",No
library\AndroidManifest.xml,library\AndroidManifest.xml,a73208437d43a27ac88fe3ebece441b378d15916,37a81f81e509bacd8ecc1624ea7bfbe9ac89246b,decrease minSdkVersion,"@@ -12,5 +12,5 @@
       </intent-filter>
     </activity>
   </application>
-  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
+  <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
 </manifest>
","15   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
15   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />",No
library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,aa29e222d0aecb49f6f675bc1fd8f44efbfe5849,a73208437d43a27ac88fe3ebece441b378d15916,"Be more paranoid about catching disk cache excepts

Some weird race conditions around image saving
and cache opening/closing.","@@ -72,8 +72,12 @@ public class PhotoDiskCache {
             edit = cache.edit(safeKey);
             out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
             bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
+            if (cache.isClosed()) {
+                edit.abort();
+            } else {
                 edit.commit();
-        } catch (IOException e) {
+            }
+        } catch (Exception e) {
             if (edit != null) {
                 try {
                     edit.abort();
","75             if (cache.isClosed()) {
76                 edit.abort();
77             } else {
79             }
80         } catch (Exception e) {
76         } catch (IOException e) {",No
library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,53601580ae7938c212373b8513f60d745c70fbb4,aa29e222d0aecb49f6f675bc1fd8f44efbfe5849,"Abort can throw same illegal state as commit

So don't try to abort if disk cache is closed and
catch all errors in error handeling code so we
don't cause a crash trying to abort a failed 
commit","@@ -72,16 +72,14 @@ public class PhotoDiskCache {
             edit = cache.edit(safeKey);
             out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
             bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
-            if (cache.isClosed()) {
-                edit.abort();
-            } else {
+            if (!cache.isClosed()) {
                 edit.commit();
             }
         } catch (Exception e) {
             if (edit != null) {
                 try {
                     edit.abort();
-                } catch (IOException e1) {
+                } catch (Exception e1) {
                     e1.printStackTrace();
                 }
             }
","75             if (!cache.isClosed()) {
82                 } catch (Exception e1) {
75             if (cache.isClosed()) {
76                 edit.abort();
77             } else {
84                 } catch (IOException e1) {",No
library\libs\disklrucache-1.2.1.jar,library\libs\disklrucache-1.2.1.jar,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,53601580ae7938c212373b8513f60d745c70fbb4,"Replace library disk cache with our own 

This is unfortunate, but has to be done because
the disklrucache jar is just enough to put us over
the edge so we run into linear alloc errors on
older phones. Hopefully this can be reverted in 
the future.","Binary files a/library/libs/disklrucache-1.2.1.jar and /dev/null differ
",,No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,53601580ae7938c212373b8513f60d745c70fbb4,"Replace library disk cache with our own 

This is unfortunate, but has to be done because
the disklrucache jar is just enough to put us over
the edge so we run into linear alloc errors on
older phones. Hopefully this can be reverted in 
the future.","@@ -13,12 +13,11 @@ import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.SystemClock;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
-import com.bumptech.photos.resize.cache.PhotoDiskCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
+import com.bumptech.photos.resize.cache.disk.DiskCache;
 import com.bumptech.photos.util.Util;
 
 import java.io.File;
-import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -112,7 +111,7 @@ public class ImageManager {
     private final ImageResizer resizer;
     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private final SizedBitmapCache bitmapCache;
-    private final PhotoDiskCache diskCache;
+    private final DiskCache diskCache;
     private final boolean isBitmapRecyclingEnabled;
 
     private enum ResizeType {
@@ -199,6 +198,10 @@ public class ImageManager {
      * @param options The specified options
      */
     public ImageManager(Context context, File diskCacheDir, Handler mainHandler, Options options) {
+        HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
+        bgThread.start();
+        bgHandler = new Handler(bgThread.getLooper());
+
         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
 
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
@@ -212,7 +215,7 @@ public class ImageManager {
         if (diskCacheDir == null || !options.useDiskCache) {
             diskCache = null;
         } else {
-            diskCache = new PhotoDiskCache(diskCacheDir, options.maxDiskCacheSize, options.appVersion);
+            diskCache = DiskCache.get(diskCacheDir, options.maxDiskCacheSize);
         }
 
         if (!options.useMemoryCache) {
@@ -237,9 +240,6 @@ public class ImageManager {
             bitmapCache = null;
         }
 
-        HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
-        bgThread.start();
-        bgHandler = new Handler(bgThread.getLooper());
 
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
         this.mainHandler = mainHandler;
@@ -342,13 +342,23 @@ public class ImageManager {
 
     public void pause() {
         if (diskCache != null) {
-            diskCache.stop();
+            bgHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    diskCache.close();
+                }
+            });
         }
     }
 
     public void resume() {
         if (diskCache != null) {
-            diskCache.start();
+            bgHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    diskCache.open();
+                }
+            });
         }
     }
 
@@ -459,24 +469,17 @@ public class ImageManager {
         @Override
         public void run() {
             final boolean isInDiskCache;
-            InputStream is1 = null;
-            InputStream is2 = null;
+            String path = null;
             if (useDiskCache) {
-                is1 = getFromDiskCache(key);
-                is2 = null;
-                if (is1 != null) {
-                    is2 = getFromDiskCache(key);
+                path = getFromDiskCache(key);
             }
 
-                isInDiskCache = is1 != null && is2 != null;
-            } else {
-                isInDiskCache = false;
-            }
+            isInDiskCache = path != null;
 
             Bitmap result = null;
             if (isInDiskCache) {
                 try {
-                    result = resizer.loadAsIs(is1, is2);
+                    result = resizer.loadAsIs(path);//resizer.loadAsIs(is1, is2);
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
@@ -513,17 +516,17 @@ public class ImageManager {
     }
 
 
-    private InputStream getFromDiskCache(int key) {
-        InputStream result = null;
+    private String getFromDiskCache(int key) {
+        String result = null;
         if (diskCache != null) {
-            result = diskCache.get(key);
+            result = diskCache.get(String.valueOf(key));
         }
         return result;
     }
 
     private void putInDiskCache(int key, Bitmap value) {
         if (diskCache != null) {
-            diskCache.put(key, value);
+            diskCache.put(String.valueOf(key), value);
         }
     }
 
","17 import com.bumptech.photos.resize.cache.disk.DiskCache;
114     private final DiskCache diskCache;
201         HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
202         bgThread.start();
203         bgHandler = new Handler(bgThread.getLooper());
204 
218             diskCache = DiskCache.get(diskCacheDir, options.maxDiskCacheSize);
345             bgHandler.post(new Runnable() {
346                 @Override
347                 public void run() {
348                     diskCache.close();
349                 }
350             });
356             bgHandler.post(new Runnable() {
357                 @Override
358                 public void run() {
359                     diskCache.open();
360                 }
361             });
472             String path = null;
474                 path = getFromDiskCache(key);
477             isInDiskCache = path != null;
482                     result = resizer.loadAsIs(path);//resizer.loadAsIs(is1, is2);
519     private String getFromDiskCache(int key) {
520         String result = null;
522             result = diskCache.get(String.valueOf(key));
529             diskCache.put(String.valueOf(key), value);
16 import com.bumptech.photos.resize.cache.PhotoDiskCache;
21 import java.io.InputStream;
115     private final PhotoDiskCache diskCache;
215             diskCache = new PhotoDiskCache(diskCacheDir, options.maxDiskCacheSize, options.appVersion);
240         HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
241         bgThread.start();
242         bgHandler = new Handler(bgThread.getLooper());
345             diskCache.stop();
351             diskCache.start();
462             InputStream is1 = null;
463             InputStream is2 = null;
465                 is1 = getFromDiskCache(key);
466                 is2 = null;
467                 if (is1 != null) {
468                     is2 = getFromDiskCache(key);
471                 isInDiskCache = is1 != null && is2 != null;
472             } else {
473                 isInDiskCache = false;
474             }
479                     result = resizer.loadAsIs(is1, is2);
516     private InputStream getFromDiskCache(int key) {
517         InputStream result = null;
519             result = diskCache.get(key);
526             diskCache.put(key, value);",No
library\src\com\bumptech\photos\resize\cache\PhotoDiskCache.java,,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,53601580ae7938c212373b8513f60d745c70fbb4,"Replace library disk cache with our own 

This is unfortunate, but has to be done because
the disklrucache jar is just enough to put us over
the edge so we run into linear alloc errors on
older phones. Hopefully this can be reverted in 
the future.","@@ -1,140 +0,0 @@
-package com.bumptech.photos.resize.cache;
-
-import android.graphics.Bitmap;
-import com.bumptech.photos.util.Log;
-import com.jakewharton.DiskLruCache;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-/**
- * A thin wrapper around Jake Wharton's disk cache library.
- *
- * @see com.jakewharton.DiskLruCache
- */
-public class PhotoDiskCache {
-    private final static int VALUE_COUNT = 1; //values per cache entry
-    private DiskLruCache cache;
-    private final File directory;
-    private final long maxSize;
-    private final int appVersion;
-
-    public PhotoDiskCache(File directory, long maxSize, int appVersion) {
-        this.directory = directory;
-        this.maxSize = maxSize;
-        this.appVersion = appVersion;
-        start();
-    }
-
-    public void start() {
-        if (cache != null && !cache.isClosed()) return;
-
-        try {
-            cache = DiskLruCache.open(directory, appVersion, VALUE_COUNT, maxSize);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void stop() {
-        if (cache == null) return;
-
-        try {
-            cache.close();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void put(final int key, final Bitmap bitmap) {
-        if (cache.isClosed()) {
-            Log.d(""DLRU: put while cache is closed!"");
-            return;
-        }
-
-        if (bitmap == null) return;
-        final String safeKey = sha1Hash(String.valueOf(key));
-
-        DiskLruCache.Editor edit = null;
-        OutputStream out = null;
-        try {
-            DiskLruCache.Snapshot snapshot = cache.get(safeKey);
-            if (snapshot != null) {
-                Log.d(""DLRU: not putting, already exists key="" + key);
-                return;
-            }
-            edit = cache.edit(safeKey);
-            out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
-            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
-            if (!cache.isClosed()) {
-                edit.commit();
-            }
-        } catch (Exception e) {
-            if (edit != null) {
-                try {
-                    edit.abort();
-                } catch (Exception e1) {
-                    e1.printStackTrace();
-                }
-            }
-            e.printStackTrace();
-        } finally {
-            if (out != null) {
-                try {
-                    out.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    public InputStream get(final int key) {
-        if (cache.isClosed()) {
-            Log.d(""DLRU: get while cache is closed key="" + key);
-            return null;
-        }
-        //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
-        final String safeKey = sha1Hash(String.valueOf(key));
-        InputStream result = null;
-        try {
-            DiskLruCache.Snapshot snapshot = cache.get(safeKey);
-
-            if (snapshot != null) {
-                result = snapshot.getInputStream(VALUE_COUNT - 1);
-            } else {
-                Log.d(""DLRU: snapshot not found key="" + key);
-            }
-
-        } catch (IOException e) {
-            e.printStackTrace();
-            try {
-                cache.remove(safeKey);
-            } catch (IOException e1) {
-                Log.d(""DLRU: error removing bitmap key="" + key);
-                e1.printStackTrace();
-            }
-        }
-
-        return result;
-    }
-
-    private static String sha1Hash(String toHash) {
-        String hash = null;
-        try {
-            byte[] bytes = toHash.getBytes();
-            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
-            digest.update(bytes, 0, bytes.length);
-            hash = new BigInteger(1, digest.digest()).toString(16);
-        } catch (NoSuchAlgorithmException e) {
-            e.printStackTrace();
-        }
-        return hash;
-    }
-}
","1 package com.bumptech.photos.resize.cache;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.photos.util.Log;
5 import com.jakewharton.DiskLruCache;
6 
7 import java.io.BufferedOutputStream;
8 import java.io.File;
9 import java.io.IOException;
10 import java.io.InputStream;
11 import java.io.OutputStream;
12 import java.math.BigInteger;
13 import java.security.MessageDigest;
14 import java.security.NoSuchAlgorithmException;
15 
16 /**
17  * A thin wrapper around Jake Wharton's disk cache library.
18  *
19  * @see com.jakewharton.DiskLruCache
20  */
21 public class PhotoDiskCache {
22     private final static int VALUE_COUNT = 1; //values per cache entry
23     private DiskLruCache cache;
24     private final File directory;
25     private final long maxSize;
26     private final int appVersion;
27 
28     public PhotoDiskCache(File directory, long maxSize, int appVersion) {
29         this.directory = directory;
30         this.maxSize = maxSize;
31         this.appVersion = appVersion;
32         start();
33     }
34 
35     public void start() {
36         if (cache != null && !cache.isClosed()) return;
37 
38         try {
39             cache = DiskLruCache.open(directory, appVersion, VALUE_COUNT, maxSize);
40         } catch (IOException e) {
41             e.printStackTrace();
42         }
43     }
44 
45     public void stop() {
46         if (cache == null) return;
47 
48         try {
49             cache.close();
50         } catch (IOException e) {
51             e.printStackTrace();
52         }
53     }
54 
55     public void put(final int key, final Bitmap bitmap) {
56         if (cache.isClosed()) {
57             Log.d(""DLRU: put while cache is closed!"");
58             return;
59         }
60 
61         if (bitmap == null) return;
62         final String safeKey = sha1Hash(String.valueOf(key));
63 
64         DiskLruCache.Editor edit = null;
65         OutputStream out = null;
66         try {
67             DiskLruCache.Snapshot snapshot = cache.get(safeKey);
68             if (snapshot != null) {
69                 Log.d(""DLRU: not putting, already exists key="" + key);
70                 return;
71             }
72             edit = cache.edit(safeKey);
73             out = new BufferedOutputStream(edit.newOutputStream(VALUE_COUNT - 1));
74             bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
75             if (!cache.isClosed()) {
76                 edit.commit();
77             }
78         } catch (Exception e) {
79             if (edit != null) {
80                 try {
81                     edit.abort();
82                 } catch (Exception e1) {
83                     e1.printStackTrace();
84                 }
85             }
86             e.printStackTrace();
87         } finally {
88             if (out != null) {
89                 try {
90                     out.close();
91                 } catch (IOException e) {
92                     e.printStackTrace();
93                 }
94             }
95         }
96     }
97 
98     public InputStream get(final int key) {
99         if (cache.isClosed()) {
100             Log.d(""DLRU: get while cache is closed key="" + key);
101             return null;
102         }
103         //disk cache doesn't allow keys with anything but a-zA-Z0-9 :(
104         final String safeKey = sha1Hash(String.valueOf(key));
105         InputStream result = null;
106         try {
107             DiskLruCache.Snapshot snapshot = cache.get(safeKey);
108 
109             if (snapshot != null) {
110                 result = snapshot.getInputStream(VALUE_COUNT - 1);
111             } else {
112                 Log.d(""DLRU: snapshot not found key="" + key);
113             }
114 
115         } catch (IOException e) {
116             e.printStackTrace();
117             try {
118                 cache.remove(safeKey);
119             } catch (IOException e1) {
120                 Log.d(""DLRU: error removing bitmap key="" + key);
121                 e1.printStackTrace();
122             }
123         }
124 
125         return result;
126     }
127 
128     private static String sha1Hash(String toHash) {
129         String hash = null;
130         try {
131             byte[] bytes = toHash.getBytes();
132             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
133             digest.update(bytes, 0, bytes.length);
134             hash = new BigInteger(1, digest.digest()).toString(16);
135         } catch (NoSuchAlgorithmException e) {
136             e.printStackTrace();
137         }
138         return hash;
139     }
140 }",No
,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,53601580ae7938c212373b8513f60d745c70fbb4,"Replace library disk cache with our own 

This is unfortunate, but has to be done because
the disklrucache jar is just enough to put us over
the edge so we run into linear alloc errors on
older phones. Hopefully this can be reverted in 
the future.","@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.resize.cache.disk;
+
+import android.graphics.Bitmap;
+
+import java.io.BufferedOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/26/13
+ * Time: 9:20 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class DiskCache implements Closeable {
+    private static String JOURNAL_FILE_NAME = ""JOURNAL"";
+    private static DiskCache CACHE = null;
+
+    private final File outputDir;
+    private Journal journal;
+    private boolean isOpen = false;
+
+    public static DiskCache get(File diskCacheDir, int maxCacheSize) {
+        if (CACHE == null) {
+            CACHE = new DiskCache(diskCacheDir, maxCacheSize);
+        }
+
+        return CACHE;
+    }
+
+    protected DiskCache(File outputDir, int maxCacheSize) {
+        this.outputDir = outputDir;
+        this.journal = new Journal(getFile(JOURNAL_FILE_NAME), maxCacheSize, new Journal.EvictionListener() {
+            @Override
+            public void onKeyEvicted(String safeKey) {
+                delete(safeKey);
+            }
+        });
+    }
+
+    public void open() {
+        if (isOpen) return;
+        isOpen = true;
+        try {
+            journal.open();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void close() {
+        if (!isOpen) return;
+        isOpen = false;
+        try {
+            journal.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void put(String key, final Bitmap bitmap) {
+        if (!isOpen) return;
+
+        final String safeKey = sha1Hash(key);
+
+        final File outFile = getFile(safeKey);
+
+        OutputStream out = null;
+        try {
+            if (!outFile.exists()) outFile.createNewFile();
+
+            out = new BufferedOutputStream(new FileOutputStream(outFile));
+            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e1) { }
+            }
+        }
+        try {
+            journal.put(safeKey, (int) outFile.length());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public String get(String key) {
+        if (!isOpen) return null;
+
+        final String safeKey = sha1Hash(key);
+
+        final File inFile = getFile(safeKey);
+        if (!inFile.exists()) return null;
+
+        try {
+            journal.get(safeKey);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return inFile.getAbsolutePath();
+    }
+
+    public void remove(String key) {
+        if (!isOpen) return;
+        delete(sha1Hash(key));
+    }
+
+    private void delete(String safeKey) {
+        final File toDelete = getFile(safeKey);
+        toDelete.delete();
+        try {
+            journal.delete(safeKey);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private File getFile(String safeKey) {
+        return new File(outputDir + File.separator + safeKey);
+    }
+
+    private static String sha1Hash(String toHash) {
+        String hash = null;
+        try {
+            byte[] bytes = toHash.getBytes();
+            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
+            digest.update(bytes, 0, bytes.length);
+            hash = new BigInteger(1, digest.digest()).toString(16);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+        return hash;
+    }
+}
","1 /*
2  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.resize.cache.disk;
6 
7 import android.graphics.Bitmap;
8 
9 import java.io.BufferedOutputStream;
10 import java.io.Closeable;
11 import java.io.File;
12 import java.io.FileNotFoundException;
13 import java.io.FileOutputStream;
14 import java.io.IOException;
15 import java.io.OutputStream;
16 import java.math.BigInteger;
17 import java.security.MessageDigest;
18 import java.security.NoSuchAlgorithmException;
19 
20 /**
21  * Created with IntelliJ IDEA.
22  * User: sam
23  * Date: 1/26/13
24  * Time: 9:20 AM
25  * To change this template use File | Settings | File Templates.
26  */
27 public class DiskCache implements Closeable {
28     private static String JOURNAL_FILE_NAME = ""JOURNAL"";
29     private static DiskCache CACHE = null;
30 
31     private final File outputDir;
32     private Journal journal;
33     private boolean isOpen = false;
34 
35     public static DiskCache get(File diskCacheDir, int maxCacheSize) {
36         if (CACHE == null) {
37             CACHE = new DiskCache(diskCacheDir, maxCacheSize);
38         }
39 
40         return CACHE;
41     }
42 
43     protected DiskCache(File outputDir, int maxCacheSize) {
44         this.outputDir = outputDir;
45         this.journal = new Journal(getFile(JOURNAL_FILE_NAME), maxCacheSize, new Journal.EvictionListener() {
46             @Override
47             public void onKeyEvicted(String safeKey) {
48                 delete(safeKey);
49             }
50         });
51     }
52 
53     public void open() {
54         if (isOpen) return;
55         isOpen = true;
56         try {
57             journal.open();
58         } catch (IOException e) {
59             e.printStackTrace();
60         }
61     }
62 
63     @Override
64     public void close() {
65         if (!isOpen) return;
66         isOpen = false;
67         try {
68             journal.close();
69         } catch (IOException e) {
70             e.printStackTrace();
71         }
72     }
73 
74     public void put(String key, final Bitmap bitmap) {
75         if (!isOpen) return;
76 
77         final String safeKey = sha1Hash(key);
78 
79         final File outFile = getFile(safeKey);
80 
81         OutputStream out = null;
82         try {
83             if (!outFile.exists()) outFile.createNewFile();
84 
85             out = new BufferedOutputStream(new FileOutputStream(outFile));
86             bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
87         } catch (FileNotFoundException e) {
88             e.printStackTrace();
89         } catch (IOException e) {
90             e.printStackTrace();
91         } finally {
92             if (out != null) {
93                 try {
94                     out.close();
95                 } catch (IOException e1) { }
96             }
97         }
98         try {
99             journal.put(safeKey, (int) outFile.length());
100         } catch (IOException e) {
101             e.printStackTrace();
102         }
103     }
104 
105     public String get(String key) {
106         if (!isOpen) return null;
107 
108         final String safeKey = sha1Hash(key);
109 
110         final File inFile = getFile(safeKey);
111         if (!inFile.exists()) return null;
112 
113         try {
114             journal.get(safeKey);
115         } catch (IOException e) {
116             e.printStackTrace();
117         }
118 
119         return inFile.getAbsolutePath();
120     }
121 
122     public void remove(String key) {
123         if (!isOpen) return;
124         delete(sha1Hash(key));
125     }
126 
127     private void delete(String safeKey) {
128         final File toDelete = getFile(safeKey);
129         toDelete.delete();
130         try {
131             journal.delete(safeKey);
132         } catch (IOException e) {
133             e.printStackTrace();
134         }
135     }
136 
137     private File getFile(String safeKey) {
138         return new File(outputDir + File.separator + safeKey);
139     }
140 
141     private static String sha1Hash(String toHash) {
142         String hash = null;
143         try {
144             byte[] bytes = toHash.getBytes();
145             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
146             digest.update(bytes, 0, bytes.length);
147             hash = new BigInteger(1, digest.digest()).toString(16);
148         } catch (NoSuchAlgorithmException e) {
149             e.printStackTrace();
150         }
151         return hash;
152     }
153 }",No
,library\src\com\bumptech\photos\resize\cache\disk\Journal.java,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,53601580ae7938c212373b8513f60d745c70fbb4,"Replace library disk cache with our own 

This is unfortunate, but has to be done because
the disklrucache jar is just enough to put us over
the edge so we run into linear alloc errors on
older phones. Hopefully this can be reverted in 
the future.","@@ -0,0 +1,204 @@
+package com.bumptech.photos.resize.cache.disk;
+
+import android.support.v4.util.LruCache;
+import com.bumptech.photos.util.Log;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 1/28/13
+ * Time: 9:58 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class Journal {
+    private static int MAX_LINES = 10000;
+    private MemoryJournal memoryJournal = null;
+    private final File journalFile;
+    private BufferedWriter journalWriter;
+    private final int maxCacheSize;
+    private int numLines = 0;
+    private final EvictionListener evictionListener;
+    private boolean loading = false;
+
+    public interface EvictionListener {
+        public void onKeyEvicted(String safeKey);
+    }
+
+    private enum Action{
+        GET,
+        SET,
+        DEL,
+    }
+
+    public Journal(File journalFile, int maxCacheSize, EvictionListener evictionListener) {
+        this.maxCacheSize = maxCacheSize;
+        this.journalFile = journalFile;
+        this.evictionListener = evictionListener;
+    }
+
+    private class MemoryJournal extends LruCache<String, Integer> {
+        private final EvictionListener evictionListener;
+
+        public MemoryJournal(int maxSize, EvictionListener evictionListener) {
+            super(maxSize);
+            this.evictionListener = evictionListener;
+        }
+
+        @Override
+        protected void entryRemoved(boolean evicted, String key, Integer oldValue, Integer newValue) {
+            super.entryRemoved(evicted, key, oldValue, newValue);
+            if (evicted && !loading) {
+                evictionListener.onKeyEvicted(key);
+            }
+        }
+
+        @Override
+        protected int sizeOf(String key, Integer value) {
+            return value;
+        }
+    }
+
+    public void open() throws IOException {
+        journalFile.createNewFile();
+        journalWriter = new BufferedWriter(new FileWriter(journalFile, true));
+        if (memoryJournal == null) {
+            memoryJournal = new MemoryJournal(maxCacheSize, evictionListener);
+            replayFromDisk();
+        }
+    }
+
+    public void close() throws IOException {
+        if (journalWriter != null) {
+            journalWriter.close();
+            journalWriter = null;
+        }
+    }
+
+    private void replayFromDisk() throws IOException {
+        loading = true;
+        final Pattern regex = Pattern.compile("" "");
+        String line;
+        BufferedReader reader = null;
+        numLines = 0;
+        try {
+            reader = new BufferedReader(new FileReader(journalFile));
+            while ((line = reader.readLine()) != null) {
+                numLines++;
+                String[] splitLine = regex.split(line);
+                final Action action = Action.valueOf(splitLine[0]);
+                if (action == Action.SET) {
+                    memoryJournal.put(splitLine[1], Integer.parseInt(splitLine[2]));
+                } else if (action == Action.GET) {
+                    memoryJournal.get(splitLine[1]);
+                } else {
+                    memoryJournal.remove(splitLine[1]);
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            Log.d(""DISKCACHE: corrupt journal, rebuilding from disk"");
+            rebuildFromDisk();
+        } finally {
+            if (reader != null)
+                reader.close();
+        }
+        loading = false;
+    }
+
+    private void rebuildFromDisk() {
+        File directory = journalFile.getParentFile();
+        final File[] files = directory.listFiles(new FileFilter() {
+            @Override
+            public boolean accept(File file) {
+                return file.getName() != journalFile.getName();
+            }
+        });
+        List<File> fileList = Arrays.asList(files);
+        Collections.sort(fileList, new Comparator<File>() {
+            @Override
+            public int compare(File file, File file2) {
+                final long arg1 = file.lastModified();
+                final long arg2 = file2.lastModified();
+                if (arg1 == arg2) {
+                    return 0;
+                } else if (arg1 > arg1) {
+                    return -1;
+                } else {
+                    return 1;
+                }
+            }
+        });
+
+        memoryJournal.evictAll();
+        for (File f : fileList) {
+            memoryJournal.put(f.getName(), (int) f.length());
+        }
+
+        try {
+            compact();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void put(String safeKey, int size) throws IOException {
+        writeLine(buildLine(Action.SET, safeKey, String.valueOf(size)));
+        memoryJournal.put(safeKey, size);
+    }
+
+    public void get(String safeKey) throws IOException {
+        writeLine(buildLine(Action.GET, safeKey));
+        memoryJournal.get(safeKey);
+    }
+
+    public void delete(String safeKey) throws IOException {
+        writeLine(buildLine(Action.DEL, safeKey));
+        memoryJournal.remove(safeKey);
+    }
+
+    private void writeLine(String line) throws IOException {
+        journalWriter.write(line);
+        journalWriter.newLine();
+        numLines++;
+
+        if (shouldCompact()) {
+            compact();
+        }
+    }
+
+    private void compact() throws IOException {
+        numLines = 0;
+        journalWriter = new BufferedWriter(new FileWriter(journalFile));
+        final Map<String, Integer> snapshot = memoryJournal.snapshot();
+        for (String key : snapshot.keySet()) {
+            writeLine(buildLine(Action.SET, key, String.valueOf(snapshot.get(key))));
+        }
+    }
+
+    private boolean shouldCompact() {
+        return numLines > MAX_LINES;
+    }
+
+    private static String buildLine(Action action, String... args) {
+        StringBuilder builder = new StringBuilder().append(action.name());
+        for (String arg : args) {
+            builder.append("" "");
+            builder.append(arg);
+        }
+        return builder.toString();
+    }
+}
","1 package com.bumptech.photos.resize.cache.disk;
2 
3 import android.support.v4.util.LruCache;
4 import com.bumptech.photos.util.Log;
5 
6 import java.io.BufferedReader;
7 import java.io.BufferedWriter;
8 import java.io.File;
9 import java.io.FileFilter;
10 import java.io.FileReader;
11 import java.io.FileWriter;
12 import java.io.IOException;
13 import java.util.Arrays;
14 import java.util.Collections;
15 import java.util.Comparator;
16 import java.util.List;
17 import java.util.Map;
18 import java.util.regex.Pattern;
19 
20 /**
21  * Created with IntelliJ IDEA.
22  * User: sam
23  * Date: 1/28/13
24  * Time: 9:58 AM
25  * To change this template use File | Settings | File Templates.
26  */
27 public class Journal {
28     private static int MAX_LINES = 10000;
29     private MemoryJournal memoryJournal = null;
30     private final File journalFile;
31     private BufferedWriter journalWriter;
32     private final int maxCacheSize;
33     private int numLines = 0;
34     private final EvictionListener evictionListener;
35     private boolean loading = false;
36 
37     public interface EvictionListener {
38         public void onKeyEvicted(String safeKey);
39     }
40 
41     private enum Action{
42         GET,
43         SET,
44         DEL,
45     }
46 
47     public Journal(File journalFile, int maxCacheSize, EvictionListener evictionListener) {
48         this.maxCacheSize = maxCacheSize;
49         this.journalFile = journalFile;
50         this.evictionListener = evictionListener;
51     }
52 
53     private class MemoryJournal extends LruCache<String, Integer> {
54         private final EvictionListener evictionListener;
55 
56         public MemoryJournal(int maxSize, EvictionListener evictionListener) {
57             super(maxSize);
58             this.evictionListener = evictionListener;
59         }
60 
61         @Override
62         protected void entryRemoved(boolean evicted, String key, Integer oldValue, Integer newValue) {
63             super.entryRemoved(evicted, key, oldValue, newValue);
64             if (evicted && !loading) {
65                 evictionListener.onKeyEvicted(key);
66             }
67         }
68 
69         @Override
70         protected int sizeOf(String key, Integer value) {
71             return value;
72         }
73     }
74 
75     public void open() throws IOException {
76         journalFile.createNewFile();
77         journalWriter = new BufferedWriter(new FileWriter(journalFile, true));
78         if (memoryJournal == null) {
79             memoryJournal = new MemoryJournal(maxCacheSize, evictionListener);
80             replayFromDisk();
81         }
82     }
83 
84     public void close() throws IOException {
85         if (journalWriter != null) {
86             journalWriter.close();
87             journalWriter = null;
88         }
89     }
90 
91     private void replayFromDisk() throws IOException {
92         loading = true;
93         final Pattern regex = Pattern.compile("" "");
94         String line;
95         BufferedReader reader = null;
96         numLines = 0;
97         try {
98             reader = new BufferedReader(new FileReader(journalFile));
99             while ((line = reader.readLine()) != null) {
100                 numLines++;
101                 String[] splitLine = regex.split(line);
102                 final Action action = Action.valueOf(splitLine[0]);
103                 if (action == Action.SET) {
104                     memoryJournal.put(splitLine[1], Integer.parseInt(splitLine[2]));
105                 } else if (action == Action.GET) {
106                     memoryJournal.get(splitLine[1]);
107                 } else {
108                     memoryJournal.remove(splitLine[1]);
109                 }
110             }
111         } catch (Exception e) {
112             e.printStackTrace();
113             Log.d(""DISKCACHE: corrupt journal, rebuilding from disk"");
114             rebuildFromDisk();
115         } finally {
116             if (reader != null)
117                 reader.close();
118         }
119         loading = false;
120     }
121 
122     private void rebuildFromDisk() {
123         File directory = journalFile.getParentFile();
124         final File[] files = directory.listFiles(new FileFilter() {
125             @Override
126             public boolean accept(File file) {
127                 return file.getName() != journalFile.getName();
128             }
129         });
130         List<File> fileList = Arrays.asList(files);
131         Collections.sort(fileList, new Comparator<File>() {
132             @Override
133             public int compare(File file, File file2) {
134                 final long arg1 = file.lastModified();
135                 final long arg2 = file2.lastModified();
136                 if (arg1 == arg2) {
137                     return 0;
138                 } else if (arg1 > arg1) {
139                     return -1;
140                 } else {
141                     return 1;
142                 }
143             }
144         });
145 
146         memoryJournal.evictAll();
147         for (File f : fileList) {
148             memoryJournal.put(f.getName(), (int) f.length());
149         }
150 
151         try {
152             compact();
153         } catch (IOException e) {
154             e.printStackTrace();
155         }
156     }
157 
158     public void put(String safeKey, int size) throws IOException {
159         writeLine(buildLine(Action.SET, safeKey, String.valueOf(size)));
160         memoryJournal.put(safeKey, size);
161     }
162 
163     public void get(String safeKey) throws IOException {
164         writeLine(buildLine(Action.GET, safeKey));
165         memoryJournal.get(safeKey);
166     }
167 
168     public void delete(String safeKey) throws IOException {
169         writeLine(buildLine(Action.DEL, safeKey));
170         memoryJournal.remove(safeKey);
171     }
172 
173     private void writeLine(String line) throws IOException {
174         journalWriter.write(line);
175         journalWriter.newLine();
176         numLines++;
177 
178         if (shouldCompact()) {
179             compact();
180         }
181     }
182 
183     private void compact() throws IOException {
184         numLines = 0;
185         journalWriter = new BufferedWriter(new FileWriter(journalFile));
186         final Map<String, Integer> snapshot = memoryJournal.snapshot();
187         for (String key : snapshot.keySet()) {
188             writeLine(buildLine(Action.SET, key, String.valueOf(snapshot.get(key))));
189         }
190     }
191 
192     private boolean shouldCompact() {
193         return numLines > MAX_LINES;
194     }
195 
196     private static String buildLine(Action action, String... args) {
197         StringBuilder builder = new StringBuilder().append(action.name());
198         for (String arg : args) {
199             builder.append("" "");
200             builder.append(arg);
201         }
202         return builder.toString();
203     }
204 }",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,c8c18c3138544306880fb94d4bdd9c83d8969f40,ef5a3a5b2d4187b1f62e6d11de3d8fd24676826a,"Be more paranoid about threading in disk cache

This is not really a solution, but in case
open and close overlap because of actions on 
background threads started by two different
image managers, this will at least let state
be consistent. Needs more work to avoid this
problem.","@@ -50,7 +50,7 @@ public class DiskCache implements Closeable {
         });
     }
 
-    public void open() {
+    public synchronized void open() {
         if (isOpen) return;
         isOpen = true;
         try {
@@ -61,7 +61,7 @@ public class DiskCache implements Closeable {
     }
 
     @Override
-    public void close() {
+    public synchronized void close() {
         if (!isOpen) return;
         isOpen = false;
         try {
@@ -71,7 +71,7 @@ public class DiskCache implements Closeable {
         }
     }
 
-    public void put(String key, final Bitmap bitmap) {
+    public synchronized void put(String key, final Bitmap bitmap) {
         if (!isOpen) return;
 
         final String safeKey = sha1Hash(key);
@@ -102,7 +102,7 @@ public class DiskCache implements Closeable {
         }
     }
 
-    public String get(String key) {
+    public synchronized String get(String key) {
         if (!isOpen) return null;
 
         final String safeKey = sha1Hash(key);
@@ -119,12 +119,12 @@ public class DiskCache implements Closeable {
         return inFile.getAbsolutePath();
     }
 
-    public void remove(String key) {
+    public synchronized void remove(String key) {
         if (!isOpen) return;
         delete(sha1Hash(key));
     }
 
-    private void delete(String safeKey) {
+    private synchronized void delete(String safeKey) {
         final File toDelete = getFile(safeKey);
         toDelete.delete();
         try {
","53     public synchronized void open() {
64     public synchronized void close() {
74     public synchronized void put(String key, final Bitmap bitmap) {
105     public synchronized String get(String key) {
122     public synchronized void remove(String key) {
127     private synchronized void delete(String safeKey) {
53     public void open() {
64     public void close() {
74     public void put(String key, final Bitmap bitmap) {
105     public String get(String key) {
122     public void remove(String key) {
127     private void delete(String safeKey) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,81d2ccfbb0bf21224db07b2f85942d034e72e163,c8c18c3138544306880fb94d4bdd9c83d8969f40,"Handle cache dirs being null + build version check

Apparently either get cache dir method can return
null in some circumstances. If one does, try the
other, if both do, return null. The image manager
will just not use a disk cache if the cache
dir is null. Environment.
isExternalStorageRemovable is api 9+ and we 
support 8, so add a check before using it.","@@ -15,6 +15,7 @@ import android.os.SystemClock;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.resize.cache.disk.DiskCache;
+import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Util;
 
 import java.io.File;
@@ -130,19 +131,43 @@ public class ImageManager {
     }
 
     public static File getPhotoCacheDir(Context context, String cacheName) {
-        final String cachePath;
+        String cachePath = null;
+
+        Boolean isExternalStorageRemoveable = null;
+        if (Build.VERSION.SDK_INT >= 9) {
+            isExternalStorageRemoveable = Environment.isExternalStorageRemovable();
+        }
+
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
-                !Environment.isExternalStorageRemovable()) {
-            cachePath = context.getExternalCacheDir().getPath();
+                (isExternalStorageRemoveable != null && !isExternalStorageRemoveable)) {
+            //seems like this can still be null even if the above are true
+            final File externalCacheDir = context.getExternalCacheDir();
+            if (externalCacheDir != null) {
+                cachePath = externalCacheDir.getPath();
+            } else {
+                Log.e(""IM: external cache dir is null"");
+            }
+        }
+
+        if (cachePath == null) {
+            final File internalCacheDir = context.getCacheDir();
+            if (internalCacheDir != null) {
+                cachePath = internalCacheDir.getPath();
             } else {
-            cachePath = context.getCacheDir().getPath();
+                Log.e(""IM: internal cache dir is null"");
+            }
         }
 
+        if (cachePath != null) {
             File result = new File(cachePath + File.separatorChar + cacheName);
             if (!result.exists()) {
                 result.mkdir();
             }
             return result;
+        } else {
+            Log.d(""IM: default disk cache dir is null"");
+            return null;
+        }
     }
 
     /**
","18 import com.bumptech.photos.util.Log;
134         String cachePath = null;
135 
136         Boolean isExternalStorageRemoveable = null;
137         if (Build.VERSION.SDK_INT >= 9) {
138             isExternalStorageRemoveable = Environment.isExternalStorageRemovable();
141         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
142                 (isExternalStorageRemoveable != null && !isExternalStorageRemoveable)) {
143             //seems like this can still be null even if the above are true
144             final File externalCacheDir = context.getExternalCacheDir();
145             if (externalCacheDir != null) {
146                 cachePath = externalCacheDir.getPath();
147             } else {
148                 Log.e(""IM: external cache dir is null"");
149             }
150         }
151 
152         if (cachePath == null) {
153             final File internalCacheDir = context.getCacheDir();
154             if (internalCacheDir != null) {
155                 cachePath = internalCacheDir.getPath();
156             } else {
157                 Log.e(""IM: internal cache dir is null"");
158             }
159         }
160 
161         if (cachePath != null) {
167         } else {
168             Log.d(""IM: default disk cache dir is null"");
169             return null;
170         }
133         final String cachePath;
134         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
135                 !Environment.isExternalStorageRemovable()) {
136             cachePath = context.getExternalCacheDir().getPath();
137         } else {
138             cachePath = context.getCacheDir().getPath();",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,118ddef77f1493f4516c15402ce2c9edf93b60af,81d2ccfbb0bf21224db07b2f85942d034e72e163,Don' acquire bitmap for memory cache when not used,"@@ -528,7 +528,6 @@ public class ImageManager {
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        acquireBitmap(finalResult);
                         putInMemoryCache(key, finalResult);
                         cb.onLoadCompleted(finalResult);
                     }
@@ -565,6 +564,7 @@ public class ImageManager {
 
     private void putInMemoryCache(int key, Bitmap bitmap) {
         if (memoryCache != null) {
+            acquireBitmap(bitmap);
             memoryCache.put(key, bitmap);
         }
     }
","567             acquireBitmap(bitmap);
531                         acquireBitmap(finalResult);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,1f6d436ff23669fcdc35381850a437f09a421804,118ddef77f1493f4516c15402ce2c9edf93b60af,Remove an unused option,"@@ -42,11 +42,6 @@ public class ImageManager {
      * corresponding use option to false.
      */
     public static class Options {
-        /**
-         * @see com.jakewharton.DiskLruCache#open(java.io.File, int, int, long)
-         */
-        public int appVersion = 0;
-
         /**
          * If true caches bitmaps in memory.
          *
","45         /**
46          * @see com.jakewharton.DiskLruCache#open(java.io.File, int, int, long)
47          */
48         public int appVersion = 0;
49 ",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,1f6d436ff23669fcdc35381850a437f09a421804,118ddef77f1493f4516c15402ce2c9edf93b60af,Remove an unused option,"@@ -25,8 +25,8 @@ import java.util.Queue;
  */
 public class ImageResizer {
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
-    private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
-    private SizedBitmapCache bitmapCache = null;
+    private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
+    private final SizedBitmapCache bitmapCache;
     private final BitmapFactory.Options defaultOptions;
 
     public static BitmapFactory.Options getDefaultOptions() {
@@ -70,8 +70,6 @@ public class ImageResizer {
         }
     }
 
-
-
     /**
      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
      * and then crop the image down so that it fills the given dimensions
@@ -330,10 +328,13 @@ public class ImageResizer {
     }
 
     private byte[] getTempBytes() {
-        final byte[] result;
+        byte[] result = null;
+        synchronized (tempQueue) {
             if (tempQueue.size() > 0) {
                 result = tempQueue.remove();
-        } else {
+            }
+        }
+        if (result == null) {
             Log.d(""IR: created temp bytes"");
             result = new byte[16 * 1024];
         }
@@ -341,13 +342,11 @@ public class ImageResizer {
     }
 
     private void releaseTempBytes(byte[]... byteArrays) {
+        synchronized (tempQueue) {
             for (byte[] bytes : byteArrays) {
-            releaseTempBytes(bytes);
+                tempQueue.add(bytes);
             }
         }
-
-    private void releaseTempBytes(byte[] bytes) {
-        tempQueue.add(bytes);
     }
 
     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
","28     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
29     private final SizedBitmapCache bitmapCache;
331         byte[] result = null;
332         synchronized (tempQueue) {
335             }
336         }
337         if (result == null) {
345         synchronized (tempQueue) {
349         }
350     }
28     private Queue<byte[]> tempQueue = new LinkedList<byte[]>();
29     private SizedBitmapCache bitmapCache = null;
73 
74 
333         final byte[] result;
336         } else {
345             releaseTempBytes(bytes);
346         }
347     }
348 
349     private void releaseTempBytes(byte[] bytes) {",No
library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,1f6d436ff23669fcdc35381850a437f09a421804,118ddef77f1493f4516c15402ce2c9edf93b60af,Remove an unused option,"@@ -8,9 +8,9 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
 
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
@@ -26,12 +26,17 @@ public class SizedBitmapCache {
 
     public void put(Bitmap bitmap) {
         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
-        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
+        Queue<Bitmap> available;
+        synchronized (availableBitmaps) {
+            available = availableBitmaps.get(sizeKey);
             if (available == null) {
-            available = new LinkedList<Bitmap>();
+                available = new ConcurrentLinkedQueue<Bitmap>();
                 availableBitmaps.put(sizeKey, available);
             }
+        }
+
 
+        //Log.d(""SBC: put bitmap key="" + sizeKey + "" size="" + available.size() + "" maxPerSize="" + maxPerSize);
         if (available.size() < maxPerSize) {
             available.add(bitmap);
         }
@@ -40,7 +45,12 @@ public class SizedBitmapCache {
 
     public Bitmap get(int width, int height) {
         final String sizeKey = getSizeKey(width, height);
-        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
+        final Queue<Bitmap> available;
+
+        synchronized (availableBitmaps) {
+             available = availableBitmaps.get(sizeKey);
+        }
+
         if (available == null || available.size() == 0) {
             Log.d(""SBC: missing bitmap for key= "" + sizeKey);
             return null;
","13 import java.util.concurrent.ConcurrentLinkedQueue;
29         Queue<Bitmap> available;
30         synchronized (availableBitmaps) {
31             available = availableBitmaps.get(sizeKey);
33                 available = new ConcurrentLinkedQueue<Bitmap>();
36         }
38 
39         //Log.d(""SBC: put bitmap key="" + sizeKey + "" size="" + available.size() + "" maxPerSize="" + maxPerSize);
48         final Queue<Bitmap> available;
49 
50         synchronized (availableBitmaps) {
51              available = availableBitmaps.get(sizeKey);
52         }
53 
11 import java.util.LinkedList;
29         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
31             available = new LinkedList<Bitmap>();
43         Queue<Bitmap> available = availableBitmaps.get(sizeKey);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,1f6d436ff23669fcdc35381850a437f09a421804,118ddef77f1493f4516c15402ce2c9edf93b60af,Remove an unused option,"@@ -48,7 +48,10 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
         ImageManager.Options options = new ImageManager.Options();
         options.maxPerSize = 40;
+        options.useDiskCache = false;
+        options.useMemoryCache = false;
         options.maxDiskCacheSize = 50 * 1024 * 1024;
+        options.maxMemorySize = 2 * 1024 * 1024;
         imageManager = new ImageManager(this, options);
 
         final Resources res = getResources();
","51         options.useDiskCache = false;
52         options.useMemoryCache = false;
54         options.maxMemorySize = 2 * 1024 * 1024;",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,48bec5d2675744bbefa03354860bf676517834ae,1f6d436ff23669fcdc35381850a437f09a421804,"Allow ImageResizer to resize with multiple threads

Makes associated classes thread safe. Also only
allows disk cache to be a singleton, and replaces
pause and resume with a single shutdown call
to the ImageManager.","@@ -11,7 +11,6 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.SystemClock;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.resize.cache.disk.DiskCache;
@@ -21,6 +20,9 @@ import com.bumptech.photos.util.Util;
 import java.io.File;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
@@ -101,8 +103,9 @@ public class ImageManager {
 
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
-    private final Handler mainHandler;
+    private final Handler mainHandler = new Handler();
     private final Handler bgHandler;
+    private final ExecutorService executor;
     private final LruPhotoCache memoryCache;
     private final ImageResizer resizer;
     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
@@ -188,7 +191,7 @@ public class ImageManager {
      * @param options The specified options
      */
     public ImageManager(Context context, Options options) {
-        this(context, new Handler(), options);
+        this(context, Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors())), options);
     }
 
     /**
@@ -198,11 +201,11 @@ public class ImageManager {
      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
      *                in Activities.
-     * @param mainHandler A Handler to the UI thread.
-     * @param options The specified options
+     * @param resizeService An executor service that will be used to resize photos
+     * @param options The specified option
      */
-    public ImageManager(Context context, Handler mainHandler, Options options) {
-        this(context, getPhotoCacheDir(context), mainHandler, options);
+    public ImageManager(Context context, ExecutorService resizeService, Options options) {
+        this(context, getPhotoCacheDir(context), resizeService, options);
     }
 
     /**
@@ -214,13 +217,14 @@ public class ImageManager {
      *                in Activities.
      * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
      *                     already exist
-     * @param mainHandler A Handler to the UI thread.
+     * @param resizeService An executor service that will be used to resize photos
      * @param options The specified options
      */
-    public ImageManager(Context context, File diskCacheDir, Handler mainHandler, Options options) {
-        HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
+    public ImageManager(Context context, File diskCacheDir, ExecutorService resizeService, Options options) {
+        HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
+        executor = resizeService;
 
         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
 
@@ -262,7 +266,6 @@ public class ImageManager {
 
 
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
-        this.mainHandler = mainHandler;
     }
 
     /**
@@ -360,28 +363,6 @@ public class ImageManager {
         });
     }
 
-    public void pause() {
-        if (diskCache != null) {
-            bgHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    diskCache.close();
-                }
-            });
-        }
-    }
-
-    public void resume() {
-        if (diskCache != null) {
-            bgHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    diskCache.open();
-                }
-            });
-        }
-    }
-
     /**
      * Notify the ImageManager that a bitmap it loaded is not going to be displayed and can go into a queue to be
      * reused. Does nothing if recycling is disabled or impossible.
@@ -391,16 +372,14 @@ public class ImageManager {
     public void rejectBitmap(final Bitmap b) {
         if (!isBitmapRecyclingEnabled) return;
 
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
+        final Bitmap bitmap = b;
+        final int hashCode = b.hashCode();
+        synchronized (bitmapReferenceCounter) {
+            Integer currentCount = bitmapReferenceCounter.get(hashCode);
             if (currentCount == null || currentCount == 0) {
-            bitmapReferenceCounter.remove(b.hashCode());
-            //can only put or take from bitmap cache on one thread
-            bgHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    bitmapCache.put(b);
+                bitmapReferenceCounter.remove(hashCode);
+                bitmapCache.put(bitmap);
             }
-            });
         }
     }
 
@@ -415,11 +394,14 @@ public class ImageManager {
     public void acquireBitmap(Bitmap b) {
         if (!isBitmapRecyclingEnabled) return;
 
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
+        final int hashCode = b.hashCode();
+        synchronized (bitmapReferenceCounter) {
+            Integer currentCount = bitmapReferenceCounter.get(hashCode);
             if (currentCount == null) {
                 currentCount = 0;
             }
-        bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
+            bitmapReferenceCounter.put(hashCode, currentCount + 1);
+        }
     }
 
     /**
@@ -433,31 +415,35 @@ public class ImageManager {
     public void releaseBitmap(final Bitmap b) {
         if (!isBitmapRecyclingEnabled) return;
 
-        Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
+        final Bitmap bitmap = b;
+        final int hash = b.hashCode();
+        synchronized (bitmapReferenceCounter) {
+            Integer currentCount = bitmapReferenceCounter.get(hash) - 1;
             if (currentCount == 0) {
-            bitmapReferenceCounter.remove(b.hashCode());
-            //can only put or take from bitmap cache on one thread
-            bgHandler.postAtFrontOfQueue(new Runnable() {
-                @Override
-                public void run() {
-                    bitmapCache.put(b);
-                }
-            });
+                bitmapReferenceCounter.remove(hash);
+                bitmapCache.put(bitmap);
             } else {
-            bitmapReferenceCounter.put(b.hashCode(), currentCount);
+                bitmapReferenceCounter.put(hash, currentCount);
+            }
         }
     }
 
     public void cancelTask(Object token) {
-        if (token != null)
-            bgHandler.removeCallbacksAndMessages(token);
+        if (token != null) {
+            ImageManagerJob job = (ImageManagerJob) token;
+            job.cancel();
+        }
     }
 
+    public void shutdown() {
+        executor.shutdown();
+        bgHandler.getLooper().quit();
+    }
 
     private Object runJob(int key,final LoadedCallback cb, final ImageManagerJob job) {
-        final Object token = cb;
+        final Object token = job;
         if (!returnFromCache(key, cb)) {
-            bgHandler.postAtTime(job, token, SystemClock.uptimeMillis());
+            job.execute();
         }
         return token;
     }
@@ -475,6 +461,8 @@ public class ImageManager {
         private final int key;
         private final LoadedCallback cb;
         private final boolean useDiskCache;
+        private Future future = null;
+        private volatile boolean cancelled = false;
 
         public ImageManagerJob(int key, LoadedCallback cb) {
             this(key, cb, true);
@@ -486,8 +474,26 @@ public class ImageManager {
             this.useDiskCache = useDiskCache;
         }
 
+        public void execute() {
+            bgHandler.post(this);
+        }
+
+        public void cancel() {
+            if (cancelled) return;
+            cancelled = true;
+
+            if (bgHandler != null) {
+                bgHandler.removeCallbacks(this);
+            }
+            if (future != null) {
+                future.cancel(false);
+            }
+        }
+
         @Override
         public void run() {
+            if (cancelled) return;
+
             final boolean isInDiskCache;
             String path = null;
             if (useDiskCache) {
@@ -499,36 +505,48 @@ public class ImageManager {
             Bitmap result = null;
             if (isInDiskCache) {
                 try {
-                    result = resizer.loadAsIs(path);//resizer.loadAsIs(is1, is2);
+                    result = resizer.loadAsIs(path);
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }
 
             if (result == null) {
+                if (cancelled) return;
                 try {
-                    result = resizeIfNotFound();
+                    future = executor.submit(new Runnable() {
+                        @Override
+                        public void run() {
+                            Bitmap result = resizeIfNotFound();
+                            finishResize(result, isInDiskCache);
+                        }
+                    });
                 } catch (Exception e) {
                     e.printStackTrace();
                     cb.onLoadFailed(e);
                 }
+            } else {
+                finishResize(result, isInDiskCache);
+            }
         }
 
+        private void finishResize(Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
                     putInDiskCache(key, result);
                 }
 
                 final Bitmap finalResult = result;
+                putInMemoryCache(key, finalResult);
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        putInMemoryCache(key, finalResult);
                         cb.onLoadCompleted(finalResult);
                     }
 
                 });
             }
+
         }
 
         protected abstract Bitmap resizeIfNotFound();
","23 import java.util.concurrent.ExecutorService;
24 import java.util.concurrent.Executors;
25 import java.util.concurrent.Future;
106     private final Handler mainHandler = new Handler();
108     private final ExecutorService executor;
194         this(context, Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors())), options);
204      * @param resizeService An executor service that will be used to resize photos
205      * @param options The specified option
207     public ImageManager(Context context, ExecutorService resizeService, Options options) {
208         this(context, getPhotoCacheDir(context), resizeService, options);
220      * @param resizeService An executor service that will be used to resize photos
223     public ImageManager(Context context, File diskCacheDir, ExecutorService resizeService, Options options) {
224         HandlerThread bgThread = new HandlerThread(""bg_thread"");
227         executor = resizeService;
375         final Bitmap bitmap = b;
376         final int hashCode = b.hashCode();
377         synchronized (bitmapReferenceCounter) {
378             Integer currentCount = bitmapReferenceCounter.get(hashCode);
380                 bitmapReferenceCounter.remove(hashCode);
381                 bitmapCache.put(bitmap);
397         final int hashCode = b.hashCode();
398         synchronized (bitmapReferenceCounter) {
399             Integer currentCount = bitmapReferenceCounter.get(hashCode);
403             bitmapReferenceCounter.put(hashCode, currentCount + 1);
404         }
418         final Bitmap bitmap = b;
419         final int hash = b.hashCode();
420         synchronized (bitmapReferenceCounter) {
421             Integer currentCount = bitmapReferenceCounter.get(hash) - 1;
423                 bitmapReferenceCounter.remove(hash);
424                 bitmapCache.put(bitmap);
426                 bitmapReferenceCounter.put(hash, currentCount);
427             }
432         if (token != null) {
433             ImageManagerJob job = (ImageManagerJob) token;
434             job.cancel();
435         }
438     public void shutdown() {
439         executor.shutdown();
440         bgHandler.getLooper().quit();
441     }
444         final Object token = job;
446             job.execute();
464         private Future future = null;
465         private volatile boolean cancelled = false;
477         public void execute() {
478             bgHandler.post(this);
479         }
480 
481         public void cancel() {
482             if (cancelled) return;
483             cancelled = true;
484 
485             if (bgHandler != null) {
486                 bgHandler.removeCallbacks(this);
487             }
488             if (future != null) {
489                 future.cancel(false);
490             }
491         }
492 
495             if (cancelled) return;
496 
508                     result = resizer.loadAsIs(path);
515                 if (cancelled) return;
517                     future = executor.submit(new Runnable() {
518                         @Override
519                         public void run() {
520                             Bitmap result = resizeIfNotFound();
521                             finishResize(result, isInDiskCache);
522                         }
523                     });
528             } else {
529                 finishResize(result, isInDiskCache);
530             }
533         private void finishResize(Bitmap result, boolean isInDiskCache) {
540                 putInMemoryCache(key, finalResult);
549 
14 import android.os.SystemClock;
104     private final Handler mainHandler;
191         this(context, new Handler(), options);
201      * @param mainHandler A Handler to the UI thread.
202      * @param options The specified options
204     public ImageManager(Context context, Handler mainHandler, Options options) {
205         this(context, getPhotoCacheDir(context), mainHandler, options);
217      * @param mainHandler A Handler to the UI thread.
220     public ImageManager(Context context, File diskCacheDir, Handler mainHandler, Options options) {
221         HandlerThread bgThread = new HandlerThread(""image_manager_bg"");
265         this.mainHandler = mainHandler;
363     public void pause() {
364         if (diskCache != null) {
365             bgHandler.post(new Runnable() {
366                 @Override
367                 public void run() {
368                     diskCache.close();
369                 }
370             });
371         }
372     }
373 
374     public void resume() {
375         if (diskCache != null) {
376             bgHandler.post(new Runnable() {
377                 @Override
378                 public void run() {
379                     diskCache.open();
380                 }
381             });
382         }
383     }
384 
394         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
396             bitmapReferenceCounter.remove(b.hashCode());
397             //can only put or take from bitmap cache on one thread
398             bgHandler.post(new Runnable() {
399                 @Override
400                 public void run() {
401                     bitmapCache.put(b);
403             });
418         Integer currentCount = bitmapReferenceCounter.get(b.hashCode());
422         bitmapReferenceCounter.put(b.hashCode(), currentCount + 1);
436         Integer currentCount = bitmapReferenceCounter.get(b.hashCode()) - 1;
438             bitmapReferenceCounter.remove(b.hashCode());
439             //can only put or take from bitmap cache on one thread
440             bgHandler.postAtFrontOfQueue(new Runnable() {
441                 @Override
442                 public void run() {
443                     bitmapCache.put(b);
444                 }
445             });
447             bitmapReferenceCounter.put(b.hashCode(), currentCount);
452         if (token != null)
453             bgHandler.removeCallbacksAndMessages(token);
458         final Object token = cb;
460             bgHandler.postAtTime(job, token, SystemClock.uptimeMillis());
502                     result = resizer.loadAsIs(path);//resizer.loadAsIs(is1, is2);
510                     result = resizeIfNotFound();
526                         putInMemoryCache(key, finalResult);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,48bec5d2675744bbefa03354860bf676517834ae,1f6d436ff23669fcdc35381850a437f09a421804,"Allow ImageResizer to resize with multiple threads

Makes associated classes thread safe. Also only
allows disk cache to be a singleton, and replaces
pause and resume with a single shutdown call
to the ImageManager.","@@ -285,10 +285,9 @@ public class ImageResizer {
     }
 
     private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
-        byte[] tempStorage = getTempBytes();
-        byte[] bufStorage = getTempBytes();
-        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
-        decodeBitmapOptions.inTempStorage = tempStorage;
+        final byte[][] tempBytes = getTempBytes();
+        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, tempBytes[0]);
+        decodeBitmapOptions.inTempStorage = tempBytes[1];
         Bitmap result = null;
         try {
             result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
@@ -298,7 +297,7 @@ public class ImageResizer {
             } catch (IOException e) {
                 e.printStackTrace();
             }
-            releaseTempBytes(tempStorage, bufStorage);
+            releaseTempBytes(tempBytes);
         }
         return result;
     }
@@ -327,21 +326,22 @@ public class ImageResizer {
         return result;
     }
 
-    private byte[] getTempBytes() {
-        byte[] result = null;
+    private byte[][] getTempBytes() {
+        byte[][] result = new byte[2][];
         synchronized (tempQueue) {
+            for (int i = 0; i < result.length; i++) {
                 if (tempQueue.size() > 0) {
-                result = tempQueue.remove();
+                    result[i] = tempQueue.remove();
+                } else {
+                    Log.d(""IR: created temp bytes"");
+                    result[i] = new byte[16 * 1024];
                 }
             }
-        if (result == null) {
-            Log.d(""IR: created temp bytes"");
-            result = new byte[16 * 1024];
         }
         return result;
     }
 
-    private void releaseTempBytes(byte[]... byteArrays) {
+    private void releaseTempBytes(byte[][] byteArrays) {
         synchronized (tempQueue) {
             for (byte[] bytes : byteArrays) {
                 tempQueue.add(bytes);
","288         final byte[][] tempBytes = getTempBytes();
289         ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, tempBytes[0]);
290         decodeBitmapOptions.inTempStorage = tempBytes[1];
300             releaseTempBytes(tempBytes);
329     private byte[][] getTempBytes() {
330         byte[][] result = new byte[2][];
332             for (int i = 0; i < result.length; i++) {
334                     result[i] = tempQueue.remove();
335                 } else {
337                     result[i] = new byte[16 * 1024];
338                 }
339             }
344     private void releaseTempBytes(byte[][] byteArrays) {
288         byte[] tempStorage = getTempBytes();
289         byte[] bufStorage = getTempBytes();
290         ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, bufStorage);
291         decodeBitmapOptions.inTempStorage = tempStorage;
301             releaseTempBytes(tempStorage, bufStorage);
330     private byte[] getTempBytes() {
331         byte[] result = null;
334                 result = tempQueue.remove();
335             }
336         }
337         if (result == null) {
339             result = new byte[16 * 1024];
344     private void releaseTempBytes(byte[]... byteArrays) {",No
library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,48bec5d2675744bbefa03354860bf676517834ae,1f6d436ff23669fcdc35381850a437f09a421804,"Allow ImageResizer to resize with multiple threads

Makes associated classes thread safe. Also only
allows disk cache to be a singleton, and replaces
pause and resume with a single shutdown call
to the ImageManager.","@@ -8,9 +8,9 @@ import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
 
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
@@ -24,32 +24,25 @@ public class SizedBitmapCache {
         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
     }
 
-    public void put(Bitmap bitmap) {
+    public synchronized void put(Bitmap bitmap) {
         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
         Queue<Bitmap> available;
-        synchronized (availableBitmaps) {
         available = availableBitmaps.get(sizeKey);
         if (available == null) {
-                available = new ConcurrentLinkedQueue<Bitmap>();
+            available = new LinkedList<Bitmap>();
             availableBitmaps.put(sizeKey, available);
         }
-        }
-
 
-        //Log.d(""SBC: put bitmap key="" + sizeKey + "" size="" + available.size() + "" maxPerSize="" + maxPerSize);
         if (available.size() < maxPerSize) {
             available.add(bitmap);
         }
-        //Log.d(""SBC: put key="" + sizeKey + "" available="" + available.size());
     }
 
-    public Bitmap get(int width, int height) {
+    public synchronized Bitmap get(int width, int height) {
         final String sizeKey = getSizeKey(width, height);
         final Queue<Bitmap> available;
 
-        synchronized (availableBitmaps) {
          available = availableBitmaps.get(sizeKey);
-        }
 
         if (available == null || available.size() == 0) {
             Log.d(""SBC: missing bitmap for key= "" + sizeKey);
","11 import java.util.LinkedList;
27     public synchronized void put(Bitmap bitmap) {
32             available = new LinkedList<Bitmap>();
41     public synchronized Bitmap get(int width, int height) {
13 import java.util.concurrent.ConcurrentLinkedQueue;
27     public void put(Bitmap bitmap) {
30         synchronized (availableBitmaps) {
33                 available = new ConcurrentLinkedQueue<Bitmap>();
36         }
38 
39         //Log.d(""SBC: put bitmap key="" + sizeKey + "" size="" + available.size() + "" maxPerSize="" + maxPerSize);
43         //Log.d(""SBC: put key="" + sizeKey + "" available="" + available.size());
46     public Bitmap get(int width, int height) {
50         synchronized (availableBitmaps) {
52         }",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,48bec5d2675744bbefa03354860bf676517834ae,1f6d436ff23669fcdc35381850a437f09a421804,"Allow ImageResizer to resize with multiple threads

Makes associated classes thread safe. Also only
allows disk cache to be a singleton, and replaces
pause and resume with a single shutdown call
to the ImageManager.","@@ -7,7 +7,6 @@ package com.bumptech.photos.resize.cache.disk;
 import android.graphics.Bitmap;
 
 import java.io.BufferedOutputStream;
-import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -16,6 +15,10 @@ import java.io.OutputStream;
 import java.math.BigInteger;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * Created with IntelliJ IDEA.
@@ -24,13 +27,14 @@ import java.security.NoSuchAlgorithmException;
  * Time: 9:20 AM
  * To change this template use File | Settings | File Templates.
  */
-public class DiskCache implements Closeable {
+public class DiskCache {
     private static String JOURNAL_FILE_NAME = ""JOURNAL"";
     private static DiskCache CACHE = null;
 
     private final File outputDir;
     private Journal journal;
     private boolean isOpen = false;
+    private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
 
     public static DiskCache get(File diskCacheDir, int maxCacheSize) {
         if (CACHE == null) {
@@ -50,7 +54,7 @@ public class DiskCache implements Closeable {
         });
     }
 
-    public synchronized void open() {
+    private void open() {
         if (isOpen) return;
         isOpen = true;
         try {
@@ -60,22 +64,15 @@ public class DiskCache implements Closeable {
         }
     }
 
-    @Override
-    public synchronized void close() {
-        if (!isOpen) return;
-        isOpen = false;
-        try {
-            journal.close();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
+    public void put(String key, final Bitmap bitmap) {
+        synchronized (this) {
+            if (!isOpen) open();
         }
 
-    public synchronized void put(String key, final Bitmap bitmap) {
-        if (!isOpen) return;
-
         final String safeKey = sha1Hash(key);
-
+        final Lock lock = acquireLockFor(safeKey);
+        lock.lock();
+        try {
             final File outFile = getFile(safeKey);
 
             OutputStream out = null;
@@ -100,13 +97,32 @@ public class DiskCache implements Closeable {
             } catch (IOException e) {
                 e.printStackTrace();
             }
+        } finally {
+            lock.unlock();
+        }
     }
 
-    public synchronized String get(String key) {
-        if (!isOpen) return null;
+    private Lock acquireLockFor(String safeKey) {
+        ReentrantLock lock;
+        synchronized (lockMap) {
+            lock = lockMap.get(safeKey);
+            if (lock == null) {
+                lock = new ReentrantLock();
+                lockMap.put(safeKey, lock);
+            }
+        }
+        return lock;
+    }
 
-        final String safeKey = sha1Hash(key);
+    public String get(String key) {
+        synchronized (this) {
+            if (!isOpen) open();
+        }
 
+        final String safeKey = sha1Hash(key);
+        Lock lock = acquireLockFor(safeKey);
+        lock.lock();
+        try {
             final File inFile = getFile(safeKey);
             if (!inFile.exists()) return null;
 
@@ -117,14 +133,22 @@ public class DiskCache implements Closeable {
             }
 
             return inFile.getAbsolutePath();
+        } finally {
+            lock.unlock();
+        }
     }
 
-    public synchronized void remove(String key) {
-        if (!isOpen) return;
+    public void remove(String key) {
+        synchronized (this) {
+            if (!isOpen) open();
+        }
         delete(sha1Hash(key));
     }
 
-    private synchronized void delete(String safeKey) {
+    private void delete(String safeKey) {
+        final Lock lock = acquireLockFor(safeKey);
+        lock.lock();
+        try {
             final File toDelete = getFile(safeKey);
             toDelete.delete();
             try {
@@ -132,6 +156,9 @@ public class DiskCache implements Closeable {
             } catch (IOException e) {
                 e.printStackTrace();
             }
+        } finally {
+            lock.unlock();
+        }
     }
 
     private File getFile(String safeKey) {
","18 import java.util.HashMap;
19 import java.util.Map;
20 import java.util.concurrent.locks.Lock;
21 import java.util.concurrent.locks.ReentrantLock;
30 public class DiskCache {
37     private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
57     private void open() {
67     public void put(String key, final Bitmap bitmap) {
68         synchronized (this) {
69             if (!isOpen) open();
73         final Lock lock = acquireLockFor(safeKey);
74         lock.lock();
75         try {
100         } finally {
101             lock.unlock();
102         }
105     private Lock acquireLockFor(String safeKey) {
106         ReentrantLock lock;
107         synchronized (lockMap) {
108             lock = lockMap.get(safeKey);
109             if (lock == null) {
110                 lock = new ReentrantLock();
111                 lockMap.put(safeKey, lock);
112             }
113         }
114         return lock;
115     }
116 
117     public String get(String key) {
118         synchronized (this) {
119             if (!isOpen) open();
120         }
123         Lock lock = acquireLockFor(safeKey);
124         lock.lock();
125         try {
136         } finally {
137             lock.unlock();
138         }
141     public void remove(String key) {
142         synchronized (this) {
143             if (!isOpen) open();
144         }
148     private void delete(String safeKey) {
149         final Lock lock = acquireLockFor(safeKey);
150         lock.lock();
151         try {
159         } finally {
160             lock.unlock();
161         }
10 import java.io.Closeable;
27 public class DiskCache implements Closeable {
53     public synchronized void open() {
63     @Override
64     public synchronized void close() {
65         if (!isOpen) return;
66         isOpen = false;
67         try {
68             journal.close();
69         } catch (IOException e) {
70             e.printStackTrace();
72     }
73 
74     public synchronized void put(String key, final Bitmap bitmap) {
75         if (!isOpen) return;
78 
105     public synchronized String get(String key) {
106         if (!isOpen) return null;
109 
122     public synchronized void remove(String key) {
123         if (!isOpen) return;
127     private synchronized void delete(String safeKey) {",No
library\src\com\bumptech\photos\resize\cache\disk\Journal.java,library\src\com\bumptech\photos\resize\cache\disk\Journal.java,48bec5d2675744bbefa03354860bf676517834ae,1f6d436ff23669fcdc35381850a437f09a421804,"Allow ImageResizer to resize with multiple threads

Makes associated classes thread safe. Also only
allows disk cache to be a singleton, and replaces
pause and resume with a single shutdown call
to the ImageManager.","@@ -72,7 +72,7 @@ public class Journal {
         }
     }
 
-    public void open() throws IOException {
+    public synchronized void open() throws IOException {
         journalFile.createNewFile();
         journalWriter = new BufferedWriter(new FileWriter(journalFile, true));
         if (memoryJournal == null) {
@@ -81,13 +81,6 @@ public class Journal {
         }
     }
 
-    public void close() throws IOException {
-        if (journalWriter != null) {
-            journalWriter.close();
-            journalWriter = null;
-        }
-    }
-
     private void replayFromDisk() throws IOException {
         loading = true;
         final Pattern regex = Pattern.compile("" "");
@@ -155,17 +148,17 @@ public class Journal {
         }
     }
 
-    public void put(String safeKey, int size) throws IOException {
+    public synchronized void put(String safeKey, int size) throws IOException {
         writeLine(buildLine(Action.SET, safeKey, String.valueOf(size)));
         memoryJournal.put(safeKey, size);
     }
 
-    public void get(String safeKey) throws IOException {
+    public synchronized void get(String safeKey) throws IOException {
         writeLine(buildLine(Action.GET, safeKey));
         memoryJournal.get(safeKey);
     }
 
-    public void delete(String safeKey) throws IOException {
+    public synchronized void delete(String safeKey) throws IOException {
         writeLine(buildLine(Action.DEL, safeKey));
         memoryJournal.remove(safeKey);
     }
","75     public synchronized void open() throws IOException {
151     public synchronized void put(String safeKey, int size) throws IOException {
156     public synchronized void get(String safeKey) throws IOException {
161     public synchronized void delete(String safeKey) throws IOException {
75     public void open() throws IOException {
84     public void close() throws IOException {
85         if (journalWriter != null) {
86             journalWriter.close();
87             journalWriter = null;
88         }
89     }
90 
158     public void put(String safeKey, int size) throws IOException {
163     public void get(String safeKey) throws IOException {
168     public void delete(String safeKey) throws IOException {",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,0ba5fb69da11dbe8b0dfe079eb879080b81d20b1,48bec5d2675744bbefa03354860bf676517834ae,Fix a typo in flickr Downloader,"@@ -90,7 +90,6 @@ public class Downloader {
             try {
                 final URL targetUrl = new URL(url);
                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
-                urlConnection = (HttpURLConnection) targetUrl.openConnection();
                 urlConnection.setDoInput(true);
                 urlConnection.setDoOutput(false);
                 urlConnection.setUseCaches(false);
",93                 urlConnection = (HttpURLConnection) targetUrl.openConnection();,No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,7c8d3a766ea749b104a75d0c819435069185bdb8,0ba5fb69da11dbe8b0dfe079eb879080b81d20b1,Update FlickrActivity,"@@ -48,10 +48,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
         ImageManager.Options options = new ImageManager.Options();
         options.maxPerSize = 40;
-        options.useDiskCache = false;
-        options.useMemoryCache = false;
         options.maxDiskCacheSize = 50 * 1024 * 1024;
-        options.maxMemorySize = 2 * 1024 * 1024;
         imageManager = new ImageManager(this, options);
 
         final Resources res = getResources();
@@ -68,7 +65,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                     executeSearch();
                     return true;
                 }
-                return false;  //To change body of implemented methods use File | Settings | File Templates.
+                return false;
             }
         });
 
@@ -150,15 +147,9 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     }
 
     @Override
-    protected void onResume() {
-        super.onResume();
-        imageManager.resume();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        imageManager.pause();
+    protected void onDestroy() {
+        super.onDestroy();
+        imageManager.shutdown();
     }
 
     private static class TabListener implements ActionBar.TabListener {
","68                 return false;
150     protected void onDestroy() {
151         super.onDestroy();
152         imageManager.shutdown();
51         options.useDiskCache = false;
52         options.useMemoryCache = false;
54         options.maxMemorySize = 2 * 1024 * 1024;
71                 return false;  //To change body of implemented methods use File | Settings | File Templates.
153     protected void onResume() {
154         super.onResume();
155         imageManager.resume();
156     }
157 
158     @Override
159     protected void onPause() {
160         super.onPause();
161         imageManager.pause();",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,c323a7d8372399f72f3790b5d1d3209f5ec79a52,7c8d3a766ea749b104a75d0c819435069185bdb8,resizeCenterCrop -> centerCrop,"@@ -338,7 +338,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() {
-                return resizer.resizeCenterCrop(path, width, height);
+                return resizer.centerCrop(path, width, height);
             }
         });
     }
","341                 return resizer.centerCrop(path, width, height);
341                 return resizer.resizeCenterCrop(path, width, height);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,c323a7d8372399f72f3790b5d1d3209f5ec79a52,7c8d3a766ea749b104a75d0c819435069185bdb8,resizeCenterCrop -> centerCrop,"@@ -79,7 +79,7 @@ public class ImageResizer {
      * @param height The height the final image will fill
      * @return The resized image
      */
-    public Bitmap resizeCenterCrop(final String path, final int width, final int height){
+    public Bitmap centerCrop(final String path, final int width, final int height){
         final Bitmap streamed = loadApproximate(path, width, height);
 
         if (streamed == null) return null;
","82     public Bitmap centerCrop(final String path, final int width, final int height){
82     public Bitmap resizeCenterCrop(final String path, final int width, final int height){",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,eb2ab7b42bcb26de42cfba78d94f1b7e8c8cd5ac,c323a7d8372399f72f3790b5d1d3209f5ec79a52,Add input stream interface to ImageResizer,"@@ -81,13 +81,11 @@ public class ImageResizer {
      */
     public Bitmap centerCrop(final String path, final int width, final int height){
         final Bitmap streamed = loadApproximate(path, width, height);
-
-        if (streamed == null) return null;
-
-        if (streamed.getWidth() == width && streamed.getHeight() == height) {
-            return streamed;
+        return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
+    public Bitmap resizeCenterCrop(InputStream is1, InputStream is2, int width, int height) {
+        final Bitmap streamed = loadApproximate(is1, is2, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
@@ -103,23 +101,14 @@ public class ImageResizer {
      */
     public Bitmap fitInSpace(final String path, final int width, final int height){
         final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
+        return fitInSpace(streamed, width, height);
+    }
 
-        if (streamed == null) return null;
-
+    public Bitmap fitInSpace(InputStream is1, InputStream is2, int width, int height) {
+        final Bitmap streamed = loadApproximate(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
-    /**
-     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
-     * rotate the image according to the orientation in the images EXIF data if available.
-     *
-     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
-     *
-     * @param path The path where the image is stored
-     * @param width The target width
-     * @param height The target height
-     * @return A Bitmap containing the image
-     */
     public Bitmap loadApproximate(String path, int width, int height) {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
@@ -130,7 +119,33 @@ public class ImageResizer {
             height = w;
         }
 
-        final int[] dimens = getDimensions(path);
+        Bitmap result = null;
+        try {
+            result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+
+        if (orientation != 0) {
+            result = rotateImage(result, orientation);
+        }
+        return result;
+    }
+
+    /**
+     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
+     * rotate the image according to the orientation in the images EXIF data if available.
+     *
+     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
+     *
+     * @param is1 An inputStream for the image. Can't be is2
+     * @param is2 An inputStream for the image. Can't be is1
+     * @param width The target width
+     * @param height The target height
+     * @return A Bitmap containing the image
+     */
+    public Bitmap loadApproximate(InputStream is1, InputStream is2, int width, int height) {
+        final int[] dimens = getDimensions(is1);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
@@ -140,11 +155,7 @@ public class ImageResizer {
         final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
-        Bitmap result = decodeStream(path, decodeBitmapOptions);
-
-        if (orientation != 0) {
-            result = rotateImage(result, orientation);
-        }
+        Bitmap result = decodeStream(is2, decodeBitmapOptions);
 
         return result;
     }
@@ -162,7 +173,7 @@ public class ImageResizer {
     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
         int[] dimens = new int[] {-1, -1};
         try {
-            dimens = getDimension(is1);
+            dimens = getDimensions(is1);
         } finally {
             try {
                 is1.close();
@@ -257,7 +268,7 @@ public class ImageResizer {
      * @param is The InputStream representing the image
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    private int[] getDimension(InputStream is) {
+    private int[] getDimensions(InputStream is) {
         final BitmapFactory.Options decodeBoundsOptions = getOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
         decodeStream(is, decodeBoundsOptions);
@@ -393,7 +404,9 @@ public class ImageResizer {
      * @return The resized Bitmap (will be recycled if recycled is not null)
      */
     public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
-        if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
+        if (toCrop == null) {
+            return null;
+        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
             return toCrop;
         }
         //from ImageView/Bitmap.createScaledBitmap
@@ -506,6 +519,8 @@ public class ImageResizer {
      * given dimensions and toFit fits within the given dimensions
      */
     public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
+        if (toFit == null) return null;
+
         if (height > width){
             return shrinkToWidth(toFit, width);
         } else {
","84         return centerCrop(getRecycled(width, height), streamed, width, height);
87     public Bitmap resizeCenterCrop(InputStream is1, InputStream is2, int width, int height) {
88         final Bitmap streamed = loadApproximate(is1, is2, width, height);
107     public Bitmap fitInSpace(InputStream is1, InputStream is2, int width, int height) {
108         final Bitmap streamed = loadApproximate(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
109         return fitInSpace(streamed, width, height);
110     }
111 
122         Bitmap result = null;
123         try {
124             result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
125         } catch (FileNotFoundException e) {
126             e.printStackTrace();
127         }
128 
129         if (orientation != 0) {
130             result = rotateImage(result, orientation);
131         }
132         return result;
133     }
134 
135     /**
136      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
137      * rotate the image according to the orientation in the images EXIF data if available.
138      *
139      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
140      *
141      * @param is1 An inputStream for the image. Can't be is2
142      * @param is2 An inputStream for the image. Can't be is1
143      * @param width The target width
144      * @param height The target height
145      * @return A Bitmap containing the image
146      */
147     public Bitmap loadApproximate(InputStream is1, InputStream is2, int width, int height) {
148         final int[] dimens = getDimensions(is1);
158         Bitmap result = decodeStream(is2, decodeBitmapOptions);
176             dimens = getDimensions(is1);
271     private int[] getDimensions(InputStream is) {
407         if (toCrop == null) {
408             return null;
409         } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
522         if (toFit == null) return null;
523 
84 
85         if (streamed == null) return null;
86 
87         if (streamed.getWidth() == width && streamed.getHeight() == height) {
88             return streamed;
106 
107         if (streamed == null) return null;
108 
112     /**
113      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
114      * rotate the image according to the orientation in the images EXIF data if available.
115      *
116      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
117      *
118      * @param path The path where the image is stored
119      * @param width The target width
120      * @param height The target height
121      * @return A Bitmap containing the image
122      */
133         final int[] dimens = getDimensions(path);
143         Bitmap result = decodeStream(path, decodeBitmapOptions);
144 
145         if (orientation != 0) {
146             result = rotateImage(result, orientation);
147         }
165             dimens = getDimension(is1);
260     private int[] getDimension(InputStream is) {
396         if (toCrop.getWidth() == width && toCrop.getHeight() == height) {",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,f62b7ead7e48510976d191d1f6149e403703c999,eb2ab7b42bcb26de42cfba78d94f1b7e8c8cd5ac,Naming consistency,"@@ -84,7 +84,7 @@ public class ImageResizer {
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
-    public Bitmap resizeCenterCrop(InputStream is1, InputStream is2, int width, int height) {
+    public Bitmap centerCrop(InputStream is1, InputStream is2, int width, int height) {
         final Bitmap streamed = loadApproximate(is1, is2, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
","87     public Bitmap centerCrop(InputStream is1, InputStream is2, int width, int height) {
87     public Bitmap resizeCenterCrop(InputStream is1, InputStream is2, int width, int height) {",No
library\libs\android-support-v4.jar,library\libs\android-support-v4.jar,089c40976de1604596bbcba8612218b00af06b46,f62b7ead7e48510976d191d1f6149e403703c999,update support jar,"Binary files a/library/libs/android-support-v4.jar and b/library/libs/android-support-v4.jar differ
",,No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,3bf897c290c20b110abeeff2828bf32eafb52e4d,089c40976de1604596bbcba8612218b00af06b46,Avoid NPE when bitmap's config is null...,"@@ -425,7 +425,13 @@ public class ImageResizer {
 
         m.setScale(scale, scale);
         m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
-        Bitmap result = recycled != null ? recycled : Bitmap.createBitmap(width, height, toCrop.getConfig());
+        final Bitmap result;
+        if (recycled != null) {
+            result = recycled;
+        } else {
+            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
+                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
+        };
         Canvas canvas = new Canvas(result);
         Paint paint = new Paint();
         //only if scaling up
","428         final Bitmap result;
429         if (recycled != null) {
430             result = recycled;
431         } else {
432             result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
433                                                             Bitmap.Config.ARGB_8888 : toCrop.getConfig());
434         };
428         Bitmap result = recycled != null ? recycled : Bitmap.createBitmap(width, height, toCrop.getConfig());",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,0be16397ca3146dc1bb58fb3f45d17348703aea5,3bf897c290c20b110abeeff2828bf32eafb52e4d,Maybe fix a concurrency issue,"@@ -36,7 +36,7 @@ public class DiskCache {
     private boolean isOpen = false;
     private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
 
-    public static DiskCache get(File diskCacheDir, int maxCacheSize) {
+    public static synchronized DiskCache get(File diskCacheDir, int maxCacheSize) {
         if (CACHE == null) {
             CACHE = new DiskCache(diskCacheDir, maxCacheSize);
         }
","39     public static synchronized DiskCache get(File diskCacheDir, int maxCacheSize) {
39     public static DiskCache get(File diskCacheDir, int maxCacheSize) {",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,364c29c02d829774995831302b7497f054a240f7,0be16397ca3146dc1bb58fb3f45d17348703aea5,Add method to manually set dimens on presenters,"@@ -163,6 +163,7 @@ public class ImagePresenter<T> {
     private final ImagePresenterCoordinator coordinator;
     protected final ImageView imageView;
 
+    private boolean manualDimensSet = false;
     private int height = 0;
     private int width = 0;
 
@@ -371,8 +372,16 @@ public class ImagePresenter<T> {
     }
 
     private void getDimens() {
+        if (!manualDimensSet) {
             imageView.post(getDimens);
         }
+    }
+
+    public void setDimens(int width, int height) {
+        manualDimensSet = true;
+        this.width = width;
+        this.height = height;
+    }
 
     /**
      * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
","166     private boolean manualDimensSet = false;
375         if (!manualDimensSet) {
378     }
379 
380     public void setDimens(int width, int height) {
381         manualDimensSet = true;
382         this.width = width;
383         this.height = height;
384     }",No
library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,364c29c02d829774995831302b7497f054a240f7,0be16397ca3146dc1bb58fb3f45d17348703aea5,Add method to manually set dimens on presenters,"@@ -135,6 +135,11 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         return fullPresenter.getImageView();
     }
 
+    public void setDimens(int width, int height) {
+        fullPresenter.setDimens(width, height);
+        thumbPresenter.setDimens(width, height);
+    }
+
     /**
      * Calls the corresponding method on both image presenters
      *
","138     public void setDimens(int width, int height) {
139         fullPresenter.setDimens(width, height);
140         thumbPresenter.setDimens(width, height);
141     }
142 ",No
library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,538236fdf4d3854552ea1624dd17ea8e5eb8cbce,364c29c02d829774995831302b7497f054a240f7,"in ImageManagerLoader, handle null paths","@@ -20,8 +20,10 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
     @Override
     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
         clear();
+        if (path != null) {
             loadToken = doFetchImage(path, width, height, cb);
         }
+    }
 
     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
 
","23         if (path != null) {
26     }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,3fa36d8dfee75ff064b855cbf370afe21b649a83,538236fdf4d3854552ea1624dd17ea8e5eb8cbce,Make disk cache compress format configurable,"@@ -71,6 +71,11 @@ public class ImageManager {
          */
         public int maxDiskCacheSize;
 
+       /**
+        * The output format used to store bitmaps on disk in the disk cache
+        */
+        public Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
+
         /**
          * If true, will attempt to recycle Bitmaps and all loaded Bitmaps will be mutable. If true and a memory cache
          * is used, the memory cache size should be decreased since the Bitmap cache used to recycle Bitmaps will
@@ -99,6 +104,7 @@ public class ImageManager {
          * Config and dither for example can be set
          */
         public BitmapFactory.Options bitmapDecodeOptions = ImageResizer.getDefaultOptions();
+
     }
 
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
@@ -112,6 +118,7 @@ public class ImageManager {
     private final SizedBitmapCache bitmapCache;
     private final DiskCache diskCache;
     private final boolean isBitmapRecyclingEnabled;
+    private final Bitmap.CompressFormat diskCacheFormat;
 
     private enum ResizeType {
         CENTER_CROP,
@@ -242,6 +249,8 @@ public class ImageManager {
             diskCache = DiskCache.get(diskCacheDir, options.maxDiskCacheSize);
         }
 
+        diskCacheFormat = options.diskCacheFormat;
+
         if (!options.useMemoryCache) {
             memoryCache = null;
         } else {
@@ -563,7 +572,7 @@ public class ImageManager {
 
     private void putInDiskCache(int key, Bitmap value) {
         if (diskCache != null) {
-            diskCache.put(String.valueOf(key), value);
+            diskCache.put(String.valueOf(key), value, diskCacheFormat);
         }
     }
 
","74        /**
75         * The output format used to store bitmaps on disk in the disk cache
76         */
77         public Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
78 
107 
121     private final Bitmap.CompressFormat diskCacheFormat;
252         diskCacheFormat = options.diskCacheFormat;
253 
575             diskCache.put(String.valueOf(key), value, diskCacheFormat);
566             diskCache.put(String.valueOf(key), value);",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,3fa36d8dfee75ff064b855cbf370afe21b649a83,538236fdf4d3854552ea1624dd17ea8e5eb8cbce,Make disk cache compress format configurable,"@@ -64,7 +64,7 @@ public class DiskCache {
         }
     }
 
-    public void put(String key, final Bitmap bitmap) {
+    public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
         synchronized (this) {
             if (!isOpen) open();
         }
@@ -80,7 +80,7 @@ public class DiskCache {
                 if (!outFile.exists()) outFile.createNewFile();
 
                 out = new BufferedOutputStream(new FileOutputStream(outFile));
-                bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);
+                bitmap.compress(format, 100, out);
             } catch (FileNotFoundException e) {
                 e.printStackTrace();
             } catch (IOException e) {
","67     public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
83                 bitmap.compress(format, 100, out);
67     public void put(String key, final Bitmap bitmap) {
83                 bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out);",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,363dec66e07972c5ecf5126f5d8ef128a9f4aa1b,3fa36d8dfee75ff064b855cbf370afe21b649a83,Throw errors instead of using assert,"@@ -52,9 +52,16 @@ public class ImagePresenter<T> {
          * @return A new ImagePresenter
          */
         public ImagePresenter<T> build(){
-            assert imageView != null : ""cannot create presenter without an image view"";
-            assert imageLoader != null : ""cannot create presenter without an image loader"";
-            assert pathLoader != null : ""cannot create presenter without a path loader"";
+            if (imageView == null) {
+                throw new IllegalArgumentException(""cannot create presenter without an image view"");
+            }
+            if (imageLoader == null) {
+                throw new IllegalArgumentException(""cannot create presenter without an image loader"");
+            }
+            if (pathLoader == null) {
+                throw new IllegalArgumentException(""cannot create presenter without a path loader"");
+
+            }
 
             return new ImagePresenter<T>(this);
         }
@@ -103,7 +110,9 @@ public class ImagePresenter<T> {
          * @return This Builder object
          */
         public Builder<T> setPlaceholderResource(int resourceId) {
-            assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
+            if (resourceId != 0 && placeholderDrawable != null) {
+                throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
+            }
 
             this.placeholderResourceId = resourceId;
             return this;
@@ -118,7 +127,9 @@ public class ImagePresenter<T> {
          * @return This Builder object
          */
         public Builder<T> setPlaceholderDrawable(Drawable placeholderDrawable) {
-            assert placeholderDrawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
+            if (placeholderDrawable != null && placeholderResourceId != 0) {
+                throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
+            }
 
             this.placeholderDrawable = placeholderDrawable;
             return this;
","55             if (imageView == null) {
56                 throw new IllegalArgumentException(""cannot create presenter without an image view"");
57             }
58             if (imageLoader == null) {
59                 throw new IllegalArgumentException(""cannot create presenter without an image loader"");
60             }
61             if (pathLoader == null) {
62                 throw new IllegalArgumentException(""cannot create presenter without a path loader"");
63 
64             }
113             if (resourceId != 0 && placeholderDrawable != null) {
114                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
115             }
130             if (placeholderDrawable != null && placeholderResourceId != 0) {
131                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
132             }
55             assert imageView != null : ""cannot create presenter without an image view"";
56             assert imageLoader != null : ""cannot create presenter without an image loader"";
57             assert pathLoader != null : ""cannot create presenter without a path loader"";
106             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
121             assert placeholderDrawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";",No
library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,363dec66e07972c5ecf5126f5d8ef128a9f4aa1b,3fa36d8dfee75ff064b855cbf370afe21b649a83,Throw errors instead of using assert,"@@ -34,9 +34,15 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         private int placeholderResourceId;
 
         public ThumbImagePresenter<T> build(){
-            assert fullPresenterBuilder != null : ""you must include a builder for the full image presenter"";
-            assert thumbPresenterBuilder != null : ""you must include a builder for the thumb image presenter"";
-            assert imageView != null : ""cannot create presenter without an image view"";
+            if (fullPresenterBuilder == null) {
+                throw new IllegalArgumentException(""you must include a builder for the full image presenter"");
+            }
+            if (thumbPresenterBuilder == null) {
+                throw new IllegalArgumentException(""you must include a builder for the thumb image presenter"");
+            }
+            if (imageView == null){
+                throw new IllegalArgumentException(""cannot create presenter without an image view"");
+            }
 
             return new ThumbImagePresenter<T>(this);
         }
@@ -77,7 +83,9 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderDrawable
          */
         public Builder<T> setPlaceholderDrawable(Drawable drawable) {
-            assert drawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
+            if (drawable != null && this.placeholderResourceId != 0) {
+                throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
+            }
 
             this.placeholderDrawable = drawable;
             return this;
@@ -87,7 +95,9 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderResource
          */
         public Builder<T> setPlaceholderResource(int resourceId) {
-            assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";
+            if (resourceId != 0 && placeholderDrawable != null) {
+                throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
+            }
 
             this.placeholderResourceId = resourceId;
             return this;
","37             if (fullPresenterBuilder == null) {
38                 throw new IllegalArgumentException(""you must include a builder for the full image presenter"");
39             }
40             if (thumbPresenterBuilder == null) {
41                 throw new IllegalArgumentException(""you must include a builder for the thumb image presenter"");
42             }
43             if (imageView == null){
44                 throw new IllegalArgumentException(""cannot create presenter without an image view"");
45             }
86             if (drawable != null && this.placeholderResourceId != 0) {
87                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
88             }
98             if (resourceId != 0 && placeholderDrawable != null) {
99                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
100             }
37             assert fullPresenterBuilder != null : ""you must include a builder for the full image presenter"";
38             assert thumbPresenterBuilder != null : ""you must include a builder for the thumb image presenter"";
39             assert imageView != null : ""cannot create presenter without an image view"";
80             assert drawable == null || placeholderResourceId == 0 : ""Can't set both a placeholder drawable and a placeholder resource"";
90             assert resourceId == 0 || placeholderDrawable == null : ""Can't set both a placeholder drawable and a placeholder resource"";",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,82360b66ccf73d037e8baca58397b380e3df07ab,363dec66e07972c5ecf5126f5d8ef128a9f4aa1b,"Use layoutparams to determine size in IPs

Allows us to remove setDimens method and also
avoid some uneccessary size determination steps
if the params dimens have already been set but
the view itself hasn't yet been layed out.","@@ -8,11 +8,11 @@ import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import com.bumptech.photos.util.Log;
-import com.bumptech.photos.loader.path.PathLoader;
 import com.bumptech.photos.loader.image.ImageLoader;
+import com.bumptech.photos.loader.path.PathLoader;
 
 import java.lang.ref.WeakReference;
 
@@ -174,9 +174,8 @@ public class ImagePresenter<T> {
     private final ImagePresenterCoordinator coordinator;
     protected final ImageView imageView;
 
-    private boolean manualDimensSet = false;
-    private int height = 0;
-    private int width = 0;
+    private int lastWidth = 0;
+    private int lastHeight = 0;
 
     private Handler handler = new Handler();
 
@@ -189,13 +188,12 @@ public class ImagePresenter<T> {
     private final Runnable getDimens = new Runnable() {
         @Override
         public void run() {
-            if (imageView.getWidth() == width && imageView.getHeight() == height) return;
+            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+            if (layoutParams.width == lastWidth && layoutParams.height == lastHeight) return;
 
-            width = imageView.getWidth();
-            height = imageView.getHeight();
-//            if (pendingLoad != null)
-//                Log.d(""IP: getDimens width="" + width + "" height="" + height);
-            if (width != 0 && height != 0) {
+            lastWidth = layoutParams.width;
+            lastHeight = layoutParams.height;
+            if (lastWidth != 0 && lastHeight != 0) {
                 postPendingLoad();
             }
         }
@@ -238,6 +236,9 @@ public class ImagePresenter<T> {
         this.coordinator = builder.coordinator;
         this.imageSetCallback = builder.imageSetCallback;
         imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
+        ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+        lastWidth = layoutParams.width;
+        lastHeight = layoutParams.height;
     }
 
     /**
@@ -270,11 +271,10 @@ public class ImagePresenter<T> {
         currentModel = model;
         isImageSet = false;
 
-        if (width == 0 || height == 0) {
+        if (getWidth() == 0 || getHeight() == 0) {
             pendingLoad = new Runnable() {
                 @Override
                 public void run() {
-                    Log.d(""IP: pendingLoad run width="" + width + "" height="" + height);
                     fetchPath(model, loadCount);
                     pendingLoad = null;
                 }
@@ -325,7 +325,7 @@ public class ImagePresenter<T> {
      * @return The width of the wrapped {@link android.widget.ImageView}
      */
     public int getWidth() {
-        return width;
+        return imageView.getLayoutParams().width;
     }
 
     /**
@@ -335,7 +335,7 @@ public class ImagePresenter<T> {
      * @return The width of the wrapped {@link android.widget.ImageView }
      */
     public int getHeight() {
-        return height;
+        return imageView.getLayoutParams().height;
     }
 
     private void postPendingLoad() {
@@ -365,7 +365,7 @@ public class ImagePresenter<T> {
     }
 
     private void fetchImage(final String path, T model, final int loadCount) {
-        imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
+        imageToken = imageLoader.fetchImage(path, model, getWidth(), getHeight(), new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
@@ -378,21 +378,15 @@ public class ImagePresenter<T> {
             }
 
             @Override
-            public void onError(Exception e) { }
+            public void onError(Exception e) {
+            }
         });
     }
 
     private void getDimens() {
-        if (!manualDimensSet) {
+        imageView.removeCallbacks(getDimens);
         imageView.post(getDimens);
     }
-    }
-
-    public void setDimens(int width, int height) {
-        manualDimensSet = true;
-        this.width = width;
-        this.height = height;
-    }
 
     /**
      * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
@@ -417,19 +411,31 @@ public class ImagePresenter<T> {
 
         private final WeakReference<ImageView> imageViewRef;
         private final WeakReference<ImagePresenter> imagePresenterRef;
+        private int lastWidth = 0;
+        private int lastHeight = 0;
 
-        public SizeObserver(ImageView imageVew, ImagePresenter imagePresenter) {
-            imageViewRef = new WeakReference<ImageView>(imageVew);
+        public SizeObserver(ImageView imageView, ImagePresenter imagePresenter) {
+            imageViewRef = new WeakReference<ImageView>(imageView);
             imagePresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
+            ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+            lastWidth = layoutParams.width;
+            lastHeight = layoutParams.height;
         }
 
         @Override
         public void onGlobalLayout() {
             ImageView imageView = imageViewRef.get();
             ImagePresenter presenter = imagePresenterRef.get();
-            if (imageView != null && presenter != null && imageView.getWidth() > 0 && imageView.getHeight() > 0) {
+
+            if (presenter != null && imageView != null) {
+                final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+                if (layoutParams.width > 0 && layoutParams.height > 0 &&
+                        (layoutParams.width != lastWidth || layoutParams.height != lastHeight)) {
+                    lastWidth = layoutParams.width;
+                    lastHeight = layoutParams.height;
                     presenter.getDimens();
                 }
             }
         }
     }
+}
","11 import android.view.ViewGroup;
15 import com.bumptech.photos.loader.path.PathLoader;
177     private int lastWidth = 0;
178     private int lastHeight = 0;
191             final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
192             if (layoutParams.width == lastWidth && layoutParams.height == lastHeight) return;
194             lastWidth = layoutParams.width;
195             lastHeight = layoutParams.height;
196             if (lastWidth != 0 && lastHeight != 0) {
239         ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
240         lastWidth = layoutParams.width;
241         lastHeight = layoutParams.height;
274         if (getWidth() == 0 || getHeight() == 0) {
328         return imageView.getLayoutParams().width;
338         return imageView.getLayoutParams().height;
368         imageToken = imageLoader.fetchImage(path, model, getWidth(), getHeight(), new ImageLoader.ImageReadyCallback() {
381             public void onError(Exception e) {
382             }
387         imageView.removeCallbacks(getDimens);
414         private int lastWidth = 0;
415         private int lastHeight = 0;
417         public SizeObserver(ImageView imageView, ImagePresenter imagePresenter) {
418             imageViewRef = new WeakReference<ImageView>(imageView);
420             ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
421             lastWidth = layoutParams.width;
422             lastHeight = layoutParams.height;
429 
430             if (presenter != null && imageView != null) {
431                 final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
432                 if (layoutParams.width > 0 && layoutParams.height > 0 &&
433                         (layoutParams.width != lastWidth || layoutParams.height != lastHeight)) {
434                     lastWidth = layoutParams.width;
435                     lastHeight = layoutParams.height;
441 }
13 import com.bumptech.photos.util.Log;
14 import com.bumptech.photos.loader.path.PathLoader;
177     private boolean manualDimensSet = false;
178     private int height = 0;
179     private int width = 0;
192             if (imageView.getWidth() == width && imageView.getHeight() == height) return;
194             width = imageView.getWidth();
195             height = imageView.getHeight();
196 //            if (pendingLoad != null)
197 //                Log.d(""IP: getDimens width="" + width + "" height="" + height);
198             if (width != 0 && height != 0) {
273         if (width == 0 || height == 0) {
277                     Log.d(""IP: pendingLoad run width="" + width + "" height="" + height);
328         return width;
338         return height;
368         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
381             public void onError(Exception e) { }
386         if (!manualDimensSet) {
389     }
390 
391     public void setDimens(int width, int height) {
392         manualDimensSet = true;
393         this.width = width;
394         this.height = height;
395     }
421         public SizeObserver(ImageView imageVew, ImagePresenter imagePresenter) {
422             imageViewRef = new WeakReference<ImageView>(imageVew);
430             if (imageView != null && presenter != null && imageView.getWidth() > 0 && imageView.getHeight() > 0) {",No
library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,82360b66ccf73d037e8baca58397b380e3df07ab,363dec66e07972c5ecf5126f5d8ef128a9f4aa1b,"Use layoutparams to determine size in IPs

Allows us to remove setDimens method and also
avoid some uneccessary size determination steps
if the params dimens have already been set but
the view itself hasn't yet been layed out.","@@ -145,11 +145,6 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         return fullPresenter.getImageView();
     }
 
-    public void setDimens(int width, int height) {
-        fullPresenter.setDimens(width, height);
-        thumbPresenter.setDimens(width, height);
-    }
-
     /**
      * Calls the corresponding method on both image presenters
      *
","148     public void setDimens(int width, int height) {
149         fullPresenter.setDimens(width, height);
150         thumbPresenter.setDimens(width, height);
151     }
152 ",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,a8ead54938ac8b922eacd3b38687529c1c69ea9d,82360b66ccf73d037e8baca58397b380e3df07ab,Fix race causing two loads to use same bitmap,"@@ -586,10 +586,14 @@ public class ImageManager {
 
     private void putInMemoryCache(int key, Bitmap bitmap) {
         if (memoryCache != null) {
+            synchronized (memoryCache) {
+                if (!memoryCache.contains(key)) {
                     acquireBitmap(bitmap);
                     memoryCache.put(key, bitmap);
                 }
             }
+        }
+    }
 
     private static int getKey(String path, int width, int height, ResizeType type){
         return Util.hash(path.hashCode(), width, height, type.hashCode());
","589             synchronized (memoryCache) {
590                 if (!memoryCache.contains(key)) {
595         }
596     }",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,a8ead54938ac8b922eacd3b38687529c1c69ea9d,82360b66ccf73d037e8baca58397b380e3df07ab,Fix race causing two loads to use same bitmap,"@@ -61,18 +61,22 @@ public class LruPhotoCache{
         this.photoRemovedListener = listener;
     }
 
-    public void put(int key, Bitmap bitmap) {
+    public synchronized void put(int key, Bitmap bitmap) {
         photoCache.put(key, bitmap);
     }
 
-    public Bitmap get(int key) {
+    public synchronized Bitmap get(int key) {
         return photoCache.get(key);
     }
 
-    public void remove(int key){
+    public synchronized void remove(int key){
         photoCache.remove(key);
     }
 
+    public synchronized boolean contains(int key) {
+        return photoCache.get(key) != null;
+    }
+
     public void evictAll(){
         photoCache.evictAll();
     }
","64     public synchronized void put(int key, Bitmap bitmap) {
68     public synchronized Bitmap get(int key) {
72     public synchronized void remove(int key){
76     public synchronized boolean contains(int key) {
77         return photoCache.get(key) != null;
78     }
79 
64     public void put(int key, Bitmap bitmap) {
68     public Bitmap get(int key) {
72     public void remove(int key){",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,c3b301f1857fd86f98b63e2adb0879152791e9b2,a8ead54938ac8b922eacd3b38687529c1c69ea9d,Move size determining code into separate class,"@@ -8,6 +8,7 @@ import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
@@ -29,6 +30,7 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
+
     /**
      * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
      * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
@@ -161,8 +163,6 @@ public class ImagePresenter<T> {
         }
     }
 
-    private static final String PENDING_LOAD_TOKEN = ""pending_load"";
-    private static final int PENDING_LOAD_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
 
     private Object pathToken;
     private Object imageToken;
@@ -174,31 +174,12 @@ public class ImagePresenter<T> {
     private final ImagePresenterCoordinator coordinator;
     protected final ImageView imageView;
 
-    private int lastWidth = 0;
-    private int lastHeight = 0;
-
-    private Handler handler = new Handler();
-
     private T currentModel;
     private int currentCount;
 
     private boolean isImageSet = false;
     private boolean loadedFromCache = false;
-
-    private final Runnable getDimens = new Runnable() {
-        @Override
-        public void run() {
-            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
-            if (layoutParams.width == lastWidth && layoutParams.height == lastHeight) return;
-
-            lastWidth = layoutParams.width;
-            lastHeight = layoutParams.height;
-            if (lastWidth != 0 && lastHeight != 0) {
-                postPendingLoad();
-            }
-        }
-    };
-    private Runnable pendingLoad = null;
+    private final SizeDeterminer sizeDeterminer;
 
     /**
      * An interface used to coordinate multiple {@link ImagePresenter} objects acting on the same view
@@ -235,10 +216,7 @@ public class ImagePresenter<T> {
         }
         this.coordinator = builder.coordinator;
         this.imageSetCallback = builder.imageSetCallback;
-        imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
-        ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
-        lastWidth = layoutParams.width;
-        lastHeight = layoutParams.height;
+        sizeDeterminer = new SizeDeterminer(imageView);
     }
 
     /**
@@ -271,18 +249,12 @@ public class ImagePresenter<T> {
         currentModel = model;
         isImageSet = false;
 
-        if (getWidth() == 0 || getHeight() == 0) {
-            pendingLoad = new Runnable() {
+        sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
             @Override
-                public void run() {
-                    fetchPath(model, loadCount);
-                    pendingLoad = null;
-                }
-            };
-            getDimens();
-        } else {
-            fetchPath(model, loadCount);
+            public void onSizeReady(int width, int height) {
+                fetchPath(model, width, height, loadCount);
             }
+        });
 
         loadedFromCache = false;
 
@@ -318,44 +290,13 @@ public class ImagePresenter<T> {
         imageLoader.clear();
     }
 
-    /**
-     * Returns the current calculated width of the wrapped view. Will be 0 if the presenter has not yet calcualted a
-     * width. May change at any time
-     *
-     * @return The width of the wrapped {@link android.widget.ImageView}
-     */
-    public int getWidth() {
-        return imageView.getLayoutParams().width;
-    }
-
-    /**
-     * Returns the current calculated height of the wrapped view. Will be 0 if the presenter has not yet calculated a
-     * height. May change at any time.
-     *
-     * @return The width of the wrapped {@link android.widget.ImageView }
-     */
-    public int getHeight() {
-        return imageView.getLayoutParams().height;
-    }
-
-    private void postPendingLoad() {
-        if (pendingLoad == null) return;
-
-        //If an image view is actively changing sizes, we want to delay our resize job until
-        //the size has stabilized so that the image we load will match the final size, rather than some
-        //size part way through the change. One example of this is as part of an animation where a view is
-        //expanding or shrinking
-        handler.removeCallbacksAndMessages(PENDING_LOAD_TOKEN);
-        handler.postAtTime(pendingLoad, PENDING_LOAD_TOKEN, SystemClock.uptimeMillis() + PENDING_LOAD_DELAY);
-    }
-
-    private void fetchPath(final T model, final int loadCount) {
-        pathToken = pathLoader.fetchPath(model, getWidth(), getHeight(), new PathLoader.PathReadyCallback() {
+    private void fetchPath(final T model, final int width, final int height, final int loadCount) {
+        pathToken = pathLoader.fetchPath(model, width, height, new PathLoader.PathReadyCallback() {
             @Override
-            public boolean onPathReady(String path) {
+            public boolean onPathReady(final String path) {
                 if (loadCount != currentCount) return false;
+                fetchImage(path, model, width, height, loadCount);
 
-                fetchImage(path, model, loadCount);
                 return true;
             }
 
@@ -364,8 +305,8 @@ public class ImagePresenter<T> {
         });
     }
 
-    private void fetchImage(final String path, T model, final int loadCount) {
-        imageToken = imageLoader.fetchImage(path, model, getWidth(), getHeight(), new ImageLoader.ImageReadyCallback() {
+    private void fetchImage(final String path, T model, int width, int height, final int loadCount) {
+        imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
@@ -383,11 +324,6 @@ public class ImagePresenter<T> {
         });
     }
 
-    private void getDimens() {
-        imageView.removeCallbacks(getDimens);
-        imageView.post(getDimens);
-    }
-
     /**
      * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
      *
@@ -407,33 +343,92 @@ public class ImagePresenter<T> {
         return coordinator == null || coordinator.canSetPlaceholder(this);
     }
 
-    private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
+    private static class SizeDeterminer {
+        private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
+        private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
 
-        private final WeakReference<ImageView> imageViewRef;
-        private final WeakReference<ImagePresenter> imagePresenterRef;
-        private int lastWidth = 0;
-        private int lastHeight = 0;
+        private final View view;
+        private int width = 0;
+        private int height = 0;
+        private boolean valid = false;
+        private SizeReadyCallback cb = null;
+        private final Runnable getDimens = new Runnable() {
+            @Override
+            public void run() {
+                if (cb == null) return;
 
-        public SizeObserver(ImageView imageView, ImagePresenter imagePresenter) {
-            imageViewRef = new WeakReference<ImageView>(imageView);
-            imagePresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
-            ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
-            lastWidth = layoutParams.width;
-            lastHeight = layoutParams.height;
+                ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+                if (layoutParams.width > 0 && layoutParams.height > 0) {
+                    cb.onSizeReady(layoutParams.width, layoutParams.height);
+                } else if (view.getWidth() > 0 && view.getHeight() > 0) {
+                    valid = true;
+                    width = view.getWidth();
+                    height = view.getHeight();
+                    cb.onSizeReady(width, height);
+                    cb = null;
+                }
+            }
+        };
+
+        private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
+            private final WeakReference<SizeDeterminer> sizeDeterminerRef;
+            private Handler handler = new Handler();
+
+            public SizeObserver(SizeDeterminer sizeDeterminer) {
+                this.sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
             }
 
             @Override
             public void onGlobalLayout() {
-            ImageView imageView = imageViewRef.get();
-            ImagePresenter presenter = imagePresenterRef.get();
-
-            if (presenter != null && imageView != null) {
-                final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
-                if (layoutParams.width > 0 && layoutParams.height > 0 &&
-                        (layoutParams.width != lastWidth || layoutParams.height != lastHeight)) {
-                    lastWidth = layoutParams.width;
-                    lastHeight = layoutParams.height;
-                    presenter.getDimens();
+                final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+                if (sizeDeterminer != null) {
+                    handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
+                    handler.postAtTime(new Runnable() {
+                        @Override
+                        public void run() {
+                            sizeDeterminer.maybeInvalidate();
+                        }
+                    }, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
+                }
+            }
+        }
+
+        public interface SizeReadyCallback {
+            public void onSizeReady(int width, int height);
+        }
+
+        public SizeDeterminer(View view) {
+            this.view = view;
+            view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this));
+        }
+
+        public void getSize(SizeReadyCallback cb) {
+            this.cb = null;
+            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+            if (layoutParams.width > 0 && layoutParams.height > 0) {
+                cb.onSizeReady(layoutParams.width, layoutParams.height);
+            } else if (valid) {
+                cb.onSizeReady(width, height);
+            } else {
+                this.cb = cb;
+                view.removeCallbacks(getDimens);
+                view.post(getDimens);
+            }
+        }
+
+        private void maybeInvalidate() {
+            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+            if (layoutParams.width <= 0 || layoutParams.height <= 0) {
+                if (view.getWidth() >= 0 && view.getHeight() >= 0) {
+                    width = view.getWidth();
+                    height = view.getHeight();
+                    valid = true;
+                    if (cb != null) {
+                        cb.onSizeReady(width, height);
+                        cb = null;
+                    }
+                } else {
+                    valid = false;
                 }
             }
         }
","11 import android.view.View;
33 
182     private final SizeDeterminer sizeDeterminer;
219         sizeDeterminer = new SizeDeterminer(imageView);
252         sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
254             public void onSizeReady(int width, int height) {
255                 fetchPath(model, width, height, loadCount);
257         });
293     private void fetchPath(final T model, final int width, final int height, final int loadCount) {
294         pathToken = pathLoader.fetchPath(model, width, height, new PathLoader.PathReadyCallback() {
296             public boolean onPathReady(final String path) {
298                 fetchImage(path, model, width, height, loadCount);
308     private void fetchImage(final String path, T model, int width, int height, final int loadCount) {
309         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
346     private static class SizeDeterminer {
347         private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
348         private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
349 
350         private final View view;
351         private int width = 0;
352         private int height = 0;
353         private boolean valid = false;
354         private SizeReadyCallback cb = null;
355         private final Runnable getDimens = new Runnable() {
356             @Override
357             public void run() {
358                 if (cb == null) return;
359 
360                 ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
361                 if (layoutParams.width > 0 && layoutParams.height > 0) {
362                     cb.onSizeReady(layoutParams.width, layoutParams.height);
363                 } else if (view.getWidth() > 0 && view.getHeight() > 0) {
364                     valid = true;
365                     width = view.getWidth();
366                     height = view.getHeight();
367                     cb.onSizeReady(width, height);
368                     cb = null;
369                 }
370             }
371         };
372 
374             private final WeakReference<SizeDeterminer> sizeDeterminerRef;
375             private Handler handler = new Handler();
377             public SizeObserver(SizeDeterminer sizeDeterminer) {
378                 this.sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
383                 final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
384                 if (sizeDeterminer != null) {
385                     handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
386                     handler.postAtTime(new Runnable() {
387                         @Override
388                         public void run() {
389                             sizeDeterminer.maybeInvalidate();
390                         }
391                     }, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
392                 }
393             }
394         }
396         public interface SizeReadyCallback {
397             public void onSizeReady(int width, int height);
398         }
399 
400         public SizeDeterminer(View view) {
401             this.view = view;
402             view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this));
403         }
404 
405         public void getSize(SizeReadyCallback cb) {
406             this.cb = null;
407             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
408             if (layoutParams.width > 0 && layoutParams.height > 0) {
409                 cb.onSizeReady(layoutParams.width, layoutParams.height);
410             } else if (valid) {
411                 cb.onSizeReady(width, height);
412             } else {
413                 this.cb = cb;
414                 view.removeCallbacks(getDimens);
415                 view.post(getDimens);
416             }
417         }
418 
419         private void maybeInvalidate() {
420             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
421             if (layoutParams.width <= 0 || layoutParams.height <= 0) {
422                 if (view.getWidth() >= 0 && view.getHeight() >= 0) {
423                     width = view.getWidth();
424                     height = view.getHeight();
425                     valid = true;
426                     if (cb != null) {
427                         cb.onSizeReady(width, height);
428                         cb = null;
429                     }
430                 } else {
431                     valid = false;
164     private static final String PENDING_LOAD_TOKEN = ""pending_load"";
165     private static final int PENDING_LOAD_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
177     private int lastWidth = 0;
178     private int lastHeight = 0;
179 
180     private Handler handler = new Handler();
181 
187 
188     private final Runnable getDimens = new Runnable() {
189         @Override
190         public void run() {
191             final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
192             if (layoutParams.width == lastWidth && layoutParams.height == lastHeight) return;
193 
194             lastWidth = layoutParams.width;
195             lastHeight = layoutParams.height;
196             if (lastWidth != 0 && lastHeight != 0) {
197                 postPendingLoad();
198             }
199         }
200     };
201     private Runnable pendingLoad = null;
238         imageView.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(imageView, ImagePresenter.this));
239         ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
240         lastWidth = layoutParams.width;
241         lastHeight = layoutParams.height;
274         if (getWidth() == 0 || getHeight() == 0) {
275             pendingLoad = new Runnable() {
277                 public void run() {
278                     fetchPath(model, loadCount);
279                     pendingLoad = null;
280                 }
281             };
282             getDimens();
283         } else {
284             fetchPath(model, loadCount);
321     /**
322      * Returns the current calculated width of the wrapped view. Will be 0 if the presenter has not yet calcualted a
323      * width. May change at any time
324      *
325      * @return The width of the wrapped {@link android.widget.ImageView}
326      */
327     public int getWidth() {
328         return imageView.getLayoutParams().width;
329     }
330 
331     /**
332      * Returns the current calculated height of the wrapped view. Will be 0 if the presenter has not yet calculated a
333      * height. May change at any time.
334      *
335      * @return The width of the wrapped {@link android.widget.ImageView }
336      */
337     public int getHeight() {
338         return imageView.getLayoutParams().height;
339     }
340 
341     private void postPendingLoad() {
342         if (pendingLoad == null) return;
343 
344         //If an image view is actively changing sizes, we want to delay our resize job until
345         //the size has stabilized so that the image we load will match the final size, rather than some
346         //size part way through the change. One example of this is as part of an animation where a view is
347         //expanding or shrinking
348         handler.removeCallbacksAndMessages(PENDING_LOAD_TOKEN);
349         handler.postAtTime(pendingLoad, PENDING_LOAD_TOKEN, SystemClock.uptimeMillis() + PENDING_LOAD_DELAY);
350     }
351 
352     private void fetchPath(final T model, final int loadCount) {
353         pathToken = pathLoader.fetchPath(model, getWidth(), getHeight(), new PathLoader.PathReadyCallback() {
355             public boolean onPathReady(String path) {
358                 fetchImage(path, model, loadCount);
367     private void fetchImage(final String path, T model, final int loadCount) {
368         imageToken = imageLoader.fetchImage(path, model, getWidth(), getHeight(), new ImageLoader.ImageReadyCallback() {
386     private void getDimens() {
387         imageView.removeCallbacks(getDimens);
388         imageView.post(getDimens);
389     }
390 
412         private final WeakReference<ImageView> imageViewRef;
413         private final WeakReference<ImagePresenter> imagePresenterRef;
414         private int lastWidth = 0;
415         private int lastHeight = 0;
416 
417         public SizeObserver(ImageView imageView, ImagePresenter imagePresenter) {
418             imageViewRef = new WeakReference<ImageView>(imageView);
419             imagePresenterRef = new WeakReference<ImagePresenter>(imagePresenter);
420             ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
421             lastWidth = layoutParams.width;
422             lastHeight = layoutParams.height;
427             ImageView imageView = imageViewRef.get();
428             ImagePresenter presenter = imagePresenterRef.get();
430             if (presenter != null && imageView != null) {
431                 final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
432                 if (layoutParams.width > 0 && layoutParams.height > 0 &&
433                         (layoutParams.width != lastWidth || layoutParams.height != lastHeight)) {
434                     lastWidth = layoutParams.width;
435                     lastHeight = layoutParams.height;
436                     presenter.getDimens();",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,fac5216512ca376a9128307ea812fba51970a7b1,c3b301f1857fd86f98b63e2adb0879152791e9b2,Fix type in name of recyclable is,"@@ -297,7 +297,7 @@ public class ImageResizer {
 
     private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
         final byte[][] tempBytes = getTempBytes();
-        ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, tempBytes[0]);
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);
         decodeBitmapOptions.inTempStorage = tempBytes[1];
         Bitmap result = null;
         try {
","300         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);
300         ReycleableBufferedInputStream bis = new ReycleableBufferedInputStream(is, tempBytes[0]);",No
library\src\com\bumptech\photos\resize\ReycleableBufferedInputStream.java,library\src\com\bumptech\photos\resize\RecyclableBufferedInputStream.java,fac5216512ca376a9128307ea812fba51970a7b1,c3b301f1857fd86f98b63e2adb0879152791e9b2,Fix type in name of recyclable is,"@@ -37,7 +37,7 @@ import java.io.InputStream;
  * &lt;/pre&gt;
  *
  */
-public class ReycleableBufferedInputStream extends FilterInputStream {
+public class RecyclableBufferedInputStream extends FilterInputStream {
     /**
      * The buffer containing the current bytes read from the target InputStream.
      */
@@ -74,7 +74,7 @@ public class ReycleableBufferedInputStream extends FilterInputStream {
      *
      * @param in the {@code InputStream} the buffer reads from.
      */
-    public ReycleableBufferedInputStream(InputStream in) {
+    public RecyclableBufferedInputStream(InputStream in) {
         this(in, 8192);
     }
 
@@ -90,11 +90,11 @@ public class ReycleableBufferedInputStream extends FilterInputStream {
      * @param size the size of buffer in bytes.
      * @throws IllegalArgumentException if {@code size &lt;= 0}.
      */
-    public ReycleableBufferedInputStream(InputStream in, int size) {
+    public RecyclableBufferedInputStream(InputStream in, int size) {
         this(in, new byte[size]);
     }
 
-    public ReycleableBufferedInputStream(InputStream in, byte[] buffer) {
+    public RecyclableBufferedInputStream(InputStream in, byte[] buffer) {
         super(in);
         if (buffer == null || buffer.length == 0) {
             throw new IllegalArgumentException(""buffer is null or empty"");
","40 public class RecyclableBufferedInputStream extends FilterInputStream {
77     public RecyclableBufferedInputStream(InputStream in) {
93     public RecyclableBufferedInputStream(InputStream in, int size) {
97     public RecyclableBufferedInputStream(InputStream in, byte[] buffer) {
40 public class ReycleableBufferedInputStream extends FilterInputStream {
77     public ReycleableBufferedInputStream(InputStream in) {
93     public ReycleableBufferedInputStream(InputStream in, int size) {
97     public ReycleableBufferedInputStream(InputStream in, byte[] buffer) {",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,03f18152c182cf110389a6d626c656518853ceba,fac5216512ca376a9128307ea812fba51970a7b1,Fix warning on BufferedOutputStream buffer size,"@@ -79,7 +79,7 @@ public class DiskCache {
             try {
                 if (!outFile.exists()) outFile.createNewFile();
 
-                out = new BufferedOutputStream(new FileOutputStream(outFile));
+                out = new BufferedOutputStream(new FileOutputStream(outFile), 8192);
                 bitmap.compress(format, 100, out);
             } catch (FileNotFoundException e) {
                 e.printStackTrace();
","82                 out = new BufferedOutputStream(new FileOutputStream(outFile), 8192);
82                 out = new BufferedOutputStream(new FileOutputStream(outFile));",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,35d81b95812cd086e2145dcf20319c40316c59c3,03f18152c182cf110389a6d626c656518853ceba,Small locking optimization rejecting bitmaps,"@@ -383,13 +383,17 @@ public class ImageManager {
 
         final Bitmap bitmap = b;
         final int hashCode = b.hashCode();
+        final boolean addToCache;
         synchronized (bitmapReferenceCounter) {
-            Integer currentCount = bitmapReferenceCounter.get(hashCode);
-            if (currentCount == null || currentCount == 0) {
+            final Integer currentCount = bitmapReferenceCounter.get(hashCode);
+            addToCache = currentCount == null || currentCount == 0;
+            if (addToCache) {
                 bitmapReferenceCounter.remove(hashCode);
-                bitmapCache.put(bitmap);
             }
         }
+        if (addToCache) {
+            bitmapCache.put(bitmap);
+        }
     }
 
     /**
","386         final boolean addToCache;
388             final Integer currentCount = bitmapReferenceCounter.get(hashCode);
389             addToCache = currentCount == null || currentCount == 0;
390             if (addToCache) {
394         if (addToCache) {
395             bitmapCache.put(bitmap);
396         }
387             Integer currentCount = bitmapReferenceCounter.get(hashCode);
388             if (currentCount == null || currentCount == 0) {
390                 bitmapCache.put(bitmap);",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,35d81b95812cd086e2145dcf20319c40316c59c3,Explode inner class to main class in LruPhotoCache,"@@ -14,9 +14,8 @@ import android.support.v4.util.LruCache;
  *
  * @see android.support.v4.util.LruCache
  */
-public class LruPhotoCache{
+public class LruPhotoCache extends LruCache<Integer, Bitmap> {
     private static final float SIZE_RATIO = 1f/10f;
-    private final PhotoCache photoCache;
     private PhotoRemovedListener photoRemovedListener;
 
     public interface PhotoRemovedListener {
@@ -31,13 +30,10 @@ public class LruPhotoCache{
         return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
     }
 
-    private class PhotoCache extends LruCache<Integer, Bitmap> {
-
-        private PhotoCache(int maxSize) {
+    public LruPhotoCache(int maxSize) {
         super(maxSize);
     }
 
-
     @Override
     protected int sizeOf(Integer key, Bitmap value) {
         //get the size, getByteCount() is API 12+...
@@ -51,33 +47,12 @@ public class LruPhotoCache{
             photoRemovedListener.onPhotoRemoved(key, oldValue);
         }
     }
-    }
-
-    public LruPhotoCache(int size) {
-        photoCache = new PhotoCache(size);
-    }
 
     public void setPhotoRemovedListener(PhotoRemovedListener listener) {
         this.photoRemovedListener = listener;
     }
 
-    public synchronized void put(int key, Bitmap bitmap) {
-        photoCache.put(key, bitmap);
-    }
-
-    public synchronized Bitmap get(int key) {
-        return photoCache.get(key);
-    }
-
-    public synchronized void remove(int key){
-        photoCache.remove(key);
-    }
-
-    public synchronized boolean contains(int key) {
-        return photoCache.get(key) != null;
-    }
-
-    public void evictAll(){
-        photoCache.evictAll();
+    public boolean contains(Integer key) {
+        return get(key) != null;
     }
 }
","17 public class LruPhotoCache extends LruCache<Integer, Bitmap> {
33     public LruPhotoCache(int maxSize) {
55     public boolean contains(Integer key) {
56         return get(key) != null;
17 public class LruPhotoCache{
19     private final PhotoCache photoCache;
34     private class PhotoCache extends LruCache<Integer, Bitmap> {
35 
36         private PhotoCache(int maxSize) {
40 
54     }
55 
56     public LruPhotoCache(int size) {
57         photoCache = new PhotoCache(size);
58     }
64     public synchronized void put(int key, Bitmap bitmap) {
65         photoCache.put(key, bitmap);
66     }
67 
68     public synchronized Bitmap get(int key) {
69         return photoCache.get(key);
70     }
71 
72     public synchronized void remove(int key){
73         photoCache.remove(key);
74     }
75 
76     public synchronized boolean contains(int key) {
77         return photoCache.get(key) != null;
78     }
79 
80     public void evictAll(){
81         photoCache.evictAll();",No
library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -54,11 +54,14 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
      * A lifecycle method called after the requesting object is notified that this loader failed to loada Bitmap. Should
      * be used to cleanup or update any data related to the failed load.
      *
-     * @param path The path to the image this loader failed to load
-     * @param model The model representing the image this loader failed to load
      * @param e The exception that caused the failure, or null
+     * @param model The model representing the image this loader failed to load
+     * @param path The path to the image this loader failed to load
+     * @return True iff this image loader has handled the exception and the cb should not be notified.
      */
-    protected void onImageLoadFailed(String path, T model, Exception e) { }
+    protected boolean onImageLoadFailed(Exception e, T model, String path) {
+        return false;
+    }
 
     protected class InternalImageReadyCallback implements ImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
@@ -84,12 +87,13 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
         }
 
         @Override
-        public void onError(Exception e) {
+        public void onException(Exception e) {
             final ImageReadyCallback cb = cbRef.get();
             final T model = modelRef.get();
             if (cb != null && model != null) {
-                cb.onError(e);
-                BaseImageLoader.this.onImageLoadFailed(path, model, e);
+                if (!BaseImageLoader.this.onImageLoadFailed(e, model, path)) {
+                    cb.onException(e);
+                }
             }
         }
     }
","58      * @param model The model representing the image this loader failed to load
59      * @param path The path to the image this loader failed to load
60      * @return True iff this image loader has handled the exception and the cb should not be notified.
62     protected boolean onImageLoadFailed(Exception e, T model, String path) {
63         return false;
64     }
90         public void onException(Exception e) {
94                 if (!BaseImageLoader.this.onImageLoadFailed(e, model, path)) {
95                     cb.onException(e);
96                 }
57      * @param path The path to the image this loader failed to load
58      * @param model The model representing the image this loader failed to load
61     protected void onImageLoadFailed(String path, T model, Exception e) { }
87         public void onError(Exception e) {
91                 cb.onError(e);
92                 BaseImageLoader.this.onImageLoadFailed(path, model, e);",No
library\src\com\bumptech\photos\loader\image\ImageLoader.java,library\src\com\bumptech\photos\loader\image\ImageLoader.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -29,7 +29,7 @@ public interface ImageLoader<T> {
          *
          * @param e The exception that caused the load to fail, or null
          */
-        public void onError(Exception e);
+        public void onException(Exception e);
     }
 
     /**
","32         public void onException(Exception e);
32         public void onError(Exception e);",No
library\src\com\bumptech\photos\loader\path\BasePathLoader.java,library\src\com\bumptech\photos\loader\path\BasePathLoader.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -47,10 +47,13 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
      * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
      * SHould be used to cleanup or update any data related to the failed load.
      *
-     * @param model The model representing the image this loader failed to fetch a path for
      * @param e The exception that caused the failure, or null
+     * @param model The model representing the image this loader failed to fetch a path for
+     * @return True iff this path loader has handled the exception and the cb should not be notified.
      */
-    protected void onPathFetchFailed(T model, Exception e) { }
+    protected boolean onPathFetchFailed(Exception e, T model) {
+        return false;
+    }
 
     protected class InternalPathReadyCallback implements PathReadyCallback{
         private final WeakReference<PathReadyCallback> cbRef;
@@ -74,12 +77,13 @@ public abstract class BasePathLoader<T> implements PathLoader<T> {
         }
 
         @Override
-        public final void onError(Exception e) {
+        public final void onException(Exception e) {
             final PathReadyCallback cb = cbRef.get();
             final T model = modelRef.get();
             if (cb != null && model != null) {
-                cb.onError(e);
-                BasePathLoader.this.onPathFetchFailed(model, e);
+                if (!BasePathLoader.this.onPathFetchFailed(e, model)) {
+                    cb.onException(e);
+                }
             }
         }
     }
","51      * @param model The model representing the image this loader failed to fetch a path for
52      * @return True iff this path loader has handled the exception and the cb should not be notified.
54     protected boolean onPathFetchFailed(Exception e, T model) {
55         return false;
56     }
80         public final void onException(Exception e) {
84                 if (!BasePathLoader.this.onPathFetchFailed(e, model)) {
85                     cb.onException(e);
86                 }
50      * @param model The model representing the image this loader failed to fetch a path for
53     protected void onPathFetchFailed(T model, Exception e) { }
77         public final void onError(Exception e) {
81                 cb.onError(e);
82                 BasePathLoader.this.onPathFetchFailed(model, e);",No
library\src\com\bumptech\photos\loader\path\PathLoader.java,library\src\com\bumptech\photos\loader\path\PathLoader.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -30,7 +30,7 @@ public interface PathLoader<T> {
          *
          * @param e The exception that caused the load to fail, or null
          */
-        public void onError(Exception e);
+        public void onException(Exception e);
     }
 
     /**
","33         public void onException(Exception e);
33         public void onError(Exception e);",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -30,7 +30,6 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
-
     /**
      * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
      * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
@@ -47,6 +46,7 @@ public class ImagePresenter<T> {
         private ImagePresenterCoordinator coordinator;
         private ImageLoader<T> imageLoader;
         private PathLoader<T> pathLoader;
+        private ExceptionHandler<T> exceptionHandler;
 
         /**
          * Builds an ImagePresenter
@@ -161,8 +161,19 @@ public class ImagePresenter<T> {
             this.coordinator = coordinator;
             return this;
         }
-    }
 
+        /**
+         * Optional Sets a handler that will be notified if any path or image load causes an exception.
+         * See {@link com.bumptech.photos.presenter.ImagePresenter.ExceptionHandler}.
+         *
+         * @param exceptionHandler The exception handler to set
+         * @return This builder object
+         */
+        public Builder<T> setExceptionHandler(ExceptionHandler<T> exceptionHandler) {
+            this.exceptionHandler = exceptionHandler;
+            return this;
+        }
+    }
 
     private Object pathToken;
     private Object imageToken;
@@ -172,6 +183,7 @@ public class ImagePresenter<T> {
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
     private final ImagePresenterCoordinator coordinator;
+    private final ExceptionHandler<T> exceptionHandler;
     protected final ImageView imageView;
 
     private T currentModel;
@@ -205,6 +217,11 @@ public class ImagePresenter<T> {
         public boolean canSetPlaceholder(ImagePresenter<T> presenter);
     }
 
+    public interface ExceptionHandler<T> {
+        public void onPathLoadException(Exception e, T model, boolean isCurrent);
+        public void onImageLoadException(Exception e, T model, String path, boolean isCurrent);
+    }
+
     private ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
@@ -216,6 +233,7 @@ public class ImagePresenter<T> {
         }
         this.coordinator = builder.coordinator;
         this.imageSetCallback = builder.imageSetCallback;
+        this.exceptionHandler = builder.exceptionHandler;
         sizeDeterminer = new SizeDeterminer(imageView);
     }
 
@@ -301,11 +319,15 @@ public class ImagePresenter<T> {
             }
 
             @Override
-            public void onError(Exception e) { }
+            public void onException(Exception e) {
+                if (exceptionHandler != null) {
+                    exceptionHandler.onPathLoadException(e, model, loadCount == currentCount);
+                }
+            }
         });
     }
 
-    private void fetchImage(final String path, T model, int width, int height, final int loadCount) {
+    private void fetchImage(final String path, final T model, int width, int height, final int loadCount) {
         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
@@ -319,7 +341,10 @@ public class ImagePresenter<T> {
             }
 
             @Override
-            public void onError(Exception e) {
+            public void onException(Exception e) {
+                if (exceptionHandler != null) {
+                    exceptionHandler.onImageLoadException(e, model, path, loadCount == currentCount);
+                }
             }
         });
     }
","49         private ExceptionHandler<T> exceptionHandler;
165         /**
166          * Optional Sets a handler that will be notified if any path or image load causes an exception.
167          * See {@link com.bumptech.photos.presenter.ImagePresenter.ExceptionHandler}.
168          *
169          * @param exceptionHandler The exception handler to set
170          * @return This builder object
171          */
172         public Builder<T> setExceptionHandler(ExceptionHandler<T> exceptionHandler) {
173             this.exceptionHandler = exceptionHandler;
174             return this;
175         }
176     }
186     private final ExceptionHandler<T> exceptionHandler;
220     public interface ExceptionHandler<T> {
221         public void onPathLoadException(Exception e, T model, boolean isCurrent);
222         public void onImageLoadException(Exception e, T model, String path, boolean isCurrent);
223     }
224 
236         this.exceptionHandler = builder.exceptionHandler;
322             public void onException(Exception e) {
323                 if (exceptionHandler != null) {
324                     exceptionHandler.onPathLoadException(e, model, loadCount == currentCount);
325                 }
326             }
330     private void fetchImage(final String path, final T model, int width, int height, final int loadCount) {
344             public void onException(Exception e) {
345                 if (exceptionHandler != null) {
346                     exceptionHandler.onImageLoadException(e, model, path, loadCount == currentCount);
347                 }
33 
164     }
304             public void onError(Exception e) { }
308     private void fetchImage(final String path, T model, int width, int height, final int loadCount) {
322             public void onError(Exception e) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -18,6 +18,7 @@ import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Util;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
@@ -288,7 +289,7 @@ public class ImageManager {
         final int key = getKey(path, -1, -1, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
-            protected Bitmap resizeIfNotFound() {
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAsIs(path);
             }
         });
@@ -307,7 +308,7 @@ public class ImageManager {
         final int key = getKey(path, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
             @Override
-            protected Bitmap resizeIfNotFound() {
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAsIs(path, width, height);
             }
         });
@@ -326,7 +327,7 @@ public class ImageManager {
         final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-            protected Bitmap resizeIfNotFound() {
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadApproximate(path, width, height);
             }
         });
@@ -346,7 +347,7 @@ public class ImageManager {
         final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-            protected Bitmap resizeIfNotFound() {
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.centerCrop(path, width, height);
             }
         });
@@ -366,7 +367,7 @@ public class ImageManager {
         final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
-            protected Bitmap resizeIfNotFound() {
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.fitInSpace(path, width, height);
             }
         });
@@ -526,18 +527,17 @@ public class ImageManager {
 
             if (result == null) {
                 if (cancelled) return;
-                try {
                 future = executor.submit(new Runnable() {
                     @Override
                     public void run() {
+                        try {
                             Bitmap result = resizeIfNotFound();
                             finishResize(result, isInDiskCache);
-                        }
-                    });
                         } catch (Exception e) {
-                    e.printStackTrace();
                             cb.onLoadFailed(e);
                         }
+                    }
+                });
             } else {
                 finishResize(result, isInDiskCache);
             }
@@ -562,7 +562,7 @@ public class ImageManager {
 
         }
 
-        protected abstract Bitmap resizeIfNotFound();
+        protected abstract Bitmap resizeIfNotFound() throws FileNotFoundException;
     }
 
 
","21 import java.io.FileNotFoundException;
292             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
311             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
330             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
350             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
370             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
533                         try {
539                     }
540                 });
565         protected abstract Bitmap resizeIfNotFound() throws FileNotFoundException;
291             protected Bitmap resizeIfNotFound() {
310             protected Bitmap resizeIfNotFound() {
329             protected Bitmap resizeIfNotFound() {
349             protected Bitmap resizeIfNotFound() {
369             protected Bitmap resizeIfNotFound() {
529                 try {
535                         }
536                     });
538                     e.printStackTrace();
565         protected abstract Bitmap resizeIfNotFound();",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -79,7 +79,7 @@ public class ImageResizer {
      * @param height The height the final image will fill
      * @return The resized image
      */
-    public Bitmap centerCrop(final String path, final int width, final int height){
+    public Bitmap centerCrop(final String path, final int width, final int height) throws FileNotFoundException {
         final Bitmap streamed = loadApproximate(path, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
@@ -99,7 +99,7 @@ public class ImageResizer {
      * @param height The height the final image will fit within
      * @return The resized image
      */
-    public Bitmap fitInSpace(final String path, final int width, final int height){
+    public Bitmap fitInSpace(final String path, final int width, final int height) throws FileNotFoundException {
         final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
@@ -109,7 +109,7 @@ public class ImageResizer {
         return fitInSpace(streamed, width, height);
     }
 
-    public Bitmap loadApproximate(String path, int width, int height) {
+    public Bitmap loadApproximate(String path, int width, int height) throws FileNotFoundException {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
             //Swap width and height for initial downsample calculation if its oriented so.
@@ -119,12 +119,7 @@ public class ImageResizer {
             height = w;
         }
 
-        Bitmap result = null;
-        try {
-            result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        }
+        Bitmap result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
 
         if (orientation != 0) {
             result = rotateImage(result, orientation);
@@ -198,7 +193,7 @@ public class ImageResizer {
      * @param height The height of the image at the given path
      * @return The loaded image
      */
-    public Bitmap loadAsIs(final String path, final int width, final int height) {
+    public Bitmap loadAsIs(final String path, final int width, final int height) throws FileNotFoundException {
         return load(path, getRecycled(width, height));
     }
 
@@ -209,7 +204,7 @@ public class ImageResizer {
      * @param path The path where the image is stored
      * @return The loaded image
      */
-    public Bitmap loadAsIs(final String path){
+    public Bitmap loadAsIs(final String path) throws FileNotFoundException {
         final int[] dimens = getDimensions(path);
         return load(path, getRecycled(dimens));
     }
@@ -226,7 +221,7 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
      */
-    private Bitmap load(String path, Bitmap recycle) {
+    private Bitmap load(String path, Bitmap recycle) throws FileNotFoundException {
         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
         final Bitmap result = decodeStream(path, decodeBitmapOptions);
         return result == null ? null : orientImage(path, result);
@@ -255,7 +250,7 @@ public class ImageResizer {
      * @param path The path where the image is stored
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    private int[] getDimensions(String path) {
+    private int[] getDimensions(String path) throws FileNotFoundException {
         final BitmapFactory.Options decodeBoundsOptions = getOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
         decodeStream(path, decodeBoundsOptions);
@@ -275,14 +270,12 @@ public class ImageResizer {
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
-    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
+    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) throws FileNotFoundException {
         InputStream is = null;
         Bitmap result = null;
         try {
             is = new FileInputStream(path);
             result = decodeStream(is, decodeBitmapOptions);
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
         } finally {
             if (is !=null) {
                 try {
","82     public Bitmap centerCrop(final String path, final int width, final int height) throws FileNotFoundException {
102     public Bitmap fitInSpace(final String path, final int width, final int height) throws FileNotFoundException {
112     public Bitmap loadApproximate(String path, int width, int height) throws FileNotFoundException {
122         Bitmap result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
196     public Bitmap loadAsIs(final String path, final int width, final int height) throws FileNotFoundException {
207     public Bitmap loadAsIs(final String path) throws FileNotFoundException {
224     private Bitmap load(String path, Bitmap recycle) throws FileNotFoundException {
253     private int[] getDimensions(String path) throws FileNotFoundException {
273     private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) throws FileNotFoundException {
82     public Bitmap centerCrop(final String path, final int width, final int height){
102     public Bitmap fitInSpace(final String path, final int width, final int height){
112     public Bitmap loadApproximate(String path, int width, int height) {
122         Bitmap result = null;
123         try {
124             result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
125         } catch (FileNotFoundException e) {
126             e.printStackTrace();
127         }
201     public Bitmap loadAsIs(final String path, final int width, final int height) {
212     public Bitmap loadAsIs(final String path){
229     private Bitmap load(String path, Bitmap recycle) {
258     private int[] getDimensions(String path) {
278     private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) {
284         } catch (FileNotFoundException e) {
285             e.printStackTrace();",No
library\src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\photos\resize\loader\Approximate.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -31,7 +31,7 @@ public class Approximate<T> extends ImageManagerLoader<T> {
 
             @Override
             public void onLoadFailed(Exception e) {
-                cb.onError(e);
+                cb.onException(e);
             }
         });
     }
","34                 cb.onException(e);
34                 cb.onError(e);",No
library\src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\photos\resize\loader\AsIs.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -28,7 +28,7 @@ public class AsIs<T> extends ImageManagerLoader<T> {
 
             @Override
             public void onLoadFailed(Exception e) {
-                cb.onError(e);
+                cb.onException(e);
             }
         });
     }
","31                 cb.onException(e);
31                 cb.onError(e);",No
library\src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\photos\resize\loader\CenterCrop.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -29,7 +29,7 @@ public class CenterCrop<T> extends ImageManagerLoader<T> {
 
             @Override
             public void onLoadFailed(Exception e) {
-                cb.onError(e);
+                cb.onException(e);
             }
         });
     }
","32                 cb.onException(e);
32                 cb.onError(e);",No
library\src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\photos\resize\loader\Exact.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -32,7 +32,7 @@ public class Exact<T> extends ImageManagerLoader<T> {
 
             @Override
             public void onLoadFailed(Exception e) {
-                cb.onError(e);
+                cb.onException(e);
             }
         });
     }
","35                 cb.onException(e);
35                 cb.onError(e);",No
library\src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\photos\resize\loader\FitCenter.java,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,d9bf71390f35d5311b7b9fcde7c89dc0d4a36bea,Pass exceptions up and handle in presenter/loaders,"@@ -30,7 +30,7 @@ public class FitCenter<T> extends ImageManagerLoader<T> {
 
             @Override
             public void onLoadFailed(Exception e) {
-                cb.onError(e);
+                cb.onException(e);
             }
         });
     }
","33                 cb.onException(e);
33                 cb.onError(e);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,70fd3bd514ec623235d4f0432d26e5025e7103a4,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,"Rename loadApproximate loadAtLeast for clarity

Hopefully a little easier to tell what it does.
Also updates some documentation","@@ -328,7 +328,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.loadApproximate(path, width, height);
+                return resizer.loadAtLeast(path, width, height);
             }
         });
     }
","331                 return resizer.loadAtLeast(path, width, height);
331                 return resizer.loadApproximate(path, width, height);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,70fd3bd514ec623235d4f0432d26e5025e7103a4,411eee0e6eeb6b2ba9fc4d9ceba2aaffe9d1a73a,"Rename loadApproximate loadAtLeast for clarity

Hopefully a little easier to tell what it does.
Also updates some documentation","@@ -80,12 +80,12 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap centerCrop(final String path, final int width, final int height) throws FileNotFoundException {
-        final Bitmap streamed = loadApproximate(path, width, height);
+        final Bitmap streamed = loadAtLeast(path, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
     public Bitmap centerCrop(InputStream is1, InputStream is2, int width, int height) {
-        final Bitmap streamed = loadApproximate(is1, is2, width, height);
+        final Bitmap streamed = loadAtLeast(is1, is2, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
@@ -100,16 +100,29 @@ public class ImageResizer {
      * @return The resized image
      */
     public Bitmap fitInSpace(final String path, final int width, final int height) throws FileNotFoundException {
-        final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
+        final Bitmap streamed = loadAtLeast(path, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
     public Bitmap fitInSpace(InputStream is1, InputStream is2, int width, int height) {
-        final Bitmap streamed = loadApproximate(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
+        final Bitmap streamed = loadAtLeast(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
-    public Bitmap loadApproximate(String path, int width, int height) throws FileNotFoundException {
+    /**
+     * Load the image at the given path with dimens greater than or equal to the given dimens. If the image has a
+     * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
+     *
+     * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
+     * be enlarged and will instead be loaded at its original dimens.
+     *
+     * @param path The path to the image
+     * @param width The minimum width of the returned Bitmap
+     * @param height The minimum heght of the returned Bitmap
+     * @return
+     * @throws FileNotFoundException
+     */
+    public Bitmap loadAtLeast(String path, int width, int height) throws FileNotFoundException {
         int orientation = getOrientation(path);
         if(orientation == 90 || orientation == 270) {
             //Swap width and height for initial downsample calculation if its oriented so.
@@ -119,7 +132,7 @@ public class ImageResizer {
             height = w;
         }
 
-        Bitmap result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
+        Bitmap result = loadAtLeast(new FileInputStream(path), new FileInputStream(path), width, height);
 
         if (orientation != 0) {
             result = rotateImage(result, orientation);
@@ -128,24 +141,25 @@ public class ImageResizer {
     }
 
     /**
-     * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
-     * rotate the image according to the orientation in the images EXIF data if available.
+     * Load the image represented by the given input streams with dimens greater than or equal to the given dimens.
+     * Maintains the original proportions.
      *
-     * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
+     * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
+     * be enlarged and will instead be loaded at its original dimens.
      *
      * @param is1 An inputStream for the image. Can't be is2
      * @param is2 An inputStream for the image. Can't be is1
-     * @param width The target width
-     * @param height The target height
+     * @param width The minimum width of the returned Bitmap
+     * @param height The minimum height of the returned Bitmap
      * @return A Bitmap containing the image
      */
-    public Bitmap loadApproximate(InputStream is1, InputStream is2, int width, int height) {
+    public Bitmap loadAtLeast(InputStream is1, InputStream is2, int width, int height) {
         final int[] dimens = getDimensions(is1);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-        int sampleSize = Math.min(originalHeight / height, originalWidth / width);
+        final int sampleSize = Math.min(originalHeight / height, originalWidth / width);
 
         final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
","83         final Bitmap streamed = loadAtLeast(path, width, height);
88         final Bitmap streamed = loadAtLeast(is1, is2, width, height);
103         final Bitmap streamed = loadAtLeast(path, width > height ? 1 : width, height > width ? 1 : height);
108         final Bitmap streamed = loadAtLeast(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
112     /**
113      * Load the image at the given path with dimens greater than or equal to the given dimens. If the image has a
114      * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
115      *
116      * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
117      * be enlarged and will instead be loaded at its original dimens.
118      *
119      * @param path The path to the image
120      * @param width The minimum width of the returned Bitmap
121      * @param height The minimum heght of the returned Bitmap
122      * @return
123      * @throws FileNotFoundException
124      */
125     public Bitmap loadAtLeast(String path, int width, int height) throws FileNotFoundException {
135         Bitmap result = loadAtLeast(new FileInputStream(path), new FileInputStream(path), width, height);
144      * Load the image represented by the given input streams with dimens greater than or equal to the given dimens.
145      * Maintains the original proportions.
147      * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
148      * be enlarged and will instead be loaded at its original dimens.
152      * @param width The minimum width of the returned Bitmap
153      * @param height The minimum height of the returned Bitmap
156     public Bitmap loadAtLeast(InputStream is1, InputStream is2, int width, int height) {
162         final int sampleSize = Math.min(originalHeight / height, originalWidth / width);
83         final Bitmap streamed = loadApproximate(path, width, height);
88         final Bitmap streamed = loadApproximate(is1, is2, width, height);
103         final Bitmap streamed = loadApproximate(path, width > height ? 1 : width, height > width ? 1 : height);
108         final Bitmap streamed = loadApproximate(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
112     public Bitmap loadApproximate(String path, int width, int height) throws FileNotFoundException {
122         Bitmap result = loadApproximate(new FileInputStream(path), new FileInputStream(path), width, height);
131      * Load the image at the given path at nearly the given dimensions maintaining the original proportions. Will also
132      * rotate the image according to the orientation in the images EXIF data if available.
134      * from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first
138      * @param width The target width
139      * @param height The target height
142     public Bitmap loadApproximate(InputStream is1, InputStream is2, int width, int height) {
148         int sampleSize = Math.min(originalHeight / height, originalWidth / width);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,b8652f6e25e0f5d61640d7055ff0c8b4a7ccec55,70fd3bd514ec623235d4f0432d26e5025e7103a4,Add a load at most method,"@@ -164,11 +164,58 @@ public class ImageResizer {
         final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
-        Bitmap result = decodeStream(is2, decodeBitmapOptions);
+        return decodeStream(is2, decodeBitmapOptions);
+    }
+
+    /**
+     * Load the image at the given path with dimens less than or equal to the given dimens. If the image has a
+     * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
+     *
+     * @param path The path to the image
+     * @param width The maximum width of the returned Bitmap
+     * @param height The maximum height of the returned Bitmap
+     * @return A Bitmap containing the image
+     * @throws FileNotFoundException
+     */
+    public Bitmap loadAtMost(String path, int width, int height) throws FileNotFoundException {
+        int orientation = getOrientation(path);
+        if (orientation == 90 || orientation == 270) {
+            int w = width;
+            width = height;
+            height = w;
+        }
+
+        Bitmap result = loadAtMost(new FileInputStream(path), new FileInputStream(path), width, height);
+
+        if (orientation != 0) {
+            result = rotateImage(result, orientation);
+        }
 
         return result;
     }
 
+    /**
+     * Load the image represented by the given input streams with dimens less than or equal to the given dimens.
+     * Maintains the original proportions.
+     *
+     * @param is1 An InputStream for the image. Can't be is2
+     * @param is2 An InputStream for the image. Can't be ss1
+     * @param width The maximum width
+     * @param height The maximum height
+     * @return A bitmap containing the image
+     */
+    public Bitmap loadAtMost(InputStream is1, InputStream is2, int width, int height) {
+        final int[] dimens = getDimensions(is1);
+        final int originalWidth = dimens[0];
+        final int originalHeight = dimens[1];
+
+        final int sampleSize = Math.max(originalHeight / height, originalWidth / width);
+        final BitmapFactory.Options decodeBitmapOptions = getOptions();
+        decodeBitmapOptions.inSampleSize = sampleSize;
+
+        return decodeStream(is2, decodeBitmapOptions);
+    }
+
     /**
      * Load the image represented by the given InputStreams at its original size. Use the first InputStream to
      * try to determine the proportions of the image so that we can try to retrieve a recycled Bitmap of the correct
","167         return decodeStream(is2, decodeBitmapOptions);
168     }
169 
170     /**
171      * Load the image at the given path with dimens less than or equal to the given dimens. If the image has a
172      * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
173      *
174      * @param path The path to the image
175      * @param width The maximum width of the returned Bitmap
176      * @param height The maximum height of the returned Bitmap
177      * @return A Bitmap containing the image
178      * @throws FileNotFoundException
179      */
180     public Bitmap loadAtMost(String path, int width, int height) throws FileNotFoundException {
181         int orientation = getOrientation(path);
182         if (orientation == 90 || orientation == 270) {
183             int w = width;
184             width = height;
185             height = w;
186         }
187 
188         Bitmap result = loadAtMost(new FileInputStream(path), new FileInputStream(path), width, height);
189 
190         if (orientation != 0) {
191             result = rotateImage(result, orientation);
192         }
197     /**
198      * Load the image represented by the given input streams with dimens less than or equal to the given dimens.
199      * Maintains the original proportions.
200      *
201      * @param is1 An InputStream for the image. Can't be is2
202      * @param is2 An InputStream for the image. Can't be ss1
203      * @param width The maximum width
204      * @param height The maximum height
205      * @return A bitmap containing the image
206      */
207     public Bitmap loadAtMost(InputStream is1, InputStream is2, int width, int height) {
208         final int[] dimens = getDimensions(is1);
209         final int originalWidth = dimens[0];
210         final int originalHeight = dimens[1];
211 
212         final int sampleSize = Math.max(originalHeight / height, originalWidth / width);
213         final BitmapFactory.Options decodeBitmapOptions = getOptions();
214         decodeBitmapOptions.inSampleSize = sampleSize;
215 
216         return decodeStream(is2, decodeBitmapOptions);
217     }
218 
167         Bitmap result = decodeStream(is2, decodeBitmapOptions);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,51535aa1d870c8e097711673fb4ccc6aa7e35f99,b8652f6e25e0f5d61640d7055ff0c8b4a7ccec55,Code cleanup (spacing/old comments etc),"@@ -428,10 +428,8 @@ public class ImageResizer {
         to.inScaled = from.inScaled;
         to.inScreenDensity = from.inScreenDensity;
         to.inTargetDensity = from.inTargetDensity;
-
     }
 
-
     /**
      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
      * the original proportions of the image
@@ -529,8 +527,6 @@ public class ImageResizer {
         return cropped;
     }
 
-    //shrinks to the given width, shrinking the height to maintain the original image proportions
-
     /**
      * An expensive operation to resize the given image, maintaining the original proportions, so that its width
      * matches the given width
@@ -657,8 +653,4 @@ public class ImageResizer {
         }
         return imageToOrient;
     }
-
-
-
-
 }
","431 
434 
532     //shrinks to the given width, shrinking the height to maintain the original image proportions
533 
660 
661 
662 
663 ",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,6b909bbe47e21c78c42a1337ca45b8950ba08c60,51535aa1d870c8e097711673fb4ccc6aa7e35f99,Catch rejected execution exceptions,"@@ -24,6 +24,7 @@ import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
 
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
@@ -527,6 +528,7 @@ public class ImageManager {
 
             if (result == null) {
                 if (cancelled) return;
+                try {
                     future = executor.submit(new Runnable() {
                         @Override
                         public void run() {
@@ -538,6 +540,12 @@ public class ImageManager {
                             }
                         }
                     });
+                //in almost every case will be because of race after calling shutdown. Not much we can do
+                //either way
+                } catch (RejectedExecutionException e) {
+                    e.printStackTrace();
+                    cb.onLoadFailed(e);
+                }
             } else {
                 finishResize(result, isInDiskCache);
             }
","27 import java.util.concurrent.RejectedExecutionException;
531                 try {
543                 //in almost every case will be because of race after calling shutdown. Not much we can do
544                 //either way
545                 } catch (RejectedExecutionException e) {
546                     e.printStackTrace();
547                     cb.onLoadFailed(e);
548                 }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,71cfbc2b968c8bfaf42ce8a5f75a6bdd877ffa3e,6b909bbe47e21c78c42a1337ca45b8950ba08c60,Add input stream based api to ImageManager,"@@ -19,6 +19,7 @@ import com.bumptech.photos.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
@@ -296,6 +297,16 @@ public class ImageManager {
         });
     }
 
+    public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
+        final int key = getKey(id, -1, -1, ResizeType.AS_IS);
+        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+            @Override
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+                return resizer.loadAsIs(is1, is2);
+            }
+        });
+    }
+
     /**
      * Loads the image for the given path assuming its width and height are exactly those given.
      *
@@ -315,6 +326,16 @@ public class ImageManager {
         });
     }
 
+    public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
+        final int key = getKey(id, width, height, ResizeType.AS_IS);
+        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+            @Override
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+                return resizer.loadAsIs(is, width, height);
+            }
+        });
+    }
+
     /**
      * Loads the image for the given path to nearly the given width and height maintaining the original proportions.
      *
@@ -334,6 +355,17 @@ public class ImageManager {
         });
     }
 
+    public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
+        final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
+            @Override
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+                return resizer.loadAtLeast(is1, is2, width, height);
+            }
+        });
+    }
+
+
     /**
      * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
      * and then returns a section from the center of image exactly height pixels tall.
@@ -354,6 +386,16 @@ public class ImageManager {
         });
     }
 
+    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
+        final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
+            @Override
+            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+                return resizer.centerCrop(is1, is2, width, height);
+            }
+        });
+    }
+
     /**
      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
      * an area of width*height.
","22 import java.io.InputStream;
300     public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
301         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
302         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
303             @Override
304             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
305                 return resizer.loadAsIs(is1, is2);
306             }
307         });
308     }
309 
329     public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
330         final int key = getKey(id, width, height, ResizeType.AS_IS);
331         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
332             @Override
333             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
334                 return resizer.loadAsIs(is, width, height);
335             }
336         });
337     }
338 
358     public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
359         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
360         return runJob(key, cb, new ImageManagerJob(key, cb) {
361             @Override
362             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
363                 return resizer.loadAtLeast(is1, is2, width, height);
364             }
365         });
366     }
367 
368 
389     public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
390         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
391         return runJob(key, cb, new ImageManagerJob(key, cb) {
392             @Override
393             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
394                 return resizer.centerCrop(is1, is2, width, height);
395             }
396         });
397     }
398 ",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,71cfbc2b968c8bfaf42ce8a5f75a6bdd877ffa3e,6b909bbe47e21c78c42a1337ca45b8950ba08c60,Add input stream based api to ImageManager,"@@ -240,6 +240,10 @@ public class ImageResizer {
         return load(is2, getRecycled(dimens));
     }
 
+    public Bitmap loadAsIs(InputStream is, int width, int height) {
+        return load(is, getRecycled(width, height));
+    }
+
     /**
      * Load the image at the given path at its original size. Assume that the dimensions of the image at the given path
      * will match the given dimensions and use the given dimensions to retrieve a recycled Bitmap of the correct size.
","243     public Bitmap loadAsIs(InputStream is, int width, int height) {
244         return load(is, getRecycled(width, height));
245     }
246 ",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,2cecf0c45346ae0602680003d98817605b2c8e77,71cfbc2b968c8bfaf42ce8a5f75a6bdd877ffa3e,"Clear image presenter when get a null model

Resets the placeholder and cancels old load. 
Probably makes more sense than doing nothing 
and allowing the old load to complete","@@ -260,8 +260,9 @@ public class ImagePresenter<T> {
      * @param model The model containing the information required to load a path and/or bitmap
      */
     public void setModel(final T model) {
-        if (model == null || model.equals(currentModel)) return;
-
+        if (model == null) {
+            clear();
+        } else if (!model.equals(currentModel)) {
             loadedFromCache = true;
             final int loadCount = ++currentCount;
             currentModel = model;
@@ -280,6 +281,7 @@ public class ImagePresenter<T> {
                 resetPlaceHolder();
             }
         }
+    }
 
 
     /**
","263         if (model == null) {
264             clear();
265         } else if (!model.equals(currentModel)) {
284     }
263         if (model == null || model.equals(currentModel)) return;
264 ",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,e89a880b0fbffa78ef37299e3fc3068c4c7f554a,2cecf0c45346ae0602680003d98817605b2c8e77,Fix memory leak in ImagePresenter/SizeDeterminer,"@@ -392,8 +392,8 @@ public class ImagePresenter<T> {
                     width = view.getWidth();
                     height = view.getHeight();
                     cb.onSizeReady(width, height);
-                    cb = null;
                 }
+                cb = null;
             }
         };
 
@@ -407,14 +407,16 @@ public class ImagePresenter<T> {
 
             @Override
             public void onGlobalLayout() {
-                final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
-                if (sizeDeterminer != null) {
+                if (sizeDeterminerRef.get() != null) {
                     handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
                     handler.postAtTime(new Runnable() {
                         @Override
                         public void run() {
+                            final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+                            if (sizeDeterminer != null) {
                                 sizeDeterminer.maybeInvalidate();
                             }
+                        }
                     }, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
                 }
             }
","396                 cb = null;
410                 if (sizeDeterminerRef.get() != null) {
415                             final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
416                             if (sizeDeterminer != null) {
419                         }
395                     cb = null;
410                 final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
411                 if (sizeDeterminer != null) {",No
library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,5652d207f3c538353301a0bc22065b8de3f992f5,e89a880b0fbffa78ef37299e3fc3068c4c7f554a,Use a dequeue instead of linked list in sbc,"@@ -7,8 +7,8 @@ package com.bumptech.photos.resize.cache;
 import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
 
+import java.util.ArrayDeque;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 
@@ -26,30 +26,27 @@ public class SizedBitmapCache {
 
     public synchronized void put(Bitmap bitmap) {
         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
-        Queue<Bitmap> available;
-        available = availableBitmaps.get(sizeKey);
+        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
         if (available == null) {
-            available = new LinkedList<Bitmap>();
+            available = new ArrayDeque<Bitmap>();
             availableBitmaps.put(sizeKey, available);
         }
 
         if (available.size() < maxPerSize) {
-            available.add(bitmap);
+            available.offer(bitmap);
         }
     }
 
     public synchronized Bitmap get(int width, int height) {
         final String sizeKey = getSizeKey(width, height);
-        final Queue<Bitmap> available;
+        final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
 
-         available = availableBitmaps.get(sizeKey);
-
-        if (available == null || available.size() == 0) {
+        if (available == null) {
             Log.d(""SBC: missing bitmap for key= "" + sizeKey);
             return null;
         } else {
             //Log.d(""SBC:  get key="" + sizeKey + "" available="" + (available.size() - 1));
-            return available.remove();
+            return available.poll();
         }
     }
 
","10 import java.util.ArrayDeque;
29         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
31             available = new ArrayDeque<Bitmap>();
36             available.offer(bitmap);
42         final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
44         if (available == null) {
49             return available.poll();
11 import java.util.LinkedList;
29         Queue<Bitmap> available;
30         available = availableBitmaps.get(sizeKey);
32             available = new LinkedList<Bitmap>();
37             available.add(bitmap);
43         final Queue<Bitmap> available;
45          available = availableBitmaps.get(sizeKey);
46 
47         if (available == null || available.size() == 0) {
52             return available.remove();",No
,library\src\com\bumptech\photos\resize\BitmapTracker.java,cdd5d2d1ccd23f74c8a42887d409ddfe150c2201,5652d207f3c538353301a0bc22065b8de3f992f5,Add an external class to track bitmap references,"@@ -0,0 +1,94 @@
+package com.bumptech.photos.resize;
+
+import android.graphics.Bitmap;
+import com.bumptech.photos.resize.cache.SizedBitmapCache;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/4/13
+ * Time: 9:54 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class BitmapTracker {
+    private final SizedBitmapCache target;
+    private final BitmapReferenceCounter counter = new BitmapReferenceCounter();
+    private final Set<Integer> pending = new HashSet<Integer>();
+
+    public BitmapTracker(SizedBitmapCache target) {
+        this.target = target;
+    }
+
+    public synchronized void acquireBitmap(Bitmap bitmap) {
+        final int hashCode = bitmap.hashCode();
+        pending.remove(hashCode);
+        counter.inc(hashCode);
+    }
+
+    public synchronized void releaseBitmap(Bitmap bitmap) {
+        final int hashCode = bitmap.hashCode();
+        if (counter.dec(hashCode) == 0 && !pending.contains(hashCode)) {
+            counter.rem(hashCode);
+            target.put(bitmap);
+        }
+    }
+
+    public synchronized void rejectBitmap(Bitmap bitmap) {
+        final int hashCode = bitmap.hashCode();
+        pending.remove(hashCode);
+        if (counter.get(hashCode) == 0) {
+            counter.rem(hashCode);
+            target.put(bitmap);
+        }
+    }
+
+    public synchronized void markPending(Bitmap bitmap) {
+        final int hashCode = bitmap.hashCode();
+        pending.add(hashCode);
+    }
+
+    private class BitmapReferenceCounter {
+        private final Map<Integer, Integer> counter = new HashMap<Integer, Integer>();
+
+        public void inc(int hashCode) {
+            Integer currentCount = counter.get(hashCode);
+            if (currentCount == null) {
+                currentCount = 0;
+            }
+            counter.put(hashCode, currentCount + 1);
+        }
+
+        public int dec(int hashCode) {
+            Integer currentCount = counter.get(hashCode);
+            if (currentCount == null) {
+                throw new IllegalArgumentException(""Can't decrement null count bitmap="" + hashCode);
+            }
+
+            currentCount--;
+
+            counter.put(hashCode, currentCount);
+
+            return currentCount;
+        }
+
+        public int get(int hashCode) {
+            Integer currentCount = counter.get(hashCode);
+
+            if (currentCount == null) {
+                currentCount = 0;
+            }
+
+            return currentCount;
+        }
+
+        public void rem(int hashCode) {
+            counter.remove(hashCode);
+        }
+
+    }
+}
","1 package com.bumptech.photos.resize;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.photos.resize.cache.SizedBitmapCache;
5 
6 import java.util.HashMap;
7 import java.util.HashSet;
8 import java.util.Map;
9 import java.util.Set;
10 
11 /**
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 6/4/13
15  * Time: 9:54 AM
16  * To change this template use File | Settings | File Templates.
17  */
18 public class BitmapTracker {
19     private final SizedBitmapCache target;
20     private final BitmapReferenceCounter counter = new BitmapReferenceCounter();
21     private final Set<Integer> pending = new HashSet<Integer>();
22 
23     public BitmapTracker(SizedBitmapCache target) {
24         this.target = target;
25     }
26 
27     public synchronized void acquireBitmap(Bitmap bitmap) {
28         final int hashCode = bitmap.hashCode();
29         pending.remove(hashCode);
30         counter.inc(hashCode);
31     }
32 
33     public synchronized void releaseBitmap(Bitmap bitmap) {
34         final int hashCode = bitmap.hashCode();
35         if (counter.dec(hashCode) == 0 && !pending.contains(hashCode)) {
36             counter.rem(hashCode);
37             target.put(bitmap);
38         }
39     }
40 
41     public synchronized void rejectBitmap(Bitmap bitmap) {
42         final int hashCode = bitmap.hashCode();
43         pending.remove(hashCode);
44         if (counter.get(hashCode) == 0) {
45             counter.rem(hashCode);
46             target.put(bitmap);
47         }
48     }
49 
50     public synchronized void markPending(Bitmap bitmap) {
51         final int hashCode = bitmap.hashCode();
52         pending.add(hashCode);
53     }
54 
55     private class BitmapReferenceCounter {
56         private final Map<Integer, Integer> counter = new HashMap<Integer, Integer>();
57 
58         public void inc(int hashCode) {
59             Integer currentCount = counter.get(hashCode);
60             if (currentCount == null) {
61                 currentCount = 0;
62             }
63             counter.put(hashCode, currentCount + 1);
64         }
65 
66         public int dec(int hashCode) {
67             Integer currentCount = counter.get(hashCode);
68             if (currentCount == null) {
69                 throw new IllegalArgumentException(""Can't decrement null count bitmap="" + hashCode);
70             }
71 
72             currentCount--;
73 
74             counter.put(hashCode, currentCount);
75 
76             return currentCount;
77         }
78 
79         public int get(int hashCode) {
80             Integer currentCount = counter.get(hashCode);
81 
82             if (currentCount == null) {
83                 currentCount = 0;
84             }
85 
86             return currentCount;
87         }
88 
89         public void rem(int hashCode) {
90             counter.remove(hashCode);
91         }
92 
93     }
94 }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,cdd5d2d1ccd23f74c8a42887d409ddfe150c2201,5652d207f3c538353301a0bc22065b8de3f992f5,Add an external class to track bitmap references,"@@ -20,8 +20,6 @@ import com.bumptech.photos.util.Util;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -39,6 +37,7 @@ import java.util.concurrent.RejectedExecutionException;
 public class ImageManager {
     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
+    private final BitmapTracker bitmapTracker;
 
     /**
      * A class for setting options for an ImageManager
@@ -117,10 +116,8 @@ public class ImageManager {
     private final ExecutorService executor;
     private final LruPhotoCache memoryCache;
     private final ImageResizer resizer;
-    private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
     private final SizedBitmapCache bitmapCache;
     private final DiskCache diskCache;
-    private final boolean isBitmapRecyclingEnabled;
     private final Bitmap.CompressFormat diskCacheFormat;
 
     private enum ResizeType {
@@ -236,7 +233,6 @@ public class ImageManager {
         bgHandler = new Handler(bgThread.getLooper());
         executor = resizeService;
 
-        isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
 
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
@@ -260,7 +256,7 @@ public class ImageManager {
             memoryCache = new LruPhotoCache(options.maxMemorySize);
         }
 
-        if (isBitmapRecyclingEnabled) {
+        if (options.recycleBitmaps && CAN_RECYCLE) {
             if (memoryCache != null) {
                 memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
                     @Override
@@ -270,13 +266,14 @@ public class ImageManager {
                 });
             }
             bitmapCache = new SizedBitmapCache(options.maxPerSize);
+            bitmapTracker = new BitmapTracker(bitmapCache);
         } else {
             if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
             bitmapCache = null;
+            bitmapTracker = null;
         }
 
-
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
     }
 
@@ -423,21 +420,8 @@ public class ImageManager {
      * @param b The rejected Bitmap
      */
     public void rejectBitmap(final Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        final Bitmap bitmap = b;
-        final int hashCode = b.hashCode();
-        final boolean addToCache;
-        synchronized (bitmapReferenceCounter) {
-            final Integer currentCount = bitmapReferenceCounter.get(hashCode);
-            addToCache = currentCount == null || currentCount == 0;
-            if (addToCache) {
-                bitmapReferenceCounter.remove(hashCode);
-            }
-        }
-        if (addToCache) {
-            bitmapCache.put(bitmap);
-        }
+        if (bitmapTracker == null) return;
+        bitmapTracker.rejectBitmap(b);
     }
 
     /**
@@ -449,16 +433,8 @@ public class ImageManager {
      * @param b The acquired Bitmap
      */
     public void acquireBitmap(Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        final int hashCode = b.hashCode();
-        synchronized (bitmapReferenceCounter) {
-            Integer currentCount = bitmapReferenceCounter.get(hashCode);
-            if (currentCount == null) {
-                currentCount = 0;
-            }
-            bitmapReferenceCounter.put(hashCode, currentCount + 1);
-        }
+        if (bitmapTracker == null) return;
+        bitmapTracker.acquireBitmap(b);
     }
 
     /**
@@ -470,18 +446,8 @@ public class ImageManager {
      * @param b The releasedBitmap
      */
     public void releaseBitmap(final Bitmap b) {
-        if (!isBitmapRecyclingEnabled) return;
-
-        final Bitmap bitmap = b;
-        final int hash = b.hashCode();
-        synchronized (bitmapReferenceCounter) {
-            Integer currentCount = bitmapReferenceCounter.get(hash) - 1;
-            if (currentCount == 0) {
-                bitmapReferenceCounter.remove(hash);
-                bitmapCache.put(bitmap);
-            } else {
-                bitmapReferenceCounter.put(hash, currentCount);
-            }
+        if (bitmapTracker == null) return;
+        bitmapTracker.releaseBitmap(b);
     }
     }
 
","40     private final BitmapTracker bitmapTracker;
259         if (options.recycleBitmaps && CAN_RECYCLE) {
269             bitmapTracker = new BitmapTracker(bitmapCache);
274             bitmapTracker = null;
423         if (bitmapTracker == null) return;
424         bitmapTracker.rejectBitmap(b);
436         if (bitmapTracker == null) return;
437         bitmapTracker.acquireBitmap(b);
449         if (bitmapTracker == null) return;
450         bitmapTracker.releaseBitmap(b);
23 import java.util.HashMap;
24 import java.util.Map;
120     private final Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();
123     private final boolean isBitmapRecyclingEnabled;
239         isBitmapRecyclingEnabled = options.recycleBitmaps && CAN_RECYCLE;
263         if (isBitmapRecyclingEnabled) {
279 
426         if (!isBitmapRecyclingEnabled) return;
427 
428         final Bitmap bitmap = b;
429         final int hashCode = b.hashCode();
430         final boolean addToCache;
431         synchronized (bitmapReferenceCounter) {
432             final Integer currentCount = bitmapReferenceCounter.get(hashCode);
433             addToCache = currentCount == null || currentCount == 0;
434             if (addToCache) {
435                 bitmapReferenceCounter.remove(hashCode);
436             }
437         }
438         if (addToCache) {
439             bitmapCache.put(bitmap);
440         }
452         if (!isBitmapRecyclingEnabled) return;
453 
454         final int hashCode = b.hashCode();
455         synchronized (bitmapReferenceCounter) {
456             Integer currentCount = bitmapReferenceCounter.get(hashCode);
457             if (currentCount == null) {
458                 currentCount = 0;
459             }
460             bitmapReferenceCounter.put(hashCode, currentCount + 1);
461         }
473         if (!isBitmapRecyclingEnabled) return;
474 
475         final Bitmap bitmap = b;
476         final int hash = b.hashCode();
477         synchronized (bitmapReferenceCounter) {
478             Integer currentCount = bitmapReferenceCounter.get(hash) - 1;
479             if (currentCount == 0) {
480                 bitmapReferenceCounter.remove(hash);
481                 bitmapCache.put(bitmap);
482             } else {
483                 bitmapReferenceCounter.put(hash, currentCount);
484             }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,a42166e132f6902051a583e8aff6aca9b8f71e4c,cdd5d2d1ccd23f74c8a42887d409ddfe150c2201,Fix race causing bitmaps to be recycled 2+ times,"@@ -449,6 +449,22 @@ public class ImageManager {
         if (bitmapTracker == null) return;
         bitmapTracker.releaseBitmap(b);
     }
+
+    /**
+     * An internal method notifying the tracker that this bitmap is referenced but not necessarily used
+     * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
+     * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
+     * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
+     * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
+     * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
+     * recycled once by the memory cache and then again by the object owning the callback.
+     *
+     * @param b The bitmap to mark
+     */
+    private void markBitmapPending(final Bitmap b) {
+        if (bitmapTracker == null) return;
+
+        bitmapTracker.markPending(b);
     }
 
     public void cancelTask(Object token) {
@@ -609,6 +625,7 @@ public class ImageManager {
             synchronized (memoryCache) {
                 if (!memoryCache.contains(key)) {
                     acquireBitmap(bitmap);
+                    markBitmapPending(bitmap);
                     memoryCache.put(key, bitmap);
                 }
             }
","452 
453     /**
454      * An internal method notifying the tracker that this bitmap is referenced but not necessarily used
455      * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
456      * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
457      * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
458      * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
459      * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
460      * recycled once by the memory cache and then again by the object owning the callback.
461      *
462      * @param b The bitmap to mark
463      */
464     private void markBitmapPending(final Bitmap b) {
465         if (bitmapTracker == null) return;
466 
467         bitmapTracker.markPending(b);
628                     markBitmapPending(bitmap);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,6e1e771e040ad99be5953c307765ca385c4a35ed,a42166e132f6902051a583e8aff6aca9b8f71e4c,Remove a uneccessary var,"@@ -575,20 +575,18 @@ public class ImageManager {
             }
         }
 
-        private void finishResize(Bitmap result, boolean isInDiskCache) {
+        private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
                     putInDiskCache(key, result);
                 }
 
-                final Bitmap finalResult = result;
-                putInMemoryCache(key, finalResult);
+                putInMemoryCache(key, result);
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
-                        cb.onLoadCompleted(finalResult);
+                        cb.onLoadCompleted(result);
                     }
-
                 });
             }
 
","578         private void finishResize(final Bitmap result, boolean isInDiskCache) {
584                 putInMemoryCache(key, result);
588                         cb.onLoadCompleted(result);
578         private void finishResize(Bitmap result, boolean isInDiskCache) {
584                 final Bitmap finalResult = result;
585                 putInMemoryCache(key, finalResult);
589                         cb.onLoadCompleted(finalResult);
591 ",No
library\src\com\bumptech\photos\resize\BitmapTracker.java,library\src\com\bumptech\photos\resize\BitmapTracker.java,2a2882e26b572d6d69939ac553cd840059caee3a,6e1e771e040ad99be5953c307765ca385c4a35ed,Use per bitmap obj instead of map for ref tracking,"@@ -3,10 +3,9 @@ package com.bumptech.photos.resize;
 import android.graphics.Bitmap;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
 
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * Created with IntelliJ IDEA.
@@ -16,79 +15,95 @@ import java.util.Set;
  * To change this template use File | Settings | File Templates.
  */
 public class BitmapTracker {
-    private final SizedBitmapCache target;
-    private final BitmapReferenceCounter counter = new BitmapReferenceCounter();
-    private final Set<Integer> pending = new HashSet<Integer>();
 
-    public BitmapTracker(SizedBitmapCache target) {
-        this.target = target;
+    private static class InnerTrackerPool {
+        private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
+
+        public InnerTracker get() {
+            InnerTracker result = pool.poll();
+            if (result == null) {
+                result = new InnerTracker();
             }
 
-    public synchronized void acquireBitmap(Bitmap bitmap) {
-        final int hashCode = bitmap.hashCode();
-        pending.remove(hashCode);
-        counter.inc(hashCode);
+            return result;
         }
 
-    public synchronized void releaseBitmap(Bitmap bitmap) {
-        final int hashCode = bitmap.hashCode();
-        if (counter.dec(hashCode) == 0 && !pending.contains(hashCode)) {
-            counter.rem(hashCode);
-            target.put(bitmap);
+        public void release(InnerTracker innerTracker) {
+            pool.offer(innerTracker);
         }
     }
 
-    public synchronized void rejectBitmap(Bitmap bitmap) {
-        final int hashCode = bitmap.hashCode();
-        pending.remove(hashCode);
-        if (counter.get(hashCode) == 0) {
-            counter.rem(hashCode);
-            target.put(bitmap);
+    private static class InnerTracker {
+        private volatile int refs = 0;
+        private volatile boolean pending = false;
+
+        public void acquire() {
+            pending = false;
+            synchronized (this) {
+                refs++;
             }
         }
 
-    public synchronized void markPending(Bitmap bitmap) {
-        final int hashCode = bitmap.hashCode();
-        pending.add(hashCode);
+        public boolean release() {
+            synchronized (this) {
+                refs--;
             }
 
-    private class BitmapReferenceCounter {
-        private final Map<Integer, Integer> counter = new HashMap<Integer, Integer>();
-
-        public void inc(int hashCode) {
-            Integer currentCount = counter.get(hashCode);
-            if (currentCount == null) {
-                currentCount = 0;
+            return refs == 0 && !pending;
         }
-            counter.put(hashCode, currentCount + 1);
+
+        public boolean reject() {
+            pending = false;
+            return refs == 0;
         }
 
-        public int dec(int hashCode) {
-            Integer currentCount = counter.get(hashCode);
-            if (currentCount == null) {
-                throw new IllegalArgumentException(""Can't decrement null count bitmap="" + hashCode);
+        public void markPending() {
+            pending = true;
+        }
     }
 
-            currentCount--;
+    private final Map<Integer, InnerTracker> counter;
+    private final SizedBitmapCache target;
+    private final InnerTrackerPool pool = new InnerTrackerPool();
 
-            counter.put(hashCode, currentCount);
+    public BitmapTracker(SizedBitmapCache target, int bitmapsPerSize) {
+        this.target = target;
+        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
+    }
 
-            return currentCount;
+    public void initBitmap(Bitmap toInit) {
+        counter.put(toInit.hashCode(), pool.get());
     }
 
-        public int get(int hashCode) {
-            Integer currentCount = counter.get(hashCode);
+    public void acquireBitmap(Bitmap bitmap) {
+        get(bitmap).acquire();
+    }
 
-            if (currentCount == null) {
-                currentCount = 0;
+    public void releaseBitmap(Bitmap bitmap) {
+        final InnerTracker tracker = get(bitmap);
+        if (tracker.release()) {
+            recycle(tracker, bitmap);
+        }
     }
 
-            return currentCount;
+    public void rejectBitmap(Bitmap bitmap) {
+        final InnerTracker tracker = get(bitmap);
+        if (tracker.reject()) {
+            recycle(tracker, bitmap);
+        }
+    }
+
+    public void markPending(Bitmap bitmap) {
+        get(bitmap).markPending();
     }
 
-        public void rem(int hashCode) {
-            counter.remove(hashCode);
+    private InnerTracker get(Bitmap bitmap) {
+        return counter.get(bitmap.hashCode());
     }
 
+    private void recycle(InnerTracker tracker, Bitmap bitmap) {
+        counter.remove(bitmap.hashCode());
+        pool.release(tracker);
+        target.put(bitmap);
     }
 }
","7 import java.util.concurrent.ConcurrentHashMap;
8 import java.util.concurrent.ConcurrentLinkedQueue;
18 
19     private static class InnerTrackerPool {
20         private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
21 
22         public InnerTracker get() {
23             InnerTracker result = pool.poll();
24             if (result == null) {
25                 result = new InnerTracker();
26             }
27 
28             return result;
29         }
30 
31         public void release(InnerTracker innerTracker) {
32             pool.offer(innerTracker);
33         }
34     }
35 
36     private static class InnerTracker {
37         private volatile int refs = 0;
38         private volatile boolean pending = false;
39 
40         public void acquire() {
41             pending = false;
42             synchronized (this) {
43                 refs++;
44             }
45         }
46 
47         public boolean release() {
48             synchronized (this) {
49                 refs--;
50             }
51 
52             return refs == 0 && !pending;
53         }
54 
55         public boolean reject() {
56             pending = false;
57             return refs == 0;
58         }
59 
60         public void markPending() {
61             pending = true;
62         }
63     }
64 
65     private final Map<Integer, InnerTracker> counter;
67     private final InnerTrackerPool pool = new InnerTrackerPool();
69     public BitmapTracker(SizedBitmapCache target, int bitmapsPerSize) {
71         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
74     public void initBitmap(Bitmap toInit) {
75         counter.put(toInit.hashCode(), pool.get());
78     public void acquireBitmap(Bitmap bitmap) {
79         get(bitmap).acquire();
80     }
81 
82     public void releaseBitmap(Bitmap bitmap) {
83         final InnerTracker tracker = get(bitmap);
84         if (tracker.release()) {
85             recycle(tracker, bitmap);
86         }
87     }
88 
89     public void rejectBitmap(Bitmap bitmap) {
90         final InnerTracker tracker = get(bitmap);
91         if (tracker.reject()) {
92             recycle(tracker, bitmap);
93         }
94     }
95 
96     public void markPending(Bitmap bitmap) {
97         get(bitmap).markPending();
98     }
99 
100     private InnerTracker get(Bitmap bitmap) {
101         return counter.get(bitmap.hashCode());
102     }
103 
104     private void recycle(InnerTracker tracker, Bitmap bitmap) {
105         counter.remove(bitmap.hashCode());
106         pool.release(tracker);
6 import java.util.HashMap;
7 import java.util.HashSet;
9 import java.util.Set;
20     private final BitmapReferenceCounter counter = new BitmapReferenceCounter();
21     private final Set<Integer> pending = new HashSet<Integer>();
23     public BitmapTracker(SizedBitmapCache target) {
27     public synchronized void acquireBitmap(Bitmap bitmap) {
28         final int hashCode = bitmap.hashCode();
29         pending.remove(hashCode);
30         counter.inc(hashCode);
33     public synchronized void releaseBitmap(Bitmap bitmap) {
34         final int hashCode = bitmap.hashCode();
35         if (counter.dec(hashCode) == 0 && !pending.contains(hashCode)) {
36             counter.rem(hashCode);
40 
41     public synchronized void rejectBitmap(Bitmap bitmap) {
42         final int hashCode = bitmap.hashCode();
43         pending.remove(hashCode);
44         if (counter.get(hashCode) == 0) {
45             counter.rem(hashCode);
46             target.put(bitmap);
47         }
48     }
49 
50     public synchronized void markPending(Bitmap bitmap) {
51         final int hashCode = bitmap.hashCode();
52         pending.add(hashCode);
53     }
54 
55     private class BitmapReferenceCounter {
56         private final Map<Integer, Integer> counter = new HashMap<Integer, Integer>();
57 
58         public void inc(int hashCode) {
59             Integer currentCount = counter.get(hashCode);
60             if (currentCount == null) {
61                 currentCount = 0;
62             }
63             counter.put(hashCode, currentCount + 1);
64         }
65 
66         public int dec(int hashCode) {
67             Integer currentCount = counter.get(hashCode);
68             if (currentCount == null) {
69                 throw new IllegalArgumentException(""Can't decrement null count bitmap="" + hashCode);
70             }
71 
72             currentCount--;
73 
74             counter.put(hashCode, currentCount);
75 
76             return currentCount;
77         }
78 
79         public int get(int hashCode) {
80             Integer currentCount = counter.get(hashCode);
81 
82             if (currentCount == null) {
83                 currentCount = 0;
84             }
85 
86             return currentCount;
87         }
88 
89         public void rem(int hashCode) {
90             counter.remove(hashCode);
91         }
92 
93     }
94 }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,2a2882e26b572d6d69939ac553cd840059caee3a,6e1e771e040ad99be5953c307765ca385c4a35ed,Use per bitmap obj instead of map for ref tracking,"@@ -266,7 +266,7 @@ public class ImageManager {
                 });
             }
             bitmapCache = new SizedBitmapCache(options.maxPerSize);
-            bitmapTracker = new BitmapTracker(bitmapCache);
+            bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
@@ -467,6 +467,12 @@ public class ImageManager {
         bitmapTracker.markPending(b);
     }
 
+    private void initBitmapTracker(final Bitmap b) {
+        if (bitmapTracker == null) return;
+
+        bitmapTracker.initBitmap(b);
+    }
+
     public void cancelTask(Object token) {
         if (token != null) {
             ImageManagerJob job = (ImageManagerJob) token;
@@ -581,6 +587,8 @@ public class ImageManager {
                     putInDiskCache(key, result);
                 }
 
+                initBitmapTracker(result);
+
                 putInMemoryCache(key, result);
                 mainHandler.post(new Runnable() {
                     @Override
","269             bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
470     private void initBitmapTracker(final Bitmap b) {
471         if (bitmapTracker == null) return;
472 
473         bitmapTracker.initBitmap(b);
474     }
475 
590                 initBitmapTracker(result);
591 
269             bitmapTracker = new BitmapTracker(bitmapCache);",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,2e8da58144b6337e8bcd270058b743630764c9e9,2a2882e26b572d6d69939ac553cd840059caee3a,Fix size determiner setting size during animation,"@@ -379,6 +379,7 @@ public class ImagePresenter<T> {
         private int height = 0;
         private boolean valid = false;
         private SizeReadyCallback cb = null;
+        private Handler handler = new Handler();
         private final Runnable getDimens = new Runnable() {
             @Override
             public void run() {
@@ -399,10 +400,11 @@ public class ImagePresenter<T> {
 
         private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
             private final WeakReference<SizeDeterminer> sizeDeterminerRef;
-            private Handler handler = new Handler();
+            private final Handler handler;
 
-            public SizeObserver(SizeDeterminer sizeDeterminer) {
+            public SizeObserver(SizeDeterminer sizeDeterminer, Handler handler) {
                 this.sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
+                this.handler = handler;
             }
 
             @Override
@@ -428,10 +430,11 @@ public class ImagePresenter<T> {
 
         public SizeDeterminer(View view) {
             this.view = view;
-            view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this));
+            view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this, handler));
         }
 
         public void getSize(SizeReadyCallback cb) {
+            handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
             this.cb = null;
             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
             if (layoutParams.width > 0 && layoutParams.height > 0) {
@@ -440,8 +443,7 @@ public class ImagePresenter<T> {
                 cb.onSizeReady(width, height);
             } else {
                 this.cb = cb;
-                view.removeCallbacks(getDimens);
-                view.post(getDimens);
+                handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
             }
         }
 
","382         private Handler handler = new Handler();
403             private final Handler handler;
405             public SizeObserver(SizeDeterminer sizeDeterminer, Handler handler) {
407                 this.handler = handler;
433             view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this, handler));
437             handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
446                 handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
402             private Handler handler = new Handler();
404             public SizeObserver(SizeDeterminer sizeDeterminer) {
431             view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this));
443                 view.removeCallbacks(getDimens);
444                 view.post(getDimens);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,2e8da58144b6337e8bcd270058b743630764c9e9,remove null checks for disk cache,"@@ -11,9 +11,11 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
+import com.bumptech.photos.resize.cache.DiskCache;
+import com.bumptech.photos.resize.cache.DiskCacheAdapter;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
-import com.bumptech.photos.resize.cache.disk.DiskCache;
+import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
 import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Util;
 
@@ -175,6 +177,20 @@ public class ImageManager {
         }
     }
 
+    private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {
+        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
+            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
+        }
+        final DiskCache result;
+        if (diskCacheDir == null || !options.useDiskCache) {
+            result = new DiskCacheAdapter();
+        } else {
+            result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);
+        }
+
+        return result;
+    }
+
     /**
      * Create an ImageManager using the default options. Note that this will create a single background thread to use
      * to resize and load images from disk. Must be created in the UI thread!
@@ -228,28 +244,21 @@ public class ImageManager {
      * @param options The specified options
      */
     public ImageManager(Context context, File diskCacheDir, ExecutorService resizeService, Options options) {
+        this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);
+    }
+
+    public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {
         HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
         executor = resizeService;
 
+        diskCacheFormat = options.diskCacheFormat;
 
         if (options.useMemoryCache && options.maxMemorySize <= 0) {
             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
         }
 
-        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
-            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
-        }
-
-        if (diskCacheDir == null || !options.useDiskCache) {
-            diskCache = null;
-        } else {
-            diskCache = DiskCache.get(diskCacheDir, options.maxDiskCacheSize);
-        }
-
-        diskCacheFormat = options.diskCacheFormat;
-
         if (!options.useMemoryCache) {
             memoryCache = null;
         } else {
@@ -274,6 +283,7 @@ public class ImageManager {
             bitmapTracker = null;
         }
 
+        this.diskCache = diskCache;
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
     }
 
@@ -542,7 +552,7 @@ public class ImageManager {
             final boolean isInDiskCache;
             String path = null;
             if (useDiskCache) {
-                path = getFromDiskCache(key);
+                path = diskCache.get(String.valueOf(key));
             }
 
             isInDiskCache = path != null;
@@ -584,7 +594,7 @@ public class ImageManager {
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
-                    putInDiskCache(key, result);
+                    diskCache.put(String.valueOf(key), result, diskCacheFormat);
                 }
 
                 initBitmapTracker(result);
@@ -604,20 +614,6 @@ public class ImageManager {
     }
 
 
-    private String getFromDiskCache(int key) {
-        String result = null;
-        if (diskCache != null) {
-            result = diskCache.get(String.valueOf(key));
-        }
-        return result;
-    }
-
-    private void putInDiskCache(int key, Bitmap value) {
-        if (diskCache != null) {
-            diskCache.put(String.valueOf(key), value, diskCacheFormat);
-        }
-    }
-
     private Bitmap getFromMemoryCache(int key) {
         Bitmap result = null;
         if (memoryCache != null) {
","14 import com.bumptech.photos.resize.cache.DiskCache;
15 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
18 import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
180     private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {
181         if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
182             options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
183         }
184         final DiskCache result;
185         if (diskCacheDir == null || !options.useDiskCache) {
186             result = new DiskCacheAdapter();
187         } else {
188             result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);
189         }
190 
191         return result;
192     }
193 
247         this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);
248     }
249 
250     public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {
256         diskCacheFormat = options.diskCacheFormat;
286         this.diskCache = diskCache;
555                 path = diskCache.get(String.valueOf(key));
597                     diskCache.put(String.valueOf(key), result, diskCacheFormat);
16 import com.bumptech.photos.resize.cache.disk.DiskCache;
241         if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
242             options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
243         }
244 
245         if (diskCacheDir == null || !options.useDiskCache) {
246             diskCache = null;
247         } else {
248             diskCache = DiskCache.get(diskCacheDir, options.maxDiskCacheSize);
249         }
250 
251         diskCacheFormat = options.diskCacheFormat;
252 
545                 path = getFromDiskCache(key);
587                     putInDiskCache(key, result);
607     private String getFromDiskCache(int key) {
608         String result = null;
609         if (diskCache != null) {
610             result = diskCache.get(String.valueOf(key));
611         }
612         return result;
613     }
614 
615     private void putInDiskCache(int key, Bitmap value) {
616         if (diskCache != null) {
617             diskCache.put(String.valueOf(key), value, diskCacheFormat);
618         }
619     }
620 ",No
,library\src\com\bumptech\photos\resize\cache\DiskCache.java,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,2e8da58144b6337e8bcd270058b743630764c9e9,remove null checks for disk cache,"@@ -0,0 +1,16 @@
+package com.bumptech.photos.resize.cache;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 10:21 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface DiskCache {
+    public String get(String key);
+    public void put(String key, Bitmap value, Bitmap.CompressFormat format);
+
+}
","1 package com.bumptech.photos.resize.cache;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 10:21 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public interface DiskCache {
13     public String get(String key);
14     public void put(String key, Bitmap value, Bitmap.CompressFormat format);
15 
16 }",No
,library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,2e8da58144b6337e8bcd270058b743630764c9e9,remove null checks for disk cache,"@@ -0,0 +1,20 @@
+package com.bumptech.photos.resize.cache;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 10:24 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class DiskCacheAdapter implements DiskCache {
+    @Override
+    public String get(String key) {
+        return null;
+    }
+
+    @Override
+    public void put(String key, Bitmap value, Bitmap.CompressFormat format) { }
+}
","1 package com.bumptech.photos.resize.cache;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 10:24 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public class DiskCacheAdapter implements DiskCache {
13     @Override
14     public String get(String key) {
15         return null;
16     }
17 
18     @Override
19     public void put(String key, Bitmap value, Bitmap.CompressFormat format) { }
20 }",No
library\src\com\bumptech\photos\resize\cache\disk\DiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,2e8da58144b6337e8bcd270058b743630764c9e9,remove null checks for disk cache,"@@ -5,6 +5,7 @@
 package com.bumptech.photos.resize.cache.disk;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.resize.cache.DiskCache;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -27,24 +28,24 @@ import java.util.concurrent.locks.ReentrantLock;
  * Time: 9:20 AM
  * To change this template use File | Settings | File Templates.
  */
-public class DiskCache {
-    private static String JOURNAL_FILE_NAME = ""JOURNAL"";
-    private static DiskCache CACHE = null;
+public class AndroidDiskCache implements DiskCache {
+    private static final String JOURNAL_FILE_NAME = ""JOURNAL"";
+    private static AndroidDiskCache CACHE = null;
 
     private final File outputDir;
     private Journal journal;
     private boolean isOpen = false;
     private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
 
-    public static synchronized DiskCache get(File diskCacheDir, int maxCacheSize) {
+    public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
         if (CACHE == null) {
-            CACHE = new DiskCache(diskCacheDir, maxCacheSize);
+            CACHE = new AndroidDiskCache(diskCacheDir, maxCacheSize);
         }
 
         return CACHE;
     }
 
-    protected DiskCache(File outputDir, int maxCacheSize) {
+    protected AndroidDiskCache(File outputDir, int maxCacheSize) {
         this.outputDir = outputDir;
         this.journal = new Journal(getFile(JOURNAL_FILE_NAME), maxCacheSize, new Journal.EvictionListener() {
             @Override
@@ -64,6 +65,7 @@ public class DiskCache {
         }
     }
 
+    @Override
     public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
         synchronized (this) {
             if (!isOpen) open();
@@ -114,6 +116,7 @@ public class DiskCache {
         return lock;
     }
 
+    @Override
     public String get(String key) {
         synchronized (this) {
             if (!isOpen) open();
","8 import com.bumptech.photos.resize.cache.DiskCache;
31 public class AndroidDiskCache implements DiskCache {
32     private static final String JOURNAL_FILE_NAME = ""JOURNAL"";
33     private static AndroidDiskCache CACHE = null;
40     public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
42             CACHE = new AndroidDiskCache(diskCacheDir, maxCacheSize);
48     protected AndroidDiskCache(File outputDir, int maxCacheSize) {
68     @Override
119     @Override
30 public class DiskCache {
31     private static String JOURNAL_FILE_NAME = ""JOURNAL"";
32     private static DiskCache CACHE = null;
39     public static synchronized DiskCache get(File diskCacheDir, int maxCacheSize) {
41             CACHE = new DiskCache(diskCacheDir, maxCacheSize);
47     protected DiskCache(File outputDir, int maxCacheSize) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,f13c881b00196dcfdf4e631129cda50de6e3446e,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,remove null checks for memory cache,"@@ -14,6 +14,8 @@ import android.os.HandlerThread;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
+import com.bumptech.photos.resize.cache.MemoryCache;
+import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
 import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
 import com.bumptech.photos.util.Log;
@@ -116,7 +118,7 @@ public class ImageManager {
     private final Handler mainHandler = new Handler();
     private final Handler bgHandler;
     private final ExecutorService executor;
-    private final LruPhotoCache memoryCache;
+    private final MemoryCache memoryCache;
     private final ImageResizer resizer;
     private final SizedBitmapCache bitmapCache;
     private final DiskCache diskCache;
@@ -189,6 +191,21 @@ public class ImageManager {
         }
 
         return result;
+
+    }
+
+    private static MemoryCache buildMemoryCache(Options options, Context context) {
+        if (options.useMemoryCache && options.maxMemorySize <= 0) {
+            options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
+        }
+
+        final MemoryCache result;
+        if (!options.useMemoryCache) {
+            result = new MemoryCacheAdapter();
+        } else {
+            result = new LruPhotoCache(options.maxMemorySize);
+        }
+        return result;
     }
 
     /**
@@ -248,6 +265,10 @@ public class ImageManager {
     }
 
     public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {
+        this(buildMemoryCache(options, context), diskCache, resizeService, options);
+    }
+
+    public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
         HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
@@ -255,25 +276,13 @@ public class ImageManager {
 
         diskCacheFormat = options.diskCacheFormat;
 
-        if (options.useMemoryCache && options.maxMemorySize <= 0) {
-            options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
-        }
-
-        if (!options.useMemoryCache) {
-            memoryCache = null;
-        } else {
-            memoryCache = new LruPhotoCache(options.maxMemorySize);
-        }
-
         if (options.recycleBitmaps && CAN_RECYCLE) {
-            if (memoryCache != null) {
-                memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
+            memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
                 @Override
-                    public void onPhotoRemoved(Integer key, Bitmap bitmap) {
+                public void onImageRemoved(Bitmap bitmap) {
                     releaseBitmap(bitmap);
                 }
             });
-            }
             bitmapCache = new SizedBitmapCache(options.maxPerSize);
             bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
         } else {
@@ -283,6 +292,7 @@ public class ImageManager {
             bitmapTracker = null;
         }
 
+        this.memoryCache = memoryCache;
         this.diskCache = diskCache;
         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
     }
@@ -504,7 +514,7 @@ public class ImageManager {
     }
 
     private boolean returnFromCache(int key, LoadedCallback cb) {
-        Bitmap inCache = getFromMemoryCache(key);
+        Bitmap inCache = memoryCache.get(key);
         boolean found = inCache != null;
         if (found) {
             cb.onLoadCompleted(inCache);
@@ -614,23 +624,10 @@ public class ImageManager {
     }
 
 
-    private Bitmap getFromMemoryCache(int key) {
-        Bitmap result = null;
-        if (memoryCache != null) {
-            result = memoryCache.get(key);
-        }
-        return result;
-    }
-
     private void putInMemoryCache(int key, Bitmap bitmap) {
-        if (memoryCache != null) {
-            synchronized (memoryCache) {
-                if (!memoryCache.contains(key)) {
+        if (memoryCache.put(key, bitmap) != bitmap) {
             acquireBitmap(bitmap);
             markBitmapPending(bitmap);
-                    memoryCache.put(key, bitmap);
-                }
-            }
         }
     }
 
","17 import com.bumptech.photos.resize.cache.MemoryCache;
18 import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
121     private final MemoryCache memoryCache;
194 
195     }
196 
197     private static MemoryCache buildMemoryCache(Options options, Context context) {
198         if (options.useMemoryCache && options.maxMemorySize <= 0) {
199             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
200         }
201 
202         final MemoryCache result;
203         if (!options.useMemoryCache) {
204             result = new MemoryCacheAdapter();
205         } else {
206             result = new LruPhotoCache(options.maxMemorySize);
207         }
208         return result;
268         this(buildMemoryCache(options, context), diskCache, resizeService, options);
269     }
270 
271     public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
280             memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
282                 public void onImageRemoved(Bitmap bitmap) {
295         this.memoryCache = memoryCache;
517         Bitmap inCache = memoryCache.get(key);
628         if (memoryCache.put(key, bitmap) != bitmap) {
119     private final LruPhotoCache memoryCache;
258         if (options.useMemoryCache && options.maxMemorySize <= 0) {
259             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
260         }
261 
262         if (!options.useMemoryCache) {
263             memoryCache = null;
264         } else {
265             memoryCache = new LruPhotoCache(options.maxMemorySize);
266         }
267 
269             if (memoryCache != null) {
270                 memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {
272                     public void onPhotoRemoved(Integer key, Bitmap bitmap) {
276             }
507         Bitmap inCache = getFromMemoryCache(key);
617     private Bitmap getFromMemoryCache(int key) {
618         Bitmap result = null;
619         if (memoryCache != null) {
620             result = memoryCache.get(key);
621         }
622         return result;
623     }
624 
626         if (memoryCache != null) {
627             synchronized (memoryCache) {
628                 if (!memoryCache.contains(key)) {
631                     memoryCache.put(key, bitmap);
632                 }
633             }",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,f13c881b00196dcfdf4e631129cda50de6e3446e,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,remove null checks for memory cache,"@@ -14,13 +14,10 @@ import android.support.v4.util.LruCache;
  *
  * @see android.support.v4.util.LruCache
  */
-public class LruPhotoCache extends LruCache<Integer, Bitmap> {
+public class LruPhotoCache implements MemoryCache {
     private static final float SIZE_RATIO = 1f/10f;
-    private PhotoRemovedListener photoRemovedListener;
-
-    public interface PhotoRemovedListener {
-        public void onPhotoRemoved(Integer key, Bitmap bitmap);
-    }
+    private final LruCache<Integer, Bitmap> lruCache;
+    private ImageRemovedListener imageRemovedListener;
 
     /*
     Can only call after context is created (ie in onCreate or later...)
@@ -31,7 +28,13 @@ public class LruPhotoCache extends LruCache<Integer, Bitmap> {
     }
 
     public LruPhotoCache(int maxSize) {
-        super(maxSize);
+        lruCache = new LruCache<Integer, Bitmap>(maxSize) {
+            @Override
+            protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
+                super.entryRemoved(evicted, key, oldValue, newValue);
+                if (imageRemovedListener != null) {
+                    imageRemovedListener.onImageRemoved(oldValue);
+                }
             }
 
             @Override
@@ -39,20 +42,25 @@ public class LruPhotoCache extends LruCache<Integer, Bitmap> {
                 //get the size, getByteCount() is API 12+...
                 return value.getHeight() * value.getRowBytes();
             }
+        };
+    }
 
-    @Override
-    protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
-        super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
-        if (photoRemovedListener != null) {
-            photoRemovedListener.onPhotoRemoved(key, oldValue);
+    public boolean contains(Integer key) {
+        return get(key) != null;
     }
+
+    @Override
+    public Bitmap get(Integer key) {
+        return lruCache.get(key);
     }
 
-    public void setPhotoRemovedListener(PhotoRemovedListener listener) {
-        this.photoRemovedListener = listener;
+    @Override
+    public Bitmap put(Integer key, Bitmap bitmap) {
+        return lruCache.put(key, bitmap);
     }
 
-    public boolean contains(Integer key) {
-        return get(key) != null;
+    @Override
+    public void setImageRemovedListener(ImageRemovedListener listener) {
+        this.imageRemovedListener = listener;
     }
 }
","17 public class LruPhotoCache implements MemoryCache {
19     private final LruCache<Integer, Bitmap> lruCache;
20     private ImageRemovedListener imageRemovedListener;
31         lruCache = new LruCache<Integer, Bitmap>(maxSize) {
32             @Override
33             protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
34                 super.entryRemoved(evicted, key, oldValue, newValue);
35                 if (imageRemovedListener != null) {
36                     imageRemovedListener.onImageRemoved(oldValue);
37                 }
45         };
51 
52     @Override
53     public Bitmap get(Integer key) {
54         return lruCache.get(key);
55     }
56 
57     @Override
58     public Bitmap put(Integer key, Bitmap bitmap) {
59         return lruCache.put(key, bitmap);
60     }
61 
62     @Override
63     public void setImageRemovedListener(ImageRemovedListener listener) {
64         this.imageRemovedListener = listener;
65     }
17 public class LruPhotoCache extends LruCache<Integer, Bitmap> {
19     private PhotoRemovedListener photoRemovedListener;
20 
21     public interface PhotoRemovedListener {
22         public void onPhotoRemoved(Integer key, Bitmap bitmap);
23     }
34         super(maxSize);
42 
43     @Override
44     protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
45         super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates.
46         if (photoRemovedListener != null) {
47             photoRemovedListener.onPhotoRemoved(key, oldValue);
48         }
49     }
50 
51     public void setPhotoRemovedListener(PhotoRemovedListener listener) {
52         this.photoRemovedListener = listener;",No
,library\src\com\bumptech\photos\resize\cache\MemoryCache.java,f13c881b00196dcfdf4e631129cda50de6e3446e,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,remove null checks for memory cache,"@@ -0,0 +1,28 @@
+package com.bumptech.photos.resize.cache;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 11:29 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface MemoryCache {
+    public interface ImageRemovedListener {
+        public void onImageRemoved(Bitmap removed);
+    }
+
+    public boolean contains(Integer key);
+    public Bitmap get(Integer key);
+
+    /**
+     * Add bitmap to the cache with the given key
+     * @param key The key to retrieve the bitmap
+     * @param bitmap The bitmap to store
+     * @return The old value of key (null if key is not in map)
+     */
+    public Bitmap put(Integer key, Bitmap bitmap);
+    public void setImageRemovedListener(ImageRemovedListener listener);
+}
","1 package com.bumptech.photos.resize.cache;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 11:29 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public interface MemoryCache {
13     public interface ImageRemovedListener {
14         public void onImageRemoved(Bitmap removed);
15     }
16 
17     public boolean contains(Integer key);
18     public Bitmap get(Integer key);
19 
20     /**
21      * Add bitmap to the cache with the given key
22      * @param key The key to retrieve the bitmap
23      * @param bitmap The bitmap to store
24      * @return The old value of key (null if key is not in map)
25      */
26     public Bitmap put(Integer key, Bitmap bitmap);
27     public void setImageRemovedListener(ImageRemovedListener listener);
28 }",No
,library\src\com\bumptech\photos\resize\cache\MemoryCacheAdapter.java,f13c881b00196dcfdf4e631129cda50de6e3446e,f7de145d9bebfdd354a234479e1d1f28e1d3e11b,remove null checks for memory cache,"@@ -0,0 +1,30 @@
+package com.bumptech.photos.resize.cache;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 11:31 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class MemoryCacheAdapter implements MemoryCache {
+    @Override
+    public boolean contains(Integer key) {
+        return false;
+    }
+
+    @Override
+    public Bitmap get(Integer key) {
+        return null;
+    }
+
+    @Override
+    public Bitmap put(Integer key, Bitmap bitmap) {
+        return null;
+    }
+
+    @Override
+    public void setImageRemovedListener(ImageRemovedListener listener) { }
+}
","1 package com.bumptech.photos.resize.cache;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 11:31 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public class MemoryCacheAdapter implements MemoryCache {
13     @Override
14     public boolean contains(Integer key) {
15         return false;
16     }
17 
18     @Override
19     public Bitmap get(Integer key) {
20         return null;
21     }
22 
23     @Override
24     public Bitmap put(Integer key, Bitmap bitmap) {
25         return null;
26     }
27 
28     @Override
29     public void setImageRemovedListener(ImageRemovedListener listener) { }
30 }",No
library\src\com\bumptech\photos\resize\BitmapTracker.java,library\src\com\bumptech\photos\resize\BitmapTracker.java,5e6ad9282157314e8557251e43f4df80dae31247,f13c881b00196dcfdf4e631129cda50de6e3446e,SizedBitmapCache -> BitmapPool,"@@ -1,7 +1,7 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.cache.SizedBitmapCache;
+import com.bumptech.photos.resize.cache.BitmapPool;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
@@ -63,10 +63,10 @@ public class BitmapTracker {
     }
 
     private final Map<Integer, InnerTracker> counter;
-    private final SizedBitmapCache target;
+    private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public BitmapTracker(SizedBitmapCache target, int bitmapsPerSize) {
+    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
         this.target = target;
         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
     }
","4 import com.bumptech.photos.resize.cache.BitmapPool;
66     private final BitmapPool target;
69     public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
4 import com.bumptech.photos.resize.cache.SizedBitmapCache;
66     private final SizedBitmapCache target;
69     public BitmapTracker(SizedBitmapCache target, int bitmapsPerSize) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,5e6ad9282157314e8557251e43f4df80dae31247,f13c881b00196dcfdf4e631129cda50de6e3446e,SizedBitmapCache -> BitmapPool,"@@ -11,12 +11,12 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
+import com.bumptech.photos.resize.cache.BitmapPool;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.MemoryCache;
 import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
-import com.bumptech.photos.resize.cache.SizedBitmapCache;
 import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
 import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Util;
@@ -120,7 +120,7 @@ public class ImageManager {
     private final ExecutorService executor;
     private final MemoryCache memoryCache;
     private final ImageResizer resizer;
-    private final SizedBitmapCache bitmapCache;
+    private final BitmapPool bitmapCache;
     private final DiskCache diskCache;
     private final Bitmap.CompressFormat diskCacheFormat;
 
@@ -283,7 +283,7 @@ public class ImageManager {
                     releaseBitmap(bitmap);
                 }
             });
-            bitmapCache = new SizedBitmapCache(options.maxPerSize);
+            bitmapCache = new BitmapPool(options.maxPerSize);
             bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
","14 import com.bumptech.photos.resize.cache.BitmapPool;
123     private final BitmapPool bitmapCache;
286             bitmapCache = new BitmapPool(options.maxPerSize);
19 import com.bumptech.photos.resize.cache.SizedBitmapCache;
123     private final SizedBitmapCache bitmapCache;
286             bitmapCache = new SizedBitmapCache(options.maxPerSize);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,5e6ad9282157314e8557251e43f4df80dae31247,f13c881b00196dcfdf4e631129cda50de6e3446e,SizedBitmapCache -> BitmapPool,"@@ -10,7 +10,7 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
-import com.bumptech.photos.resize.cache.SizedBitmapCache;
+import com.bumptech.photos.resize.cache.BitmapPool;
 import com.bumptech.photos.util.Log;
 
 import java.io.FileInputStream;
@@ -26,7 +26,7 @@ import java.util.Queue;
 public class ImageResizer {
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
-    private final SizedBitmapCache bitmapCache;
+    private final BitmapPool bitmapPool;
     private final BitmapFactory.Options defaultOptions;
 
     public static BitmapFactory.Options getDefaultOptions() {
@@ -48,8 +48,8 @@ public class ImageResizer {
         this(null, null);
     }
 
-    public ImageResizer(SizedBitmapCache bitmapCache) {
-        this(bitmapCache, null);
+    public ImageResizer(BitmapPool bitmapPool) {
+        this(bitmapPool, null);
     }
 
     public ImageResizer(BitmapFactory.Options options) {
@@ -59,10 +59,11 @@ public class ImageResizer {
     /**
      * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
      *
-     * @param bitmapCache The cache to try to recycle {@link android.graphics.Bitmap}s from
+     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
      */
-    public ImageResizer(SizedBitmapCache bitmapCache, BitmapFactory.Options defaultOptions){
-        this.bitmapCache = bitmapCache;
+    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
+        this.bitmapPool = bitmapPool;
+
         if (defaultOptions == null) {
             this.defaultOptions = getDefaultOptions();
         } else {
@@ -389,8 +390,8 @@ public class ImageResizer {
 
     private Bitmap getRecycled(int width, int height) {
         Bitmap result = null;
-        if (bitmapCache != null) {
-            result = bitmapCache.get(width, height);
+        if (bitmapPool != null) {
+            result = bitmapPool.get(width, height);
         }
         return result;
     }
","13 import com.bumptech.photos.resize.cache.BitmapPool;
29     private final BitmapPool bitmapPool;
51     public ImageResizer(BitmapPool bitmapPool) {
52         this(bitmapPool, null);
62      * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
64     public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
65         this.bitmapPool = bitmapPool;
66 
393         if (bitmapPool != null) {
394             result = bitmapPool.get(width, height);
13 import com.bumptech.photos.resize.cache.SizedBitmapCache;
29     private final SizedBitmapCache bitmapCache;
51     public ImageResizer(SizedBitmapCache bitmapCache) {
52         this(bitmapCache, null);
62      * @param bitmapCache The cache to try to recycle {@link android.graphics.Bitmap}s from
64     public ImageResizer(SizedBitmapCache bitmapCache, BitmapFactory.Options defaultOptions){
65         this.bitmapCache = bitmapCache;
392         if (bitmapCache != null) {
393             result = bitmapCache.get(width, height);",No
library\src\com\bumptech\photos\resize\cache\SizedBitmapCache.java,library\src\com\bumptech\photos\resize\cache\BitmapPool.java,5e6ad9282157314e8557251e43f4df80dae31247,f13c881b00196dcfdf4e631129cda50de6e3446e,SizedBitmapCache -> BitmapPool,"@@ -15,12 +15,12 @@ import java.util.Queue;
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
-public class SizedBitmapCache {
+public class BitmapPool {
     private static final int DEFAULT_MAX_PER_SIZE = 20;
     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
     private final int maxPerSize;
 
-    public SizedBitmapCache(int maxPerSize) {
+    public BitmapPool(int maxPerSize) {
         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
     }
 
","18 public class BitmapPool {
23     public BitmapPool(int maxPerSize) {
18 public class SizedBitmapCache {
23     public SizedBitmapCache(int maxPerSize) {",No
library\src\com\bumptech\photos\resize\cache\BitmapPool.java,library\src\com\bumptech\photos\resize\cache\BitmapPool.java,d63075c870f203874bae02ede0058555f6d8e08a,5e6ad9282157314e8557251e43f4df80dae31247,Minor bitmap pool optimizations,"@@ -17,7 +17,7 @@ import java.util.Queue;
  */
 public class BitmapPool {
     private static final int DEFAULT_MAX_PER_SIZE = 20;
-    private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
+    private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
     private final int maxPerSize;
 
     public BitmapPool(int maxPerSize) {
@@ -25,20 +25,19 @@ public class BitmapPool {
     }
 
     public synchronized void put(Bitmap bitmap) {
-        final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
+        final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
         if (available == null) {
             available = new ArrayDeque<Bitmap>();
             availableBitmaps.put(sizeKey, available);
-        }
-
-        if (available.size() < maxPerSize) {
+            available.offer(bitmap);
+        } else if (available.size() < maxPerSize) {
             available.offer(bitmap);
         }
     }
 
     public synchronized Bitmap get(int width, int height) {
-        final String sizeKey = getSizeKey(width, height);
+        final int sizeKey = getSizeKey(width, height);
         final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
 
         if (available == null) {
@@ -50,7 +49,9 @@ public class BitmapPool {
         }
     }
 
-    private static final String getSizeKey(int width, int height) {
-        return width + ""_"" + height;
+    //see http://szudzik.com/ElegantPairing.pdf
+    //assumes width <= Short.MAX_VALUE && height <= SHORT.MAX_VALUE && width >= 0 && height >= 0
+    private static int getSizeKey(int width, int height) {
+        return width >= height ? width * width + width + height : width + height * height;
     }
 }
","20     private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
28         final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
33             available.offer(bitmap);
34         } else if (available.size() < maxPerSize) {
40         final int sizeKey = getSizeKey(width, height);
52     //see http://szudzik.com/ElegantPairing.pdf
53     //assumes width <= Short.MAX_VALUE && height <= SHORT.MAX_VALUE && width >= 0 && height >= 0
54     private static int getSizeKey(int width, int height) {
55         return width >= height ? width * width + width + height : width + height * height;
20     private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();
28         final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
33         }
34 
35         if (available.size() < maxPerSize) {
41         final String sizeKey = getSizeKey(width, height);
53     private static final String getSizeKey(int width, int height) {
54         return width + ""_"" + height;",No
library\src\com\bumptech\photos\resize\BitmapTracker.java,library\src\com\bumptech\photos\resize\BitmapTracker.java,b4ac01f44816fafed761e98b406eccb34c1fa8e9,d63075c870f203874bae02ede0058555f6d8e08a,BitmapPool -> ConcurrentBitmapPool,"@@ -1,7 +1,7 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.cache.BitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
@@ -63,10 +63,10 @@ public class BitmapTracker {
     }
 
     private final Map<Integer, InnerTracker> counter;
-    private final BitmapPool target;
+    private final ConcurrentBitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
+    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {
         this.target = target;
         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
     }
","4 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
66     private final ConcurrentBitmapPool target;
69     public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {
4 import com.bumptech.photos.resize.cache.BitmapPool;
66     private final BitmapPool target;
69     public BitmapTracker(BitmapPool target, int bitmapsPerSize) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,b4ac01f44816fafed761e98b406eccb34c1fa8e9,d63075c870f203874bae02ede0058555f6d8e08a,BitmapPool -> ConcurrentBitmapPool,"@@ -11,7 +11,7 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import com.bumptech.photos.resize.cache.BitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
@@ -120,7 +120,7 @@ public class ImageManager {
     private final ExecutorService executor;
     private final MemoryCache memoryCache;
     private final ImageResizer resizer;
-    private final BitmapPool bitmapCache;
+    private final ConcurrentBitmapPool bitmapCache;
     private final DiskCache diskCache;
     private final Bitmap.CompressFormat diskCacheFormat;
 
@@ -283,7 +283,7 @@ public class ImageManager {
                     releaseBitmap(bitmap);
                 }
             });
-            bitmapCache = new BitmapPool(options.maxPerSize);
+            bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);
             bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
","14 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
123     private final ConcurrentBitmapPool bitmapCache;
286             bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);
14 import com.bumptech.photos.resize.cache.BitmapPool;
123     private final BitmapPool bitmapCache;
286             bitmapCache = new BitmapPool(options.maxPerSize);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,b4ac01f44816fafed761e98b406eccb34c1fa8e9,d63075c870f203874bae02ede0058555f6d8e08a,BitmapPool -> ConcurrentBitmapPool,"@@ -10,7 +10,7 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
-import com.bumptech.photos.resize.cache.BitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.photos.util.Log;
 
 import java.io.FileInputStream;
@@ -26,7 +26,9 @@ import java.util.Queue;
 public class ImageResizer {
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
-    private final BitmapPool bitmapPool;
+
+    private final ConcurrentBitmapPool bitmapPool;
+
     private final BitmapFactory.Options defaultOptions;
 
     public static BitmapFactory.Options getDefaultOptions() {
@@ -48,7 +50,7 @@ public class ImageResizer {
         this(null, null);
     }
 
-    public ImageResizer(BitmapPool bitmapPool) {
+    public ImageResizer(ConcurrentBitmapPool bitmapPool) {
         this(bitmapPool, null);
     }
 
@@ -61,9 +63,8 @@ public class ImageResizer {
      *
      * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
      */
-    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
+    public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
         this.bitmapPool = bitmapPool;
-
         if (defaultOptions == null) {
             this.defaultOptions = getDefaultOptions();
         } else {
","13 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
29 
30     private final ConcurrentBitmapPool bitmapPool;
31 
53     public ImageResizer(ConcurrentBitmapPool bitmapPool) {
66     public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
13 import com.bumptech.photos.resize.cache.BitmapPool;
29     private final BitmapPool bitmapPool;
51     public ImageResizer(BitmapPool bitmapPool) {
64     public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
66 ",No
library\src\com\bumptech\photos\resize\cache\BitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,b4ac01f44816fafed761e98b406eccb34c1fa8e9,d63075c870f203874bae02ede0058555f6d8e08a,BitmapPool -> ConcurrentBitmapPool,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.cache;
+package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.util.Log;
@@ -15,12 +15,12 @@ import java.util.Queue;
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
-public class BitmapPool {
+public class ConcurrentBitmapPool {
     private static final int DEFAULT_MAX_PER_SIZE = 20;
     private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
     private final int maxPerSize;
 
-    public BitmapPool(int maxPerSize) {
+    public ConcurrentBitmapPool(int maxPerSize) {
         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
     }
 
","5 package com.bumptech.photos.resize.bitmap_recycle;
18 public class ConcurrentBitmapPool {
23     public ConcurrentBitmapPool(int maxPerSize) {
5 package com.bumptech.photos.resize.cache;
18 public class BitmapPool {
23     public BitmapPool(int maxPerSize) {",No
library\src\com\bumptech\photos\resize\BitmapTracker.java,library\src\com\bumptech\photos\resize\BitmapTracker.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -1,7 +1,7 @@
 package com.bumptech.photos.resize;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
@@ -63,10 +63,10 @@ public class BitmapTracker {
     }
 
     private final Map<Integer, InnerTracker> counter;
-    private final ConcurrentBitmapPool target;
+    private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {
+    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
         this.target = target;
         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
     }
","4 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
66     private final BitmapPool target;
69     public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
4 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
66     private final ConcurrentBitmapPool target;
69     public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -11,6 +11,7 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
@@ -120,7 +121,6 @@ public class ImageManager {
     private final ExecutorService executor;
     private final MemoryCache memoryCache;
     private final ImageResizer resizer;
-    private final ConcurrentBitmapPool bitmapCache;
     private final DiskCache diskCache;
     private final Bitmap.CompressFormat diskCacheFormat;
 
@@ -276,6 +276,7 @@ public class ImageManager {
 
         diskCacheFormat = options.diskCacheFormat;
 
+        final BitmapPool bitmapPool;
         if (options.recycleBitmaps && CAN_RECYCLE) {
             memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
                 @Override
@@ -283,18 +284,18 @@ public class ImageManager {
                     releaseBitmap(bitmap);
                 }
             });
-            bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);
-            bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
+            bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
+            bitmapTracker = new BitmapTracker(bitmapPool, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
-            bitmapCache = null;
+            bitmapPool = null;
             bitmapTracker = null;
         }
 
         this.memoryCache = memoryCache;
         this.diskCache = diskCache;
-        this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);
+        this.resizer = new ImageResizer(bitmapPool, options.bitmapDecodeOptions);
     }
 
     /**
","14 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
279         final BitmapPool bitmapPool;
287             bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
288             bitmapTracker = new BitmapTracker(bitmapPool, options.maxPerSize);
292             bitmapPool = null;
298         this.resizer = new ImageResizer(bitmapPool, options.bitmapDecodeOptions);
123     private final ConcurrentBitmapPool bitmapCache;
286             bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);
287             bitmapTracker = new BitmapTracker(bitmapCache, options.maxPerSize);
291             bitmapCache = null;
297         this.resizer = new ImageResizer(bitmapCache, options.bitmapDecodeOptions);",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\photos\resize\ImageResizer.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -10,7 +10,8 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
-import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.photos.util.Log;
 
 import java.io.FileInputStream;
@@ -26,8 +27,7 @@ import java.util.Queue;
 public class ImageResizer {
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
-
-    private final ConcurrentBitmapPool bitmapPool;
+    private final BitmapPool bitmapPool;
 
     private final BitmapFactory.Options defaultOptions;
 
@@ -50,7 +50,7 @@ public class ImageResizer {
         this(null, null);
     }
 
-    public ImageResizer(ConcurrentBitmapPool bitmapPool) {
+    public ImageResizer(BitmapPool bitmapPool) {
         this(bitmapPool, null);
     }
 
@@ -63,8 +63,13 @@ public class ImageResizer {
      *
      * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
      */
-    public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
+    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
+        if (bitmapPool == null) {
+            this.bitmapPool = new BitmapPoolAdapter();
+        } else {
             this.bitmapPool = bitmapPool;
+        }
+
         if (defaultOptions == null) {
             this.defaultOptions = getDefaultOptions();
         } else {
@@ -390,11 +395,7 @@ public class ImageResizer {
     }
 
     private Bitmap getRecycled(int width, int height) {
-        Bitmap result = null;
-        if (bitmapPool != null) {
-            result = bitmapPool.get(width, height);
-        }
-        return result;
+        return bitmapPool.get(width, height);
     }
 
     private byte[][] getTempBytes() {
","13 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
14 import com.bumptech.photos.resize.bitmap_recycle.BitmapPoolAdapter;
30     private final BitmapPool bitmapPool;
53     public ImageResizer(BitmapPool bitmapPool) {
66     public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
67         if (bitmapPool == null) {
68             this.bitmapPool = new BitmapPoolAdapter();
69         } else {
71         }
72 
398         return bitmapPool.get(width, height);
13 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
29 
30     private final ConcurrentBitmapPool bitmapPool;
53     public ImageResizer(ConcurrentBitmapPool bitmapPool) {
66     public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
393         Bitmap result = null;
394         if (bitmapPool != null) {
395             result = bitmapPool.get(width, height);
396         }
397         return result;",No
,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPool.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -0,0 +1,16 @@
+package com.bumptech.photos.resize.bitmap_recycle;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 2:52 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface BitmapPool {
+    public void put(Bitmap bitmap);
+    public Bitmap get(int width, int height);
+
+}
","1 package com.bumptech.photos.resize.bitmap_recycle;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 2:52 PM
10  * To change this template use File | Settings | File Templates.
11  */
12 public interface BitmapPool {
13     public void put(Bitmap bitmap);
14     public Bitmap get(int width, int height);
15 
16 }",No
,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPoolAdapter.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -0,0 +1,20 @@
+package com.bumptech.photos.resize.bitmap_recycle;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 2:58 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class BitmapPoolAdapter implements BitmapPool {
+    @Override
+    public void put(Bitmap bitmap) { }
+
+    @Override
+    public Bitmap get(int width, int height) {
+        return null;
+    }
+}
","1 package com.bumptech.photos.resize.bitmap_recycle;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 2:58 PM
10  * To change this template use File | Settings | File Templates.
11  */
12 public class BitmapPoolAdapter implements BitmapPool {
13     @Override
14     public void put(Bitmap bitmap) { }
15 
16     @Override
17     public Bitmap get(int width, int height) {
18         return null;
19     }
20 }",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,b4ac01f44816fafed761e98b406eccb34c1fa8e9,Remove null checks for bitmap pool/cache,"@@ -15,7 +15,7 @@ import java.util.Queue;
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
-public class ConcurrentBitmapPool {
+public class ConcurrentBitmapPool implements BitmapPool {
     private static final int DEFAULT_MAX_PER_SIZE = 20;
     private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
     private final int maxPerSize;
@@ -24,6 +24,7 @@ public class ConcurrentBitmapPool {
         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
     }
 
+    @Override
     public synchronized void put(Bitmap bitmap) {
         final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
@@ -36,6 +37,7 @@ public class ConcurrentBitmapPool {
         }
     }
 
+    @Override
     public synchronized Bitmap get(int width, int height) {
         final int sizeKey = getSizeKey(width, height);
         final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
","18 public class ConcurrentBitmapPool implements BitmapPool {
27     @Override
40     @Override
18 public class ConcurrentBitmapPool {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,ec22143311afbbcffa25f0babcb12c71826897d4,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,BitmapTracker -> ConcurrentBitmapReferenceCounter,"@@ -13,6 +13,7 @@ import android.os.Handler;
 import android.os.HandlerThread;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
@@ -42,7 +43,7 @@ import java.util.concurrent.RejectedExecutionException;
 public class ImageManager {
     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
-    private final BitmapTracker bitmapTracker;
+    private final ConcurrentBitmapReferenceCounter bitmapTracker;
 
     /**
      * A class for setting options for an ImageManager
@@ -285,7 +286,7 @@ public class ImageManager {
                 }
             });
             bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
-            bitmapTracker = new BitmapTracker(bitmapPool, options.maxPerSize);
+            bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
","16 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
46     private final ConcurrentBitmapReferenceCounter bitmapTracker;
289             bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
45     private final BitmapTracker bitmapTracker;
288             bitmapTracker = new BitmapTracker(bitmapPool, options.maxPerSize);",No
library\src\com\bumptech\photos\resize\BitmapTracker.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,ec22143311afbbcffa25f0babcb12c71826897d4,9b2c9802d9eb0fb9aaa25388ad064a41b95186af,BitmapTracker -> ConcurrentBitmapReferenceCounter,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize;
+package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
@@ -14,7 +14,7 @@ import java.util.concurrent.ConcurrentLinkedQueue;
  * Time: 9:54 AM
  * To change this template use File | Settings | File Templates.
  */
-public class BitmapTracker {
+public class ConcurrentBitmapReferenceCounter {
 
     private static class InnerTrackerPool {
         private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
@@ -66,7 +66,7 @@ public class BitmapTracker {
     private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {
+    public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {
         this.target = target;
         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
     }
","1 package com.bumptech.photos.resize.bitmap_recycle;
17 public class ConcurrentBitmapReferenceCounter {
69     public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {
1 package com.bumptech.photos.resize;
17 public class BitmapTracker {
69     public BitmapTracker(BitmapPool target, int bitmapsPerSize) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,e356a4f7ddc93843f8a28d810ff4c8777032411c,ec22143311afbbcffa25f0babcb12c71826897d4,Remove null checks for bitmap reference counter,"@@ -12,6 +12,8 @@ import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
+import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
 import com.bumptech.photos.resize.cache.DiskCache;
@@ -43,7 +45,7 @@ import java.util.concurrent.RejectedExecutionException;
 public class ImageManager {
     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
-    private final ConcurrentBitmapReferenceCounter bitmapTracker;
+    private final BitmapReferenceCounter bitmapReferenceCounter;
 
     /**
      * A class for setting options for an ImageManager
@@ -286,12 +288,12 @@ public class ImageManager {
                 }
             });
             bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
-            bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
+            bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
         } else {
             if (CAN_RECYCLE)
                 options.bitmapDecodeOptions.inMutable = false;
             bitmapPool = null;
-            bitmapTracker = null;
+            bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
         }
 
         this.memoryCache = memoryCache;
@@ -442,8 +444,7 @@ public class ImageManager {
      * @param b The rejected Bitmap
      */
     public void rejectBitmap(final Bitmap b) {
-        if (bitmapTracker == null) return;
-        bitmapTracker.rejectBitmap(b);
+        bitmapReferenceCounter.rejectBitmap(b);
     }
 
     /**
@@ -455,8 +456,7 @@ public class ImageManager {
      * @param b The acquired Bitmap
      */
     public void acquireBitmap(Bitmap b) {
-        if (bitmapTracker == null) return;
-        bitmapTracker.acquireBitmap(b);
+        bitmapReferenceCounter.acquireBitmap(b);
     }
 
     /**
@@ -468,31 +468,7 @@ public class ImageManager {
      * @param b The releasedBitmap
      */
     public void releaseBitmap(final Bitmap b) {
-        if (bitmapTracker == null) return;
-        bitmapTracker.releaseBitmap(b);
-    }
-
-    /**
-     * An internal method notifying the tracker that this bitmap is referenced but not necessarily used
-     * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
-     * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
-     * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
-     * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
-     * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
-     * recycled once by the memory cache and then again by the object owning the callback.
-     *
-     * @param b The bitmap to mark
-     */
-    private void markBitmapPending(final Bitmap b) {
-        if (bitmapTracker == null) return;
-
-        bitmapTracker.markPending(b);
-    }
-
-    private void initBitmapTracker(final Bitmap b) {
-        if (bitmapTracker == null) return;
-
-        bitmapTracker.initBitmap(b);
+        bitmapReferenceCounter.releaseBitmap(b);
     }
 
     public void cancelTask(Object token) {
@@ -609,7 +585,7 @@ public class ImageManager {
                     diskCache.put(String.valueOf(key), result, diskCacheFormat);
                 }
 
-                initBitmapTracker(result);
+                bitmapReferenceCounter.initBitmap(result);
 
                 putInMemoryCache(key, result);
                 mainHandler.post(new Runnable() {
@@ -629,7 +605,7 @@ public class ImageManager {
     private void putInMemoryCache(int key, Bitmap bitmap) {
         if (memoryCache.put(key, bitmap) != bitmap) {
             acquireBitmap(bitmap);
-            markBitmapPending(bitmap);
+            bitmapReferenceCounter.markPending(bitmap);
         }
     }
 
","15 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
16 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
48     private final BitmapReferenceCounter bitmapReferenceCounter;
291             bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
296             bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
447         bitmapReferenceCounter.rejectBitmap(b);
459         bitmapReferenceCounter.acquireBitmap(b);
471         bitmapReferenceCounter.releaseBitmap(b);
588                 bitmapReferenceCounter.initBitmap(result);
608             bitmapReferenceCounter.markPending(bitmap);
46     private final ConcurrentBitmapReferenceCounter bitmapTracker;
289             bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
294             bitmapTracker = null;
445         if (bitmapTracker == null) return;
446         bitmapTracker.rejectBitmap(b);
458         if (bitmapTracker == null) return;
459         bitmapTracker.acquireBitmap(b);
471         if (bitmapTracker == null) return;
472         bitmapTracker.releaseBitmap(b);
473     }
474 
475     /**
476      * An internal method notifying the tracker that this bitmap is referenced but not necessarily used
477      * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
478      * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
479      * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
480      * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
481      * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
482      * recycled once by the memory cache and then again by the object owning the callback.
483      *
484      * @param b The bitmap to mark
485      */
486     private void markBitmapPending(final Bitmap b) {
487         if (bitmapTracker == null) return;
488 
489         bitmapTracker.markPending(b);
490     }
491 
492     private void initBitmapTracker(final Bitmap b) {
493         if (bitmapTracker == null) return;
494 
495         bitmapTracker.initBitmap(b);
612                 initBitmapTracker(result);
632             markBitmapPending(bitmap);",No
,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapReferenceCounter.java,e356a4f7ddc93843f8a28d810ff4c8777032411c,ec22143311afbbcffa25f0babcb12c71826897d4,Remove null checks for bitmap reference counter,"@@ -0,0 +1,34 @@
+package com.bumptech.photos.resize.bitmap_recycle;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 12:39 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public interface BitmapReferenceCounter {
+
+    public void initBitmap(Bitmap bitmap);
+
+    public void acquireBitmap(Bitmap bitmap);
+
+    public void releaseBitmap(Bitmap bitmap);
+
+    public void rejectBitmap(Bitmap bitmap);
+
+    /**
+     * A method notifying the tracker that this bitmap is referenced but not necessarily used
+     * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
+     * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
+     * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
+     * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
+     * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
+     * recycled once by the memory cache and then again by the object owning the callback.
+     *
+     * @param bitmap The bitmap to mark
+     */
+     public void markPending(Bitmap bitmap);
+}
","1 package com.bumptech.photos.resize.bitmap_recycle;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 12:39 PM
10  * To change this template use File | Settings | File Templates.
11  */
12 public interface BitmapReferenceCounter {
13 
14     public void initBitmap(Bitmap bitmap);
15 
16     public void acquireBitmap(Bitmap bitmap);
17 
18     public void releaseBitmap(Bitmap bitmap);
19 
20     public void rejectBitmap(Bitmap bitmap);
21 
22     /**
23      * A method notifying the tracker that this bitmap is referenced but not necessarily used
24      * by an external object. These bitmaps will not be recycled if their references drop to 0 unless they are
25      * first accepted or are rejected before or after their references drop to 0. This is used because the memory cache
26      * can force a bitmap to be removed b/c of size constraints while a callback referencing that bitmap is still
27      * on the queue of the main thread waiting to be called. If the bitmap were not marked and the memory cache released
28      * the bitmap before the callback was called on the main thread, then the bitmap would be placed in the queue to be
29      * recycled once by the memory cache and then again by the object owning the callback.
30      *
31      * @param bitmap The bitmap to mark
32      */
33      public void markPending(Bitmap bitmap);
34 }",No
,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapReferenceCounterAdapter.java,e356a4f7ddc93843f8a28d810ff4c8777032411c,ec22143311afbbcffa25f0babcb12c71826897d4,Remove null checks for bitmap reference counter,"@@ -0,0 +1,27 @@
+package com.bumptech.photos.resize.bitmap_recycle;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 6/5/13
+ * Time: 3:22 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class BitmapReferenceCounterAdapter implements BitmapReferenceCounter {
+    @Override
+    public void initBitmap(Bitmap bitmap) { }
+
+    @Override
+    public void acquireBitmap(Bitmap bitmap) { }
+
+    @Override
+    public void releaseBitmap(Bitmap bitmap) { }
+
+    @Override
+    public void rejectBitmap(Bitmap bitmap) { }
+
+    @Override
+    public void markPending(Bitmap bitmap) { }
+}
","1 package com.bumptech.photos.resize.bitmap_recycle;
2 
3 import android.graphics.Bitmap;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 3:22 PM
10  * To change this template use File | Settings | File Templates.
11  */
12 public class BitmapReferenceCounterAdapter implements BitmapReferenceCounter {
13     @Override
14     public void initBitmap(Bitmap bitmap) { }
15 
16     @Override
17     public void acquireBitmap(Bitmap bitmap) { }
18 
19     @Override
20     public void releaseBitmap(Bitmap bitmap) { }
21 
22     @Override
23     public void rejectBitmap(Bitmap bitmap) { }
24 
25     @Override
26     public void markPending(Bitmap bitmap) { }
27 }",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,e356a4f7ddc93843f8a28d810ff4c8777032411c,ec22143311afbbcffa25f0babcb12c71826897d4,Remove null checks for bitmap reference counter,"@@ -1,7 +1,6 @@
 package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
@@ -14,7 +13,7 @@ import java.util.concurrent.ConcurrentLinkedQueue;
  * Time: 9:54 AM
  * To change this template use File | Settings | File Templates.
  */
-public class ConcurrentBitmapReferenceCounter {
+public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter {
 
     private static class InnerTrackerPool {
         private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
@@ -71,14 +70,17 @@ public class ConcurrentBitmapReferenceCounter {
         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
     }
 
+    @Override
     public void initBitmap(Bitmap toInit) {
         counter.put(toInit.hashCode(), pool.get());
     }
 
+    @Override
     public void acquireBitmap(Bitmap bitmap) {
         get(bitmap).acquire();
     }
 
+    @Override
     public void releaseBitmap(Bitmap bitmap) {
         final InnerTracker tracker = get(bitmap);
         if (tracker.release()) {
@@ -86,6 +88,7 @@ public class ConcurrentBitmapReferenceCounter {
         }
     }
 
+    @Override
     public void rejectBitmap(Bitmap bitmap) {
         final InnerTracker tracker = get(bitmap);
         if (tracker.reject()) {
@@ -93,6 +96,7 @@ public class ConcurrentBitmapReferenceCounter {
         }
     }
 
+    @Override
     public void markPending(Bitmap bitmap) {
         get(bitmap).markPending();
     }
","16 public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter {
73     @Override
78     @Override
83     @Override
91     @Override
99     @Override
4 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
17 public class ConcurrentBitmapReferenceCounter {",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,4e909cdb8c804b85d7df78a80b87d3077cd896a0,e356a4f7ddc93843f8a28d810ff4c8777032411c,Lock less in the concurrent bitmap pool,"@@ -5,19 +5,17 @@
 package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.util.Log;
 
 import java.util.ArrayDeque;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * A cache of Bitmaps made available by size used to manage recycled bitmaps
  */
 public class ConcurrentBitmapPool implements BitmapPool {
     private static final int DEFAULT_MAX_PER_SIZE = 20;
-    private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
+    private ConcurrentHashMap<Integer, Queue<Bitmap>> availableBitmaps = new ConcurrentHashMap<Integer, Queue<Bitmap>>();
     private final int maxPerSize;
 
     public ConcurrentBitmapPool(int maxPerSize) {
@@ -25,30 +23,35 @@ public class ConcurrentBitmapPool implements BitmapPool {
     }
 
     @Override
-    public synchronized void put(Bitmap bitmap) {
+    public void put(Bitmap bitmap) {
         final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
         if (available == null) {
-            available = new ArrayDeque<Bitmap>();
+            synchronized (this) {
+                available = availableBitmaps.get(sizeKey);
+                if (available == null) {
+                    available = new ArrayDeque<Bitmap>(maxPerSize);
                     availableBitmaps.put(sizeKey, available);
-            available.offer(bitmap);
-        } else if (available.size() < maxPerSize) {
+                }
+            }
+        }
+
+        synchronized (available) {
             available.offer(bitmap);
         }
     }
 
     @Override
-    public synchronized Bitmap get(int width, int height) {
+    public Bitmap get(int width, int height) {
         final int sizeKey = getSizeKey(width, height);
         final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
-
-        if (available == null) {
-            Log.d(""SBC: missing bitmap for key= "" + sizeKey);
-            return null;
-        } else {
-            //Log.d(""SBC:  get key="" + sizeKey + "" available="" + (available.size() - 1));
-            return available.poll();
+        Bitmap result = null;
+        if (available != null) {
+            synchronized (available) {
+                result = available.poll();
+            }
         }
+        return result;
     }
 
     //see http://szudzik.com/ElegantPairing.pdf
","11 import java.util.concurrent.ConcurrentHashMap;
18     private ConcurrentHashMap<Integer, Queue<Bitmap>> availableBitmaps = new ConcurrentHashMap<Integer, Queue<Bitmap>>();
26     public void put(Bitmap bitmap) {
30             synchronized (this) {
31                 available = availableBitmaps.get(sizeKey);
32                 if (available == null) {
33                     available = new ArrayDeque<Bitmap>(maxPerSize);
35                 }
36             }
37         }
38 
39         synchronized (available) {
45     public Bitmap get(int width, int height) {
48         Bitmap result = null;
49         if (available != null) {
50             synchronized (available) {
51                 result = available.poll();
54         return result;
55     }
8 import com.bumptech.photos.util.Log;
11 import java.util.HashMap;
12 import java.util.Map;
20     private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();
28     public synchronized void put(Bitmap bitmap) {
32             available = new ArrayDeque<Bitmap>();
34             available.offer(bitmap);
35         } else if (available.size() < maxPerSize) {
41     public synchronized Bitmap get(int width, int height) {
44 
45         if (available == null) {
46             Log.d(""SBC: missing bitmap for key= "" + sizeKey);
47             return null;
48         } else {
49             //Log.d(""SBC:  get key="" + sizeKey + "" available="" + (available.size() - 1));
50             return available.poll();",No
library\src\com\bumptech\photos\resize\cache\disk\Journal.java,library\src\com\bumptech\photos\resize\cache\disk\Journal.java,ea13d7e8ea6508ec167622d747c415c6040aff19,4e909cdb8c804b85d7df78a80b87d3077cd896a0,Fix some typos/bugs in disk cache journal,"@@ -25,7 +25,7 @@ import java.util.regex.Pattern;
  * To change this template use File | Settings | File Templates.
  */
 public class Journal {
-    private static int MAX_LINES = 10000;
+    private static final int MAX_LINES = 10000;
     private MemoryJournal memoryJournal = null;
     private final File journalFile;
     private BufferedWriter journalWriter;
@@ -117,7 +117,7 @@ public class Journal {
         final File[] files = directory.listFiles(new FileFilter() {
             @Override
             public boolean accept(File file) {
-                return file.getName() != journalFile.getName();
+                return !file.getName().equals(journalFile.getName());
             }
         });
         List<File> fileList = Arrays.asList(files);
@@ -128,7 +128,7 @@ public class Journal {
                 final long arg2 = file2.lastModified();
                 if (arg1 == arg2) {
                     return 0;
-                } else if (arg1 > arg1) {
+                } else if (arg1 > arg2) {
                     return -1;
                 } else {
                     return 1;
","28     private static final int MAX_LINES = 10000;
120                 return !file.getName().equals(journalFile.getName());
131                 } else if (arg1 > arg2) {
28     private static int MAX_LINES = 10000;
120                 return file.getName() != journalFile.getName();
131                 } else if (arg1 > arg1) {",No
library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,cf05cd678cb38154b8c54b5b9dd4526c00074c25,ea13d7e8ea6508ec167622d747c415c6040aff19,Use concurrent hash map in disk cache,"@@ -16,8 +16,7 @@ import java.io.OutputStream;
 import java.math.BigInteger;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
@@ -35,7 +34,7 @@ public class AndroidDiskCache implements DiskCache {
     private final File outputDir;
     private Journal journal;
     private boolean isOpen = false;
-    private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
+    private ConcurrentHashMap<String, ReentrantLock> lockMap = new ConcurrentHashMap<String, ReentrantLock>();
 
     public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
         if (CACHE == null) {
@@ -105,12 +104,12 @@ public class AndroidDiskCache implements DiskCache {
     }
 
     private Lock acquireLockFor(String safeKey) {
-        ReentrantLock lock;
-        synchronized (lockMap) {
-            lock = lockMap.get(safeKey);
+        ReentrantLock lock = lockMap.get(safeKey);
         if (lock == null) {
-                lock = new ReentrantLock();
-                lockMap.put(safeKey, lock);
+            ReentrantLock newLock = new ReentrantLock();
+            lock = lockMap.putIfAbsent(safeKey, newLock);
+            if (lock == null) {
+                lock = newLock;
             }
         }
         return lock;
","19 import java.util.concurrent.ConcurrentHashMap;
37     private ConcurrentHashMap<String, ReentrantLock> lockMap = new ConcurrentHashMap<String, ReentrantLock>();
107         ReentrantLock lock = lockMap.get(safeKey);
109             ReentrantLock newLock = new ReentrantLock();
110             lock = lockMap.putIfAbsent(safeKey, newLock);
111             if (lock == null) {
112                 lock = newLock;
19 import java.util.HashMap;
20 import java.util.Map;
38     private Map<String, ReentrantLock> lockMap = new HashMap<String, ReentrantLock>();
108         ReentrantLock lock;
109         synchronized (lockMap) {
110             lock = lockMap.get(safeKey);
112                 lock = new ReentrantLock();
113                 lockMap.put(safeKey, lock);",No
library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,32686b6b43ef88b4714e3e2bfcc9dc4290e7ba21,cf05cd678cb38154b8c54b5b9dd4526c00074c25,Open disk cache during singleton creation,"@@ -33,12 +33,12 @@ public class AndroidDiskCache implements DiskCache {
 
     private final File outputDir;
     private Journal journal;
-    private boolean isOpen = false;
     private ConcurrentHashMap<String, ReentrantLock> lockMap = new ConcurrentHashMap<String, ReentrantLock>();
 
     public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
         if (CACHE == null) {
             CACHE = new AndroidDiskCache(diskCacheDir, maxCacheSize);
+            CACHE.open();
         }
 
         return CACHE;
@@ -55,8 +55,6 @@ public class AndroidDiskCache implements DiskCache {
     }
 
     private void open() {
-        if (isOpen) return;
-        isOpen = true;
         try {
             journal.open();
         } catch (IOException e) {
@@ -66,10 +64,6 @@ public class AndroidDiskCache implements DiskCache {
 
     @Override
     public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
-        synchronized (this) {
-            if (!isOpen) open();
-        }
-
         final String safeKey = sha1Hash(key);
         final Lock lock = acquireLockFor(safeKey);
         lock.lock();
@@ -117,9 +111,6 @@ public class AndroidDiskCache implements DiskCache {
 
     @Override
     public String get(String key) {
-        synchronized (this) {
-            if (!isOpen) open();
-        }
 
         final String safeKey = sha1Hash(key);
         Lock lock = acquireLockFor(safeKey);
@@ -141,9 +132,6 @@ public class AndroidDiskCache implements DiskCache {
     }
 
     public void remove(String key) {
-        synchronized (this) {
-            if (!isOpen) open();
-        }
         delete(sha1Hash(key));
     }
 
","41             CACHE.open();
36     private boolean isOpen = false;
58         if (isOpen) return;
59         isOpen = true;
69         synchronized (this) {
70             if (!isOpen) open();
71         }
72 
120         synchronized (this) {
121             if (!isOpen) open();
122         }
144         synchronized (this) {
145             if (!isOpen) open();
146         }",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,adf463ee840af5d27be64698f9d218f041670e64,32686b6b43ef88b4714e3e2bfcc9dc4290e7ba21,Fix not limiting # of recycled bitmaps per size,"@@ -36,10 +36,14 @@ public class ConcurrentBitmapPool implements BitmapPool {
             }
         }
 
+        final boolean result;
         synchronized (available) {
+            result = available.size() < maxPerSize;
+            if (result) {
                 available.offer(bitmap);
             }
         }
+    }
 
     @Override
     public Bitmap get(int width, int height) {
","39         final boolean result;
41             result = available.size() < maxPerSize;
42             if (result) {
46     }",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPool.java,58ba89d87f7dc53dd734f32db1cc9c3d56027f44,adf463ee840af5d27be64698f9d218f041670e64,Try to remove and add less from reference counter,"@@ -10,7 +10,7 @@ import android.graphics.Bitmap;
  * To change this template use File | Settings | File Templates.
  */
 public interface BitmapPool {
-    public void put(Bitmap bitmap);
+    public boolean put(Bitmap bitmap);
     public Bitmap get(int width, int height);
 
 }
","13     public boolean put(Bitmap bitmap);
13     public void put(Bitmap bitmap);",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPoolAdapter.java,library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPoolAdapter.java,58ba89d87f7dc53dd734f32db1cc9c3d56027f44,adf463ee840af5d27be64698f9d218f041670e64,Try to remove and add less from reference counter,"@@ -11,7 +11,9 @@ import android.graphics.Bitmap;
  */
 public class BitmapPoolAdapter implements BitmapPool {
     @Override
-    public void put(Bitmap bitmap) { }
+    public boolean put(Bitmap bitmap) {
+        return false;
+    }
 
     @Override
     public Bitmap get(int width, int height) {
","14     public boolean put(Bitmap bitmap) {
15         return false;
16     }
14     public void put(Bitmap bitmap) { }",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,58ba89d87f7dc53dd734f32db1cc9c3d56027f44,adf463ee840af5d27be64698f9d218f041670e64,Try to remove and add less from reference counter,"@@ -23,7 +23,7 @@ public class ConcurrentBitmapPool implements BitmapPool {
     }
 
     @Override
-    public void put(Bitmap bitmap) {
+    public boolean put(Bitmap bitmap) {
         final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
         if (available == null) {
@@ -43,6 +43,8 @@ public class ConcurrentBitmapPool implements BitmapPool {
                 available.offer(bitmap);
             }
         }
+
+        return result;
     }
 
     @Override
","26     public boolean put(Bitmap bitmap) {
46 
47         return result;
26     public void put(Bitmap bitmap) {",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,58ba89d87f7dc53dd734f32db1cc9c3d56027f44,adf463ee840af5d27be64698f9d218f041670e64,Try to remove and add less from reference counter,"@@ -2,7 +2,6 @@ package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
@@ -61,18 +60,22 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
         }
     }
 
-    private final Map<Integer, InnerTracker> counter;
+    private final ConcurrentHashMap<Integer, InnerTracker> counter;
     private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
     public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {
         this.target = target;
-        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
+        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 12);
     }
 
     @Override
     public void initBitmap(Bitmap toInit) {
-        counter.put(toInit.hashCode(), pool.get());
+        final InnerTracker ifAbsent = pool.get();
+        final InnerTracker old = counter.putIfAbsent(toInit.hashCode(), ifAbsent);
+        if (old != null) {
+            pool.release(ifAbsent);
+        }
     }
 
     @Override
@@ -106,8 +109,9 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
     }
 
     private void recycle(InnerTracker tracker, Bitmap bitmap) {
+        if (!target.put(bitmap)) {
             counter.remove(bitmap.hashCode());
             pool.release(tracker);
-        target.put(bitmap);
+        }
     }
 }
","63     private final ConcurrentHashMap<Integer, InnerTracker> counter;
69         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 12);
74         final InnerTracker ifAbsent = pool.get();
75         final InnerTracker old = counter.putIfAbsent(toInit.hashCode(), ifAbsent);
76         if (old != null) {
77             pool.release(ifAbsent);
78         }
112         if (!target.put(bitmap)) {
115         }
5 import java.util.Map;
64     private final Map<Integer, InnerTracker> counter;
70         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);
75         counter.put(toInit.hashCode(), pool.get());
111         target.put(bitmap);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,d1066dce39cc2d2dfd5e95b6a1adb5ca717b8c3b,58ba89d87f7dc53dd734f32db1cc9c3d56027f44,Use background priority levels for threads,"@@ -7,10 +7,7 @@ package com.bumptech.photos.resize;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.os.Build;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.HandlerThread;
+import android.os.*;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
@@ -32,6 +29,9 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ThreadFactory;
+
+import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
 
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
@@ -211,6 +211,17 @@ public class ImageManager {
         return result;
     }
 
+    private static ExecutorService buildExecutor() {
+        return Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
+            @Override
+            public Thread newThread(Runnable runnable) {
+                final Thread result = new Thread(runnable);
+                result.setPriority(Thread.MIN_PRIORITY);
+                return result;
+            }
+        });
+    }
+
     /**
      * Create an ImageManager using the default options. Note that this will create a single background thread to use
      * to resize and load images from disk. Must be created in the UI thread!
@@ -234,7 +245,7 @@ public class ImageManager {
      * @param options The specified options
      */
     public ImageManager(Context context, Options options) {
-        this(context, Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors())), options);
+        this(context, buildExecutor(), options);
     }
 
     /**
@@ -272,7 +283,7 @@ public class ImageManager {
     }
 
     public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
-        HandlerThread bgThread = new HandlerThread(""bg_thread"");
+        HandlerThread bgThread = new HandlerThread(""bg_thread"", THREAD_PRIORITY_BACKGROUND);
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
         executor = resizeService;
","10 import android.os.*;
32 import java.util.concurrent.ThreadFactory;
33 
34 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
214     private static ExecutorService buildExecutor() {
215         return Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
216             @Override
217             public Thread newThread(Runnable runnable) {
218                 final Thread result = new Thread(runnable);
219                 result.setPriority(Thread.MIN_PRIORITY);
220                 return result;
221             }
222         });
223     }
224 
248         this(context, buildExecutor(), options);
286         HandlerThread bgThread = new HandlerThread(""bg_thread"", THREAD_PRIORITY_BACKGROUND);
10 import android.os.Build;
11 import android.os.Environment;
12 import android.os.Handler;
13 import android.os.HandlerThread;
237         this(context, Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors())), options);
275         HandlerThread bgThread = new HandlerThread(""bg_thread"");",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,0c001203beadf5130eb36f72180583f797af7709,d1066dce39cc2d2dfd5e95b6a1adb5ca717b8c3b,"Store exactly resized images in the disk cache

Doing so seems to noticably increase the speed
and smoothness of image loads, presumably because
of the simpler bitmap format we use?","@@ -350,7 +350,7 @@ public class ImageManager {
      */
     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(path, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAsIs(path, width, height);
@@ -360,7 +360,7 @@ public class ImageManager {
 
     public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+        return runJob(key, cb, new ImageManagerJob(key, cb) {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
                 return resizer.loadAsIs(is, width, height);
@@ -397,7 +397,6 @@ public class ImageManager {
         });
     }
 
-
     /**
      * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
      * and then returns a section from the center of image exactly height pixels tall.
@@ -495,11 +494,10 @@ public class ImageManager {
     }
 
     private Object runJob(int key, final LoadedCallback cb, final ImageManagerJob job) {
-        final Object token = job;
         if (!returnFromCache(key, cb)) {
             job.execute();
         }
-        return token;
+        return job;
     }
 
     private boolean returnFromCache(int key, LoadedCallback cb) {
@@ -548,46 +546,39 @@ public class ImageManager {
         public void run() {
             if (cancelled) return;
 
-            final boolean isInDiskCache;
             String path = null;
             if (useDiskCache) {
                 path = diskCache.get(String.valueOf(key));
             }
 
-            isInDiskCache = path != null;
+            if (cancelled) return;
 
-            Bitmap result = null;
-            if (isInDiskCache) {
             try {
-                    result = resizer.loadAsIs(path);
+                if (path != null) {
+                    finishResize(resizer.loadAsIs(path), true);
+                } else {
+                    resizeWithPool();
+                }
             } catch (Exception e) {
-                    e.printStackTrace();
+                cb.onLoadFailed(e);
             }
         }
 
-            if (result == null) {
-                if (cancelled) return;
-                try {
+        //in almost every case exception will be because of race after calling shutdown. Not much we can do
+        //either way
+        private void resizeWithPool() throws RejectedExecutionException {
             future = executor.submit(new Runnable() {
                 @Override
                 public void run() {
+                    if (cancelled) return;
+
                     try {
-                                Bitmap result = resizeIfNotFound();
-                                finishResize(result, isInDiskCache);
+                        finishResize(resizeIfNotFound(), false);
                     } catch (Exception e) {
                         cb.onLoadFailed(e);
                     }
                 }
             });
-                //in almost every case will be because of race after calling shutdown. Not much we can do
-                //either way
-                } catch (RejectedExecutionException e) {
-                    e.printStackTrace();
-                    cb.onLoadFailed(e);
-                }
-            } else {
-                finishResize(result, isInDiskCache);
-            }
         }
 
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
","353         return runJob(key, cb, new ImageManagerJob(key, cb) {
363         return runJob(key, cb, new ImageManagerJob(key, cb) {
500         return job;
555 
557                 if (path != null) {
558                     finishResize(resizer.loadAsIs(path), true);
559                 } else {
560                     resizeWithPool();
561                 }
562             } catch (Exception e) {
563                 cb.onLoadFailed(e);
564             }
565         }
566 
567         //in almost every case exception will be because of race after calling shutdown. Not much we can do
568         //either way
569         private void resizeWithPool() throws RejectedExecutionException {
573                     if (cancelled) return;
574 
576                         finishResize(resizeIfNotFound(), false);
353         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
363         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
400 
498         final Object token = job;
502         return token;
551             final boolean isInDiskCache;
557             isInDiskCache = path != null;
558 
559             Bitmap result = null;
560             if (isInDiskCache) {
561                 try {
562                     result = resizer.loadAsIs(path);
563                 } catch (Exception e) {
564                     e.printStackTrace();
565                 }
566             }
567 
568             if (result == null) {
575                                 Bitmap result = resizeIfNotFound();
576                                 finishResize(result, isInDiskCache);
582                 //in almost every case will be because of race after calling shutdown. Not much we can do
583                 //either way
584                 } catch (RejectedExecutionException e) {
585                     e.printStackTrace();
586                     cb.onLoadFailed(e);
587                 }
588             } else {
589                 finishResize(result, isInDiskCache);
590             }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,fc2ec8570105927bc88b22f8538f5053ba7f05b5,0c001203beadf5130eb36f72180583f797af7709,Reduce some redundant variable passing,"@@ -7,7 +7,10 @@ package com.bumptech.photos.resize;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.os.*;
+import android.os.Build;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.HandlerThread;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
@@ -321,7 +324,7 @@ public class ImageManager {
      */
     public Object getImage(final String path, final LoadedCallback cb){
         final int key = getKey(path, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+        return runJob(key, cb, false, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAsIs(path);
@@ -331,7 +334,7 @@ public class ImageManager {
 
     public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb, false) {
+        return runJob(key, cb, false, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
                 return resizer.loadAsIs(is1, is2);
@@ -350,7 +353,7 @@ public class ImageManager {
      */
     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(path, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAsIs(path, width, height);
@@ -360,7 +363,7 @@ public class ImageManager {
 
     public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
                 return resizer.loadAsIs(is, width, height);
@@ -379,7 +382,7 @@ public class ImageManager {
      */
     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
         final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.loadAtLeast(path, width, height);
@@ -389,7 +392,7 @@ public class ImageManager {
 
     public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
                 return resizer.loadAtLeast(is1, is2, width, height);
@@ -409,7 +412,7 @@ public class ImageManager {
      */
     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
         final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.centerCrop(path, width, height);
@@ -419,7 +422,7 @@ public class ImageManager {
 
     public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
                 return resizer.centerCrop(is1, is2, width, height);
@@ -439,7 +442,7 @@ public class ImageManager {
      */
     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
         final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
-        return runJob(key, cb, new ImageManagerJob(key, cb) {
+        return runJob(key, cb, new ImageManagerJob() {
             @Override
             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
                 return resizer.fitInSpace(path, width, height);
@@ -493,9 +496,13 @@ public class ImageManager {
         bgHandler.getLooper().quit();
     }
 
-    private Object runJob(int key, final LoadedCallback cb, final ImageManagerJob job) {
+    private Object runJob(int key, LoadedCallback cb, ImageManagerJob job) {
+        return runJob(key, cb, true, job);
+    }
+
+    private Object runJob(int key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
         if (!returnFromCache(key, cb)) {
-            job.execute();
+            job.execute(key, cb, useDiskCache);
         }
         return job;
     }
@@ -510,23 +517,16 @@ public class ImageManager {
     }
 
     private abstract class ImageManagerJob implements Runnable {
-        private final int key;
-        private final LoadedCallback cb;
-        private final boolean useDiskCache;
+        private int key;
+        private LoadedCallback cb;
+        private boolean useDiskCache;
         private Future future = null;
         private volatile boolean cancelled = false;
 
-        public ImageManagerJob(int key, LoadedCallback cb) {
-            this(key, cb, true);
-        }
-
-        public ImageManagerJob(int key, LoadedCallback cb, boolean useDiskCache) {
+        public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
             this.key = key;
             this.cb = cb;
             this.useDiskCache = useDiskCache;
-        }
-
-        public void execute() {
             bgHandler.post(this);
         }
 
","10 import android.os.Build;
11 import android.os.Environment;
12 import android.os.Handler;
13 import android.os.HandlerThread;
327         return runJob(key, cb, false, new ImageManagerJob() {
337         return runJob(key, cb, false, new ImageManagerJob() {
356         return runJob(key, cb, new ImageManagerJob() {
366         return runJob(key, cb, new ImageManagerJob() {
385         return runJob(key, cb, new ImageManagerJob() {
395         return runJob(key, cb, new ImageManagerJob() {
415         return runJob(key, cb, new ImageManagerJob() {
425         return runJob(key, cb, new ImageManagerJob() {
445         return runJob(key, cb, new ImageManagerJob() {
499     private Object runJob(int key, LoadedCallback cb, ImageManagerJob job) {
500         return runJob(key, cb, true, job);
501     }
502 
503     private Object runJob(int key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
505             job.execute(key, cb, useDiskCache);
520         private int key;
521         private LoadedCallback cb;
522         private boolean useDiskCache;
526         public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
10 import android.os.*;
324         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
334         return runJob(key, cb, new ImageManagerJob(key, cb, false) {
353         return runJob(key, cb, new ImageManagerJob(key, cb) {
363         return runJob(key, cb, new ImageManagerJob(key, cb) {
382         return runJob(key, cb, new ImageManagerJob(key, cb) {
392         return runJob(key, cb, new ImageManagerJob(key, cb) {
412         return runJob(key, cb, new ImageManagerJob(key, cb) {
422         return runJob(key, cb, new ImageManagerJob(key, cb) {
442         return runJob(key, cb, new ImageManagerJob(key, cb) {
496     private Object runJob(int key, final LoadedCallback cb, final ImageManagerJob job) {
498             job.execute();
513         private final int key;
514         private final LoadedCallback cb;
515         private final boolean useDiskCache;
519         public ImageManagerJob(int key, LoadedCallback cb) {
520             this(key, cb, true);
521         }
522 
523         public ImageManagerJob(int key, LoadedCallback cb, boolean useDiskCache) {
527         }
528 
529         public void execute() {",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,e954f763e7f47e4e632cce8cdc7276bd3816bf0a,fc2ec8570105927bc88b22f8538f5053ba7f05b5,Don't use ArrayDequeue since its api 9+,"@@ -6,7 +6,7 @@ package com.bumptech.photos.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-import java.util.ArrayDeque;
+import java.util.LinkedList;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -30,7 +30,7 @@ public class ConcurrentBitmapPool implements BitmapPool {
             synchronized (this) {
                 available = availableBitmaps.get(sizeKey);
                 if (available == null) {
-                    available = new ArrayDeque<Bitmap>(maxPerSize);
+                    available = new LinkedList<Bitmap>();
                     availableBitmaps.put(sizeKey, available);
                 }
             }
","9 import java.util.LinkedList;
33                     available = new LinkedList<Bitmap>();
9 import java.util.ArrayDeque;
33                     available = new ArrayDeque<Bitmap>(maxPerSize);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,785ee3bd2f343b795a86d07fbc508ef5fc7883fc,e954f763e7f47e4e632cce8cdc7276bd3816bf0a,Delete from disk cache if we fail to load a photo,"@@ -546,22 +546,37 @@ public class ImageManager {
         public void run() {
             if (cancelled) return;
 
-            String path = null;
+            Bitmap result = null;
             if (useDiskCache) {
-                path = diskCache.get(String.valueOf(key));
+                result = loadFromDiskCache();
             }
 
-            if (cancelled) return;
-
+            if (result == null) {
                 try {
-                if (path != null) {
-                    finishResize(resizer.loadAsIs(path), true);
-                } else {
                     resizeWithPool();
-                }
                 } catch (Exception e) {
                     cb.onLoadFailed(e);
                 }
+            } else {
+                finishResize(result, true);
+            }
+        }
+
+        private Bitmap loadFromDiskCache() {
+            final String path = diskCache.get(String.valueOf(key));
+
+            Bitmap result = null;
+            if (path != null) {
+                try {
+                    result = resizer.loadAsIs(path);
+                } catch (FileNotFoundException e) {
+                    e.printStackTrace();
+                }
+                if (result == null) {
+                    diskCache.delete(String.valueOf(key));
+                }
+            }
+            return result;
         }
 
         //in almost every case exception will be because of race after calling shutdown. Not much we can do
","549             Bitmap result = null;
551                 result = loadFromDiskCache();
554             if (result == null) {
560             } else {
561                 finishResize(result, true);
562             }
563         }
564 
565         private Bitmap loadFromDiskCache() {
566             final String path = diskCache.get(String.valueOf(key));
567 
568             Bitmap result = null;
569             if (path != null) {
570                 try {
571                     result = resizer.loadAsIs(path);
572                 } catch (FileNotFoundException e) {
573                     e.printStackTrace();
574                 }
575                 if (result == null) {
576                     diskCache.delete(String.valueOf(key));
577                 }
578             }
579             return result;
549             String path = null;
551                 path = diskCache.get(String.valueOf(key));
554             if (cancelled) return;
555 
557                 if (path != null) {
558                     finishResize(resizer.loadAsIs(path), true);
559                 } else {
561                 }",No
library\src\com\bumptech\photos\resize\cache\DiskCache.java,library\src\com\bumptech\photos\resize\cache\DiskCache.java,785ee3bd2f343b795a86d07fbc508ef5fc7883fc,e954f763e7f47e4e632cce8cdc7276bd3816bf0a,Delete from disk cache if we fail to load a photo,"@@ -12,5 +12,5 @@ import android.graphics.Bitmap;
 public interface DiskCache {
     public String get(String key);
     public void put(String key, Bitmap value, Bitmap.CompressFormat format);
-
+    public void delete(String key);
 }
","15     public void delete(String key);
15 ",No
library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,785ee3bd2f343b795a86d07fbc508ef5fc7883fc,e954f763e7f47e4e632cce8cdc7276bd3816bf0a,Delete from disk cache if we fail to load a photo,"@@ -17,4 +17,7 @@ public class DiskCacheAdapter implements DiskCache {
 
     @Override
     public void put(String key, Bitmap value, Bitmap.CompressFormat format) { }
+
+    @Override
+    public void delete(String key) { }
 }
","20 
21     @Override
22     public void delete(String key) { }",No
library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,785ee3bd2f343b795a86d07fbc508ef5fc7883fc,e954f763e7f47e4e632cce8cdc7276bd3816bf0a,Delete from disk cache if we fail to load a photo,"@@ -131,11 +131,12 @@ public class AndroidDiskCache implements DiskCache {
         }
     }
 
-    public void remove(String key) {
-        delete(sha1Hash(key));
+    @Override
+    public void delete(String key) {
+        remove(sha1Hash(key));
     }
 
-    private void delete(String safeKey) {
+    private void remove(String safeKey) {
         final Lock lock = acquireLockFor(safeKey);
         lock.lock();
         try {
","134     @Override
135     public void delete(String key) {
136         remove(sha1Hash(key));
139     private void remove(String safeKey) {
134     public void remove(String key) {
135         delete(sha1Hash(key));
138     private void delete(String safeKey) {",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,a1210954ad6c1a5c7859161a2beeabce69828024,785ee3bd2f343b795a86d07fbc508ef5fc7883fc,"Revert running IM thread with bg priority

Makes image loading too slow.","@@ -34,8 +34,6 @@ import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadFactory;
 
-import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
-
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
  * sdk version, uses a  combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
@@ -286,7 +284,7 @@ public class ImageManager {
     }
 
     public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
-        HandlerThread bgThread = new HandlerThread(""bg_thread"", THREAD_PRIORITY_BACKGROUND);
+        HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
         executor = resizeService;
","287         HandlerThread bgThread = new HandlerThread(""bg_thread"");
37 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
38 
289         HandlerThread bgThread = new HandlerThread(""bg_thread"", THREAD_PRIORITY_BACKGROUND);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,d344878a73dbdf0d6221ce3f4daaa9f97c33d719,a1210954ad6c1a5c7859161a2beeabce69828024,"Don't post jobs to threads after IM shuts down

If we do, the bg thread might be dead which will
cause an exception when we post to the bg handler.","@@ -47,6 +47,7 @@ public class ImageManager {
     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
     private final BitmapReferenceCounter bitmapReferenceCounter;
+    private boolean shutdown = false;
 
     /**
      * A class for setting options for an ImageManager
@@ -490,6 +491,7 @@ public class ImageManager {
     }
 
     public void shutdown() {
+        shutdown = true;
         executor.shutdown();
         bgHandler.getLooper().quit();
     }
@@ -499,6 +501,8 @@ public class ImageManager {
     }
 
     private Object runJob(int key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
+        if (shutdown) return null;
+
         if (!returnFromCache(key, cb)) {
             job.execute(key, cb, useDiskCache);
         }
","50     private boolean shutdown = false;
494         shutdown = true;
504         if (shutdown) return null;
505 ",No
library\libs\android-support-v4.jar,library\libs\android-support-v4.jar,405de1fc5b1fac1690ce03ec630f584b398e158e,d344878a73dbdf0d6221ce3f4daaa9f97c33d719,upgrade to latest support jar,"Binary files a/library/libs/android-support-v4.jar and b/library/libs/android-support-v4.jar differ
",,No
library\libs\disklrucache-2.0.2.jar,library\libs\disklrucache-2.0.2.jar,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"Binary files /dev/null and b/library/libs/disklrucache-2.0.2.jar differ
",,No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -18,16 +18,18 @@ import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
 import com.bumptech.photos.resize.cache.DiskCache;
 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
+import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
 import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.resize.cache.MemoryCache;
 import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
-import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
 import com.bumptech.photos.util.Log;
 import com.bumptech.photos.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -188,11 +190,16 @@ public class ImageManager {
         if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
             options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
         }
-        final DiskCache result;
+        DiskCache result;
         if (diskCacheDir == null || !options.useDiskCache) {
             result = new DiskCacheAdapter();
         } else {
-            result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);
+            try {
+                result = DiskLruCacheWrapper.get(diskCacheDir, options.maxDiskCacheSize);
+            } catch (IOException e) {
+                e.printStackTrace();
+                result = new DiskCacheAdapter();
+            }
         }
 
         return result;
@@ -548,9 +555,19 @@ public class ImageManager {
         public void run() {
             if (cancelled) return;
 
+            final String stringKey = String.valueOf(key);
             Bitmap result = null;
             if (useDiskCache) {
-                result = loadFromDiskCache();
+                result = diskCache.get(stringKey, new DiskCache.Reader() {
+                    @Override
+                    public Bitmap read(InputStream is1, InputStream is2) {
+                        Bitmap result = resizer.loadAsIs(is1, is2);
+                        if (result == null) {
+                            diskCache.delete(stringKey);
+                        }
+                        return result;
+                    }
+                });
             }
 
             if (result == null) {
@@ -564,23 +581,6 @@ public class ImageManager {
             }
         }
 
-        private Bitmap loadFromDiskCache() {
-            final String path = diskCache.get(String.valueOf(key));
-
-            Bitmap result = null;
-            if (path != null) {
-                try {
-                    result = resizer.loadAsIs(path);
-                } catch (FileNotFoundException e) {
-                    e.printStackTrace();
-                }
-                if (result == null) {
-                    diskCache.delete(String.valueOf(key));
-                }
-            }
-            return result;
-        }
-
         //in almost every case exception will be because of race after calling shutdown. Not much we can do
         //either way
         private void resizeWithPool() throws RejectedExecutionException {
@@ -601,11 +601,15 @@ public class ImageManager {
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
-                    diskCache.put(String.valueOf(key), result, diskCacheFormat);
+                    diskCache.put(String.valueOf(key), new DiskCache.Writer() {
+                        @Override
+                        public void write(OutputStream os) {
+                            result.compress(diskCacheFormat, 100, os);
+                        }
+                    });
                 }
 
                 bitmapReferenceCounter.initBitmap(result);
-
                 putInMemoryCache(key, result);
                 mainHandler.post(new Runnable() {
                     @Override
@@ -614,7 +618,6 @@ public class ImageManager {
                     }
                 });
             }
-
         }
 
         protected abstract Bitmap resizeIfNotFound() throws FileNotFoundException;
","21 import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
30 import java.io.IOException;
32 import java.io.OutputStream;
193         DiskCache result;
197             try {
198                 result = DiskLruCacheWrapper.get(diskCacheDir, options.maxDiskCacheSize);
199             } catch (IOException e) {
200                 e.printStackTrace();
201                 result = new DiskCacheAdapter();
202             }
558             final String stringKey = String.valueOf(key);
561                 result = diskCache.get(stringKey, new DiskCache.Reader() {
562                     @Override
563                     public Bitmap read(InputStream is1, InputStream is2) {
564                         Bitmap result = resizer.loadAsIs(is1, is2);
565                         if (result == null) {
566                             diskCache.delete(stringKey);
567                         }
568                         return result;
569                     }
570                 });
604                     diskCache.put(String.valueOf(key), new DiskCache.Writer() {
605                         @Override
606                         public void write(OutputStream os) {
607                             result.compress(diskCacheFormat, 100, os);
608                         }
609                     });
24 import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;
191         final DiskCache result;
195             result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);
553                 result = loadFromDiskCache();
567         private Bitmap loadFromDiskCache() {
568             final String path = diskCache.get(String.valueOf(key));
569 
570             Bitmap result = null;
571             if (path != null) {
572                 try {
573                     result = resizer.loadAsIs(path);
574                 } catch (FileNotFoundException e) {
575                     e.printStackTrace();
576                 }
577                 if (result == null) {
578                     diskCache.delete(String.valueOf(key));
579                 }
580             }
581             return result;
582         }
583 
604                     diskCache.put(String.valueOf(key), result, diskCacheFormat);
608 
617 ",No
library\src\com\bumptech\photos\resize\cache\DiskCache.java,library\src\com\bumptech\photos\resize\cache\DiskCache.java,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -2,6 +2,9 @@ package com.bumptech.photos.resize.cache;
 
 import android.graphics.Bitmap;
 
+import java.io.InputStream;
+import java.io.OutputStream;
+
 /**
  * Created with IntelliJ IDEA.
  * User: sam
@@ -10,7 +13,15 @@ import android.graphics.Bitmap;
  * To change this template use File | Settings | File Templates.
  */
 public interface DiskCache {
-    public String get(String key);
-    public void put(String key, Bitmap value, Bitmap.CompressFormat format);
+    public interface Writer {
+        public void write(OutputStream os);
+    }
+
+    public interface Reader {
+        public Bitmap read(InputStream is1, InputStream is2);
+    }
+
+    public Bitmap get(String key, Reader reader);
+    public void put(String key, Writer writer);
     public void delete(String key);
 }
","5 import java.io.InputStream;
6 import java.io.OutputStream;
7 
16     public interface Writer {
17         public void write(OutputStream os);
18     }
19 
20     public interface Reader {
21         public Bitmap read(InputStream is1, InputStream is2);
22     }
23 
24     public Bitmap get(String key, Reader reader);
25     public void put(String key, Writer writer);
13     public String get(String key);
14     public void put(String key, Bitmap value, Bitmap.CompressFormat format);",No
library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -11,12 +11,12 @@ import android.graphics.Bitmap;
  */
 public class DiskCacheAdapter implements DiskCache {
     @Override
-    public String get(String key) {
+    public Bitmap get(String key, Reader reader) {
         return null;
     }
 
     @Override
-    public void put(String key, Bitmap value, Bitmap.CompressFormat format) { }
+    public void put(String key, Writer writer) { }
 
     @Override
     public void delete(String key) { }
","14     public Bitmap get(String key, Reader reader) {
19     public void put(String key, Writer writer) { }
14     public String get(String key) {
19     public void put(String key, Bitmap value, Bitmap.CompressFormat format) { }",No
,library\src\com\bumptech\photos\resize\cache\DiskLruCacheWrapper.java,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.photos.resize.cache;
+
+import android.graphics.Bitmap;
+import com.jakewharton.disklrucache.DiskLruCache;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/5/13
+ * Time: 10:57 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class DiskLruCacheWrapper implements DiskCache {
+
+    private static DiskLruCache CACHE = null;
+
+    private synchronized static DiskLruCache getDiskLruCache(File directory, int maxSize) throws IOException {
+        if (CACHE == null) {
+            CACHE = DiskLruCache.open(directory, 0, 1, maxSize);
+        }
+        return CACHE;
+    }
+
+    public static DiskLruCacheWrapper get(File directory, int maxSize) throws IOException {
+        return new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
+    }
+
+    private final DiskLruCache diskLruCache;
+
+    protected DiskLruCacheWrapper(DiskLruCache diskLruCache) {
+        this.diskLruCache = diskLruCache;
+    }
+
+    @Override
+    public Bitmap get(String key, Reader reader) {
+        Bitmap result = null;
+        try {
+            //It is possible that the there will be a put in between these two gets. If so that shouldn't be a problem
+            //because we will always put the same value at the same key so our input streams will still represent
+            //the same data
+            final DiskLruCache.Snapshot snapshot1 = diskLruCache.get(key);
+            if (snapshot1 != null) {
+                final DiskLruCache.Snapshot snapshot2 = diskLruCache.get(key);
+                if (snapshot2 != null) {
+                    final InputStream is1 = snapshot1.getInputStream(0);
+                    final InputStream is2 = snapshot2.getInputStream(0);
+                    result = reader.read(is1, is2);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+
+    @Override
+    public void put(String key, Writer writer) {
+        try {
+            DiskLruCache.Editor editor = diskLruCache.edit(key);
+            //editor will be null if there are two concurrent puts
+            //worst case just silently fail
+            if (editor != null) {
+                writer.write(editor.newOutputStream(0));
+                editor.commit();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void delete(String key) {
+        try {
+            diskLruCache.remove(key);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
","1 /*
2  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.resize.cache;
6 
7 import android.graphics.Bitmap;
8 import com.jakewharton.disklrucache.DiskLruCache;
9 
10 import java.io.File;
11 import java.io.IOException;
12 import java.io.InputStream;
13 
14 /**
15  * Created with IntelliJ IDEA.
16  * User: sam
17  * Date: 7/5/13
18  * Time: 10:57 AM
19  * To change this template use File | Settings | File Templates.
20  */
21 public class DiskLruCacheWrapper implements DiskCache {
22 
23     private static DiskLruCache CACHE = null;
24 
25     private synchronized static DiskLruCache getDiskLruCache(File directory, int maxSize) throws IOException {
26         if (CACHE == null) {
27             CACHE = DiskLruCache.open(directory, 0, 1, maxSize);
28         }
29         return CACHE;
30     }
31 
32     public static DiskLruCacheWrapper get(File directory, int maxSize) throws IOException {
33         return new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
34     }
35 
36     private final DiskLruCache diskLruCache;
37 
38     protected DiskLruCacheWrapper(DiskLruCache diskLruCache) {
39         this.diskLruCache = diskLruCache;
40     }
41 
42     @Override
43     public Bitmap get(String key, Reader reader) {
44         Bitmap result = null;
45         try {
46             //It is possible that the there will be a put in between these two gets. If so that shouldn't be a problem
47             //because we will always put the same value at the same key so our input streams will still represent
48             //the same data
49             final DiskLruCache.Snapshot snapshot1 = diskLruCache.get(key);
50             if (snapshot1 != null) {
51                 final DiskLruCache.Snapshot snapshot2 = diskLruCache.get(key);
52                 if (snapshot2 != null) {
53                     final InputStream is1 = snapshot1.getInputStream(0);
54                     final InputStream is2 = snapshot2.getInputStream(0);
55                     result = reader.read(is1, is2);
56                 }
57             }
58         } catch (IOException e) {
59             e.printStackTrace();
60         }
61         return result;
62     }
63 
64     @Override
65     public void put(String key, Writer writer) {
66         try {
67             DiskLruCache.Editor editor = diskLruCache.edit(key);
68             //editor will be null if there are two concurrent puts
69             //worst case just silently fail
70             if (editor != null) {
71                 writer.write(editor.newOutputStream(0));
72                 editor.commit();
73             }
74         } catch (IOException e) {
75             e.printStackTrace();
76         }
77     }
78 
79     @Override
80     public void delete(String key) {
81         try {
82             diskLruCache.remove(key);
83         } catch (IOException e) {
84             e.printStackTrace();
85         }
86     }
87 }",No
library\src\com\bumptech\photos\resize\cache\disk\AndroidDiskCache.java,,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -1,171 +0,0 @@
-/*
- * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.resize.cache.disk;
-
-import android.graphics.Bitmap;
-import com.bumptech.photos.resize.cache.DiskCache;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/26/13
- * Time: 9:20 AM
- * To change this template use File | Settings | File Templates.
- */
-public class AndroidDiskCache implements DiskCache {
-    private static final String JOURNAL_FILE_NAME = ""JOURNAL"";
-    private static AndroidDiskCache CACHE = null;
-
-    private final File outputDir;
-    private Journal journal;
-    private ConcurrentHashMap<String, ReentrantLock> lockMap = new ConcurrentHashMap<String, ReentrantLock>();
-
-    public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
-        if (CACHE == null) {
-            CACHE = new AndroidDiskCache(diskCacheDir, maxCacheSize);
-            CACHE.open();
-        }
-
-        return CACHE;
-    }
-
-    protected AndroidDiskCache(File outputDir, int maxCacheSize) {
-        this.outputDir = outputDir;
-        this.journal = new Journal(getFile(JOURNAL_FILE_NAME), maxCacheSize, new Journal.EvictionListener() {
-            @Override
-            public void onKeyEvicted(String safeKey) {
-                delete(safeKey);
-            }
-        });
-    }
-
-    private void open() {
-        try {
-            journal.open();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Override
-    public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
-        final String safeKey = sha1Hash(key);
-        final Lock lock = acquireLockFor(safeKey);
-        lock.lock();
-        try {
-            final File outFile = getFile(safeKey);
-
-            OutputStream out = null;
-            try {
-                if (!outFile.exists()) outFile.createNewFile();
-
-                out = new BufferedOutputStream(new FileOutputStream(outFile), 8192);
-                bitmap.compress(format, 100, out);
-            } catch (FileNotFoundException e) {
-                e.printStackTrace();
-            } catch (IOException e) {
-                e.printStackTrace();
-            } finally {
-                if (out != null) {
-                    try {
-                        out.close();
-                    } catch (IOException e1) { }
-                }
-            }
-            try {
-                journal.put(safeKey, (int) outFile.length());
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    private Lock acquireLockFor(String safeKey) {
-        ReentrantLock lock = lockMap.get(safeKey);
-        if (lock == null) {
-            ReentrantLock newLock = new ReentrantLock();
-            lock = lockMap.putIfAbsent(safeKey, newLock);
-            if (lock == null) {
-                lock = newLock;
-            }
-        }
-        return lock;
-    }
-
-    @Override
-    public String get(String key) {
-
-        final String safeKey = sha1Hash(key);
-        Lock lock = acquireLockFor(safeKey);
-        lock.lock();
-        try {
-            final File inFile = getFile(safeKey);
-            if (!inFile.exists()) return null;
-
-            try {
-                journal.get(safeKey);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-
-            return inFile.getAbsolutePath();
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    @Override
-    public void delete(String key) {
-        remove(sha1Hash(key));
-    }
-
-    private void remove(String safeKey) {
-        final Lock lock = acquireLockFor(safeKey);
-        lock.lock();
-        try {
-            final File toDelete = getFile(safeKey);
-            toDelete.delete();
-            try {
-                journal.delete(safeKey);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    private File getFile(String safeKey) {
-        return new File(outputDir + File.separator + safeKey);
-    }
-
-    private static String sha1Hash(String toHash) {
-        String hash = null;
-        try {
-            byte[] bytes = toHash.getBytes();
-            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
-            digest.update(bytes, 0, bytes.length);
-            hash = new BigInteger(1, digest.digest()).toString(16);
-        } catch (NoSuchAlgorithmException e) {
-            e.printStackTrace();
-        }
-        return hash;
-    }
-}
","1 /*
2  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.resize.cache.disk;
6 
7 import android.graphics.Bitmap;
8 import com.bumptech.photos.resize.cache.DiskCache;
9 
10 import java.io.BufferedOutputStream;
11 import java.io.File;
12 import java.io.FileNotFoundException;
13 import java.io.FileOutputStream;
14 import java.io.IOException;
15 import java.io.OutputStream;
16 import java.math.BigInteger;
17 import java.security.MessageDigest;
18 import java.security.NoSuchAlgorithmException;
19 import java.util.concurrent.ConcurrentHashMap;
20 import java.util.concurrent.locks.Lock;
21 import java.util.concurrent.locks.ReentrantLock;
22 
23 /**
24  * Created with IntelliJ IDEA.
25  * User: sam
26  * Date: 1/26/13
27  * Time: 9:20 AM
28  * To change this template use File | Settings | File Templates.
29  */
30 public class AndroidDiskCache implements DiskCache {
31     private static final String JOURNAL_FILE_NAME = ""JOURNAL"";
32     private static AndroidDiskCache CACHE = null;
33 
34     private final File outputDir;
35     private Journal journal;
36     private ConcurrentHashMap<String, ReentrantLock> lockMap = new ConcurrentHashMap<String, ReentrantLock>();
37 
38     public static synchronized AndroidDiskCache get(File diskCacheDir, int maxCacheSize) {
39         if (CACHE == null) {
40             CACHE = new AndroidDiskCache(diskCacheDir, maxCacheSize);
41             CACHE.open();
42         }
43 
44         return CACHE;
45     }
46 
47     protected AndroidDiskCache(File outputDir, int maxCacheSize) {
48         this.outputDir = outputDir;
49         this.journal = new Journal(getFile(JOURNAL_FILE_NAME), maxCacheSize, new Journal.EvictionListener() {
50             @Override
51             public void onKeyEvicted(String safeKey) {
52                 delete(safeKey);
53             }
54         });
55     }
56 
57     private void open() {
58         try {
59             journal.open();
60         } catch (IOException e) {
61             e.printStackTrace();
62         }
63     }
64 
65     @Override
66     public void put(String key, final Bitmap bitmap, Bitmap.CompressFormat format) {
67         final String safeKey = sha1Hash(key);
68         final Lock lock = acquireLockFor(safeKey);
69         lock.lock();
70         try {
71             final File outFile = getFile(safeKey);
72 
73             OutputStream out = null;
74             try {
75                 if (!outFile.exists()) outFile.createNewFile();
76 
77                 out = new BufferedOutputStream(new FileOutputStream(outFile), 8192);
78                 bitmap.compress(format, 100, out);
79             } catch (FileNotFoundException e) {
80                 e.printStackTrace();
81             } catch (IOException e) {
82                 e.printStackTrace();
83             } finally {
84                 if (out != null) {
85                     try {
86                         out.close();
87                     } catch (IOException e1) { }
88                 }
89             }
90             try {
91                 journal.put(safeKey, (int) outFile.length());
92             } catch (IOException e) {
93                 e.printStackTrace();
94             }
95         } finally {
96             lock.unlock();
97         }
98     }
99 
100     private Lock acquireLockFor(String safeKey) {
101         ReentrantLock lock = lockMap.get(safeKey);
102         if (lock == null) {
103             ReentrantLock newLock = new ReentrantLock();
104             lock = lockMap.putIfAbsent(safeKey, newLock);
105             if (lock == null) {
106                 lock = newLock;
107             }
108         }
109         return lock;
110     }
111 
112     @Override
113     public String get(String key) {
114 
115         final String safeKey = sha1Hash(key);
116         Lock lock = acquireLockFor(safeKey);
117         lock.lock();
118         try {
119             final File inFile = getFile(safeKey);
120             if (!inFile.exists()) return null;
121 
122             try {
123                 journal.get(safeKey);
124             } catch (IOException e) {
125                 e.printStackTrace();
126             }
127 
128             return inFile.getAbsolutePath();
129         } finally {
130             lock.unlock();
131         }
132     }
133 
134     @Override
135     public void delete(String key) {
136         remove(sha1Hash(key));
137     }
138 
139     private void remove(String safeKey) {
140         final Lock lock = acquireLockFor(safeKey);
141         lock.lock();
142         try {
143             final File toDelete = getFile(safeKey);
144             toDelete.delete();
145             try {
146                 journal.delete(safeKey);
147             } catch (IOException e) {
148                 e.printStackTrace();
149             }
150         } finally {
151             lock.unlock();
152         }
153     }
154 
155     private File getFile(String safeKey) {
156         return new File(outputDir + File.separator + safeKey);
157     }
158 
159     private static String sha1Hash(String toHash) {
160         String hash = null;
161         try {
162             byte[] bytes = toHash.getBytes();
163             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
164             digest.update(bytes, 0, bytes.length);
165             hash = new BigInteger(1, digest.digest()).toString(16);
166         } catch (NoSuchAlgorithmException e) {
167             e.printStackTrace();
168         }
169         return hash;
170     }
171 }",No
library\src\com\bumptech\photos\resize\cache\disk\Journal.java,,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -1,197 +0,0 @@
-package com.bumptech.photos.resize.cache.disk;
-
-import android.support.v4.util.LruCache;
-import com.bumptech.photos.util.Log;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileFilter;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/28/13
- * Time: 9:58 AM
- * To change this template use File | Settings | File Templates.
- */
-public class Journal {
-    private static final int MAX_LINES = 10000;
-    private MemoryJournal memoryJournal = null;
-    private final File journalFile;
-    private BufferedWriter journalWriter;
-    private final int maxCacheSize;
-    private int numLines = 0;
-    private final EvictionListener evictionListener;
-    private boolean loading = false;
-
-    public interface EvictionListener {
-        public void onKeyEvicted(String safeKey);
-    }
-
-    private enum Action{
-        GET,
-        SET,
-        DEL,
-    }
-
-    public Journal(File journalFile, int maxCacheSize, EvictionListener evictionListener) {
-        this.maxCacheSize = maxCacheSize;
-        this.journalFile = journalFile;
-        this.evictionListener = evictionListener;
-    }
-
-    private class MemoryJournal extends LruCache<String, Integer> {
-        private final EvictionListener evictionListener;
-
-        public MemoryJournal(int maxSize, EvictionListener evictionListener) {
-            super(maxSize);
-            this.evictionListener = evictionListener;
-        }
-
-        @Override
-        protected void entryRemoved(boolean evicted, String key, Integer oldValue, Integer newValue) {
-            super.entryRemoved(evicted, key, oldValue, newValue);
-            if (evicted && !loading) {
-                evictionListener.onKeyEvicted(key);
-            }
-        }
-
-        @Override
-        protected int sizeOf(String key, Integer value) {
-            return value;
-        }
-    }
-
-    public synchronized void open() throws IOException {
-        journalFile.createNewFile();
-        journalWriter = new BufferedWriter(new FileWriter(journalFile, true));
-        if (memoryJournal == null) {
-            memoryJournal = new MemoryJournal(maxCacheSize, evictionListener);
-            replayFromDisk();
-        }
-    }
-
-    private void replayFromDisk() throws IOException {
-        loading = true;
-        final Pattern regex = Pattern.compile("" "");
-        String line;
-        BufferedReader reader = null;
-        numLines = 0;
-        try {
-            reader = new BufferedReader(new FileReader(journalFile));
-            while ((line = reader.readLine()) != null) {
-                numLines++;
-                String[] splitLine = regex.split(line);
-                final Action action = Action.valueOf(splitLine[0]);
-                if (action == Action.SET) {
-                    memoryJournal.put(splitLine[1], Integer.parseInt(splitLine[2]));
-                } else if (action == Action.GET) {
-                    memoryJournal.get(splitLine[1]);
-                } else {
-                    memoryJournal.remove(splitLine[1]);
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.d(""DISKCACHE: corrupt journal, rebuilding from disk"");
-            rebuildFromDisk();
-        } finally {
-            if (reader != null)
-                reader.close();
-        }
-        loading = false;
-    }
-
-    private void rebuildFromDisk() {
-        File directory = journalFile.getParentFile();
-        final File[] files = directory.listFiles(new FileFilter() {
-            @Override
-            public boolean accept(File file) {
-                return !file.getName().equals(journalFile.getName());
-            }
-        });
-        List<File> fileList = Arrays.asList(files);
-        Collections.sort(fileList, new Comparator<File>() {
-            @Override
-            public int compare(File file, File file2) {
-                final long arg1 = file.lastModified();
-                final long arg2 = file2.lastModified();
-                if (arg1 == arg2) {
-                    return 0;
-                } else if (arg1 > arg2) {
-                    return -1;
-                } else {
-                    return 1;
-                }
-            }
-        });
-
-        memoryJournal.evictAll();
-        for (File f : fileList) {
-            memoryJournal.put(f.getName(), (int) f.length());
-        }
-
-        try {
-            compact();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public synchronized void put(String safeKey, int size) throws IOException {
-        writeLine(buildLine(Action.SET, safeKey, String.valueOf(size)));
-        memoryJournal.put(safeKey, size);
-    }
-
-    public synchronized void get(String safeKey) throws IOException {
-        writeLine(buildLine(Action.GET, safeKey));
-        memoryJournal.get(safeKey);
-    }
-
-    public synchronized void delete(String safeKey) throws IOException {
-        writeLine(buildLine(Action.DEL, safeKey));
-        memoryJournal.remove(safeKey);
-    }
-
-    private void writeLine(String line) throws IOException {
-        journalWriter.write(line);
-        journalWriter.newLine();
-        numLines++;
-
-        if (shouldCompact()) {
-            compact();
-        }
-    }
-
-    private void compact() throws IOException {
-        numLines = 0;
-        journalWriter = new BufferedWriter(new FileWriter(journalFile));
-        final Map<String, Integer> snapshot = memoryJournal.snapshot();
-        for (String key : snapshot.keySet()) {
-            writeLine(buildLine(Action.SET, key, String.valueOf(snapshot.get(key))));
-        }
-    }
-
-    private boolean shouldCompact() {
-        return numLines > MAX_LINES;
-    }
-
-    private static String buildLine(Action action, String... args) {
-        StringBuilder builder = new StringBuilder().append(action.name());
-        for (String arg : args) {
-            builder.append("" "");
-            builder.append(arg);
-        }
-        return builder.toString();
-    }
-}
","1 package com.bumptech.photos.resize.cache.disk;
2 
3 import android.support.v4.util.LruCache;
4 import com.bumptech.photos.util.Log;
5 
6 import java.io.BufferedReader;
7 import java.io.BufferedWriter;
8 import java.io.File;
9 import java.io.FileFilter;
10 import java.io.FileReader;
11 import java.io.FileWriter;
12 import java.io.IOException;
13 import java.util.Arrays;
14 import java.util.Collections;
15 import java.util.Comparator;
16 import java.util.List;
17 import java.util.Map;
18 import java.util.regex.Pattern;
19 
20 /**
21  * Created with IntelliJ IDEA.
22  * User: sam
23  * Date: 1/28/13
24  * Time: 9:58 AM
25  * To change this template use File | Settings | File Templates.
26  */
27 public class Journal {
28     private static final int MAX_LINES = 10000;
29     private MemoryJournal memoryJournal = null;
30     private final File journalFile;
31     private BufferedWriter journalWriter;
32     private final int maxCacheSize;
33     private int numLines = 0;
34     private final EvictionListener evictionListener;
35     private boolean loading = false;
36 
37     public interface EvictionListener {
38         public void onKeyEvicted(String safeKey);
39     }
40 
41     private enum Action{
42         GET,
43         SET,
44         DEL,
45     }
46 
47     public Journal(File journalFile, int maxCacheSize, EvictionListener evictionListener) {
48         this.maxCacheSize = maxCacheSize;
49         this.journalFile = journalFile;
50         this.evictionListener = evictionListener;
51     }
52 
53     private class MemoryJournal extends LruCache<String, Integer> {
54         private final EvictionListener evictionListener;
55 
56         public MemoryJournal(int maxSize, EvictionListener evictionListener) {
57             super(maxSize);
58             this.evictionListener = evictionListener;
59         }
60 
61         @Override
62         protected void entryRemoved(boolean evicted, String key, Integer oldValue, Integer newValue) {
63             super.entryRemoved(evicted, key, oldValue, newValue);
64             if (evicted && !loading) {
65                 evictionListener.onKeyEvicted(key);
66             }
67         }
68 
69         @Override
70         protected int sizeOf(String key, Integer value) {
71             return value;
72         }
73     }
74 
75     public synchronized void open() throws IOException {
76         journalFile.createNewFile();
77         journalWriter = new BufferedWriter(new FileWriter(journalFile, true));
78         if (memoryJournal == null) {
79             memoryJournal = new MemoryJournal(maxCacheSize, evictionListener);
80             replayFromDisk();
81         }
82     }
83 
84     private void replayFromDisk() throws IOException {
85         loading = true;
86         final Pattern regex = Pattern.compile("" "");
87         String line;
88         BufferedReader reader = null;
89         numLines = 0;
90         try {
91             reader = new BufferedReader(new FileReader(journalFile));
92             while ((line = reader.readLine()) != null) {
93                 numLines++;
94                 String[] splitLine = regex.split(line);
95                 final Action action = Action.valueOf(splitLine[0]);
96                 if (action == Action.SET) {
97                     memoryJournal.put(splitLine[1], Integer.parseInt(splitLine[2]));
98                 } else if (action == Action.GET) {
99                     memoryJournal.get(splitLine[1]);
100                 } else {
101                     memoryJournal.remove(splitLine[1]);
102                 }
103             }
104         } catch (Exception e) {
105             e.printStackTrace();
106             Log.d(""DISKCACHE: corrupt journal, rebuilding from disk"");
107             rebuildFromDisk();
108         } finally {
109             if (reader != null)
110                 reader.close();
111         }
112         loading = false;
113     }
114 
115     private void rebuildFromDisk() {
116         File directory = journalFile.getParentFile();
117         final File[] files = directory.listFiles(new FileFilter() {
118             @Override
119             public boolean accept(File file) {
120                 return !file.getName().equals(journalFile.getName());
121             }
122         });
123         List<File> fileList = Arrays.asList(files);
124         Collections.sort(fileList, new Comparator<File>() {
125             @Override
126             public int compare(File file, File file2) {
127                 final long arg1 = file.lastModified();
128                 final long arg2 = file2.lastModified();
129                 if (arg1 == arg2) {
130                     return 0;
131                 } else if (arg1 > arg2) {
132                     return -1;
133                 } else {
134                     return 1;
135                 }
136             }
137         });
138 
139         memoryJournal.evictAll();
140         for (File f : fileList) {
141             memoryJournal.put(f.getName(), (int) f.length());
142         }
143 
144         try {
145             compact();
146         } catch (IOException e) {
147             e.printStackTrace();
148         }
149     }
150 
151     public synchronized void put(String safeKey, int size) throws IOException {
152         writeLine(buildLine(Action.SET, safeKey, String.valueOf(size)));
153         memoryJournal.put(safeKey, size);
154     }
155 
156     public synchronized void get(String safeKey) throws IOException {
157         writeLine(buildLine(Action.GET, safeKey));
158         memoryJournal.get(safeKey);
159     }
160 
161     public synchronized void delete(String safeKey) throws IOException {
162         writeLine(buildLine(Action.DEL, safeKey));
163         memoryJournal.remove(safeKey);
164     }
165 
166     private void writeLine(String line) throws IOException {
167         journalWriter.write(line);
168         journalWriter.newLine();
169         numLines++;
170 
171         if (shouldCompact()) {
172             compact();
173         }
174     }
175 
176     private void compact() throws IOException {
177         numLines = 0;
178         journalWriter = new BufferedWriter(new FileWriter(journalFile));
179         final Map<String, Integer> snapshot = memoryJournal.snapshot();
180         for (String key : snapshot.keySet()) {
181             writeLine(buildLine(Action.SET, key, String.valueOf(snapshot.get(key))));
182         }
183     }
184 
185     private boolean shouldCompact() {
186         return numLines > MAX_LINES;
187     }
188 
189     private static String buildLine(Action action, String... args) {
190         StringBuilder builder = new StringBuilder().append(action.name());
191         for (String arg : args) {
192             builder.append("" "");
193             builder.append(arg);
194         }
195         return builder.toString();
196     }
197 }",No
library\src\com\bumptech\photos\util\Util.java,library\src\com\bumptech\photos\util\Util.java,309fea9a2ecf04b8466cc3869b5af798199cd8d5,405de1fc5b1fac1690ce03ec630f584b398e158e,Replace disk cache with open source cache,"@@ -1,5 +1,9 @@
 package com.bumptech.photos.util;
 
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
 /**
  * Created with IntelliJ IDEA.
  * User: sam
@@ -17,4 +21,17 @@ public class Util {
         }
         return result;
     }
+
+    public static String sha1Hash(String toHash) {
+        String hash = null;
+        try {
+            byte[] bytes = toHash.getBytes();
+            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
+            digest.update(bytes, 0, bytes.length);
+            hash = new BigInteger(1, digest.digest()).toString(16);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+        return hash;
+    }
 }
","3 import java.math.BigInteger;
4 import java.security.MessageDigest;
5 import java.security.NoSuchAlgorithmException;
6 
24 
25     public static String sha1Hash(String toHash) {
26         String hash = null;
27         try {
28             byte[] bytes = toHash.getBytes();
29             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
30             digest.update(bytes, 0, bytes.length);
31             hash = new BigInteger(1, digest.digest()).toString(16);
32         } catch (NoSuchAlgorithmException e) {
33             e.printStackTrace();
34         }
35         return hash;
36     }",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,34ea26f6351441ce8592c4800d5588680b71cd93,309fea9a2ecf04b8466cc3869b5af798199cd8d5,Use a builder for ImageManager,"@@ -46,83 +46,13 @@ import java.util.concurrent.ThreadFactory;
  * that Bitmap recycling is only available on Honeycomb and up.
  */
 public class ImageManager {
-    private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
-    private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
+    private static final String DEFAULT_DISK_CACHE_DIR = ""image_manager_disk_cache"";
+    private static final int DEFAULT_DISK_CACHE_SIZE = 30 * 1024 * 1024;
+    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
+
     private final BitmapReferenceCounter bitmapReferenceCounter;
     private boolean shutdown = false;
 
-    /**
-     * A class for setting options for an ImageManager
-     *
-     * Boolean use options for the caches superseed sizes, and invalid * sizes (<= 0) are equivalent to setting the
-     * corresponding use option to false.
-     */
-    public static class Options {
-        /**
-         * If true caches bitmaps in memory.
-         *
-         * Defaults to true
-         */
-        public boolean useMemoryCache = true;
-
-        /**
-         * The maximum memory cache size. This should be decreased on devices where recycling Bitmaps is possible and
-         * enabled because the Bitmap cache used to recycle Bitmaps will take a substantial amount of memory.
-         *
-         * Defaults to 1/8th of the total application memory
-         */
-        public int maxMemorySize;
-
-        /**
-         * If true, caches resized bitmaps on disk.
-         */
-        public boolean useDiskCache = true;
-
-        /**
-         * The maximum disk cache size.
-         *
-         * Defaults to 30mb
-         */
-        public int maxDiskCacheSize;
-
-       /**
-        * The output format used to store bitmaps on disk in the disk cache
-        */
-        public Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
-
-        /**
-         * If true, will attempt to recycle Bitmaps and all loaded Bitmaps will be mutable. If true and a memory cache
-         * is used, the memory cache size should be decreased since the Bitmap cache used to recycle Bitmaps will
-         * take a substantial amount of memory.
-         *
-         * Defaults to true if Android version is 3.0 or greater and will always be false, regardless of this attribute
-         * otherwise.
-         */
-        public boolean recycleBitmaps = true;
-
-        /**
-         * The maximum number of recycled bitmaps of any requested size to keep around. Only used if recycleBitmaps
-         * is true. A higher number means loads are more likely to be able to reuse a bitmap but also that this object
-         * will use more memory. Increase this if there are few varieties of bitmaps that will be scrolled rapidly (ie
-         * a GridView of images with lots of columns), and decrease it if there are a lot of different sizes of bitmaps
-         * and limited memory is available.
-         *
-         * Defaults to 20
-         */
-        public int maxPerSize = 0;
-
-        /**
-         * Options for loading bitmaps. Some of these fields will be overwritten, including inSampleSize, inBitmap,
-         * and maybe inMutable depending on how recycleBitmaps is set.
-         *
-         * Config and dither for example can be set
-         */
-        public BitmapFactory.Options bitmapDecodeOptions = ImageResizer.getDefaultOptions();
-
-    }
-
-    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
-
     private final Handler mainHandler = new Handler();
     private final Handler bgHandler;
     private final ExecutorService executor;
@@ -143,7 +73,7 @@ public class ImageManager {
      * cache directory if no name is provided
      */
     public static File getPhotoCacheDir(Context context) {
-        return getPhotoCacheDir(context, DISK_CACHE_DIR);
+        return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
     }
 
     public static File getPhotoCacheDir(Context context, String cacheName) {
@@ -186,42 +116,112 @@ public class ImageManager {
         }
     }
 
-    private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {
-        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
-            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
+    public static class Builder {
+        private final Context context;
+
+        private ExecutorService resizeService = null;
+        private MemoryCache memoryCache = null;
+        private DiskCache diskCache = null;
+
+        private Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
+        private boolean recycleBitmaps = CAN_RECYCLE;
+        private int maxBitmapsPerSize = 20;
+
+        public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();
+
+        public Builder(Context context) {
+            this.context = context;
         }
-        DiskCache result;
-        if (diskCacheDir == null || !options.useDiskCache) {
-            result = new DiskCacheAdapter();
-        } else {
-            try {
-                result = DiskLruCacheWrapper.get(diskCacheDir, options.maxDiskCacheSize);
-            } catch (IOException e) {
-                e.printStackTrace();
-                result = new DiskCacheAdapter();
+
+        public ImageManager build() {
+            setDefaults();
+
+            return new ImageManager(this);
+        }
+
+        public Builder setResizeService(ExecutorService resizeService) {
+            this.resizeService = resizeService;
+            return this;
         }
+
+        public Builder setDiskCacheFormat(Bitmap.CompressFormat diskCacheFormat) {
+            this.diskCacheFormat = diskCacheFormat;
+            return this;
         }
 
-        return result;
+        public Builder setRecycleBitmaps(boolean recycleBitmaps) {
+            this.recycleBitmaps = recycleBitmaps && CAN_RECYCLE;
+            return this;
+        }
 
+        public Builder setMemoryCache(MemoryCache memoryCache) {
+            this.memoryCache = memoryCache;
+            return this;
         }
 
-    private static MemoryCache buildMemoryCache(Options options, Context context) {
-        if (options.useMemoryCache && options.maxMemorySize <= 0) {
-            options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
+        public Builder disableMemoryCache() {
+            if (memoryCache != null) {
+                throw new IllegalArgumentException(""Can't disable memory cache after setting it"");
+            }
+            memoryCache = new MemoryCacheAdapter();
+            return this;
         }
 
-        final MemoryCache result;
-        if (!options.useMemoryCache) {
-            result = new MemoryCacheAdapter();
-        } else {
-            result = new LruPhotoCache(options.maxMemorySize);
+        public Builder setDefaultMemoryCacheSize(int maxSize) {
+            if (memoryCache != null) {
+                throw new IllegalArgumentException(""Can't set a default memory cache after setting a custom one"");
             }
-        return result;
+
+            memoryCache = new LruPhotoCache(maxSize);
+            return this;
+        }
+
+        public Builder setDiskCache(DiskCache diskCache) {
+            this.diskCache = diskCache;
+            return this;
+        }
+
+        public Builder disableDiskCache() {
+            diskCache = new DiskCacheAdapter();
+            return this;
+        }
+
+        public Builder setDefaultDiskCacheOptions(File dir) {
+            setDefaultDiskCacheOptions(dir, DEFAULT_DISK_CACHE_SIZE);
+            return this;
+        }
+
+        public Builder setDefaultDiskCacheOptions(int size) {
+            setDefaultDiskCacheOptions(getPhotoCacheDir(context), size);
+            return this;
+        }
+
+        public Builder setDefaultDiskCacheOptions(File dir, int size) {
+            if (size <= 0) {
+                throw new IllegalArgumentException(""Size must be >= 0"");
+            }
+
+            if (diskCache != null) {
+                throw new IllegalArgumentException(""Can't set disk cache twice"");
+            }
+
+            try {
+                diskCache = DiskLruCacheWrapper.get(dir, size);
+            } catch (IOException e) {
+                e.printStackTrace();
+                disableDiskCache();
+            }
+            return this;
         }
 
-    private static ExecutorService buildExecutor() {
-        return Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
+        public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
+            this.maxBitmapsPerSize = maxBitmapsPerSize;
+            return this;
+        }
+
+        private void setDefaults() {
+            if (resizeService == null) {
+                resizeService = Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
                     @Override
                     public Thread newThread(Runnable runnable) {
                         final Thread result = new Thread(runnable);
@@ -231,94 +231,41 @@ public class ImageManager {
                 });
             }
 
-    /**
-     * Create an ImageManager using the default options. Note that this will create a single background thread to use
-     * to resize and load images from disk. Must be created in the UI thread!
-     *
-     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
-     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
-     *                in Activities.
-     */
-    public ImageManager(Context context) {
-        this(context, new Options());
+            if (memoryCache == null) {
+                setDefaultMemoryCacheSize(LruPhotoCache.getMaxCacheSize(context));
             }
 
-
-    /**
-     * Create an ImageManager using the given options and that performs image loads and resize operations using the
-     * given Executor. Must be created in the UI thread!
-     *
-     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
-     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
-     *                in Activities.
-     * @param options The specified options
-     */
-    public ImageManager(Context context, Options options) {
-        this(context, buildExecutor(), options);
+            if (diskCache == null) {
+                setDefaultDiskCacheOptions(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
             }
-
-    /**
-     * Create an ImageManager using the given options and that performs image loads and resize operations using the
-     * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
-     *
-     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
-     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
-     *                in Activities.
-     * @param resizeService An executor service that will be used to resize photos
-     * @param options The specified option
-     */
-    public ImageManager(Context context, ExecutorService resizeService, Options options) {
-        this(context, getPhotoCacheDir(context), resizeService, options);
-    }
-
-    /**
-     * Create an ImageManager using the given options and that performs image loads and resize operations using the
-     * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
-     *
-     * @param context A Context used once to find or create a directory for the disk cache. This reference will not
-     *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
-     *                in Activities.
-     * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
-     *                     already exist
-     * @param resizeService An executor service that will be used to resize photos
-     * @param options The specified options
-     */
-    public ImageManager(Context context, File diskCacheDir, ExecutorService resizeService, Options options) {
-        this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);
         }
-
-    public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {
-        this(buildMemoryCache(options, context), diskCache, resizeService, options);
     }
 
-    public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
+    public ImageManager(Builder builder) {
         HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
-        executor = resizeService;
-
-        diskCacheFormat = options.diskCacheFormat;
+        executor = builder.resizeService;
+        diskCacheFormat = builder.diskCacheFormat;
+        memoryCache = builder.memoryCache;
+        diskCache = builder.diskCache;
 
         final BitmapPool bitmapPool;
-        if (options.recycleBitmaps && CAN_RECYCLE) {
+        if (builder.recycleBitmaps) {
             memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
                 @Override
-                public void onImageRemoved(Bitmap bitmap) {
-                    releaseBitmap(bitmap);
+                public void onImageRemoved(Bitmap removed) {
+                    releaseBitmap(removed);
                 }
             });
-            bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
-            bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
+            bitmapPool = new ConcurrentBitmapPool(builder.maxBitmapsPerSize);
+            bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, builder.maxBitmapsPerSize);
         } else {
-            if (CAN_RECYCLE)
-                options.bitmapDecodeOptions.inMutable = false;
             bitmapPool = null;
             bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
         }
 
-        this.memoryCache = memoryCache;
-        this.diskCache = diskCache;
-        this.resizer = new ImageResizer(bitmapPool, options.bitmapDecodeOptions);
+        this.resizer = new ImageResizer(bitmapPool, builder.decodeBitmapOptions);
     }
 
     /**
","49     private static final String DEFAULT_DISK_CACHE_DIR = ""image_manager_disk_cache"";
50     private static final int DEFAULT_DISK_CACHE_SIZE = 30 * 1024 * 1024;
51     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
52 
76         return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
119     public static class Builder {
120         private final Context context;
121 
122         private ExecutorService resizeService = null;
123         private MemoryCache memoryCache = null;
124         private DiskCache diskCache = null;
125 
126         private Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
127         private boolean recycleBitmaps = CAN_RECYCLE;
128         private int maxBitmapsPerSize = 20;
129 
130         public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();
131 
132         public Builder(Context context) {
133             this.context = context;
135 
136         public ImageManager build() {
137             setDefaults();
138 
139             return new ImageManager(this);
140         }
141 
142         public Builder setResizeService(ExecutorService resizeService) {
143             this.resizeService = resizeService;
144             return this;
145         }
146 
147         public Builder setDiskCacheFormat(Bitmap.CompressFormat diskCacheFormat) {
148             this.diskCacheFormat = diskCacheFormat;
149             return this;
150         }
151 
152         public Builder setRecycleBitmaps(boolean recycleBitmaps) {
153             this.recycleBitmaps = recycleBitmaps && CAN_RECYCLE;
154             return this;
155         }
156 
157         public Builder setMemoryCache(MemoryCache memoryCache) {
158             this.memoryCache = memoryCache;
159             return this;
160         }
161 
162         public Builder disableMemoryCache() {
163             if (memoryCache != null) {
164                 throw new IllegalArgumentException(""Can't disable memory cache after setting it"");
165             }
166             memoryCache = new MemoryCacheAdapter();
167             return this;
168         }
169 
170         public Builder setDefaultMemoryCacheSize(int maxSize) {
171             if (memoryCache != null) {
172                 throw new IllegalArgumentException(""Can't set a default memory cache after setting a custom one"");
173             }
174 
175             memoryCache = new LruPhotoCache(maxSize);
176             return this;
177         }
178 
179         public Builder setDiskCache(DiskCache diskCache) {
180             this.diskCache = diskCache;
181             return this;
182         }
183 
184         public Builder disableDiskCache() {
185             diskCache = new DiskCacheAdapter();
186             return this;
187         }
188 
189         public Builder setDefaultDiskCacheOptions(File dir) {
190             setDefaultDiskCacheOptions(dir, DEFAULT_DISK_CACHE_SIZE);
191             return this;
192         }
193 
194         public Builder setDefaultDiskCacheOptions(int size) {
195             setDefaultDiskCacheOptions(getPhotoCacheDir(context), size);
196             return this;
197         }
198 
199         public Builder setDefaultDiskCacheOptions(File dir, int size) {
200             if (size <= 0) {
201                 throw new IllegalArgumentException(""Size must be >= 0"");
202             }
203 
204             if (diskCache != null) {
205                 throw new IllegalArgumentException(""Can't set disk cache twice"");
206             }
207 
209                 diskCache = DiskLruCacheWrapper.get(dir, size);
212                 disableDiskCache();
214             return this;
217         public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
218             this.maxBitmapsPerSize = maxBitmapsPerSize;
219             return this;
222         private void setDefaults() {
223             if (resizeService == null) {
224                 resizeService = Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
234             if (memoryCache == null) {
235                 setDefaultMemoryCacheSize(LruPhotoCache.getMaxCacheSize(context));
238             if (diskCache == null) {
239                 setDefaultDiskCacheOptions(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
240             }
241         }
244     public ImageManager(Builder builder) {
248         executor = builder.resizeService;
249         diskCacheFormat = builder.diskCacheFormat;
250         memoryCache = builder.memoryCache;
251         diskCache = builder.diskCache;
254         if (builder.recycleBitmaps) {
257                 public void onImageRemoved(Bitmap removed) {
258                     releaseBitmap(removed);
261             bitmapPool = new ConcurrentBitmapPool(builder.maxBitmapsPerSize);
262             bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, builder.maxBitmapsPerSize);
268         this.resizer = new ImageResizer(bitmapPool, builder.decodeBitmapOptions);
49     private static final String DISK_CACHE_DIR = ""image_manager_disk_cache"";
50     private static final int MAX_DISK_CACHE_SIZE = 30 * 1024 * 1024;
54     /**
55      * A class for setting options for an ImageManager
56      *
57      * Boolean use options for the caches superseed sizes, and invalid * sizes (<= 0) are equivalent to setting the
58      * corresponding use option to false.
59      */
60     public static class Options {
61         /**
62          * If true caches bitmaps in memory.
63          *
64          * Defaults to true
65          */
66         public boolean useMemoryCache = true;
67 
68         /**
69          * The maximum memory cache size. This should be decreased on devices where recycling Bitmaps is possible and
70          * enabled because the Bitmap cache used to recycle Bitmaps will take a substantial amount of memory.
71          *
72          * Defaults to 1/8th of the total application memory
73          */
74         public int maxMemorySize;
75 
76         /**
77          * If true, caches resized bitmaps on disk.
78          */
79         public boolean useDiskCache = true;
80 
81         /**
82          * The maximum disk cache size.
83          *
84          * Defaults to 30mb
85          */
86         public int maxDiskCacheSize;
87 
88        /**
89         * The output format used to store bitmaps on disk in the disk cache
90         */
91         public Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
92 
93         /**
94          * If true, will attempt to recycle Bitmaps and all loaded Bitmaps will be mutable. If true and a memory cache
95          * is used, the memory cache size should be decreased since the Bitmap cache used to recycle Bitmaps will
96          * take a substantial amount of memory.
97          *
98          * Defaults to true if Android version is 3.0 or greater and will always be false, regardless of this attribute
99          * otherwise.
100          */
101         public boolean recycleBitmaps = true;
102 
103         /**
104          * The maximum number of recycled bitmaps of any requested size to keep around. Only used if recycleBitmaps
105          * is true. A higher number means loads are more likely to be able to reuse a bitmap but also that this object
106          * will use more memory. Increase this if there are few varieties of bitmaps that will be scrolled rapidly (ie
107          * a GridView of images with lots of columns), and decrease it if there are a lot of different sizes of bitmaps
108          * and limited memory is available.
109          *
110          * Defaults to 20
111          */
112         public int maxPerSize = 0;
113 
114         /**
115          * Options for loading bitmaps. Some of these fields will be overwritten, including inSampleSize, inBitmap,
116          * and maybe inMutable depending on how recycleBitmaps is set.
117          *
118          * Config and dither for example can be set
119          */
120         public BitmapFactory.Options bitmapDecodeOptions = ImageResizer.getDefaultOptions();
121 
122     }
123 
124     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
125 
146         return getPhotoCacheDir(context, DISK_CACHE_DIR);
189     private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {
190         if (options.useDiskCache && options.maxDiskCacheSize <= 0) {
191             options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;
193         DiskCache result;
194         if (diskCacheDir == null || !options.useDiskCache) {
195             result = new DiskCacheAdapter();
196         } else {
198                 result = DiskLruCacheWrapper.get(diskCacheDir, options.maxDiskCacheSize);
201                 result = new DiskCacheAdapter();
205         return result;
206 
209     private static MemoryCache buildMemoryCache(Options options, Context context) {
210         if (options.useMemoryCache && options.maxMemorySize <= 0) {
211             options.maxMemorySize = LruPhotoCache.getMaxCacheSize(context);
212         }
213 
214         final MemoryCache result;
215         if (!options.useMemoryCache) {
216             result = new MemoryCacheAdapter();
217         } else {
218             result = new LruPhotoCache(options.maxMemorySize);
219         }
220         return result;
221     }
222 
223     private static ExecutorService buildExecutor() {
224         return Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
234     /**
235      * Create an ImageManager using the default options. Note that this will create a single background thread to use
236      * to resize and load images from disk. Must be created in the UI thread!
237      *
238      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
239      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
240      *                in Activities.
241      */
242     public ImageManager(Context context) {
243         this(context, new Options());
246 
247     /**
248      * Create an ImageManager using the given options and that performs image loads and resize operations using the
249      * given Executor. Must be created in the UI thread!
250      *
251      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
252      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
253      *                in Activities.
254      * @param options The specified options
255      */
256     public ImageManager(Context context, Options options) {
257         this(context, buildExecutor(), options);
260     /**
261      * Create an ImageManager using the given options and that performs image loads and resize operations using the
262      * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
263      *
264      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
265      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
266      *                in Activities.
267      * @param resizeService An executor service that will be used to resize photos
268      * @param options The specified option
269      */
270     public ImageManager(Context context, ExecutorService resizeService, Options options) {
271         this(context, getPhotoCacheDir(context), resizeService, options);
272     }
273 
274     /**
275      * Create an ImageManager using the given options and that performs image loads and resize operations using the
276      * given Executor. Can be created in any thread, but the mainHandler must be a Handler for the UI thread.
277      *
278      * @param context A Context used once to find or create a directory for the disk cache. This reference will not
279      *                be retained by this ImageManager object and is only used in the constructor so it is safe to pass
280      *                in Activities.
281      * @param diskCacheDir The directory containing the disk cache or in which to create a disk cache if one does not
282      *                     already exist
283      * @param resizeService An executor service that will be used to resize photos
284      * @param options The specified options
285      */
286     public ImageManager(Context context, File diskCacheDir, ExecutorService resizeService, Options options) {
287         this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);
288     }
289 
290     public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {
291         this(buildMemoryCache(options, context), diskCache, resizeService, options);
292     }
293 
294     public ImageManager(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService, Options options) {
298         executor = resizeService;
299 
300         diskCacheFormat = options.diskCacheFormat;
303         if (options.recycleBitmaps && CAN_RECYCLE) {
306                 public void onImageRemoved(Bitmap bitmap) {
307                     releaseBitmap(bitmap);
310             bitmapPool = new ConcurrentBitmapPool(options.maxPerSize);
311             bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);
313             if (CAN_RECYCLE)
314                 options.bitmapDecodeOptions.inMutable = false;
319         this.memoryCache = memoryCache;
320         this.diskCache = diskCache;
321         this.resizer = new ImageResizer(bitmapPool, options.bitmapDecodeOptions);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,7aa5da14cdc71cba8286e737746303a9e933375f,34ea26f6351441ce8592c4800d5588680b71cd93,Fix sample project for api changes,"@@ -46,10 +46,10 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             cacheDir.mkdir();
         }
 
-        ImageManager.Options options = new ImageManager.Options();
-        options.maxPerSize = 40;
-        options.maxDiskCacheSize = 50 * 1024 * 1024;
-        imageManager = new ImageManager(this, options);
+        imageManager = new ImageManager.Builder(this)
+                .setDefaultDiskCacheOptions(50 * 1024 * 1024)
+                .setMaxBitmapsPerSize(40)
+                .build();
 
         final Resources res = getResources();
         flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
","49         imageManager = new ImageManager.Builder(this)
50                 .setDefaultDiskCacheOptions(50 * 1024 * 1024)
51                 .setMaxBitmapsPerSize(40)
52                 .build();
49         ImageManager.Options options = new ImageManager.Options();
50         options.maxPerSize = 40;
51         options.maxDiskCacheSize = 50 * 1024 * 1024;
52         imageManager = new ImageManager(this, options);",No
,LICENSE,1dfef8c093fd8f6cb014f60ae321b25ded43e641,7aa5da14cdc71cba8286e737746303a9e933375f,Add bsd license,"@@ -0,0 +1,25 @@
+Copyright 2013 Bump Technologies, Inc. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are
+permitted provided that the following conditions are met:
+
+   1. Redistributions of source code must retain the above copyright notice, this list of
+         conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above copyright notice, this list
+         of conditions and the following disclaimer in the documentation and/or other materials
+         provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The views and conclusions contained in the software and documentation are those of the
+authors and should not be interpreted as representing official policies, either expressed
+or implied, of Bump Technologies, Inc.
","1 Copyright 2013 Bump Technologies, Inc. All rights reserved.
2 
3 Redistribution and use in source and binary forms, with or without modification, are
4 permitted provided that the following conditions are met:
5 
6    1. Redistributions of source code must retain the above copyright notice, this list of
7          conditions and the following disclaimer.
8 
9    2. Redistributions in binary form must reproduce the above copyright notice, this list
10          of conditions and the following disclaimer in the documentation and/or other materials
11          provided with the distribution.
12 
13 THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED
14 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
15 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR
16 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
17 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
18 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
19 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
20 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
21 ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
22 
23 The views and conclusions contained in the software and documentation are those of the
24 authors and should not be interpreted as representing official policies, either expressed
25 or implied, of Bump Technologies, Inc.",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,a0e21bfff1d3e17bf2edb7b15c43036a6306debc,1dfef8c093fd8f6cb014f60ae321b25ded43e641,"Remove set default options in ImageManager

Simpler interface if people just set instances of
default disk/memory cache that they create","@@ -27,7 +27,6 @@ import com.bumptech.photos.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.concurrent.ExecutorService;
@@ -167,15 +166,6 @@ public class ImageManager {
             return this;
         }
 
-        public Builder setDefaultMemoryCacheSize(int maxSize) {
-            if (memoryCache != null) {
-                throw new IllegalArgumentException(""Can't set a default memory cache after setting a custom one"");
-            }
-
-            memoryCache = new LruPhotoCache(maxSize);
-            return this;
-        }
-
         public Builder setDiskCache(DiskCache diskCache) {
             this.diskCache = diskCache;
             return this;
@@ -186,33 +176,6 @@ public class ImageManager {
             return this;
         }
 
-        public Builder setDefaultDiskCacheOptions(File dir) {
-            setDefaultDiskCacheOptions(dir, DEFAULT_DISK_CACHE_SIZE);
-            return this;
-        }
-
-        public Builder setDefaultDiskCacheOptions(int size) {
-            setDefaultDiskCacheOptions(getPhotoCacheDir(context), size);
-            return this;
-        }
-
-        public Builder setDefaultDiskCacheOptions(File dir, int size) {
-            if (size <= 0) {
-                throw new IllegalArgumentException(""Size must be >= 0"");
-            }
-
-            if (diskCache != null) {
-                throw new IllegalArgumentException(""Can't set disk cache twice"");
-            }
-
-            try {
-                diskCache = DiskLruCacheWrapper.get(dir, size);
-            } catch (IOException e) {
-                e.printStackTrace();
-                disableDiskCache();
-            }
-            return this;
-        }
 
         public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
             this.maxBitmapsPerSize = maxBitmapsPerSize;
@@ -232,11 +195,11 @@ public class ImageManager {
             }
 
             if (memoryCache == null) {
-                setDefaultMemoryCacheSize(LruPhotoCache.getMaxCacheSize(context));
+                memoryCache = new LruPhotoCache(LruPhotoCache.getMaxCacheSize(context));
             }
 
             if (diskCache == null) {
-                setDefaultDiskCacheOptions(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
+                diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
             }
         }
     }
","198                 memoryCache = new LruPhotoCache(LruPhotoCache.getMaxCacheSize(context));
202                 diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
30 import java.io.IOException;
170         public Builder setDefaultMemoryCacheSize(int maxSize) {
171             if (memoryCache != null) {
172                 throw new IllegalArgumentException(""Can't set a default memory cache after setting a custom one"");
173             }
174 
175             memoryCache = new LruPhotoCache(maxSize);
176             return this;
177         }
178 
189         public Builder setDefaultDiskCacheOptions(File dir) {
190             setDefaultDiskCacheOptions(dir, DEFAULT_DISK_CACHE_SIZE);
191             return this;
192         }
193 
194         public Builder setDefaultDiskCacheOptions(int size) {
195             setDefaultDiskCacheOptions(getPhotoCacheDir(context), size);
196             return this;
197         }
198 
199         public Builder setDefaultDiskCacheOptions(File dir, int size) {
200             if (size <= 0) {
201                 throw new IllegalArgumentException(""Size must be >= 0"");
202             }
203 
204             if (diskCache != null) {
205                 throw new IllegalArgumentException(""Can't set disk cache twice"");
206             }
207 
208             try {
209                 diskCache = DiskLruCacheWrapper.get(dir, size);
210             } catch (IOException e) {
211                 e.printStackTrace();
212                 disableDiskCache();
213             }
214             return this;
215         }
235                 setDefaultMemoryCacheSize(LruPhotoCache.getMaxCacheSize(context));
239                 setDefaultDiskCacheOptions(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,a0e21bfff1d3e17bf2edb7b15c43036a6306debc,1dfef8c093fd8f6cb014f60ae321b25ded43e641,"Remove set default options in ImageManager

Simpler interface if people just set instances of
default disk/memory cache that they create","@@ -18,6 +18,8 @@ import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
+import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.util.Log;
 
 import java.io.File;
@@ -47,7 +49,8 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         }
 
         imageManager = new ImageManager.Builder(this)
-                .setDefaultDiskCacheOptions(50 * 1024 * 1024)
+                .setMemoryCache(new LruPhotoCache(1234))
+                .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))
                 .setMaxBitmapsPerSize(40)
                 .build();
 
","21 import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
22 import com.bumptech.photos.resize.cache.LruPhotoCache;
52                 .setMemoryCache(new LruPhotoCache(1234))
53                 .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))
50                 .setDefaultDiskCacheOptions(50 * 1024 * 1024)",No
library\src\com\bumptech\photos\resize\cache\DiskLruCacheWrapper.java,library\src\com\bumptech\photos\resize\cache\DiskLruCacheWrapper.java,ac51901554a404bfcfaaac90e93bd1cec00ba5f5,a0e21bfff1d3e17bf2edb7b15c43036a6306debc,"Make DiskLruCacheWrapper a singleton

Makes it more apparent that options can only bet
set once, rather than each time a new wrapper is
created","@@ -21,6 +21,7 @@ import java.io.InputStream;
 public class DiskLruCacheWrapper implements DiskCache {
 
     private static DiskLruCache CACHE = null;
+    private static DiskLruCacheWrapper WRAPPER = null;
 
     private synchronized static DiskLruCache getDiskLruCache(File directory, int maxSize) throws IOException {
         if (CACHE == null) {
@@ -29,8 +30,15 @@ public class DiskLruCacheWrapper implements DiskCache {
         return CACHE;
     }
 
-    public static DiskLruCacheWrapper get(File directory, int maxSize) throws IOException {
-        return new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
+    public static DiskLruCacheWrapper get(File directory, int maxSize) {
+        if (WRAPPER == null) {
+            try {
+                WRAPPER = new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return WRAPPER;
     }
 
     private final DiskLruCache diskLruCache;
","24     private static DiskLruCacheWrapper WRAPPER = null;
33     public static DiskLruCacheWrapper get(File directory, int maxSize) {
34         if (WRAPPER == null) {
35             try {
36                 WRAPPER = new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
37             } catch (IOException e) {
38                 throw new RuntimeException(e);
39             }
40         }
41         return WRAPPER;
32     public static DiskLruCacheWrapper get(File directory, int maxSize) throws IOException {
33         return new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,6ca35fac19ce301c9ffbabe4e940fe7762266a3a,ac51901554a404bfcfaaac90e93bd1cec00ba5f5,diskCacheFormat -> bitmapCompressFormat,"@@ -58,7 +58,7 @@ public class ImageManager {
     private final MemoryCache memoryCache;
     private final ImageResizer resizer;
     private final DiskCache diskCache;
-    private final Bitmap.CompressFormat diskCacheFormat;
+    private final Bitmap.CompressFormat bitmapCompressFormat;
 
     private enum ResizeType {
         CENTER_CROP,
@@ -122,7 +122,7 @@ public class ImageManager {
         private MemoryCache memoryCache = null;
         private DiskCache diskCache = null;
 
-        private Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
+        private Bitmap.CompressFormat bitmapCompressFormat = Bitmap.CompressFormat.JPEG;
         private boolean recycleBitmaps = CAN_RECYCLE;
         private int maxBitmapsPerSize = 20;
 
@@ -143,8 +143,8 @@ public class ImageManager {
             return this;
         }
 
-        public Builder setDiskCacheFormat(Bitmap.CompressFormat diskCacheFormat) {
-            this.diskCacheFormat = diskCacheFormat;
+        public Builder setBitmapCompressFormat(Bitmap.CompressFormat bitmapCompressFormat) {
+            this.bitmapCompressFormat = bitmapCompressFormat;
             return this;
         }
 
@@ -209,12 +209,13 @@ public class ImageManager {
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
         executor = builder.resizeService;
-        diskCacheFormat = builder.diskCacheFormat;
+        bitmapCompressFormat = builder.bitmapCompressFormat;
         memoryCache = builder.memoryCache;
         diskCache = builder.diskCache;
 
         final BitmapPool bitmapPool;
         if (builder.recycleBitmaps) {
+            Log.d(""IM: recycle bitmaps total per size="" + builder.maxBitmapsPerSize);
             memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
                 @Override
                 public void onImageRemoved(Bitmap removed) {
@@ -514,7 +515,7 @@ public class ImageManager {
                     diskCache.put(String.valueOf(key), new DiskCache.Writer() {
                         @Override
                         public void write(OutputStream os) {
-                            result.compress(diskCacheFormat, 100, os);
+                            result.compress(bitmapCompressFormat, 100, os);
                         }
                     });
                 }
","61     private final Bitmap.CompressFormat bitmapCompressFormat;
125         private Bitmap.CompressFormat bitmapCompressFormat = Bitmap.CompressFormat.JPEG;
146         public Builder setBitmapCompressFormat(Bitmap.CompressFormat bitmapCompressFormat) {
147             this.bitmapCompressFormat = bitmapCompressFormat;
212         bitmapCompressFormat = builder.bitmapCompressFormat;
218             Log.d(""IM: recycle bitmaps total per size="" + builder.maxBitmapsPerSize);
518                             result.compress(bitmapCompressFormat, 100, os);
61     private final Bitmap.CompressFormat diskCacheFormat;
125         private Bitmap.CompressFormat diskCacheFormat = Bitmap.CompressFormat.JPEG;
146         public Builder setDiskCacheFormat(Bitmap.CompressFormat diskCacheFormat) {
147             this.diskCacheFormat = diskCacheFormat;
212         diskCacheFormat = builder.diskCacheFormat;
517                             result.compress(diskCacheFormat, 100, os);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,b08c284744aa51abde6f1ec7d485225fb26f7657,6ca35fac19ce301c9ffbabe4e940fe7762266a3a,"Move getMaxCacheSize to ImaageManager

Similar method to getPhotoCache, so might as well
be in the same place","@@ -4,6 +4,7 @@
 
 package com.bumptech.photos.resize;
 
+import android.app.ActivityManager;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -47,6 +48,7 @@ import java.util.concurrent.ThreadFactory;
 public class ImageManager {
     private static final String DEFAULT_DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int DEFAULT_DISK_CACHE_SIZE = 30 * 1024 * 1024;
+    private static final float MEMORY_SIZE_RATIO = 1f/10f;
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private final BitmapReferenceCounter bitmapReferenceCounter;
@@ -66,6 +68,13 @@ public class ImageManager {
         APPROXIMATE,
         AS_IS
     }
+    /*
+     *    Can only call after context is created (ie in onCreate or later...)
+     */
+    public static int getMaxCacheSize(Context context){
+        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        return Math.round(MEMORY_SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
+    }
 
     /**
      * Try to get the external cache directory if available and default to the internal. Use a default name for the
@@ -195,7 +204,7 @@ public class ImageManager {
             }
 
             if (memoryCache == null) {
-                memoryCache = new LruPhotoCache(LruPhotoCache.getMaxCacheSize(context));
+                memoryCache = new LruPhotoCache(getMaxCacheSize(context));
             }
 
             if (diskCache == null) {
","7 import android.app.ActivityManager;
51     private static final float MEMORY_SIZE_RATIO = 1f/10f;
71     /*
72      *    Can only call after context is created (ie in onCreate or later...)
73      */
74     public static int getMaxCacheSize(Context context){
75         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
76         return Math.round(MEMORY_SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
77     }
207                 memoryCache = new LruPhotoCache(getMaxCacheSize(context));
198                 memoryCache = new LruPhotoCache(LruPhotoCache.getMaxCacheSize(context));",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,b08c284744aa51abde6f1ec7d485225fb26f7657,6ca35fac19ce301c9ffbabe4e940fe7762266a3a,"Move getMaxCacheSize to ImaageManager

Similar method to getPhotoCache, so might as well
be in the same place","@@ -4,8 +4,6 @@
 
 package com.bumptech.photos.resize.cache;
 
-import android.app.ActivityManager;
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.v4.util.LruCache;
 
@@ -15,18 +13,9 @@ import android.support.v4.util.LruCache;
  * @see android.support.v4.util.LruCache
  */
 public class LruPhotoCache implements MemoryCache {
-    private static final float SIZE_RATIO = 1f/10f;
     private final LruCache<Integer, Bitmap> lruCache;
     private ImageRemovedListener imageRemovedListener;
 
-    /*
-    Can only call after context is created (ie in onCreate or later...)
-    */
-    public static int getMaxCacheSize(Context context){
-        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-        return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
-    }
-
     public LruPhotoCache(int maxSize) {
         lruCache = new LruCache<Integer, Bitmap>(maxSize) {
             @Override
","7 import android.app.ActivityManager;
8 import android.content.Context;
18     private static final float SIZE_RATIO = 1f/10f;
22     /*
23     Can only call after context is created (ie in onCreate or later...)
24     */
25     public static int getMaxCacheSize(Context context){
26         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
27         return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
28     }
29 ",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,e87f04030d4bd0570551ae9333085c4d8710a443,b08c284744aa51abde6f1ec7d485225fb26f7657,getMaxCacheSize -> getSafeMemoryCacheSize,"@@ -68,10 +68,16 @@ public class ImageManager {
         APPROXIMATE,
         AS_IS
     }
-    /*
-     *    Can only call after context is created (ie in onCreate or later...)
+
+    /**
+     * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
+     * This is a conservative estimate that has been safe for 2.2+ devices consistnetly. It is probably rather small
+     * for newer devices.
+     *
+     * @param context
+     * @return the maximum safe size for the memory cache for this devices in bytes
      */
-    public static int getMaxCacheSize(Context context){
+    public static int getSafeMemoryCacheSize(Context context){
         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
         return Math.round(MEMORY_SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
     }
@@ -204,7 +210,7 @@ public class ImageManager {
             }
 
             if (memoryCache == null) {
-                memoryCache = new LruPhotoCache(getMaxCacheSize(context));
+                memoryCache = new LruPhotoCache(getSafeMemoryCacheSize(context));
             }
 
             if (diskCache == null) {
","71 
72     /**
73      * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
74      * This is a conservative estimate that has been safe for 2.2+ devices consistnetly. It is probably rather small
75      * for newer devices.
76      *
77      * @param context
78      * @return the maximum safe size for the memory cache for this devices in bytes
80     public static int getSafeMemoryCacheSize(Context context){
213                 memoryCache = new LruPhotoCache(getSafeMemoryCacheSize(context));
71     /*
72      *    Can only call after context is created (ie in onCreate or later...)
74     public static int getMaxCacheSize(Context context){
207                 memoryCache = new LruPhotoCache(getMaxCacheSize(context));",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,75a875cec2a817841ea688a46ec4f1414d0c0202,e87f04030d4bd0570551ae9333085c4d8710a443,Add comments to ImageManager builder,"@@ -75,7 +75,7 @@ public class ImageManager {
      * for newer devices.
      *
      * @param context
-     * @return the maximum safe size for the memory cache for this devices in bytes
+     * @return The maximum safe size for the memory cache for this devices in bytes
      */
     public static int getSafeMemoryCacheSize(Context context){
         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
@@ -85,11 +85,22 @@ public class ImageManager {
     /**
      * Try to get the external cache directory if available and default to the internal. Use a default name for the
      * cache directory if no name is provided
+     *
+     * @param context A context
+     * @return A File representing the default disk cache directory
      */
     public static File getPhotoCacheDir(Context context) {
         return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
     }
 
+    /**
+     * Try to get the external cache directory if available and default to the internal. Use a default name for the
+     * cache directory if no name is provided
+     *
+     * @param context A context
+     * @param cacheName The name of the subdirectory in which to store the cache
+     * @return A File representing the default disk cache directory
+     */
     public static File getPhotoCacheDir(Context context, String cacheName) {
         String cachePath = null;
 
@@ -143,55 +154,119 @@ public class ImageManager {
 
         public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();
 
+        /**
+         * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
+         * cache, and will recycle bitmaps if the device sdk version allows it.
+         *
+         * @param context Any context (will not be retained after build)
+         */
         public Builder(Context context) {
             this.context = context;
         }
 
+        /**
+         * Builds an ImageManager. Any defaults that haven't been set will be set
+         *
+         * @return A new ImageManager
+         */
         public ImageManager build() {
             setDefaults();
 
             return new ImageManager(this);
         }
 
+        /**
+         * Sets the service that will be used to load and resize images not yet in the disk cache.
+         *
+         * Defaults to a fixed thread pool with the number of threads equal to the number of available processors
+         * where every thread is run at min priority.
+         *
+         * @param resizeService The executor service to use to resize images
+         * @return This Builder
+         */
         public Builder setResizeService(ExecutorService resizeService) {
             this.resizeService = resizeService;
             return this;
         }
 
+        /**
+         * Sets the format that will be used to write bitmaps to disk in the disk cache (if one is present). Defaults
+         * to JPEG. Set to PNG if you need transparency
+         *
+         * @param bitmapCompressFormat The format to pass to
+         *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
+         *  to the disk cache
+         * @return This Builder
+         */
         public Builder setBitmapCompressFormat(Bitmap.CompressFormat bitmapCompressFormat) {
             this.bitmapCompressFormat = bitmapCompressFormat;
             return this;
         }
 
+        /**
+         * Set whether or not to recycle bitmaps. Defaults to enabled. If enabled, devices with SDK < 11 will not
+         * recycle bitmaps while those with SDK >= 11 will recycle bitmaps. See also
+         * {@link ImageManager.Builder#setMaxBitmapsPerSize(int)}
+         *
+         * @param recycleBitmaps True to enable recycling bitmaps, false otherwise.
+         * @return This Builder
+         */
         public Builder setRecycleBitmaps(boolean recycleBitmaps) {
             this.recycleBitmaps = recycleBitmaps && CAN_RECYCLE;
             return this;
         }
 
+        /**
+         * Set the memory cache implementation. See also
+         * {@link com.bumptech.photos.resize.ImageManager.Builder#disableMemoryCache()}
+         *
+         * @param memoryCache The memory cache implementation to use
+         * @return This Builder
+         */
         public Builder setMemoryCache(MemoryCache memoryCache) {
             this.memoryCache = memoryCache;
             return this;
         }
 
+        /**
+         * Call to prevent the ImageManager from using a memory cache.
+         *
+         * @return This Builder
+         */
         public Builder disableMemoryCache() {
-            if (memoryCache != null) {
-                throw new IllegalArgumentException(""Can't disable memory cache after setting it"");
-            }
-            memoryCache = new MemoryCacheAdapter();
-            return this;
+            return setMemoryCache(new MemoryCacheAdapter());
         }
 
+        /**
+         * Set the disk cache implementation. See also
+         *  {@link com.bumptech.photos.resize.ImageManager.Builder#disableDiskCache()}
+         *
+         * @param diskCache The disk cache implementation to use
+         * @return This Builder
+         */
         public Builder setDiskCache(DiskCache diskCache) {
             this.diskCache = diskCache;
             return this;
         }
 
+        /**
+         * Call to prevent the ImageManager from using a disk cache
+         * @return
+         */
         public Builder disableDiskCache() {
-            diskCache = new DiskCacheAdapter();
-            return this;
+            return setDiskCache(new DiskCacheAdapter());
         }
 
-
+        /**
+         * Set the maximum number of bitmaps for a given size to store in memory at one time. Defaults to 20. The larger
+         * the number, the more memory will be used to store recycled bitmaps but the smoother scrolling will be. Set
+         * this * number larger when loading lots of smaller photos and/or when you expect your users to scroll rapidly.
+         * Set this number smaller when loading larger images and/or a lot of different sizes of images and/or when you
+         * expect your users to scroll relatively slowly.
+         *
+         * @param maxBitmapsPerSize The maximum number of bitmaps of any given size to keep in the recycle pool
+         * @return This Builder
+         */
         public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
             this.maxBitmapsPerSize = maxBitmapsPerSize;
             return this;
@@ -219,7 +294,7 @@ public class ImageManager {
         }
     }
 
-    public ImageManager(Builder builder) {
+    private ImageManager(Builder builder) {
         HandlerThread bgThread = new HandlerThread(""bg_thread"");
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
","78      * @return The maximum safe size for the memory cache for this devices in bytes
88      *
89      * @param context A context
90      * @return A File representing the default disk cache directory
96     /**
97      * Try to get the external cache directory if available and default to the internal. Use a default name for the
98      * cache directory if no name is provided
99      *
100      * @param context A context
101      * @param cacheName The name of the subdirectory in which to store the cache
102      * @return A File representing the default disk cache directory
103      */
157         /**
158          * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
159          * cache, and will recycle bitmaps if the device sdk version allows it.
160          *
161          * @param context Any context (will not be retained after build)
162          */
167         /**
168          * Builds an ImageManager. Any defaults that haven't been set will be set
169          *
170          * @return A new ImageManager
171          */
178         /**
179          * Sets the service that will be used to load and resize images not yet in the disk cache.
180          *
181          * Defaults to a fixed thread pool with the number of threads equal to the number of available processors
182          * where every thread is run at min priority.
183          *
184          * @param resizeService The executor service to use to resize images
185          * @return This Builder
186          */
192         /**
193          * Sets the format that will be used to write bitmaps to disk in the disk cache (if one is present). Defaults
194          * to JPEG. Set to PNG if you need transparency
195          *
196          * @param bitmapCompressFormat The format to pass to
197          *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
198          *  to the disk cache
199          * @return This Builder
200          */
206         /**
207          * Set whether or not to recycle bitmaps. Defaults to enabled. If enabled, devices with SDK < 11 will not
208          * recycle bitmaps while those with SDK >= 11 will recycle bitmaps. See also
209          * {@link ImageManager.Builder#setMaxBitmapsPerSize(int)}
210          *
211          * @param recycleBitmaps True to enable recycling bitmaps, false otherwise.
212          * @return This Builder
213          */
219         /**
220          * Set the memory cache implementation. See also
221          * {@link com.bumptech.photos.resize.ImageManager.Builder#disableMemoryCache()}
222          *
223          * @param memoryCache The memory cache implementation to use
224          * @return This Builder
225          */
231         /**
232          * Call to prevent the ImageManager from using a memory cache.
233          *
234          * @return This Builder
235          */
237             return setMemoryCache(new MemoryCacheAdapter());
240         /**
241          * Set the disk cache implementation. See also
242          *  {@link com.bumptech.photos.resize.ImageManager.Builder#disableDiskCache()}
243          *
244          * @param diskCache The disk cache implementation to use
245          * @return This Builder
246          */
252         /**
253          * Call to prevent the ImageManager from using a disk cache
254          * @return
255          */
257             return setDiskCache(new DiskCacheAdapter());
260         /**
261          * Set the maximum number of bitmaps for a given size to store in memory at one time. Defaults to 20. The larger
262          * the number, the more memory will be used to store recycled bitmaps but the smoother scrolling will be. Set
263          * this * number larger when loading lots of smaller photos and/or when you expect your users to scroll rapidly.
264          * Set this number smaller when loading larger images and/or a lot of different sizes of images and/or when you
265          * expect your users to scroll relatively slowly.
266          *
267          * @param maxBitmapsPerSize The maximum number of bitmaps of any given size to keep in the recycle pool
268          * @return This Builder
269          */
297     private ImageManager(Builder builder) {
78      * @return the maximum safe size for the memory cache for this devices in bytes
177             if (memoryCache != null) {
178                 throw new IllegalArgumentException(""Can't disable memory cache after setting it"");
179             }
180             memoryCache = new MemoryCacheAdapter();
181             return this;
190             diskCache = new DiskCacheAdapter();
191             return this;
194 
222     public ImageManager(Builder builder) {",No
library\src\com\bumptech\photos\presenter\ImageSetCallback.java,library\src\com\bumptech\photos\presenter\ImageSetCallback.java,3621c9213a3fc613813252d1fc741894324f6af8,75a875cec2a817841ea688a46ec4f1414d0c0202,Update comment on ImageSetCallback,"@@ -16,7 +16,7 @@ public interface ImageSetCallback {
      * The method called when a bitmap is set
      *
      * @param view The view that will display the bitmap
-     * @param fromCache True iff the bitmap was loaded synchronously.
+     * @param fromCache True iff the bitmap load completed without a placeholder being shown.
      */
     public void onImageSet(ImageView view, boolean fromCache);
 }
","19      * @param fromCache True iff the bitmap load completed without a placeholder being shown.
19      * @param fromCache True iff the bitmap was loaded synchronously.",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,230a51b0aba6ab1708e341f648b06ff70eda6d03,3621c9213a3fc613813252d1fc741894324f6af8,More ImageManager comments,"@@ -339,6 +339,13 @@ public class ImageManager {
         });
     }
 
+    /**
+     * @see #getImage(String, LoadedCallback)
+     *
+     * Same as getImage except with two input streams representing the image instead of a path. One
+     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
+     * from disk
+     */
     public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
         return runJob(key, cb, false, new ImageManagerJob() {
@@ -368,6 +375,11 @@ public class ImageManager {
         });
     }
 
+    /**
+     * @see #getImageExact(String, int, int, LoadedCallback)
+     *
+     * Same as getImageExact except with an input stream instead of a path
+     */
     public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob() {
@@ -397,6 +409,13 @@ public class ImageManager {
         });
     }
 
+    /**
+     * @see #getImageApproximate(String, int, int, LoadedCallback)
+     *
+     * Same as getImageApproximate except with two input streams representing the image instead of a path. One
+     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
+     * from disk
+     */
     public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob() {
@@ -427,7 +446,13 @@ public class ImageManager {
         });
     }
 
-    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
+    /**
+     * @see #centerCrop(String, int, int, LoadedCallback)
+     *
+     * Same as centerCrop except with two input streams representing the image instead of a path. One
+     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
+     * from disk
+     */    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob() {
             @Override
@@ -491,6 +516,11 @@ public class ImageManager {
         bitmapReferenceCounter.releaseBitmap(b);
     }
 
+    /**
+     * Cancel the task represented by the given token. If token is null this call will be ignored.
+     *
+     * @param token The token returned by the ImageManager in a get call
+     */
     public void cancelTask(Object token) {
         if (token != null) {
             ImageManagerJob job = (ImageManagerJob) token;
@@ -498,6 +528,9 @@ public class ImageManager {
         }
     }
 
+    /**
+     * Shuts down all of the background threads used by the ImageManager including the executor service
+     */
     public void shutdown() {
         shutdown = true;
         executor.shutdown();
","342     /**
343      * @see #getImage(String, LoadedCallback)
344      *
345      * Same as getImage except with two input streams representing the image instead of a path. One
346      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
347      * from disk
348      */
378     /**
379      * @see #getImageExact(String, int, int, LoadedCallback)
380      *
381      * Same as getImageExact except with an input stream instead of a path
382      */
412     /**
413      * @see #getImageApproximate(String, int, int, LoadedCallback)
414      *
415      * Same as getImageApproximate except with two input streams representing the image instead of a path. One
416      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
417      * from disk
418      */
449     /**
450      * @see #centerCrop(String, int, int, LoadedCallback)
451      *
452      * Same as centerCrop except with two input streams representing the image instead of a path. One
453      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
454      * from disk
455      */    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
519     /**
520      * Cancel the task represented by the given token. If token is null this call will be ignored.
521      *
522      * @param token The token returned by the ImageManager in a get call
523      */
531     /**
532      * Shuts down all of the background threads used by the ImageManager including the executor service
533      */
430     public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {",No
library\AndroidManifest.xml,library\AndroidManifest.xml,df887db6053d8e6fbfe8a1905194af59b3cf9376,230a51b0aba6ab1708e341f648b06ff70eda6d03,Remove unused activity from manifest,"@@ -3,14 +3,5 @@
           package=""com.bumptech.photos""
           android:versionCode=""1""
           android:versionName=""1.0"">
-  <application android:label=""@string/app_name"">
-    <activity android:name=""ACTIVITY_ENTRY_NAME""
-              android:label=""@string/app_name"">
-      <intent-filter>
-        <action android:name=""android.intent.action.MAIN""/>
-        <category android:name=""android.intent.category.LAUNCHER""/>
-      </intent-filter>
-    </activity>
-  </application>
   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
 </manifest>
","6   <application android:label=""@string/app_name"">
7     <activity android:name=""ACTIVITY_ENTRY_NAME""
8               android:label=""@string/app_name"">
9       <intent-filter>
10         <action android:name=""android.intent.action.MAIN""/>
11         <category android:name=""android.intent.category.LAUNCHER""/>
12       </intent-filter>
13     </activity>
14   </application>",No
README,README,1ce6faa2aa74941b2a9b3f478f62085e30640b49,df887db6053d8e6fbfe8a1905194af59b3cf9376,Add a rough readme,"@@ -0,0 +1,79 @@
+Glide
+=====
+Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
+
+Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
+
+Who Shouldn't Use Glide?
+------------------------
+If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
+
+Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
+
+Also you probably shouldn't bother if you're not writing an Android app...
+
+Who Should Use Glide?
+---------------------
+Anyone who displays large numbers of images can benefit from Glide.
+
+Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
+
+Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
+
+Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
+
+How Do I Use Glide?
+-------------------
+The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
+
+```Java
+
+public class MyAdapter extends BaseAdapter {
+    private final ImageManager imageManager;
+
+    public MyAdapter(Context context) {
+         imageManager = new ImageManager.Builder(context).build();
+    }
+
+    ...
+    @Override
+    public View getView(int position, View recycled, ViewGroup container) {
+        final MyModel current = myModels.get(position);
+        final ImagePresenter<MyModel> presenter;
+        if (recycled == null) {
+            recycled = myInflater.inflate(R.layout.my_image_view, container, false);
+
+            presenter = new ImagePresenter.Builder<MyModel>()
+                    .setImageView((ImageView) recycled)
+                    .setPathLoader(new MyPathLoader())
+                    .setImageLoader(new CenterCrop(imageManager))
+                    .build();
+            recycled.setTag(presenter);
+        } else {
+            presenter = (ImagePresenter<MyModel>) recycled.getTag();
+        }
+        presenter.setModel(current);
+    }
+}
+
+```
+
+The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
+
+This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
+
+Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
+
+Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
+
+For more examples see the sample flickr app.
+
+How do I add Glide to my project?
+--------------------------------
+Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
+
+Intellij and Eclipse instructions coming soon.
+
+Status
+------
+Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
","1 Glide
2 =====
3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
4 
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
6 
7 Who Shouldn't Use Glide?
8 ------------------------
9 If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
10 
11 Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
12 
13 Also you probably shouldn't bother if you're not writing an Android app...
14 
15 Who Should Use Glide?
16 ---------------------
17 Anyone who displays large numbers of images can benefit from Glide.
18 
19 Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
20 
21 Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
22 
23 Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
24 
25 How Do I Use Glide?
26 -------------------
27 The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
28 
29 ```Java
30 
31 public class MyAdapter extends BaseAdapter {
32     private final ImageManager imageManager;
33 
34     public MyAdapter(Context context) {
35          imageManager = new ImageManager.Builder(context).build();
36     }
37 
38     ...
39     @Override
40     public View getView(int position, View recycled, ViewGroup container) {
41         final MyModel current = myModels.get(position);
42         final ImagePresenter<MyModel> presenter;
43         if (recycled == null) {
44             recycled = myInflater.inflate(R.layout.my_image_view, container, false);
45 
46             presenter = new ImagePresenter.Builder<MyModel>()
47                     .setImageView((ImageView) recycled)
48                     .setPathLoader(new MyPathLoader())
49                     .setImageLoader(new CenterCrop(imageManager))
50                     .build();
51             recycled.setTag(presenter);
52         } else {
53             presenter = (ImagePresenter<MyModel>) recycled.getTag();
54         }
55         presenter.setModel(current);
56     }
57 }
58 
59 ```
60 
61 The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
62 
63 This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
64 
65 Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
66 
67 Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
68 
69 For more examples see the sample flickr app.
70 
71 How do I add Glide to my project?
72 --------------------------------
73 Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
74 
75 Intellij and Eclipse instructions coming soon.
76 
77 Status
78 ------
79 Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!",Yes
,README.md,939a18deade2490d0693f62ee86bdccbc9485127,1ce6faa2aa74941b2a9b3f478f62085e30640b49,README -> README.md,"@@ -0,0 +1,79 @@
+Glide
+=====
+Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
+
+Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
+
+Who Shouldn't Use Glide?
+------------------------
+If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
+
+Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
+
+Also you probably shouldn't bother if you're not writing an Android app...
+
+Who Should Use Glide?
+---------------------
+Anyone who displays large numbers of images can benefit from Glide.
+
+Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
+
+Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
+
+Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
+
+How Do I Use Glide?
+-------------------
+The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
+
+```Java
+
+public class MyAdapter extends BaseAdapter {
+    private final ImageManager imageManager;
+
+    public MyAdapter(Context context) {
+         imageManager = new ImageManager.Builder(context).build();
+    }
+
+    ...
+    @Override
+    public View getView(int position, View recycled, ViewGroup container) {
+        final MyModel current = myModels.get(position);
+        final ImagePresenter<MyModel> presenter;
+        if (recycled == null) {
+            recycled = myInflater.inflate(R.layout.my_image_view, container, false);
+
+            presenter = new ImagePresenter.Builder<MyModel>()
+                    .setImageView((ImageView) recycled)
+                    .setPathLoader(new MyPathLoader())
+                    .setImageLoader(new CenterCrop(imageManager))
+                    .build();
+            recycled.setTag(presenter);
+        } else {
+            presenter = (ImagePresenter<MyModel>) recycled.getTag();
+        }
+        presenter.setModel(current);
+    }
+}
+
+```
+
+The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
+
+This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
+
+Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
+
+Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
+
+For more examples see the sample flickr app.
+
+How do I add Glide to my project?
+--------------------------------
+Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
+
+Intellij and Eclipse instructions coming soon.
+
+Status
+------
+Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
","1 Glide
2 =====
3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
4 
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
6 
7 Who Shouldn't Use Glide?
8 ------------------------
9 If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
10 
11 Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
12 
13 Also you probably shouldn't bother if you're not writing an Android app...
14 
15 Who Should Use Glide?
16 ---------------------
17 Anyone who displays large numbers of images can benefit from Glide.
18 
19 Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
20 
21 Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
22 
23 Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
24 
25 How Do I Use Glide?
26 -------------------
27 The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
28 
29 ```Java
30 
31 public class MyAdapter extends BaseAdapter {
32     private final ImageManager imageManager;
33 
34     public MyAdapter(Context context) {
35          imageManager = new ImageManager.Builder(context).build();
36     }
37 
38     ...
39     @Override
40     public View getView(int position, View recycled, ViewGroup container) {
41         final MyModel current = myModels.get(position);
42         final ImagePresenter<MyModel> presenter;
43         if (recycled == null) {
44             recycled = myInflater.inflate(R.layout.my_image_view, container, false);
45 
46             presenter = new ImagePresenter.Builder<MyModel>()
47                     .setImageView((ImageView) recycled)
48                     .setPathLoader(new MyPathLoader())
49                     .setImageLoader(new CenterCrop(imageManager))
50                     .build();
51             recycled.setTag(presenter);
52         } else {
53             presenter = (ImagePresenter<MyModel>) recycled.getTag();
54         }
55         presenter.setModel(current);
56     }
57 }
58 
59 ```
60 
61 The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
62 
63 This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
64 
65 Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
66 
67 Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
68 
69 For more examples see the sample flickr app.
70 
71 How do I add Glide to my project?
72 --------------------------------
73 Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
74 
75 Intellij and Eclipse instructions coming soon.
76 
77 Status
78 ------
79 Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!",Yes
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,8856168e303b108a5e0c5f1554573670083349e6,939a18deade2490d0693f62ee86bdccbc9485127,Fix bitmap recycling bug,"@@ -659,7 +659,15 @@ public class ImageManager {
 
 
     private void putInMemoryCache(int key, Bitmap bitmap) {
-        if (memoryCache.put(key, bitmap) != bitmap) {
+        final boolean inCache;
+        synchronized (memoryCache) {
+            inCache = memoryCache.contains(key);
+            if (!inCache) {
+                memoryCache.put(key, bitmap);
+            }
+        }
+
+        if (!inCache) {
             acquireBitmap(bitmap);
             bitmapReferenceCounter.markPending(bitmap);
         }
","662         final boolean inCache;
663         synchronized (memoryCache) {
664             inCache = memoryCache.contains(key);
665             if (!inCache) {
666                 memoryCache.put(key, bitmap);
667             }
668         }
669 
670         if (!inCache) {
662         if (memoryCache.put(key, bitmap) != bitmap) {",No
README,,2cdb0abe14e75e7497c6d39d92058ebeb3499694,8856168e303b108a5e0c5f1554573670083349e6,remove unused readme,"@@ -1,79 +0,0 @@
-Glide
-=====
-Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
-
-Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
-
-Who Shouldn't Use Glide?
-------------------------
-If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
-
-Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
-
-Also you probably shouldn't bother if you're not writing an Android app...
-
-Who Should Use Glide?
----------------------
-Anyone who displays large numbers of images can benefit from Glide.
-
-Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
-
-Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
-
-Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
-
-How Do I Use Glide?
--------------------
-The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
-
-```Java
-
-public class MyAdapter extends BaseAdapter {
-    private final ImageManager imageManager;
-
-    public MyAdapter(Context context) {
-         imageManager = new ImageManager.Builder(context).build();
-    }
-
-    ...
-    @Override
-    public View getView(int position, View recycled, ViewGroup container) {
-        final MyModel current = myModels.get(position);
-        final ImagePresenter<MyModel> presenter;
-        if (recycled == null) {
-            recycled = myInflater.inflate(R.layout.my_image_view, container, false);
-
-            presenter = new ImagePresenter.Builder<MyModel>()
-                    .setImageView((ImageView) recycled)
-                    .setPathLoader(new MyPathLoader())
-                    .setImageLoader(new CenterCrop(imageManager))
-                    .build();
-            recycled.setTag(presenter);
-        } else {
-            presenter = (ImagePresenter<MyModel>) recycled.getTag();
-        }
-        presenter.setModel(current);
-    }
-}
-
-```
-
-The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
-
-This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
-
-Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
-
-Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
-
-For more examples see the sample flickr app.
-
-How do I add Glide to my project?
---------------------------------
-Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
-
-Intellij and Eclipse instructions coming soon.
-
-Status
-------
-Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
","1 Glide
2 =====
3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
4 
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
6 
7 Who Shouldn't Use Glide?
8 ------------------------
9 If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
10 
11 Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
12 
13 Also you probably shouldn't bother if you're not writing an Android app...
14 
15 Who Should Use Glide?
16 ---------------------
17 Anyone who displays large numbers of images can benefit from Glide.
18 
19 Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
20 
21 Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
22 
23 Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
24 
25 How Do I Use Glide?
26 -------------------
27 The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
28 
29 ```Java
30 
31 public class MyAdapter extends BaseAdapter {
32     private final ImageManager imageManager;
33 
34     public MyAdapter(Context context) {
35          imageManager = new ImageManager.Builder(context).build();
36     }
37 
38     ...
39     @Override
40     public View getView(int position, View recycled, ViewGroup container) {
41         final MyModel current = myModels.get(position);
42         final ImagePresenter<MyModel> presenter;
43         if (recycled == null) {
44             recycled = myInflater.inflate(R.layout.my_image_view, container, false);
45 
46             presenter = new ImagePresenter.Builder<MyModel>()
47                     .setImageView((ImageView) recycled)
48                     .setPathLoader(new MyPathLoader())
49                     .setImageLoader(new CenterCrop(imageManager))
50                     .build();
51             recycled.setTag(presenter);
52         } else {
53             presenter = (ImagePresenter<MyModel>) recycled.getTag();
54         }
55         presenter.setModel(current);
56     }
57 }
58 
59 ```
60 
61 The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
62 
63 This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
64 
65 Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
66 
67 Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
68 
69 For more examples see the sample flickr app.
70 
71 How do I add Glide to my project?
72 --------------------------------
73 Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
74 
75 Intellij and Eclipse instructions coming soon.
76 
77 Status
78 ------
79 Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!",Yes
library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,20 +1,19 @@
 package com.bumptech.photos.loader.image;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 
 import java.lang.ref.WeakReference;
 
 
 /**
  * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
- * subclasses with a weak reference to the calling object.
- *
- * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
+ * subclasses with a weak reference to the calling {@link com.bumptech.photos.presenter.ImagePresenter}.
  */
-public abstract class BaseImageLoader<T> implements ImageLoader<T> {
+public abstract class BaseImageLoader implements ImageLoader {
     @Override
-    public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
-        doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb, path, model));
+    public final Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
+        doFetchImage(id, streamOpener, width, height, new InternalImageReadyCallback(cb, id));
         return cb;
     }
 
@@ -27,15 +26,15 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
      * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
      * image is ready.
      *
-     * @see ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
+     * @see ImageLoader#fetchImage(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
      *
-     * @param path The path to the image or null if the required information is contained in the model
-     * @param model The object that represents or contains an image that can be displayed
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The width of the view where the image will be displayed
      * @param height The height of the view where the image will be displayed
      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
      */
-    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
+    protected abstract void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
 
     /**
      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
@@ -43,45 +42,40 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
      * an image is displayed. See {@link com.bumptech.photos.presenter.ImageSetCallback} instead to make a visual change
      * when a load completes.
      *
-     * @param path The path to the loaded image
-     * @param model The model representing the loaded image
+     * @param id The unique id of the image
      * @param image The loaded image
      * @param isUsed True iff the requesting object is going to display the image
      */
-    protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) { }
+    protected void onImageReady(String id, Bitmap image, boolean isUsed) { }
 
     /**
-     * A lifecycle method called after the requesting object is notified that this loader failed to loada Bitmap. Should
-     * be used to cleanup or update any data related to the failed load.
+     * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
+     * Should be used to cleanup or update any data related to the failed load.
      *
      * @param e The exception that caused the failure, or null
-     * @param model The model representing the image this loader failed to load
-     * @param path The path to the image this loader failed to load
+     * @param id The unique id of the image
      * @return True iff this image loader has handled the exception and the cb should not be notified.
      */
-    protected boolean onImageLoadFailed(Exception e, T model, String path) {
+    protected boolean onImageLoadFailed(Exception e, String id) {
         return false;
     }
 
     protected class InternalImageReadyCallback implements ImageReadyCallback {
         private final WeakReference<ImageReadyCallback> cbRef;
-        private final String path;
-        private final WeakReference<T> modelRef;
+        private final String id;
 
-        public InternalImageReadyCallback(ImageReadyCallback cb, String path, T model) {
+        public InternalImageReadyCallback(ImageReadyCallback cb, String id) {
             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
-            this.modelRef = new WeakReference<T>(model);
-            this.path = path;
+            this.id = id;
         }
 
         @Override
         public final boolean onImageReady(Bitmap image) {
             final ImageReadyCallback cb = cbRef.get();
-            final T model = modelRef.get();
             boolean result = false;
-            if (cb != null && modelRef != null) {
+            if (cb != null) {
                 result = cb.onImageReady(image);
-                BaseImageLoader.this.onImageReady(path, model, image, result);
+                BaseImageLoader.this.onImageReady(id, image, result);
             }
             return result;
         }
@@ -89,9 +83,8 @@ public abstract class BaseImageLoader<T> implements ImageLoader<T> {
         @Override
         public void onException(Exception e) {
             final ImageReadyCallback cb = cbRef.get();
-            final T model = modelRef.get();
-            if (cb != null && model != null) {
-                if (!BaseImageLoader.this.onImageLoadFailed(e, model, path)) {
+            if (cb != null) {
+                if (!BaseImageLoader.this.onImageLoadFailed(e, id)) {
                     cb.onException(e);
                 }
             }
","4 import com.bumptech.photos.loader.opener.StreamOpener;
11  * subclasses with a weak reference to the calling {@link com.bumptech.photos.presenter.ImagePresenter}.
13 public abstract class BaseImageLoader implements ImageLoader {
15     public final Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
16         doFetchImage(id, streamOpener, width, height, new InternalImageReadyCallback(cb, id));
29      * @see ImageLoader#fetchImage(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
31      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
32      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
37     protected abstract void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
45      * @param id The unique id of the image
49     protected void onImageReady(String id, Bitmap image, boolean isUsed) { }
52      * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
53      * Should be used to cleanup or update any data related to the failed load.
56      * @param id The unique id of the image
59     protected boolean onImageLoadFailed(Exception e, String id) {
65         private final String id;
67         public InternalImageReadyCallback(ImageReadyCallback cb, String id) {
69             this.id = id;
76             if (cb != null) {
78                 BaseImageLoader.this.onImageReady(id, image, result);
86             if (cb != null) {
87                 if (!BaseImageLoader.this.onImageLoadFailed(e, id)) {
10  * subclasses with a weak reference to the calling object.
11  *
12  * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
14 public abstract class BaseImageLoader<T> implements ImageLoader<T> {
16     public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
17         doFetchImage(path, model, width, height, new InternalImageReadyCallback(cb, path, model));
30      * @see ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
32      * @param path The path to the image or null if the required information is contained in the model
33      * @param model The object that represents or contains an image that can be displayed
38     protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
46      * @param path The path to the loaded image
47      * @param model The model representing the loaded image
51     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) { }
54      * A lifecycle method called after the requesting object is notified that this loader failed to loada Bitmap. Should
55      * be used to cleanup or update any data related to the failed load.
58      * @param model The model representing the image this loader failed to load
59      * @param path The path to the image this loader failed to load
62     protected boolean onImageLoadFailed(Exception e, T model, String path) {
68         private final String path;
69         private final WeakReference<T> modelRef;
71         public InternalImageReadyCallback(ImageReadyCallback cb, String path, T model) {
73             this.modelRef = new WeakReference<T>(model);
74             this.path = path;
80             final T model = modelRef.get();
82             if (cb != null && modelRef != null) {
84                 BaseImageLoader.this.onImageReady(path, model, image, result);
92             final T model = modelRef.get();
93             if (cb != null && model != null) {
94                 if (!BaseImageLoader.this.onImageLoadFailed(e, model, path)) {",No
library\src\com\bumptech\photos\loader\image\ImageLoader.java,library\src\com\bumptech\photos\loader\image\ImageLoader.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,18 +1,18 @@
 package com.bumptech.photos.loader.image;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 
 /**
- * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given path and/or
- * model
+ * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given id and
+ * dimensions and/or input streams
  *
- * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
  */
-public interface ImageLoader<T> {
+public interface ImageLoader {
 
     /**
      * An interface defining a callback that will be passed to an {@link ImageLoader} and that should be called by the
-     * {@link ImageLoader} when a load completes either successfully or because of a failure
+     * {@link ImageLoader} when a load completes either successfully or because of an exception
      */
     public interface ImageReadyCallback {
 
@@ -35,15 +35,15 @@ public interface ImageLoader<T> {
     /**
      * Load the image at the given path represented by the given model
      *
-     * @param path The path to the image or null if the required information is contained in the model
-     * @param model The object that represents or contains an image that can be displayed
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The width of the view where the image will be displayed
      * @param height The height of the view where the image will be displayed
      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
      *
      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
      */
-    public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);
+    public Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
 
     /**
      * Called when the current image load does not need to continue and any corresponding cleanup to save cpu
","4 import com.bumptech.photos.loader.opener.StreamOpener;
7  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given id and
8  * dimensions and/or input streams
11 public interface ImageLoader {
15      * {@link ImageLoader} when a load completes either successfully or because of an exception
38      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
39      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
46     public Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
6  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given path and/or
7  * model
9  * @param <T> The type of the model this loader must be able to load a {@link android.graphics.Bitmap} for
11 public interface ImageLoader<T> {
15      * {@link ImageLoader} when a load completes either successfully or because of a failure
38      * @param path The path to the image or null if the required information is contained in the model
39      * @param model The object that represents or contains an image that can be displayed
46     public Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb);",No
,library\src\com\bumptech\photos\loader\model\ModelStreamLoader.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -0,0 +1,52 @@
+package com.bumptech.photos.loader.model;
+
+import com.bumptech.photos.loader.opener.StreamOpener;
+
+/**
+ * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a unique id and a means of
+ * obtaining input streams to an image represented by the given model
+ *
+ * @param <T> The type of the model that represents an image
+ */
+public interface ModelStreamLoader<T> {
+    /**
+     * An interface defining a callback that will be passed to an {@link ModelStreamLoader}
+     * and that should be called by the {@link ModelStreamLoader} when a load completes either successfully or
+     * because of an exception
+     */
+    public interface ModelStreamsReadyCallback {
+        /**
+         * The method a loader should call when a load completes successfully
+         *
+         * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+         * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+         * @return True iff the loaded streamOpener and id was used by the class that requested
+         */
+        public boolean onStreamsReady(String id, StreamOpener streamOpener);
+
+        /**
+         * The method a loader should call when a load fails
+         *
+         * @param e The exception that caused the load to fail, or null
+         */
+        public void onException(Exception e);
+    }
+
+    /**
+     * Obtain an id and {@link StreamOpener} represented by the given model at the given dimension
+     *
+     * @param model The model representing the image to be loaded
+     * @param width The width of the view the image will be displayed in
+     * @param height The height of the view the image will be displayed in
+     * @param cb The callback to call when the load completes
+     *
+     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relavent
+     */
+    public Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
+
+    /**
+     * Called when the current load does not need to continue and any corresponding cleanup to save cpu or memory can be
+     * done. Will not be called if a load completes successfully.
+     */
+    public void clear();
+}
","1 package com.bumptech.photos.loader.model;
2 
3 import com.bumptech.photos.loader.opener.StreamOpener;
4 
5 /**
6  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a unique id and a means of
7  * obtaining input streams to an image represented by the given model
8  *
9  * @param <T> The type of the model that represents an image
10  */
11 public interface ModelStreamLoader<T> {
12     /**
13      * An interface defining a callback that will be passed to an {@link ModelStreamLoader}
14      * and that should be called by the {@link ModelStreamLoader} when a load completes either successfully or
15      * because of an exception
16      */
17     public interface ModelStreamsReadyCallback {
18         /**
19          * The method a loader should call when a load completes successfully
20          *
21          * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
22          * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
23          * @return True iff the loaded streamOpener and id was used by the class that requested
24          */
25         public boolean onStreamsReady(String id, StreamOpener streamOpener);
26 
27         /**
28          * The method a loader should call when a load fails
29          *
30          * @param e The exception that caused the load to fail, or null
31          */
32         public void onException(Exception e);
33     }
34 
35     /**
36      * Obtain an id and {@link StreamOpener} represented by the given model at the given dimension
37      *
38      * @param model The model representing the image to be loaded
39      * @param width The width of the view the image will be displayed in
40      * @param height The height of the view the image will be displayed in
41      * @param cb The callback to call when the load completes
42      *
43      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relavent
44      */
45     public Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
46 
47     /**
48      * Called when the current load does not need to continue and any corresponding cleanup to save cpu or memory can be
49      * done. Will not be called if a load completes successfully.
50      */
51     public void clear();
52 }",No
,library\src\com\bumptech\photos\loader\opener\StreamOpener.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -0,0 +1,42 @@
+package com.bumptech.photos.loader.opener;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * An interface that encapsulates code to open InputStreams for an image.
+ */
+public interface StreamOpener {
+    /**
+     * A simple class to reference two InputStreams
+     */
+    public static class Streams {
+        public final InputStream is1;
+        public final InputStream is2;
+
+        public Streams(InputStream is1, InputStream is2) {
+            this.is1 = is1;
+            this.is2 = is2;
+        }
+    }
+
+    /**
+     * A method to actually create InputStreams. It will always be called on a background thread and therefore it is
+     * safe to perform long running requests in this method (like an http call). This method is used to load an image
+     * only if that image is not cached so this code may or may not be called
+     *
+     * @return A holder containing both opened InputStreams
+     * @throws IOException
+     */
+    public Streams openStreams() throws IOException;
+
+    /**
+     * A method that is called after openStreams in a try/finally block to allow this object to cleanup anything
+     * releated to the InputStreams. The InputStreams will be closed after the image load so it is not neccessary to
+     * close the InputStreams here. Instead this should be used for things like
+     * {@link java.net.HttpURLConnection#disconnect()} that must only be done after the streams are used.
+     *
+     * This method will not be called if openStreams is not called (ie if the image is cached)
+     */
+    public void cleanup();
+}
","1 package com.bumptech.photos.loader.opener;
2 
3 import java.io.IOException;
4 import java.io.InputStream;
5 
6 /**
7  * An interface that encapsulates code to open InputStreams for an image.
8  */
9 public interface StreamOpener {
10     /**
11      * A simple class to reference two InputStreams
12      */
13     public static class Streams {
14         public final InputStream is1;
15         public final InputStream is2;
16 
17         public Streams(InputStream is1, InputStream is2) {
18             this.is1 = is1;
19             this.is2 = is2;
20         }
21     }
22 
23     /**
24      * A method to actually create InputStreams. It will always be called on a background thread and therefore it is
25      * safe to perform long running requests in this method (like an http call). This method is used to load an image
26      * only if that image is not cached so this code may or may not be called
27      *
28      * @return A holder containing both opened InputStreams
29      * @throws IOException
30      */
31     public Streams openStreams() throws IOException;
32 
33     /**
34      * A method that is called after openStreams in a try/finally block to allow this object to cleanup anything
35      * releated to the InputStreams. The InputStreams will be closed after the image load so it is not neccessary to
36      * close the InputStreams here. Instead this should be used for things like
37      * {@link java.net.HttpURLConnection#disconnect()} that must only be done after the streams are used.
38      *
39      * This method will not be called if openStreams is not called (ie if the image is cached)
40      */
41     public void cleanup();
42 }",No
library\src\com\bumptech\photos\loader\path\BasePathLoader.java,,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,91 +0,0 @@
-package com.bumptech.photos.loader.path;
-
-import java.lang.ref.WeakReference;
-
-/**
- * A base class for {@link PathLoader that provides some lifecycle methods and prevents memory leaks by only providing
- * subclasses with a weak reference to the callinb object.}
- *
- * @param <T> The type of the model this loader must be able to load a path for
- */
-public abstract class BasePathLoader<T> implements PathLoader<T> {
-    @Override
-    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
-        doFetchPath(model, width, height, new InternalPathReadyCallback(cb, model));
-        return cb;
-    }
-
-    @Override
-    public void clear() { }
-
-    /**
-     * The method where subclasses should actually begin any long running load to fetch the path from the given model.
-     * It is safe to strongly reference the given callback since that callback only weakly references the object that
-     * created it. Once a load completes or fails the given callback should be called to signal to the calling object
-     * that the path is ready.
-     *
-     * @see com.bumptech.photos.loader.image.ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
-     *
-     * @param model The object that represents or contains a path to an image to be displayed
-     * @param width The width of the view where the image will be displayed
-     * @param height The height of the view where the image will be displayed
-     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
-     */
-    protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
-
-    /**
-     * A lifecycle method called after the requesting object is notified that this loader has loaded a path. Should be
-     * used to cleanup or update any data related ot the completed load.
-     *
-     * @param path The retrieved path to the image
-     * @param model The model representing the image
-     * @param isUsed True iff the requesting object is going to load the image at the given path
-     */
-    protected void onPathReady(String path, T model, boolean isUsed) { }
-
-    /**
-     * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
-     * SHould be used to cleanup or update any data related to the failed load.
-     *
-     * @param e The exception that caused the failure, or null
-     * @param model The model representing the image this loader failed to fetch a path for
-     * @return True iff this path loader has handled the exception and the cb should not be notified.
-     */
-    protected boolean onPathFetchFailed(Exception e, T model) {
-        return false;
-    }
-
-    protected class InternalPathReadyCallback implements PathReadyCallback{
-        private final WeakReference<PathReadyCallback> cbRef;
-        private final WeakReference<T> modelRef;
-
-        public InternalPathReadyCallback(PathReadyCallback cb, T model) {
-            this.cbRef = new WeakReference<PathReadyCallback>(cb);
-            this.modelRef = new WeakReference<T>(model);
-        }
-
-        @Override
-        public final boolean onPathReady(String path) {
-            final PathReadyCallback cb = cbRef.get();
-            final T model = modelRef.get();
-            boolean result = false;
-            if (cb != null && model != null) {
-                result = cb.onPathReady(path);
-                BasePathLoader.this.onPathReady(path, model, result);
-            }
-            return result;
-        }
-
-        @Override
-        public final void onException(Exception e) {
-            final PathReadyCallback cb = cbRef.get();
-            final T model = modelRef.get();
-            if (cb != null && model != null) {
-                if (!BasePathLoader.this.onPathFetchFailed(e, model)) {
-                    cb.onException(e);
-                }
-            }
-        }
-    }
-
-}
","1 package com.bumptech.photos.loader.path;
2 
3 import java.lang.ref.WeakReference;
4 
5 /**
6  * A base class for {@link PathLoader that provides some lifecycle methods and prevents memory leaks by only providing
7  * subclasses with a weak reference to the callinb object.}
8  *
9  * @param <T> The type of the model this loader must be able to load a path for
10  */
11 public abstract class BasePathLoader<T> implements PathLoader<T> {
12     @Override
13     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
14         doFetchPath(model, width, height, new InternalPathReadyCallback(cb, model));
15         return cb;
16     }
17 
18     @Override
19     public void clear() { }
20 
21     /**
22      * The method where subclasses should actually begin any long running load to fetch the path from the given model.
23      * It is safe to strongly reference the given callback since that callback only weakly references the object that
24      * created it. Once a load completes or fails the given callback should be called to signal to the calling object
25      * that the path is ready.
26      *
27      * @see com.bumptech.photos.loader.image.ImageLoader#fetchImage(String, Object, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
28      *
29      * @param model The object that represents or contains a path to an image to be displayed
30      * @param width The width of the view where the image will be displayed
31      * @param height The height of the view where the image will be displayed
32      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
33      */
34     protected abstract void doFetchPath(T model, int width, int height, PathReadyCallback cb);
35 
36     /**
37      * A lifecycle method called after the requesting object is notified that this loader has loaded a path. Should be
38      * used to cleanup or update any data related ot the completed load.
39      *
40      * @param path The retrieved path to the image
41      * @param model The model representing the image
42      * @param isUsed True iff the requesting object is going to load the image at the given path
43      */
44     protected void onPathReady(String path, T model, boolean isUsed) { }
45 
46     /**
47      * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
48      * SHould be used to cleanup or update any data related to the failed load.
49      *
50      * @param e The exception that caused the failure, or null
51      * @param model The model representing the image this loader failed to fetch a path for
52      * @return True iff this path loader has handled the exception and the cb should not be notified.
53      */
54     protected boolean onPathFetchFailed(Exception e, T model) {
55         return false;
56     }
57 
58     protected class InternalPathReadyCallback implements PathReadyCallback{
59         private final WeakReference<PathReadyCallback> cbRef;
60         private final WeakReference<T> modelRef;
61 
62         public InternalPathReadyCallback(PathReadyCallback cb, T model) {
63             this.cbRef = new WeakReference<PathReadyCallback>(cb);
64             this.modelRef = new WeakReference<T>(model);
65         }
66 
67         @Override
68         public final boolean onPathReady(String path) {
69             final PathReadyCallback cb = cbRef.get();
70             final T model = modelRef.get();
71             boolean result = false;
72             if (cb != null && model != null) {
73                 result = cb.onPathReady(path);
74                 BasePathLoader.this.onPathReady(path, model, result);
75             }
76             return result;
77         }
78 
79         @Override
80         public final void onException(Exception e) {
81             final PathReadyCallback cb = cbRef.get();
82             final T model = modelRef.get();
83             if (cb != null && model != null) {
84                 if (!BasePathLoader.this.onPathFetchFailed(e, model)) {
85                     cb.onException(e);
86                 }
87             }
88         }
89     }
90 
91 }",No
library\src\com\bumptech\photos\loader\path\DirectPathLoader.java,,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.loader.path;
-
-/**
- * A simple synchronous implementation of a {@link PathLoader}
- *
- * @param <T> The type of the model that contains a path
- */
-public abstract class DirectPathLoader<T> implements PathLoader<T> {
-
-    @Override
-    public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
-        cb.onPathReady(getPath(model, width, height));
-        return null;  //To change body of implemented methods use File | Settings | File Templates.
-    }
-
-    /**
-     * A method to be implemented by subclasses that should return a path for a given model (or null if the model
-     * contains some other mechanism to load the image directly)
-     *
-     * @param model The object containing the path
-     * @param width The width of the {@link android.widget.ImageView} that will be displaying the image
-     * @param height The height of the {@link android.widget.ImageView} that will be displaying the image
-     * @return The path where the image is located, or null
-     */
-    protected abstract String getPath(T model, int width, int height);
-
-    @Override
-    public final void clear() { }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.loader.path;
6 
7 /**
8  * A simple synchronous implementation of a {@link PathLoader}
9  *
10  * @param <T> The type of the model that contains a path
11  */
12 public abstract class DirectPathLoader<T> implements PathLoader<T> {
13 
14     @Override
15     public final Object fetchPath(T model, int width, int height, PathReadyCallback cb) {
16         cb.onPathReady(getPath(model, width, height));
17         return null;  //To change body of implemented methods use File | Settings | File Templates.
18     }
19 
20     /**
21      * A method to be implemented by subclasses that should return a path for a given model (or null if the model
22      * contains some other mechanism to load the image directly)
23      *
24      * @param model The object containing the path
25      * @param width The width of the {@link android.widget.ImageView} that will be displaying the image
26      * @param height The height of the {@link android.widget.ImageView} that will be displaying the image
27      * @return The path where the image is located, or null
28      */
29     protected abstract String getPath(T model, int width, int height);
30 
31     @Override
32     public final void clear() { }
33 }",No
library\src\com\bumptech\photos\loader\path\PathLoader.java,,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.photos.loader.path;
-
-/**
- * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a path for a given model
- *
- * @param <T> The type of the model this loader must be able to fetch paths for
- */
-public interface PathLoader<T> {
-
-    /**
-     * An interface defining a callback that will be passed to a {@link PathLoader} and that should be called by the
-     * {@link PathLoader} when a load completes either successfully or because of a failure
-     */
-    public interface PathReadyCallback {
-
-        /**
-         * The method a loader should call when a load completes successfully
-         *
-         * @param path The requested path
-         * @return True iff the loaded path was used by the class that requested it from the {@link PathLoader}
-         */
-        public boolean onPathReady(String path);
-
-        /**
-         * The method a loader should call when a load fails
-         *
-         * @param e The exception that caused the load to fail, or null
-         */
-        public void onException(Exception e);
-    }
-
-    /**
-     * Load the path represented by the given model
-     *
-     * @param model The object that represents or contains the path to an image.
-     * @param width The width of the view where the image will be displayed
-     * @param height The height of the view where the image will be displayed
-     * @param cb The callback to call when the path is loaded or when a load fails
-     *
-     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
-     */
-    public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
-
-    /**
-     * Called when the current path load does not need to conintue and any corresponding cleanup to save cpu or memory
-     * can be done. Will not be called if a load completes successfully.
-     */
-    public void clear();
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.photos.loader.path;
6 
7 /**
8  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a path for a given model
9  *
10  * @param <T> The type of the model this loader must be able to fetch paths for
11  */
12 public interface PathLoader<T> {
13 
14     /**
15      * An interface defining a callback that will be passed to a {@link PathLoader} and that should be called by the
16      * {@link PathLoader} when a load completes either successfully or because of a failure
17      */
18     public interface PathReadyCallback {
19 
20         /**
21          * The method a loader should call when a load completes successfully
22          *
23          * @param path The requested path
24          * @return True iff the loaded path was used by the class that requested it from the {@link PathLoader}
25          */
26         public boolean onPathReady(String path);
27 
28         /**
29          * The method a loader should call when a load fails
30          *
31          * @param e The exception that caused the load to fail, or null
32          */
33         public void onException(Exception e);
34     }
35 
36     /**
37      * Load the path represented by the given model
38      *
39      * @param model The object that represents or contains the path to an image.
40      * @param width The width of the view where the image will be displayed
41      * @param height The height of the view where the image will be displayed
42      * @param cb The callback to call when the path is loaded or when a load fails
43      *
44      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
45      */
46     public Object fetchPath(T model, int width, int height, PathReadyCallback cb);
47 
48     /**
49      * Called when the current path load does not need to conintue and any corresponding cleanup to save cpu or memory
50      * can be done. Will not be called if a load completes successfully.
51      */
52     public void clear();
53 }",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\photos\presenter\ImagePresenter.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -13,17 +13,18 @@ import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
 import com.bumptech.photos.loader.image.ImageLoader;
-import com.bumptech.photos.loader.path.PathLoader;
+import com.bumptech.photos.loader.model.ModelStreamLoader;
+import com.bumptech.photos.loader.opener.StreamOpener;
 
 import java.lang.ref.WeakReference;
 
 /**
  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and loading bitmaps correctly
- * when views are being recycled. Uses {@link PathLoader} to download
- * an image or retrieve a path for a given model and {@link ImageLoader} to load
+ * when views are being recycled. Uses {@link ModelStreamLoader} to download
+ * an image or otherwise retrieve InputStreams for a given model and {@link ImageLoader} to load
  * a bitmap from a given path and/or model. Also determines the actual width and height of the wrapped
  * {@link android.widget.ImageView} and passes that information to the provided
- * {@link PathLoader} and {@link ImageLoader}.
+ * {@link ModelStreamLoader} and {@link ImageLoader}.
  *
  * @param <T> The type of the model that contains information necessary to display an image. Can be as simple
  *            as a String containing a path or a complex data type.
@@ -44,9 +45,9 @@ public class ImagePresenter<T> {
         private Drawable placeholderDrawable;
         private ImageSetCallback imageSetCallback;
         private ImagePresenterCoordinator coordinator;
-        private ImageLoader<T> imageLoader;
-        private PathLoader<T> pathLoader;
+        private ImageLoader imageLoader;
         private ExceptionHandler<T> exceptionHandler;
+        private ModelStreamLoader<T> modelStreamLoader;
 
         /**
          * Builds an ImagePresenter
@@ -60,9 +61,8 @@ public class ImagePresenter<T> {
             if (imageLoader == null) {
                 throw new IllegalArgumentException(""cannot create presenter without an image loader"");
             }
-            if (pathLoader == null) {
-                throw new IllegalArgumentException(""cannot create presenter without a path loader"");
-
+            if (modelStreamLoader == null) {
+                throw new IllegalArgumentException(""cannot create presenter without a model stream loader"");
             }
 
             return new ImagePresenter<T>(this);
@@ -80,14 +80,14 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Required sets the {@link com.bumptech.photos.loader.path.PathLoader} the presenter will use to download an
-         * image or otherwise retrieve a path for a given T model
+         * Required. Sets the {@link ModelStreamLoader} the presenter will use to obtain an Id and InputStreams to the
+         * image represented by a given model
          *
-         * @param pathLoader The {@link com.bumptech.photos.loader.path.PathLoader} to use to retrieve a path
-         * @return This Builder
+         * @param modelStreamLoader The {@link ModelStreamLoader} to use to obtain the id and InputStreams
+         * @return This Builder object
          */
-        public Builder<T> setPathLoader(PathLoader<T> pathLoader) {
-            this.pathLoader = pathLoader;
+        public Builder<T> setModelStreamLoader(ModelStreamLoader<T> modelStreamLoader) {
+            this.modelStreamLoader = modelStreamLoader;
             return this;
         }
 
@@ -98,7 +98,7 @@ public class ImagePresenter<T> {
          * @param imageLoader The {@link com.bumptech.photos.loader.image.ImageLoader} to use to load an image
          * @return This Builder object
          */
-        public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
+        public Builder<T> setImageLoader(ImageLoader imageLoader) {
             this.imageLoader = imageLoader;
             return this;
         }
@@ -175,11 +175,11 @@ public class ImagePresenter<T> {
         }
     }
 
-    private Object pathToken;
     private Object imageToken;
+    private Object modelStreamToken;
 
-    private final PathLoader<T> pathLoader;
-    private final ImageLoader<T> imageLoader;
+    private final ModelStreamLoader<T> modelStreamLoader;
+    private final ImageLoader imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
     private final ImagePresenterCoordinator coordinator;
@@ -218,14 +218,14 @@ public class ImagePresenter<T> {
     }
 
     public interface ExceptionHandler<T> {
-        public void onPathLoadException(Exception e, T model, boolean isCurrent);
-        public void onImageLoadException(Exception e, T model, String path, boolean isCurrent);
+        public void onImageLoadException(Exception e, String id, boolean isCurrent);
+        public void onModelStreamLoadException(Exception e, T model, boolean isCurrent);
     }
 
-    private ImagePresenter(Builder<T> builder) {
+    protected ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
-        this.pathLoader = builder.pathLoader;
+        this.modelStreamLoader = builder.modelStreamLoader;
         if (builder.placeholderResourceId != 0) {
             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
         } else {
@@ -271,7 +271,7 @@ public class ImagePresenter<T> {
             sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
                 @Override
                 public void onSizeReady(int width, int height) {
-                    fetchPath(model, width, height, loadCount);
+                    fetchModelStreams(model, width, height, loadCount);
                 }
             });
 
@@ -297,8 +297,8 @@ public class ImagePresenter<T> {
 
     /**
      * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from
-     * being displayed and clears this presenter's {@link com.bumptech.photos.loader.image.ImageLoader} and
-     * this presenter's {@link com.bumptech.photos.loader.path.PathLoader}. Also displays the current placeholder if
+     * being displayed and clears this presenter's {@link ImageLoader} and
+     * this presenter's {@link ModelStreamLoader}. Also displays the current placeholder if
      * one is set
      */
     public void clear() {
@@ -306,16 +306,16 @@ public class ImagePresenter<T> {
         resetPlaceHolder();
         currentModel = null;
         isImageSet = false;
-        pathLoader.clear();
+        modelStreamLoader.clear();
         imageLoader.clear();
     }
 
-    private void fetchPath(final T model, final int width, final int height, final int loadCount) {
-        pathToken = pathLoader.fetchPath(model, width, height, new PathLoader.PathReadyCallback() {
+    private void fetchModelStreams(final T model, final int width, final int height, final int loadCount) {
+        modelStreamToken = modelStreamLoader.fetchModelStreams(model, width, height, new ModelStreamLoader.ModelStreamsReadyCallback() {
             @Override
-            public boolean onPathReady(final String path) {
+            public boolean onStreamsReady(String id, StreamOpener streamOpener) {
                 if (loadCount != currentCount) return false;
-                fetchImage(path, model, width, height, loadCount);
+                fetchImage(id, streamOpener, width, height, loadCount);
 
                 return true;
             }
@@ -323,14 +323,14 @@ public class ImagePresenter<T> {
             @Override
             public void onException(Exception e) {
                 if (exceptionHandler != null) {
-                    exceptionHandler.onPathLoadException(e, model, loadCount == currentCount);
+                    exceptionHandler.onModelStreamLoadException(e, model, loadCount == currentCount);
                 }
             }
         });
     }
 
-    private void fetchImage(final String path, final T model, int width, int height, final int loadCount) {
-        imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
+    private void fetchImage(final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
+        imageToken = imageLoader.fetchImage(id, streamOpener, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
@@ -345,7 +345,7 @@ public class ImagePresenter<T> {
             @Override
             public void onException(Exception e) {
                 if (exceptionHandler != null) {
-                    exceptionHandler.onImageLoadException(e, model, path, loadCount == currentCount);
+                    exceptionHandler.onImageLoadException(e, id, loadCount == currentCount);
                 }
             }
         });
","16 import com.bumptech.photos.loader.model.ModelStreamLoader;
17 import com.bumptech.photos.loader.opener.StreamOpener;
23  * when views are being recycled. Uses {@link ModelStreamLoader} to download
24  * an image or otherwise retrieve InputStreams for a given model and {@link ImageLoader} to load
27  * {@link ModelStreamLoader} and {@link ImageLoader}.
48         private ImageLoader imageLoader;
50         private ModelStreamLoader<T> modelStreamLoader;
64             if (modelStreamLoader == null) {
65                 throw new IllegalArgumentException(""cannot create presenter without a model stream loader"");
83          * Required. Sets the {@link ModelStreamLoader} the presenter will use to obtain an Id and InputStreams to the
84          * image represented by a given model
86          * @param modelStreamLoader The {@link ModelStreamLoader} to use to obtain the id and InputStreams
87          * @return This Builder object
89         public Builder<T> setModelStreamLoader(ModelStreamLoader<T> modelStreamLoader) {
90             this.modelStreamLoader = modelStreamLoader;
101         public Builder<T> setImageLoader(ImageLoader imageLoader) {
179     private Object modelStreamToken;
181     private final ModelStreamLoader<T> modelStreamLoader;
182     private final ImageLoader imageLoader;
221         public void onImageLoadException(Exception e, String id, boolean isCurrent);
222         public void onModelStreamLoadException(Exception e, T model, boolean isCurrent);
225     protected ImagePresenter(Builder<T> builder) {
228         this.modelStreamLoader = builder.modelStreamLoader;
274                     fetchModelStreams(model, width, height, loadCount);
300      * being displayed and clears this presenter's {@link ImageLoader} and
301      * this presenter's {@link ModelStreamLoader}. Also displays the current placeholder if
309         modelStreamLoader.clear();
313     private void fetchModelStreams(final T model, final int width, final int height, final int loadCount) {
314         modelStreamToken = modelStreamLoader.fetchModelStreams(model, width, height, new ModelStreamLoader.ModelStreamsReadyCallback() {
316             public boolean onStreamsReady(String id, StreamOpener streamOpener) {
318                 fetchImage(id, streamOpener, width, height, loadCount);
326                     exceptionHandler.onModelStreamLoadException(e, model, loadCount == currentCount);
332     private void fetchImage(final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
333         imageToken = imageLoader.fetchImage(id, streamOpener, width, height, new ImageLoader.ImageReadyCallback() {
348                     exceptionHandler.onImageLoadException(e, id, loadCount == currentCount);
16 import com.bumptech.photos.loader.path.PathLoader;
22  * when views are being recycled. Uses {@link PathLoader} to download
23  * an image or retrieve a path for a given model and {@link ImageLoader} to load
26  * {@link PathLoader} and {@link ImageLoader}.
47         private ImageLoader<T> imageLoader;
48         private PathLoader<T> pathLoader;
63             if (pathLoader == null) {
64                 throw new IllegalArgumentException(""cannot create presenter without a path loader"");
65 
83          * Required sets the {@link com.bumptech.photos.loader.path.PathLoader} the presenter will use to download an
84          * image or otherwise retrieve a path for a given T model
86          * @param pathLoader The {@link com.bumptech.photos.loader.path.PathLoader} to use to retrieve a path
87          * @return This Builder
89         public Builder<T> setPathLoader(PathLoader<T> pathLoader) {
90             this.pathLoader = pathLoader;
101         public Builder<T> setImageLoader(ImageLoader<T> imageLoader) {
178     private Object pathToken;
181     private final PathLoader<T> pathLoader;
182     private final ImageLoader<T> imageLoader;
221         public void onPathLoadException(Exception e, T model, boolean isCurrent);
222         public void onImageLoadException(Exception e, T model, String path, boolean isCurrent);
225     private ImagePresenter(Builder<T> builder) {
228         this.pathLoader = builder.pathLoader;
274                     fetchPath(model, width, height, loadCount);
300      * being displayed and clears this presenter's {@link com.bumptech.photos.loader.image.ImageLoader} and
301      * this presenter's {@link com.bumptech.photos.loader.path.PathLoader}. Also displays the current placeholder if
309         pathLoader.clear();
313     private void fetchPath(final T model, final int width, final int height, final int loadCount) {
314         pathToken = pathLoader.fetchPath(model, width, height, new PathLoader.PathReadyCallback() {
316             public boolean onPathReady(final String path) {
318                 fetchImage(path, model, width, height, loadCount);
326                     exceptionHandler.onPathLoadException(e, model, loadCount == currentCount);
332     private void fetchImage(final String path, final T model, int width, int height, final int loadCount) {
333         imageToken = imageLoader.fetchImage(path, model, width, height, new ImageLoader.ImageReadyCallback() {
348                     exceptionHandler.onImageLoadException(e, model, path, loadCount == currentCount);",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\photos\resize\ImageManager.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -12,6 +12,7 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
@@ -28,6 +29,7 @@ import com.bumptech.photos.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.concurrent.ExecutorService;
@@ -251,7 +253,7 @@ public class ImageManager {
 
         /**
          * Call to prevent the ImageManager from using a disk cache
-         * @return
+         * @return This Builder
          */
         public Builder disableDiskCache() {
             return setDiskCache(new DiskCacheAdapter());
@@ -305,7 +307,6 @@ public class ImageManager {
 
         final BitmapPool bitmapPool;
         if (builder.recycleBitmaps) {
-            Log.d(""IM: recycle bitmaps total per size="" + builder.maxBitmapsPerSize);
             memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
                 @Override
                 public void onImageRemoved(Bitmap removed) {
@@ -323,140 +324,79 @@ public class ImageManager {
     }
 
     /**
-     * Loads the image at the given path at its original dimensions.
+     * Loads the image at its original dimensions.
      *
-     * @param path The path id to the image
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImage(final String path, final LoadedCallback cb){
-        final int key = getKey(path, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, false, new ImageManagerJob() {
-            @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.loadAsIs(path);
-            }
-        });
-    }
-
-    /**
-     * @see #getImage(String, LoadedCallback)
-     *
-     * Same as getImage except with two input streams representing the image instead of a path. One
-     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
-     * from disk
-     */
-    public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
+    public Object getImage(String id, final StreamOpener streamOpener, final LoadedCallback cb){
         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, false, new ImageManagerJob() {
+        return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException {
                 return resizer.loadAsIs(is1, is2);
             }
         });
     }
 
     /**
-     * Loads the image for the given path assuming its width and height are exactly those given.
+     * Loads the image assuming its width and height are exactly those given.
      *
-     * @param path The path to the image
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The width of the image on disk
      * @param height The height of the image on disk
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
-        final int key = getKey(path, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob() {
-            @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.loadAsIs(path, width, height);
-            }
-        });
-    }
-
-    /**
-     * @see #getImageExact(String, int, int, LoadedCallback)
-     *
-     * Same as getImageExact except with an input stream instead of a path
-     */
-    public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
+    public Object getImageExact(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob() {
+        return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
-                return resizer.loadAsIs(is, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
+                return resizer.loadAsIs(is1, width, height);
             }
         });
     }
 
     /**
-     * Loads the image for the given path to nearly the given width and height maintaining the original proportions.
+     * Loads the image to nearly the given width and height maintaining the original proportions.
      *
-     * @param path The id of the image
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The desired width in pixels
      * @param height The desired height of the slice
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
-        final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob() {
-            @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.loadAtLeast(path, width, height);
-            }
-        });
-    }
-
-    /**
-     * @see #getImageApproximate(String, int, int, LoadedCallback)
-     *
-     * Same as getImageApproximate except with two input streams representing the image instead of a path. One
-     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
-     * from disk
-     */
-    public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
+    public Object getImageApproximate(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob() {
+        return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
                 return resizer.loadAtLeast(is1, is2, width, height);
             }
         });
     }
 
     /**
-     * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
+     * Loads the image, resizes it to be exactly width pixels wide keeping proportions,
      * and then returns a section from the center of image exactly height pixels tall.
      *
-     * @param path The id of the image
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The desired width in pixels
      * @param height The desired height of the slice
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
-        final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob() {
-            @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.centerCrop(path, width, height);
-            }
-        });
-    }
-
-    /**
-     * @see #centerCrop(String, int, int, LoadedCallback)
-     *
-     * Same as centerCrop except with two input streams representing the image instead of a path. One
-     * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
-     * from disk
-     */    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
+    public Object centerCrop(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob() {
+        return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException {
+            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
                 return resizer.centerCrop(is1, is2, width, height);
             }
         });
@@ -466,18 +406,19 @@ public class ImageManager {
      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
      * an area of width*height.
      *
-     * @param path The id of the image
+     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
+     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
      * @param width The width of the space
      * @param height The height of the space
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
-        final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
-        return runJob(key, cb, new ImageManagerJob() {
+    public Object fitCenter(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb){
+        final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
+        return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound() throws FileNotFoundException{
-                return resizer.fitInSpace(path, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
+                return resizer.fitInSpace(is1, is2, width, height);
             }
         });
     }
@@ -560,12 +501,17 @@ public class ImageManager {
     }
 
     private abstract class ImageManagerJob implements Runnable {
+        private final StreamOpener streamOpener;
         private int key;
         private LoadedCallback cb;
         private boolean useDiskCache;
         private Future future = null;
         private volatile boolean cancelled = false;
 
+        public ImageManagerJob(StreamOpener streamOpener) {
+            this.streamOpener = streamOpener;
+        }
+
         public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
             this.key = key;
             this.cb = cb;
@@ -624,9 +570,12 @@ public class ImageManager {
                     if (cancelled) return;
 
                     try {
-                        finishResize(resizeIfNotFound(), false);
+                        StreamOpener.Streams streams = streamOpener.openStreams();
+                        finishResize(resizeIfNotFound(streams.is1, streams.is2), false);
                     } catch (Exception e) {
                         cb.onLoadFailed(e);
+                    } finally {
+                        streamOpener.cleanup();
                     }
                 }
             });
@@ -654,7 +603,7 @@ public class ImageManager {
             }
         }
 
-        protected abstract Bitmap resizeIfNotFound() throws FileNotFoundException;
+        protected abstract Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException;
     }
 
 
@@ -673,7 +622,7 @@ public class ImageManager {
         }
     }
 
-    private static int getKey(String path, int width, int height, ResizeType type){
-        return Util.hash(path.hashCode(), width, height, type.hashCode());
+    private static int getKey(String id, int width, int height, ResizeType type){
+        return Util.hash(id.hashCode(), width, height, type.hashCode());
     }
 }
","15 import com.bumptech.photos.loader.opener.StreamOpener;
32 import java.io.IOException;
256          * @return This Builder
327      * Loads the image at its original dimensions.
329      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
330      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
334     public Object getImage(String id, final StreamOpener streamOpener, final LoadedCallback cb){
336         return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
338             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException {
345      * Loads the image assuming its width and height are exactly those given.
347      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
348      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
354     public Object getImageExact(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
356         return runJob(key, cb, new ImageManagerJob(streamOpener) {
358             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
359                 return resizer.loadAsIs(is1, width, height);
365      * Loads the image to nearly the given width and height maintaining the original proportions.
367      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
368      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
374     public Object getImageApproximate(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
376         return runJob(key, cb, new ImageManagerJob(streamOpener) {
378             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
385      * Loads the image, resizes it to be exactly width pixels wide keeping proportions,
388      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
389      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
395     public Object centerCrop(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
397         return runJob(key, cb, new ImageManagerJob(streamOpener) {
399             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
409      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
410      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
416     public Object fitCenter(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb){
417         final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
418         return runJob(key, cb, new ImageManagerJob(streamOpener) {
420             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
421                 return resizer.fitInSpace(is1, is2, width, height);
504         private final StreamOpener streamOpener;
511         public ImageManagerJob(StreamOpener streamOpener) {
512             this.streamOpener = streamOpener;
513         }
514 
573                         StreamOpener.Streams streams = streamOpener.openStreams();
574                         finishResize(resizeIfNotFound(streams.is1, streams.is2), false);
577                     } finally {
578                         streamOpener.cleanup();
606         protected abstract Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException;
625     private static int getKey(String id, int width, int height, ResizeType type){
626         return Util.hash(id.hashCode(), width, height, type.hashCode());
254          * @return
308             Log.d(""IM: recycle bitmaps total per size="" + builder.maxBitmapsPerSize);
326      * Loads the image at the given path at its original dimensions.
328      * @param path The path id to the image
332     public Object getImage(final String path, final LoadedCallback cb){
333         final int key = getKey(path, -1, -1, ResizeType.AS_IS);
334         return runJob(key, cb, false, new ImageManagerJob() {
335             @Override
336             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
337                 return resizer.loadAsIs(path);
338             }
339         });
340     }
341 
342     /**
343      * @see #getImage(String, LoadedCallback)
344      *
345      * Same as getImage except with two input streams representing the image instead of a path. One
346      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
347      * from disk
348      */
349     public Object getImage(final InputStream is1, final InputStream is2, String id, LoadedCallback cb) {
351         return runJob(key, cb, false, new ImageManagerJob() {
353             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
360      * Loads the image for the given path assuming its width and height are exactly those given.
362      * @param path The path to the image
368     public Object getImageExact(final String path, final int width, final int height, final LoadedCallback cb) {
369         final int key = getKey(path, width, height, ResizeType.AS_IS);
370         return runJob(key, cb, new ImageManagerJob() {
371             @Override
372             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
373                 return resizer.loadAsIs(path, width, height);
374             }
375         });
376     }
377 
378     /**
379      * @see #getImageExact(String, int, int, LoadedCallback)
380      *
381      * Same as getImageExact except with an input stream instead of a path
382      */
383     public Object getImageExact(final InputStream is, final int width, final int height, String id, LoadedCallback cb) {
385         return runJob(key, cb, new ImageManagerJob() {
387             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
388                 return resizer.loadAsIs(is, width, height);
394      * Loads the image for the given path to nearly the given width and height maintaining the original proportions.
396      * @param path The id of the image
402     public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){
403         final int key = getKey(path, width, height, ResizeType.APPROXIMATE);
404         return runJob(key, cb, new ImageManagerJob() {
405             @Override
406             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
407                 return resizer.loadAtLeast(path, width, height);
408             }
409         });
410     }
411 
412     /**
413      * @see #getImageApproximate(String, int, int, LoadedCallback)
414      *
415      * Same as getImageApproximate except with two input streams representing the image instead of a path. One
416      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
417      * from disk
418      */
419     public Object getImageApproximate(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
421         return runJob(key, cb, new ImageManagerJob() {
423             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
430      * Loads the image for the given path , resizes it to be exactly width pixels wide keeping proportions,
433      * @param path The id of the image
439     public Object centerCrop(final String path, final int width, final int height, final LoadedCallback cb){
440         final int key = getKey(path, width, height, ResizeType.CENTER_CROP);
441         return runJob(key, cb, new ImageManagerJob() {
442             @Override
443             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
444                 return resizer.centerCrop(path, width, height);
445             }
446         });
447     }
448 
449     /**
450      * @see #centerCrop(String, int, int, LoadedCallback)
451      *
452      * Same as centerCrop except with two input streams representing the image instead of a path. One
453      * InputStream will be used to determine the image's dimensions and the other will be used to read the image data
454      * from disk
455      */    public Object centerCrop(final InputStream is1, final InputStream is2, final String id, final int width, final int height, final LoadedCallback cb) {
457         return runJob(key, cb, new ImageManagerJob() {
459             protected Bitmap resizeIfNotFound() throws FileNotFoundException {
469      * @param path The id of the image
475     public Object fitCenter(final String path, final int width, final int height, final LoadedCallback cb){
476         final int key = getKey(path, width, height, ResizeType.FIT_CENTER);
477         return runJob(key, cb, new ImageManagerJob() {
479             protected Bitmap resizeIfNotFound() throws FileNotFoundException{
480                 return resizer.fitInSpace(path, width, height);
627                         finishResize(resizeIfNotFound(), false);
657         protected abstract Bitmap resizeIfNotFound() throws FileNotFoundException;
676     private static int getKey(String path, int width, int height, ResizeType type){
677         return Util.hash(path.hashCode(), width, height, type.hashCode());",No
library\src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\photos\resize\loader\Approximate.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -5,6 +5,7 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
@@ -13,17 +14,17 @@ import com.bumptech.photos.resize.LoadedCallback;
  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
  * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
  *
- * @see ImageManager#getImageApproximate(String, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImageApproximate(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
-public class Approximate<T> extends ImageManagerLoader<T> {
+public class Approximate extends ImageManagerLoader {
 
     public Approximate(ImageManager imageManager) {
         super(imageManager);
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageApproximate(id, streamOpener, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.photos.loader.opener.StreamOpener;
17  * @see ImageManager#getImageApproximate(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
19 public class Approximate extends ImageManagerLoader {
26     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
27         return imageManager.getImageApproximate(id, streamOpener, width, height, new LoadedCallback() {
16  * @see ImageManager#getImageApproximate(String, int, int, com.bumptech.photos.resize.LoadedCallback)
18 public class Approximate<T> extends ImageManagerLoader<T> {
25     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.getImageApproximate(path, width, height, new LoadedCallback() {",No
library\src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\photos\resize\loader\AsIs.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,6 +1,7 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
@@ -10,17 +11,17 @@ import com.bumptech.photos.resize.LoadedCallback;
  * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
  * other implementations
  *
- * @see ImageManager#getImage(String, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImage(String, com.bumptech.photos.loader.opener.StreamOpener, com.bumptech.photos.resize.LoadedCallback)
  */
-public class AsIs<T> extends ImageManagerLoader<T> {
+public class AsIs extends ImageManagerLoader {
 
     public AsIs(ImageManager imageManager) {
         super(imageManager);
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImage(path, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImage(id, streamOpener, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","4 import com.bumptech.photos.loader.opener.StreamOpener;
14  * @see ImageManager#getImage(String, com.bumptech.photos.loader.opener.StreamOpener, com.bumptech.photos.resize.LoadedCallback)
16 public class AsIs extends ImageManagerLoader {
23     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
24         return imageManager.getImage(id, streamOpener, new LoadedCallback() {
13  * @see ImageManager#getImage(String, com.bumptech.photos.resize.LoadedCallback)
15 public class AsIs<T> extends ImageManagerLoader<T> {
22     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
23         return imageManager.getImage(path, new LoadedCallback() {",No
library\src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\photos\resize\loader\CenterCrop.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -5,23 +5,24 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads and crops in image down to the given width and height.
  *
- * @see ImageManager#centerCrop(String, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#centerCrop(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
-public class CenterCrop<T> extends ImageManagerLoader<T> {
+public class CenterCrop extends ImageManagerLoader {
 
     public CenterCrop(ImageManager imageManager) {
         super(imageManager);
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.centerCrop(path, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.centerCrop(id, streamOpener, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.photos.loader.opener.StreamOpener;
15  * @see ImageManager#centerCrop(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
17 public class CenterCrop extends ImageManagerLoader {
24     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
25         return imageManager.centerCrop(id, streamOpener, width, height, new LoadedCallback() {
14  * @see ImageManager#centerCrop(String, int, int, com.bumptech.photos.resize.LoadedCallback)
16 public class CenterCrop<T> extends ImageManagerLoader<T> {
23     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
24         return imageManager.centerCrop(path, width, height, new LoadedCallback() {",No
library\src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\photos\resize\loader\Exact.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -5,6 +5,7 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
@@ -14,17 +15,17 @@ import com.bumptech.photos.resize.LoadedCallback;
  * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
  * resize).
  *
- * @see ImageManager#getImageExact(String, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImageExact(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
-public class Exact<T> extends ImageManagerLoader<T> {
+public class Exact extends ImageManagerLoader {
 
     public Exact(ImageManager imageManager) {
         super(imageManager);
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageExact(path, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageExact(id, streamOpener, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.photos.loader.opener.StreamOpener;
18  * @see ImageManager#getImageExact(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
20 public class Exact extends ImageManagerLoader {
27     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
28         return imageManager.getImageExact(id, streamOpener, width, height, new LoadedCallback() {
17  * @see ImageManager#getImageExact(String, int, int, com.bumptech.photos.resize.LoadedCallback)
19 public class Exact<T> extends ImageManagerLoader<T> {
26     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
27         return imageManager.getImageExact(path, width, height, new LoadedCallback() {",No
library\src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\photos\resize\loader\FitCenter.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -5,6 +5,7 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.LoadedCallback;
 
@@ -12,17 +13,17 @@ import com.bumptech.photos.resize.LoadedCallback;
  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
  * proportions
  *
- * @see ImageManager#fitCenter(String, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#fitCenter(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
  */
-public class FitCenter<T> extends ImageManagerLoader<T> {
+public class FitCenter extends ImageManagerLoader {
 
     public FitCenter(ImageManager imageManager) {
         super(imageManager);
     }
 
     @Override
-    protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.fitCenter(path, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.fitCenter(id, streamOpener, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.photos.loader.opener.StreamOpener;
16  * @see ImageManager#fitCenter(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
18 public class FitCenter extends ImageManagerLoader {
25     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.fitCenter(id, streamOpener, width, height, new LoadedCallback() {
15  * @see ImageManager#fitCenter(String, int, int, com.bumptech.photos.resize.LoadedCallback)
17 public class FitCenter<T> extends ImageManagerLoader<T> {
24     protected Object doFetchImage(String path, int width, int height, final ImageReadyCallback cb) {
25         return imageManager.fitCenter(path, width, height, new LoadedCallback() {",No
library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,ed7d496cef495d8a98684bfe9e911013eeb53433,2cdb0abe14e75e7497c6d39d92058ebeb3499694,"Replace PathLoader with ModelStreamLoader

A major change that should allow a larger range
of images to be used (i.e. those to which it is
only possible to obtain an InputStream and not
a path) as well as making it possible to download
and store images directly in the cache without
an additional class or disk cache.","@@ -1,6 +1,7 @@
 package com.bumptech.photos.resize.loader;
 
 import android.graphics.Bitmap;
+import com.bumptech.photos.loader.opener.StreamOpener;
 import com.bumptech.photos.loader.image.BaseImageLoader;
 import com.bumptech.photos.resize.ImageManager;
 
@@ -8,7 +9,7 @@ import com.bumptech.photos.resize.ImageManager;
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
  * purposes.
  */
-public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
+public abstract class ImageManagerLoader extends BaseImageLoader {
 
     protected final ImageManager imageManager;
     private Bitmap acquired;
@@ -18,17 +19,17 @@ public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
         this.imageManager = imageManager;
     }
     @Override
-    protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
+    protected final void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
         clear();
-        if (path != null) {
-            loadToken = doFetchImage(path, width, height, cb);
+        if (streamOpener != null) {
+            loadToken = loadFromImageManager(id, streamOpener, width, height, cb);
         }
     }
 
-    protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
+    protected abstract Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
 
     @Override
-    protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {
+    protected void onImageReady(String id, Bitmap image, boolean isUsed) {
         if (isUsed) {
             releaseAcquired();
             imageManager.acquireBitmap(image);
","4 import com.bumptech.photos.loader.opener.StreamOpener;
12 public abstract class ImageManagerLoader extends BaseImageLoader {
22     protected final void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
24         if (streamOpener != null) {
25             loadToken = loadFromImageManager(id, streamOpener, width, height, cb);
29     protected abstract Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
32     protected void onImageReady(String id, Bitmap image, boolean isUsed) {
11 public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {
21     protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {
23         if (path != null) {
24             loadToken = doFetchImage(path, width, height, cb);
28     protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);
31     protected void onImageReady(String path, T model, Bitmap image, boolean isUsed) {",No
,library\src\com\bumptech\photos\loader\opener\FileInputStreamsOpener.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -0,0 +1,32 @@
+package com.bumptech.photos.loader.opener;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/10/13
+ * Time: 11:11 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FileInputStreamsOpener implements StreamOpener {
+    private final File file;
+
+    public FileInputStreamsOpener(String path) {
+        this(new File(path));
+    }
+
+    public FileInputStreamsOpener(File file) {
+        this.file = file;
+    }
+
+    @Override
+    public Streams openStreams() throws IOException {
+        return new Streams(new FileInputStream(file), new FileInputStream(file));
+    }
+
+    @Override
+    public void cleanup() { }
+}
","1 package com.bumptech.photos.loader.opener;
2 
3 import java.io.File;
4 import java.io.FileInputStream;
5 import java.io.IOException;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 7/10/13
11  * Time: 11:11 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class FileInputStreamsOpener implements StreamOpener {
15     private final File file;
16 
17     public FileInputStreamsOpener(String path) {
18         this(new File(path));
19     }
20 
21     public FileInputStreamsOpener(File file) {
22         this.file = file;
23     }
24 
25     @Override
26     public Streams openStreams() throws IOException {
27         return new Streams(new FileInputStream(file), new FileInputStream(file));
28     }
29 
30     @Override
31     public void cleanup() { }
32 }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -104,8 +104,8 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setPathLoader(new FlickrPathLoader(api, cacheDir))
-                        .setImageLoader(new CenterCrop<Photo>(imageManager))
+                        .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
+                        .setImageLoader(new CenterCrop(imageManager))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
","107                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
108                         .setImageLoader(new CenterCrop(imageManager))
107                         .setPathLoader(new FlickrPathLoader(api, cacheDir))
108                         .setImageLoader(new CenterCrop<Photo>(imageManager))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -107,8 +107,8 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setPathLoader(new FlickrPathLoader(api, cacheDir))
-                        .setImageLoader(new CenterCrop<Photo>(imageManager))
+                        .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
+                        .setImageLoader(new CenterCrop(imageManager))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
","110                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
111                         .setImageLoader(new CenterCrop(imageManager))
110                         .setPathLoader(new FlickrPathLoader(api, cacheDir))
111                         .setImageLoader(new CenterCrop<Photo>(imageManager))",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -19,7 +19,6 @@ import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
-import com.bumptech.photos.resize.cache.LruPhotoCache;
 import com.bumptech.photos.util.Log;
 
 import java.io.File;
@@ -49,7 +48,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         }
 
         imageManager = new ImageManager.Builder(this)
-                .setMemoryCache(new LruPhotoCache(1234))
                 .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))
                 .setMaxBitmapsPerSize(40)
                 .build();
","22 import com.bumptech.photos.resize.cache.LruPhotoCache;
52                 .setMemoryCache(new LruPhotoCache(1234))",No
samples\flickr\src\com\bumptech\flickr\FlickrPathLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -2,7 +2,8 @@ package com.bumptech.flickr;
 
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.loader.path.BasePathLoader;
+import com.bumptech.photos.loader.model.ModelStreamLoader;
+import com.bumptech.photos.loader.opener.FileInputStreamsOpener;
 
 import java.io.File;
 import java.util.concurrent.Future;
@@ -14,30 +15,30 @@ import java.util.concurrent.Future;
  * Time: 11:55 AM
  * To change this template use File | Settings | File Templates.
  */
-public class FlickrPathLoader extends BasePathLoader<Photo> {
+public class FlickrStreamLoader implements ModelStreamLoader<Photo> {
     private final Api flickrApi;
     private final File cacheDir;
     private Future current;
 
-    public FlickrPathLoader(Api flickApi, File cacheDir) {
+    public FlickrStreamLoader(Api flickApi, File cacheDir) {
         this.flickrApi = flickApi;
         this.cacheDir = cacheDir;
     }
 
     @Override
-    protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
+    public Object fetchModelStreams(Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
         clear();
         current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
-                cb.onPathReady(path);
+                cb.onStreamsReady(path, new FileInputStreamsOpener(path));
             }
         });
+        return current;
     }
 
     @Override
     public void clear() {
-        super.clear();
         if (current != null) {
             current.cancel(false);
             current = null;
","5 import com.bumptech.photos.loader.model.ModelStreamLoader;
6 import com.bumptech.photos.loader.opener.FileInputStreamsOpener;
18 public class FlickrStreamLoader implements ModelStreamLoader<Photo> {
23     public FlickrStreamLoader(Api flickApi, File cacheDir) {
29     public Object fetchModelStreams(Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
34                 cb.onStreamsReady(path, new FileInputStreamsOpener(path));
37         return current;
5 import com.bumptech.photos.loader.path.BasePathLoader;
17 public class FlickrPathLoader extends BasePathLoader<Photo> {
22     public FlickrPathLoader(Api flickApi, File cacheDir) {
28     protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {
33                 cb.onPathReady(path);
40         super.clear();",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,f68b64aae73cffd31b866b559bcabe4b600fbe85,ed7d496cef495d8a98684bfe9e911013eeb53433,Get the flickr example working again,"@@ -7,6 +7,8 @@ import org.json.JSONObject;
 
 import java.io.File;
 import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -67,6 +69,15 @@ public class Api {
         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
     }
 
+    public URL getPhotoURL(int width, int height, Photo photo) {
+        try {
+            return new URL(getPhotoUrl(photo, getSizeKey(width, height)));
+        } catch (MalformedURLException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
     private static String getUrlForMethod(String method) {
         return String.format(SIGNED_API_URL, method);
     }
","10 import java.net.MalformedURLException;
11 import java.net.URL;
72     public URL getPhotoURL(int width, int height, Photo photo) {
73         try {
74             return new URL(getPhotoUrl(photo, getSizeKey(width, height)));
75         } catch (MalformedURLException e) {
76             e.printStackTrace();
77             return null;
78         }
79     }
80 ",No
,library\src\com\bumptech\photos\loader\model\BaseModelStreamLoader.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -0,0 +1,83 @@
+package com.bumptech.photos.loader.model;
+
+import com.bumptech.photos.loader.opener.StreamOpener;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * A base class for {@link ModelStreamLoader} that provides some lifecycle methods and prevents memory leaks if a load
+ * stalls or takes a long time by only providing subclasses with a weak reference to the calling
+ * {@link com.bumptech.photos.presenter.ImagePresenter}.
+ */
+public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
+    /**
+     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     */
+    @Override
+    public final Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
+        doFetchModelStreams(model, width, height, new InternalModelStreamsReadyCallback(cb, model));
+        return cb;
+    }
+
+    /**
+     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     */
+    @Override
+    public void clear() { }
+
+    /**
+     * The method where subclasses should call into whatever external class is fetching the information necessary
+     * to build the id and stream opener. This method is run on the main thread so it is not safe to do long running
+     * tasks. Instead pass the callback to some other class that will run on a background thread
+     *
+     * @param model The model representing the image
+     * @param width The width of the view the image will be displayed in
+     * @param height The height of the view the image will be displayed in
+     * @param cb The callback to call when the id and stream opener are ready, or when the load fails
+     */
+    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
+
+    /**
+     * A lifecycle method called after the requesting object is notifie that this loader failed to load the id and/or
+     * stream opener. Should be used to cleanup or update any data related to the failed loadg.
+     *
+     * @param e The exception that caused the failure, or null
+     * @param model The model
+     * @return True iff this model stream loader has handled the exception and the cb should not be notified
+     */
+    protected boolean onModelStreamFetchFailed(Exception e, T model) {
+        return false;
+    }
+
+    protected class InternalModelStreamsReadyCallback implements ModelStreamsReadyCallback {
+
+        private final WeakReference<ModelStreamsReadyCallback> cbRef;
+        private final WeakReference<T> modelRef;
+
+        public InternalModelStreamsReadyCallback(ModelStreamsReadyCallback cb, T model) {
+            this.cbRef = new WeakReference<ModelStreamsReadyCallback>(cb);
+            this.modelRef = new WeakReference<T>(model);
+        }
+
+        @Override
+        public boolean onStreamsReady(String id, StreamOpener streamOpener) {
+            ModelStreamsReadyCallback cb = cbRef.get();
+            boolean result = false;
+            if (cb != null) {
+                result = cb.onStreamsReady(id, streamOpener);
+            }
+            return result;
+        }
+
+        @Override
+        public void onException(Exception e) {
+            ModelStreamsReadyCallback cb = cbRef.get();
+            T model = modelRef.get();
+            if (cb != null && model != null) {
+                if (!BaseModelStreamLoader.this.onModelStreamFetchFailed(e, model)) {
+                    cb.onException(e);
+                }
+            }
+        }
+    }
+}
","1 package com.bumptech.photos.loader.model;
2 
3 import com.bumptech.photos.loader.opener.StreamOpener;
4 
5 import java.lang.ref.WeakReference;
6 
7 /**
8  * A base class for {@link ModelStreamLoader} that provides some lifecycle methods and prevents memory leaks if a load
9  * stalls or takes a long time by only providing subclasses with a weak reference to the calling
10  * {@link com.bumptech.photos.presenter.ImagePresenter}.
11  */
12 public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
13     /**
14      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
15      */
16     @Override
17     public final Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
18         doFetchModelStreams(model, width, height, new InternalModelStreamsReadyCallback(cb, model));
19         return cb;
20     }
21 
22     /**
23      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
24      */
25     @Override
26     public void clear() { }
27 
28     /**
29      * The method where subclasses should call into whatever external class is fetching the information necessary
30      * to build the id and stream opener. This method is run on the main thread so it is not safe to do long running
31      * tasks. Instead pass the callback to some other class that will run on a background thread
32      *
33      * @param model The model representing the image
34      * @param width The width of the view the image will be displayed in
35      * @param height The height of the view the image will be displayed in
36      * @param cb The callback to call when the id and stream opener are ready, or when the load fails
37      */
38     protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
39 
40     /**
41      * A lifecycle method called after the requesting object is notifie that this loader failed to load the id and/or
42      * stream opener. Should be used to cleanup or update any data related to the failed loadg.
43      *
44      * @param e The exception that caused the failure, or null
45      * @param model The model
46      * @return True iff this model stream loader has handled the exception and the cb should not be notified
47      */
48     protected boolean onModelStreamFetchFailed(Exception e, T model) {
49         return false;
50     }
51 
52     protected class InternalModelStreamsReadyCallback implements ModelStreamsReadyCallback {
53 
54         private final WeakReference<ModelStreamsReadyCallback> cbRef;
55         private final WeakReference<T> modelRef;
56 
57         public InternalModelStreamsReadyCallback(ModelStreamsReadyCallback cb, T model) {
58             this.cbRef = new WeakReference<ModelStreamsReadyCallback>(cb);
59             this.modelRef = new WeakReference<T>(model);
60         }
61 
62         @Override
63         public boolean onStreamsReady(String id, StreamOpener streamOpener) {
64             ModelStreamsReadyCallback cb = cbRef.get();
65             boolean result = false;
66             if (cb != null) {
67                 result = cb.onStreamsReady(id, streamOpener);
68             }
69             return result;
70         }
71 
72         @Override
73         public void onException(Exception e) {
74             ModelStreamsReadyCallback cb = cbRef.get();
75             T model = modelRef.get();
76             if (cb != null && model != null) {
77                 if (!BaseModelStreamLoader.this.onModelStreamFetchFailed(e, model)) {
78                     cb.onException(e);
79                 }
80             }
81         }
82     }
83 }",No
,library\src\com\bumptech\photos\loader\model\DirectModelStreamLoader.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -0,0 +1,25 @@
+package com.bumptech.photos.loader.model;
+
+import com.bumptech.photos.loader.opener.StreamOpener;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/11/13
+ * Time: 11:54 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class DirectModelStreamLoader<T> extends BaseModelStreamLoader<T> {
+    @Override
+    protected void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
+        cb.onStreamsReady(getId(model), getStreamOpener(model, width, height));
+    }
+
+    @Override
+    protected boolean onModelStreamFetchFailed(Exception e, T model) {
+        return false;
+    }
+
+    protected abstract StreamOpener getStreamOpener(T model, int width, int height);
+    protected abstract String getId(T model);
+}
","1 package com.bumptech.photos.loader.model;
2 
3 import com.bumptech.photos.loader.opener.StreamOpener;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 7/11/13
9  * Time: 11:54 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public abstract class DirectModelStreamLoader<T> extends BaseModelStreamLoader<T> {
13     @Override
14     protected void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
15         cb.onStreamsReady(getId(model), getStreamOpener(model, width, height));
16     }
17 
18     @Override
19     protected boolean onModelStreamFetchFailed(Exception e, T model) {
20         return false;
21     }
22 
23     protected abstract StreamOpener getStreamOpener(T model, int width, int height);
24     protected abstract String getId(T model);
25 }",No
,library\src\com\bumptech\photos\loader\opener\HttpInputStreamsOpener.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -0,0 +1,44 @@
+package com.bumptech.photos.loader.opener;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/10/13
+ * Time: 11:21 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class HttpInputStreamsOpener implements StreamOpener {
+    private final URL url;
+    private HttpURLConnection[] urlConnections = new HttpURLConnection[2];
+
+    public HttpInputStreamsOpener(URL url) {
+        this.url = url;
+    }
+
+    @Override
+    public Streams openStreams() throws IOException {
+        urlConnections = new HttpURLConnection[] {(HttpURLConnection) url.openConnection(), (HttpURLConnection) url.openConnection()};
+        for (HttpURLConnection urlConnection : urlConnections) {
+            urlConnection = (HttpURLConnection) url.openConnection();
+            urlConnection.setDoInput(true);
+            urlConnection.setDoOutput(false);
+            urlConnection.setUseCaches(false);
+            urlConnection.setRequestProperty(""Connection"", ""close"");
+            urlConnection.connect();
+        }
+        return new Streams(urlConnections[0].getInputStream(), urlConnections[1].getInputStream());
+    }
+
+    @Override
+    public void cleanup() {
+        for (HttpURLConnection urlConnection : urlConnections) {
+            if (urlConnection != null) {
+                urlConnection.disconnect();
+            }
+        }
+    }
+}
","1 package com.bumptech.photos.loader.opener;
2 
3 import java.io.IOException;
4 import java.net.HttpURLConnection;
5 import java.net.URL;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 7/10/13
11  * Time: 11:21 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class HttpInputStreamsOpener implements StreamOpener {
15     private final URL url;
16     private HttpURLConnection[] urlConnections = new HttpURLConnection[2];
17 
18     public HttpInputStreamsOpener(URL url) {
19         this.url = url;
20     }
21 
22     @Override
23     public Streams openStreams() throws IOException {
24         urlConnections = new HttpURLConnection[] {(HttpURLConnection) url.openConnection(), (HttpURLConnection) url.openConnection()};
25         for (HttpURLConnection urlConnection : urlConnections) {
26             urlConnection = (HttpURLConnection) url.openConnection();
27             urlConnection.setDoInput(true);
28             urlConnection.setDoOutput(false);
29             urlConnection.setUseCaches(false);
30             urlConnection.setRequestProperty(""Connection"", ""close"");
31             urlConnection.connect();
32         }
33         return new Streams(urlConnections[0].getInputStream(), urlConnections[1].getInputStream());
34     }
35 
36     @Override
37     public void cleanup() {
38         for (HttpURLConnection urlConnection : urlConnections) {
39             if (urlConnection != null) {
40                 urlConnection.disconnect();
41             }
42         }
43     }
44 }",No
,samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -0,0 +1,30 @@
+package com.bumptech.flickr;
+
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.photos.loader.model.DirectModelStreamLoader;
+import com.bumptech.photos.loader.opener.HttpInputStreamsOpener;
+import com.bumptech.photos.loader.opener.StreamOpener;
+
+/**
+ * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
+ * ImageManager to download the image and resize it in memory before saving the resized version
+ * directly to the disk cache.
+ */
+public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
+    private final Api flickrApi;
+
+    public DirectFlickrStreamLoader(Api flickApi) {
+        this.flickrApi = flickApi;
+    }
+
+    @Override
+    protected StreamOpener getStreamOpener(Photo model, int width, int height) {
+        return new HttpInputStreamsOpener(flickrApi.getPhotoURL(width, height, model));
+    }
+
+    @Override
+    protected String getId(Photo model) {
+        return model.id;
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import com.bumptech.flickr.api.Api;
4 import com.bumptech.flickr.api.Photo;
5 import com.bumptech.photos.loader.model.DirectModelStreamLoader;
6 import com.bumptech.photos.loader.opener.HttpInputStreamsOpener;
7 import com.bumptech.photos.loader.opener.StreamOpener;
8 
9 /**
10  * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
11  * ImageManager to download the image and resize it in memory before saving the resized version
12  * directly to the disk cache.
13  */
14 public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
15     private final Api flickrApi;
16 
17     public DirectFlickrStreamLoader(Api flickApi) {
18         this.flickrApi = flickApi;
19     }
20 
21     @Override
22     protected StreamOpener getStreamOpener(Photo model, int width, int height) {
23         return new HttpInputStreamsOpener(flickrApi.getPhotoURL(width, height, model));
24     }
25 
26     @Override
27     protected String getId(Photo model) {
28         return model.id;
29     }
30 }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -18,7 +18,6 @@ import com.bumptech.photos.presenter.ImageSetCallback;
 import com.bumptech.photos.resize.ImageManager;
 import com.bumptech.photos.resize.loader.CenterCrop;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -33,14 +32,13 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
     private FlickrPhotoListAdapter adapter;
     private Api api;
     private ImageManager imageManager;
-    private File cacheDir;
     private List<Photo> currentPhotos;
 
-    public void setup(Api api, ImageManager imageManager, File cacheDir) {
+    public void setup(Api api, ImageManager imageManager) {
         this.api = api;
         this.imageManager = imageManager;
-        this.cacheDir = cacheDir;
     }
+
     @Override
     public void onPhotosUpdated(List<Photo> photos) {
         currentPhotos = photos;
@@ -107,7 +105,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
+                        .setModelStreamLoader(new DirectFlickrStreamLoader(api))
                         .setImageLoader(new CenterCrop(imageManager))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
","37     public void setup(Api api, ImageManager imageManager) {
41 
108                         .setModelStreamLoader(new DirectFlickrStreamLoader(api))
21 import java.io.File;
36     private File cacheDir;
39     public void setup(Api api, ImageManager imageManager, File cacheDir) {
42         this.cacheDir = cacheDir;
110                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -108,7 +108,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         photoViewers.add(medium);
 
         FlickrPhotoList list =  new FlickrPhotoList();
-        list.setup(flickerApi, imageManager, cacheDir);
+        list.setup(flickerApi, imageManager);
         fragments.add(list);
         photoViewers.add(list);
 
","111         list.setup(flickerApi, imageManager);
111         list.setup(flickerApi, imageManager, cacheDir);",No
samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,26ad9c93f342f04f40d25252603c88d89a22a56b,f68b64aae73cffd31b866b559bcabe4b600fbe85,"Use direct loader in list, downloader in grid

The two grids will download each image once and
then resize it twice, the list will download and
resize each image separately to demo two different
ways of implement model stream loaders","@@ -2,39 +2,37 @@ package com.bumptech.flickr;
 
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.loader.model.ModelStreamLoader;
+import com.bumptech.photos.loader.model.BaseModelStreamLoader;
 import com.bumptech.photos.loader.opener.FileInputStreamsOpener;
 
 import java.io.File;
 import java.util.concurrent.Future;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/6/13
- * Time: 11:55 AM
- * To change this template use File | Settings | File Templates.
+ * An implementation of a ModelStreamLoader that uses a separate class to download images to disk and then uses
+ * the path where the image is downloaded to create an input stream opener. Demonstrates one way of integrating this
+ * library with existing apis for download or otherwise retrieving images
+ *
  */
-public class FlickrStreamLoader implements ModelStreamLoader<Photo> {
+public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
     private final Api flickrApi;
     private final File cacheDir;
-    private Future current;
+    private Future current = null;
 
-    public FlickrStreamLoader(Api flickApi, File cacheDir) {
-        this.flickrApi = flickApi;
+    public FlickrStreamLoader(Api flickrApi, File cacheDir) {
+        this.flickrApi = flickrApi;
         this.cacheDir = cacheDir;
     }
 
     @Override
-    public Object fetchModelStreams(Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
+    protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
         clear();
         current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
-                cb.onStreamsReady(path, new FileInputStreamsOpener(path));
+                cb.onStreamsReady(model.id, new FileInputStreamsOpener(path));
             }
         });
-        return current;
     }
 
     @Override
","5 import com.bumptech.photos.loader.model.BaseModelStreamLoader;
12  * An implementation of a ModelStreamLoader that uses a separate class to download images to disk and then uses
13  * the path where the image is downloaded to create an input stream opener. Demonstrates one way of integrating this
14  * library with existing apis for download or otherwise retrieving images
15  *
17 public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
20     private Future current = null;
22     public FlickrStreamLoader(Api flickrApi, File cacheDir) {
23         this.flickrApi = flickrApi;
28     protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
33                 cb.onStreamsReady(model.id, new FileInputStreamsOpener(path));
5 import com.bumptech.photos.loader.model.ModelStreamLoader;
12  * Created with IntelliJ IDEA.
13  * User: sam
14  * Date: 1/6/13
15  * Time: 11:55 AM
16  * To change this template use File | Settings | File Templates.
18 public class FlickrStreamLoader implements ModelStreamLoader<Photo> {
21     private Future current;
23     public FlickrStreamLoader(Api flickApi, File cacheDir) {
24         this.flickrApi = flickApi;
29     public Object fetchModelStreams(Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
34                 cb.onStreamsReady(path, new FileInputStreamsOpener(path));
37         return current;",No
library\AndroidManifest.xml,library\AndroidManifest.xml,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,6 +1,6 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
-          package=""com.bumptech.photos""
+          package=""com.bumptech.glide""
           android:versionCode=""1""
           android:versionName=""1.0"">
   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
","3           package=""com.bumptech.glide""
3           package=""com.bumptech.photos""",No
library\src\com\bumptech\photos\loader\image\BaseImageLoader.java,library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,14 +1,14 @@
-package com.bumptech.photos.loader.image;
+package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 import java.lang.ref.WeakReference;
 
 
 /**
  * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
- * subclasses with a weak reference to the calling {@link com.bumptech.photos.presenter.ImagePresenter}.
+ * subclasses with a weak reference to the calling {@link com.bumptech.glide.presenter.ImagePresenter}.
  */
 public abstract class BaseImageLoader implements ImageLoader {
     @Override
@@ -26,7 +26,7 @@ public abstract class BaseImageLoader implements ImageLoader {
      * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
      * image is ready.
      *
-     * @see ImageLoader#fetchImage(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
+     * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
      *
      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
@@ -39,7 +39,7 @@ public abstract class BaseImageLoader implements ImageLoader {
     /**
      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
      * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
-     * an image is displayed. See {@link com.bumptech.photos.presenter.ImageSetCallback} instead to make a visual change
+     * an image is displayed. See {@link com.bumptech.glide.presenter.ImageSetCallback} instead to make a visual change
      * when a load completes.
      *
      * @param id The unique id of the image
","1 package com.bumptech.glide.loader.image;
4 import com.bumptech.glide.loader.opener.StreamOpener;
11  * subclasses with a weak reference to the calling {@link com.bumptech.glide.presenter.ImagePresenter}.
29      * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
42      * an image is displayed. See {@link com.bumptech.glide.presenter.ImageSetCallback} instead to make a visual change
1 package com.bumptech.photos.loader.image;
4 import com.bumptech.photos.loader.opener.StreamOpener;
11  * subclasses with a weak reference to the calling {@link com.bumptech.photos.presenter.ImagePresenter}.
29      * @see ImageLoader#fetchImage(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.loader.image.ImageLoader.ImageReadyCallback)
42      * an image is displayed. See {@link com.bumptech.photos.presenter.ImageSetCallback} instead to make a visual change",No
library\src\com\bumptech\photos\loader\image\ImageLoader.java,library\src\com\bumptech\glide\loader\image\ImageLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,10 +1,10 @@
-package com.bumptech.photos.loader.image;
+package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 /**
- * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given id and
+ * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a bitmap for a given id and
  * dimensions and/or input streams
  *
  */
","1 package com.bumptech.glide.loader.image;
4 import com.bumptech.glide.loader.opener.StreamOpener;
7  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a bitmap for a given id and
1 package com.bumptech.photos.loader.image;
4 import com.bumptech.photos.loader.opener.StreamOpener;
7  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a bitmap for a given id and",No
library\src\com\bumptech\photos\loader\model\BaseModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\BaseModelStreamLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,17 +1,17 @@
-package com.bumptech.photos.loader.model;
+package com.bumptech.glide.loader.model;
 
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 import java.lang.ref.WeakReference;
 
 /**
  * A base class for {@link ModelStreamLoader} that provides some lifecycle methods and prevents memory leaks if a load
  * stalls or takes a long time by only providing subclasses with a weak reference to the calling
- * {@link com.bumptech.photos.presenter.ImagePresenter}.
+ * {@link com.bumptech.glide.presenter.ImagePresenter}.
  */
 public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
     /**
-     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
      */
     @Override
     public final Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
@@ -20,7 +20,7 @@ public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
     }
 
     /**
-     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
      */
     @Override
     public void clear() { }
","1 package com.bumptech.glide.loader.model;
3 import com.bumptech.glide.loader.opener.StreamOpener;
10  * {@link com.bumptech.glide.presenter.ImagePresenter}.
14      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
23      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
1 package com.bumptech.photos.loader.model;
3 import com.bumptech.photos.loader.opener.StreamOpener;
10  * {@link com.bumptech.photos.presenter.ImagePresenter}.
14      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
23      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.photos.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)",No
library\src\com\bumptech\photos\loader\model\DirectModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\DirectModelStreamLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,6 +1,6 @@
-package com.bumptech.photos.loader.model;
+package com.bumptech.glide.loader.model;
 
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 /**
  * Created with IntelliJ IDEA.
","1 package com.bumptech.glide.loader.model;
3 import com.bumptech.glide.loader.opener.StreamOpener;
1 package com.bumptech.photos.loader.model;
3 import com.bumptech.photos.loader.opener.StreamOpener;",No
library\src\com\bumptech\photos\loader\model\ModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\ModelStreamLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,9 +1,9 @@
-package com.bumptech.photos.loader.model;
+package com.bumptech.glide.loader.model;
 
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 /**
- * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a unique id and a means of
+ * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a unique id and a means of
  * obtaining input streams to an image represented by the given model
  *
  * @param <T> The type of the model that represents an image
","1 package com.bumptech.glide.loader.model;
3 import com.bumptech.glide.loader.opener.StreamOpener;
6  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a unique id and a means of
1 package com.bumptech.photos.loader.model;
3 import com.bumptech.photos.loader.opener.StreamOpener;
6  * An interface used by {@link com.bumptech.photos.presenter.ImagePresenter} to fetch a unique id and a means of",No
library\src\com\bumptech\photos\loader\opener\FileInputStreamsOpener.java,library\src\com\bumptech\glide\loader\opener\FileInputStreamsOpener.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.loader.opener;
+package com.bumptech.glide.loader.opener;
 
 import java.io.File;
 import java.io.FileInputStream;
","1 package com.bumptech.glide.loader.opener;
1 package com.bumptech.photos.loader.opener;",No
library\src\com\bumptech\photos\loader\opener\HttpInputStreamsOpener.java,library\src\com\bumptech\glide\loader\opener\HttpInputStreamsOpener.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.loader.opener;
+package com.bumptech.glide.loader.opener;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
","1 package com.bumptech.glide.loader.opener;
1 package com.bumptech.photos.loader.opener;",No
library\src\com\bumptech\photos\loader\opener\StreamOpener.java,library\src\com\bumptech\glide\loader\opener\StreamOpener.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.loader.opener;
+package com.bumptech.glide.loader.opener;
 
 import java.io.IOException;
 import java.io.InputStream;
","1 package com.bumptech.glide.loader.opener;
1 package com.bumptech.photos.loader.opener;",No
library\src\com\bumptech\photos\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.presenter;
+package com.bumptech.glide.presenter;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
@@ -12,9 +12,9 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import com.bumptech.photos.loader.image.ImageLoader;
-import com.bumptech.photos.loader.model.ModelStreamLoader;
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.image.ImageLoader;
+import com.bumptech.glide.loader.model.ModelStreamLoader;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 import java.lang.ref.WeakReference;
 
@@ -92,10 +92,10 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Required Sets the {@link com.bumptech.photos.loader.image.ImageLoader} the presenter will use to load a
+         * Required Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
          * Bitmap from the given path and/or model
          *
-         * @param imageLoader The {@link com.bumptech.photos.loader.image.ImageLoader} to use to load an image
+         * @param imageLoader The {@link com.bumptech.glide.loader.image.ImageLoader} to use to load an image
          * @return This Builder object
          */
         public Builder<T> setImageLoader(ImageLoader imageLoader) {
@@ -139,7 +139,7 @@ public class ImagePresenter<T> {
 
         /**
          * Optional Sets a callback that will be called after an image is loaded by
-         * {@link com.bumptech.photos.loader.image.ImageLoader} and immediately before
+         * {@link com.bumptech.glide.loader.image.ImageLoader} and immediately before
          * {@link android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)} is called by the presenter
          *
          * @param cb The callback to call
@@ -152,7 +152,7 @@ public class ImagePresenter<T> {
 
         /**
          * Optional Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
-         * valid loads. See {@link com.bumptech.photos.presenter.ThumbImagePresenter}.
+         * valid loads. See {@link com.bumptech.glide.presenter.ThumbImagePresenter}.
          *
          * @param coordinator The coordinator to set
          * @return This Builder object
@@ -164,7 +164,7 @@ public class ImagePresenter<T> {
 
         /**
          * Optional Sets a handler that will be notified if any path or image load causes an exception.
-         * See {@link com.bumptech.photos.presenter.ImagePresenter.ExceptionHandler}.
+         * See {@link com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler}.
          *
          * @param exceptionHandler The exception handler to set
          * @return This builder object
@@ -287,7 +287,7 @@ public class ImagePresenter<T> {
     /**
      * Sets the placeholder as the current image for the {@link android.widget.ImageView}. Does not cancel any previous
      * loads, so the placeholder could be replaced with a loaded bitmap at any time. To cancel a load and display a
-     * placeholder call {@link com.bumptech.photos.presenter.ImagePresenter#clear()}.
+     * placeholder call {@link com.bumptech.glide.presenter.ImagePresenter#clear()}.
      */
     public void resetPlaceHolder() {
         if (!canSetPlaceholder()) return;
@@ -352,7 +352,7 @@ public class ImagePresenter<T> {
     }
 
     /**
-     * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}
+     * For use primarily with {@link com.bumptech.glide.presenter.ImagePresenter.ImagePresenterCoordinator}
      *
      * @return True iff the wrapped {@link android.widget.ImageView} is displaying an image loaded by this
      *          {@link ImagePresenter}. False if the wrapped {@link android.widget.ImageView} is displaying a
","5 package com.bumptech.glide.presenter;
15 import com.bumptech.glide.loader.image.ImageLoader;
16 import com.bumptech.glide.loader.model.ModelStreamLoader;
17 import com.bumptech.glide.loader.opener.StreamOpener;
95          * Required Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
98          * @param imageLoader The {@link com.bumptech.glide.loader.image.ImageLoader} to use to load an image
142          * {@link com.bumptech.glide.loader.image.ImageLoader} and immediately before
155          * valid loads. See {@link com.bumptech.glide.presenter.ThumbImagePresenter}.
167          * See {@link com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler}.
290      * placeholder call {@link com.bumptech.glide.presenter.ImagePresenter#clear()}.
355      * For use primarily with {@link com.bumptech.glide.presenter.ImagePresenter.ImagePresenterCoordinator}
5 package com.bumptech.photos.presenter;
15 import com.bumptech.photos.loader.image.ImageLoader;
16 import com.bumptech.photos.loader.model.ModelStreamLoader;
17 import com.bumptech.photos.loader.opener.StreamOpener;
95          * Required Sets the {@link com.bumptech.photos.loader.image.ImageLoader} the presenter will use to load a
98          * @param imageLoader The {@link com.bumptech.photos.loader.image.ImageLoader} to use to load an image
142          * {@link com.bumptech.photos.loader.image.ImageLoader} and immediately before
155          * valid loads. See {@link com.bumptech.photos.presenter.ThumbImagePresenter}.
167          * See {@link com.bumptech.photos.presenter.ImagePresenter.ExceptionHandler}.
290      * placeholder call {@link com.bumptech.photos.presenter.ImagePresenter#clear()}.
355      * For use primarily with {@link com.bumptech.photos.presenter.ImagePresenter.ImagePresenterCoordinator}",No
library\src\com\bumptech\photos\presenter\ImageSetCallback.java,library\src\com\bumptech\glide\presenter\ImageSetCallback.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.presenter;
+package com.bumptech.glide.presenter;
 
 import android.widget.ImageView;
 
","5 package com.bumptech.glide.presenter;
5 package com.bumptech.photos.presenter;",No
library\src\com\bumptech\photos\presenter\ThumbImagePresenter.java,library\src\com\bumptech\glide\presenter\ThumbImagePresenter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.presenter;
+package com.bumptech.glide.presenter;
 
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
","5 package com.bumptech.glide.presenter;
5 package com.bumptech.photos.presenter;",No
library\src\com\bumptech\photos\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize;
+package com.bumptech.glide.resize;
 
 import android.app.ActivityManager;
 import android.content.Context;
@@ -12,20 +12,20 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
-import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
-import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
-import com.bumptech.photos.resize.cache.DiskCache;
-import com.bumptech.photos.resize.cache.DiskCacheAdapter;
-import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
-import com.bumptech.photos.resize.cache.LruPhotoCache;
-import com.bumptech.photos.resize.cache.MemoryCache;
-import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
-import com.bumptech.photos.util.Log;
-import com.bumptech.photos.util.Util;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
+import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapPool;
+import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
+import com.bumptech.glide.resize.cache.DiskCache;
+import com.bumptech.glide.resize.cache.DiskCacheAdapter;
+import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.resize.cache.LruPhotoCache;
+import com.bumptech.glide.resize.cache.MemoryCache;
+import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
+import com.bumptech.glide.util.Log;
+import com.bumptech.glide.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -220,7 +220,7 @@ public class ImageManager {
 
         /**
          * Set the memory cache implementation. See also
-         * {@link com.bumptech.photos.resize.ImageManager.Builder#disableMemoryCache()}
+         * {@link com.bumptech.glide.resize.ImageManager.Builder#disableMemoryCache()}
          *
          * @param memoryCache The memory cache implementation to use
          * @return This Builder
@@ -241,7 +241,7 @@ public class ImageManager {
 
         /**
          * Set the disk cache implementation. See also
-         *  {@link com.bumptech.photos.resize.ImageManager.Builder#disableDiskCache()}
+         *  {@link com.bumptech.glide.resize.ImageManager.Builder#disableDiskCache()}
          *
          * @param diskCache The disk cache implementation to use
          * @return This Builder
","5 package com.bumptech.glide.resize;
15 import com.bumptech.glide.loader.opener.StreamOpener;
16 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
17 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
18 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
19 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapPool;
20 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
21 import com.bumptech.glide.resize.cache.DiskCache;
22 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
23 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
24 import com.bumptech.glide.resize.cache.LruPhotoCache;
25 import com.bumptech.glide.resize.cache.MemoryCache;
26 import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
27 import com.bumptech.glide.util.Log;
28 import com.bumptech.glide.util.Util;
223          * {@link com.bumptech.glide.resize.ImageManager.Builder#disableMemoryCache()}
244          *  {@link com.bumptech.glide.resize.ImageManager.Builder#disableDiskCache()}
5 package com.bumptech.photos.resize;
15 import com.bumptech.photos.loader.opener.StreamOpener;
16 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
17 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounter;
18 import com.bumptech.photos.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
19 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;
20 import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
21 import com.bumptech.photos.resize.cache.DiskCache;
22 import com.bumptech.photos.resize.cache.DiskCacheAdapter;
23 import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
24 import com.bumptech.photos.resize.cache.LruPhotoCache;
25 import com.bumptech.photos.resize.cache.MemoryCache;
26 import com.bumptech.photos.resize.cache.MemoryCacheAdapter;
27 import com.bumptech.photos.util.Log;
28 import com.bumptech.photos.util.Util;
223          * {@link com.bumptech.photos.resize.ImageManager.Builder#disableMemoryCache()}
244          *  {@link com.bumptech.photos.resize.ImageManager.Builder#disableDiskCache()}",No
library\src\com\bumptech\photos\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
  */
-package com.bumptech.photos.resize;
+package com.bumptech.glide.resize;
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -10,9 +10,9 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
-import com.bumptech.photos.resize.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.photos.util.Log;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.util.Log;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
","4 package com.bumptech.glide.resize;
13 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
14 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
15 import com.bumptech.glide.util.Log;
4 package com.bumptech.photos.resize;
13 import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;
14 import com.bumptech.photos.resize.bitmap_recycle.BitmapPoolAdapter;
15 import com.bumptech.photos.util.Log;",No
library\src\com\bumptech\photos\resize\LoadedCallback.java,library\src\com\bumptech\glide\resize\LoadedCallback.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize;
+package com.bumptech.glide.resize;
 
 import android.graphics.Bitmap;
 
","5 package com.bumptech.glide.resize;
5 package com.bumptech.photos.resize;",No
library\src\com\bumptech\photos\resize\RecyclableBufferedInputStream.java,library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize;
+package com.bumptech.glide.resize;
 
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
","1 package com.bumptech.glide.resize;
1 package com.bumptech.photos.resize;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPool.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.bitmap_recycle;
1 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapPoolAdapter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPoolAdapter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.bitmap_recycle;
1 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.bitmap_recycle;
1 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\BitmapReferenceCounterAdapter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounterAdapter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.bitmap_recycle;
1 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapPool.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","5 package com.bumptech.glide.resize.bitmap_recycle;
5 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.bitmap_recycle;
+package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.bitmap_recycle;
1 package com.bumptech.photos.resize.bitmap_recycle;",No
library\src\com\bumptech\photos\resize\cache\DiskCache.java,library\src\com\bumptech\glide\resize\cache\DiskCache.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.cache;
1 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\cache\DiskCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\DiskCacheAdapter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.cache;
1 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\cache\DiskLruCacheWrapper.java,library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2013. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 import com.jakewharton.disklrucache.DiskLruCache;
","5 package com.bumptech.glide.resize.cache;
5 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\cache\LruPhotoCache.java,library\src\com\bumptech\glide\resize\cache\LruPhotoCache.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,7 +2,7 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 import android.support.v4.util.LruCache;
","5 package com.bumptech.glide.resize.cache;
5 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\cache\MemoryCache.java,library\src\com\bumptech\glide\resize\cache\MemoryCache.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.cache;
1 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\cache\MemoryCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\MemoryCacheAdapter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.resize.cache;
+package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 
","1 package com.bumptech.glide.resize.cache;
1 package com.bumptech.photos.resize.cache;",No
library\src\com\bumptech\photos\resize\loader\Approximate.java,library\src\com\bumptech\glide\resize\loader\Approximate.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,19 +2,19 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
  * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
  *
- * @see ImageManager#getImageApproximate(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class Approximate extends ImageManagerLoader {
 
","5 package com.bumptech.glide.resize.loader;
8 import com.bumptech.glide.loader.opener.StreamOpener;
9 import com.bumptech.glide.resize.ImageManager;
10 import com.bumptech.glide.resize.LoadedCallback;
17  * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.loader.opener.StreamOpener;
9 import com.bumptech.photos.resize.ImageManager;
10 import com.bumptech.photos.resize.LoadedCallback;
17  * @see ImageManager#getImageApproximate(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)",No
library\src\com\bumptech\photos\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,9 +1,9 @@
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
@@ -11,7 +11,7 @@ import com.bumptech.photos.resize.LoadedCallback;
  * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
  * other implementations
  *
- * @see ImageManager#getImage(String, com.bumptech.photos.loader.opener.StreamOpener, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImage(String, com.bumptech.glide.loader.opener.StreamOpener, com.bumptech.glide.resize.LoadedCallback)
  */
 public class AsIs extends ImageManagerLoader {
 
","1 package com.bumptech.glide.resize.loader;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 import com.bumptech.glide.resize.ImageManager;
6 import com.bumptech.glide.resize.LoadedCallback;
14  * @see ImageManager#getImage(String, com.bumptech.glide.loader.opener.StreamOpener, com.bumptech.glide.resize.LoadedCallback)
1 package com.bumptech.photos.resize.loader;
4 import com.bumptech.photos.loader.opener.StreamOpener;
5 import com.bumptech.photos.resize.ImageManager;
6 import com.bumptech.photos.resize.LoadedCallback;
14  * @see ImageManager#getImage(String, com.bumptech.photos.loader.opener.StreamOpener, com.bumptech.photos.resize.LoadedCallback)",No
library\src\com\bumptech\photos\resize\loader\CenterCrop.java,library\src\com\bumptech\glide\resize\loader\CenterCrop.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,17 +2,17 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads and crops in image down to the given width and height.
  *
- * @see ImageManager#centerCrop(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class CenterCrop extends ImageManagerLoader {
 
","5 package com.bumptech.glide.resize.loader;
8 import com.bumptech.glide.loader.opener.StreamOpener;
9 import com.bumptech.glide.resize.ImageManager;
10 import com.bumptech.glide.resize.LoadedCallback;
15  * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.loader.opener.StreamOpener;
9 import com.bumptech.photos.resize.ImageManager;
10 import com.bumptech.photos.resize.LoadedCallback;
15  * @see ImageManager#centerCrop(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)",No
library\src\com\bumptech\photos\resize\loader\Exact.java,library\src\com\bumptech\glide\resize\loader\Exact.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,12 +2,12 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
@@ -15,7 +15,7 @@ import com.bumptech.photos.resize.LoadedCallback;
  * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
  * resize).
  *
- * @see ImageManager#getImageExact(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class Exact extends ImageManagerLoader {
 
","5 package com.bumptech.glide.resize.loader;
8 import com.bumptech.glide.loader.opener.StreamOpener;
9 import com.bumptech.glide.resize.ImageManager;
10 import com.bumptech.glide.resize.LoadedCallback;
18  * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.loader.opener.StreamOpener;
9 import com.bumptech.photos.resize.ImageManager;
10 import com.bumptech.photos.resize.LoadedCallback;
18  * @see ImageManager#getImageExact(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)",No
library\src\com\bumptech\photos\resize\loader\FitCenter.java,library\src\com\bumptech\glide\resize\loader\FitCenter.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,18 +2,18 @@
  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
  */
 
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.LoadedCallback;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
  * proportions
  *
- * @see ImageManager#fitCenter(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)
+ * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class FitCenter extends ImageManagerLoader {
 
","5 package com.bumptech.glide.resize.loader;
8 import com.bumptech.glide.loader.opener.StreamOpener;
9 import com.bumptech.glide.resize.ImageManager;
10 import com.bumptech.glide.resize.LoadedCallback;
16  * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
5 package com.bumptech.photos.resize.loader;
8 import com.bumptech.photos.loader.opener.StreamOpener;
9 import com.bumptech.photos.resize.ImageManager;
10 import com.bumptech.photos.resize.LoadedCallback;
16  * @see ImageManager#fitCenter(String, com.bumptech.photos.loader.opener.StreamOpener, int, int, com.bumptech.photos.resize.LoadedCallback)",No
library\src\com\bumptech\photos\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,9 +1,9 @@
-package com.bumptech.photos.resize.loader;
+package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.photos.loader.opener.StreamOpener;
-import com.bumptech.photos.loader.image.BaseImageLoader;
-import com.bumptech.photos.resize.ImageManager;
+import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.image.BaseImageLoader;
+import com.bumptech.glide.resize.ImageManager;
 
 /**
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
","1 package com.bumptech.glide.resize.loader;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 import com.bumptech.glide.loader.image.BaseImageLoader;
6 import com.bumptech.glide.resize.ImageManager;
1 package com.bumptech.photos.resize.loader;
4 import com.bumptech.photos.loader.opener.StreamOpener;
5 import com.bumptech.photos.loader.image.BaseImageLoader;
6 import com.bumptech.photos.resize.ImageManager;",No
library\src\com\bumptech\photos\util\Log.java,library\src\com\bumptech\glide\util\Log.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.util;
+package com.bumptech.glide.util;
 
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
","1 package com.bumptech.glide.util;
1 package com.bumptech.photos.util;",No
library\src\com\bumptech\photos\util\Util.java,library\src\com\bumptech\glide\util\Util.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,4 +1,4 @@
-package com.bumptech.photos.util;
+package com.bumptech.glide.util;
 
 import java.math.BigInteger;
 import java.security.MessageDigest;
","1 package com.bumptech.glide.util;
1 package com.bumptech.photos.util;",No
samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,9 +2,9 @@ package com.bumptech.flickr;
 
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.loader.model.DirectModelStreamLoader;
-import com.bumptech.photos.loader.opener.HttpInputStreamsOpener;
-import com.bumptech.photos.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.model.DirectModelStreamLoader;
+import com.bumptech.glide.loader.opener.HttpInputStreamsOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
 
 /**
  * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
","5 import com.bumptech.glide.loader.model.DirectModelStreamLoader;
6 import com.bumptech.glide.loader.opener.HttpInputStreamsOpener;
7 import com.bumptech.glide.loader.opener.StreamOpener;
5 import com.bumptech.photos.loader.model.DirectModelStreamLoader;
6 import com.bumptech.photos.loader.opener.HttpInputStreamsOpener;
7 import com.bumptech.photos.loader.opener.StreamOpener;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -12,10 +12,10 @@ import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.presenter.ImagePresenter;
-import com.bumptech.photos.presenter.ImageSetCallback;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.loader.CenterCrop;
+import com.bumptech.glide.presenter.ImagePresenter;
+import com.bumptech.glide.presenter.ImageSetCallback;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.io.File;
 import java.util.ArrayList;
","15 import com.bumptech.glide.presenter.ImagePresenter;
16 import com.bumptech.glide.presenter.ImageSetCallback;
17 import com.bumptech.glide.resize.ImageManager;
18 import com.bumptech.glide.resize.loader.CenterCrop;
15 import com.bumptech.photos.presenter.ImagePresenter;
16 import com.bumptech.photos.presenter.ImageSetCallback;
17 import com.bumptech.photos.resize.ImageManager;
18 import com.bumptech.photos.resize.loader.CenterCrop;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -13,10 +13,10 @@ import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.presenter.ImagePresenter;
-import com.bumptech.photos.presenter.ImageSetCallback;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.loader.CenterCrop;
+import com.bumptech.glide.presenter.ImagePresenter;
+import com.bumptech.glide.presenter.ImageSetCallback;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.util.ArrayList;
 import java.util.List;
","16 import com.bumptech.glide.presenter.ImagePresenter;
17 import com.bumptech.glide.presenter.ImageSetCallback;
18 import com.bumptech.glide.resize.ImageManager;
19 import com.bumptech.glide.resize.loader.CenterCrop;
16 import com.bumptech.photos.presenter.ImagePresenter;
17 import com.bumptech.photos.presenter.ImageSetCallback;
18 import com.bumptech.photos.resize.ImageManager;
19 import com.bumptech.photos.resize.loader.CenterCrop;",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -17,9 +17,9 @@ import com.actionbarsherlock.app.ActionBar;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.resize.ImageManager;
-import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
-import com.bumptech.photos.util.Log;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.util.Log;
 
 import java.io.File;
 import java.util.ArrayList;
","20 import com.bumptech.glide.resize.ImageManager;
21 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
22 import com.bumptech.glide.util.Log;
20 import com.bumptech.photos.resize.ImageManager;
21 import com.bumptech.photos.resize.cache.DiskLruCacheWrapper;
22 import com.bumptech.photos.util.Log;",No
samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -2,8 +2,8 @@ package com.bumptech.flickr;
 
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.photos.loader.model.BaseModelStreamLoader;
-import com.bumptech.photos.loader.opener.FileInputStreamsOpener;
+import com.bumptech.glide.loader.model.BaseModelStreamLoader;
+import com.bumptech.glide.loader.opener.FileInputStreamsOpener;
 
 import java.io.File;
 import java.util.concurrent.Future;
","5 import com.bumptech.glide.loader.model.BaseModelStreamLoader;
6 import com.bumptech.glide.loader.opener.FileInputStreamsOpener;
5 import com.bumptech.photos.loader.model.BaseModelStreamLoader;
6 import com.bumptech.photos.loader.opener.FileInputStreamsOpener;",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,26ad9c93f342f04f40d25252603c88d89a22a56b,com.bumptech.photos -> com.bumptech.glide,"@@ -1,6 +1,6 @@
 package com.bumptech.flickr.api;
 
-import com.bumptech.photos.util.Log;
+import com.bumptech.glide.util.Log;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
","3 import com.bumptech.glide.util.Log;
3 import com.bumptech.photos.util.Log;",No
README.md,README.md,06e2f9826fe25904f0c9a30792e1df56b136739e,b71bf819c59c4b8ea5e6a8b0929f5057ba6a01e1,Update and fix some typos in read me,"@@ -1,18 +1,16 @@
 Glide
 =====
-Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
+Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface.
 
 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
 
-Who Shouldn't Use Glide?
+Who shouldn't use Glide?
 ------------------------
 If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
 
-Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
-
 Also you probably shouldn't bother if you're not writing an Android app...
 
-Who Should Use Glide?
+Who should use Glide?
 ---------------------
 Anyone who displays large numbers of images can benefit from Glide.
 
@@ -22,7 +20,7 @@ Glide is also unobtrusive. It doesn't require you to change any xml or create an
 
 Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
 
-How Do I Use Glide?
+How do I use Glide?
 -------------------
 The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
 
@@ -66,14 +64,17 @@ Behind the scenes the ImageManager will load resize the image from disk using a
 
 Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
 
-For more examples see the sample flickr app.
 
 How do I add Glide to my project?
 --------------------------------
-Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
+Glide is an Android library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
 
 Intellij and Eclipse instructions coming soon.
 
+Great, but how do I actually use Glide in my code?
+-----------------------------------------------------
+For more concrete examples see the wiki for tutorials and/or the sample flickr app.
+
 Status
 ------
 Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
","3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface.
7 Who shouldn't use Glide?
13 Who should use Glide?
23 How do I use Glide?
70 Glide is an Android library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
74 Great, but how do I actually use Glide in my code?
75 -----------------------------------------------------
76 For more concrete examples see the wiki for tutorials and/or the sample flickr app.
77 
3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interace.
7 Who Shouldn't Use Glide?
11 Glide is also focused primarily on loading images from the sdcard efficiently and does not currently include code to download images from a URL (though that code does exist in the sample project).
12 
15 Who Should Use Glide?
25 How Do I Use Glide?
69 For more examples see the sample flickr app.
73 Glide is an Androlid library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,6ed6e22c7d4cbcf5b8269004ae37d72f0e0a5446,06e2f9826fe25904f0c9a30792e1df56b136739e,"Use a single InputStream to load images

requires using mark and reset instead which hasn't
been 100% reliable in the past and is difficult to
recover from when it fails. However, increasing
the mark length may make it reliable enough and
it allows us to avoid doing things like making
2 http calls to download each image.","@@ -336,7 +336,7 @@ public class ImageManager {
         return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException {
-                return resizer.loadAsIs(is1, is2);
+                return resizer.loadAsIs(is1);
             }
         });
     }
@@ -376,7 +376,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
-                return resizer.loadAtLeast(is1, is2, width, height);
+                return resizer.loadAtLeast(is1, width, height);
             }
         });
     }
@@ -397,7 +397,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
-                return resizer.centerCrop(is1, is2, width, height);
+                return resizer.centerCrop(is1, width, height);
             }
         });
     }
@@ -418,7 +418,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
-                return resizer.fitInSpace(is1, is2, width, height);
+                return resizer.fitInSpace(is1, width, height);
             }
         });
     }
@@ -541,7 +541,7 @@ public class ImageManager {
                 result = diskCache.get(stringKey, new DiskCache.Reader() {
                     @Override
                     public Bitmap read(InputStream is1, InputStream is2) {
-                        Bitmap result = resizer.loadAsIs(is1, is2);
+                        Bitmap result = resizer.loadAsIs(is1);
                         if (result == null) {
                             diskCache.delete(stringKey);
                         }
","339                 return resizer.loadAsIs(is1);
379                 return resizer.loadAtLeast(is1, width, height);
400                 return resizer.centerCrop(is1, width, height);
421                 return resizer.fitInSpace(is1, width, height);
544                         Bitmap result = resizer.loadAsIs(is1);
339                 return resizer.loadAsIs(is1, is2);
379                 return resizer.loadAtLeast(is1, is2, width, height);
400                 return resizer.centerCrop(is1, is2, width, height);
421                 return resizer.fitInSpace(is1, is2, width, height);
544                         Bitmap result = resizer.loadAsIs(is1, is2);",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,6ed6e22c7d4cbcf5b8269004ae37d72f0e0a5446,06e2f9826fe25904f0c9a30792e1df56b136739e,"Use a single InputStream to load images

requires using mark and reset instead which hasn't
been 100% reliable in the past and is difficult to
recover from when it fails. However, increasing
the mark length may make it reliable enough and
it allows us to avoid doing things like making
2 http calls to download each image.","@@ -25,6 +25,8 @@ import java.util.Queue;
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
+    private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
+    private static final int MARK_POSITION = 5 * 1024 * 1024; //5mb
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final BitmapPool bitmapPool;
@@ -91,8 +93,8 @@ public class ImageResizer {
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
-    public Bitmap centerCrop(InputStream is1, InputStream is2, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is1, is2, width, height);
+    public Bitmap centerCrop(InputStream is1, int width, int height) {
+        final Bitmap streamed = loadAtLeast(is1, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
@@ -111,8 +113,8 @@ public class ImageResizer {
         return fitInSpace(streamed, width, height);
     }
 
-    public Bitmap fitInSpace(InputStream is1, InputStream is2, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
+    public Bitmap fitInSpace(InputStream is1, int width, int height) {
+        final Bitmap streamed = loadAtLeast(is1, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
@@ -139,7 +141,7 @@ public class ImageResizer {
             height = w;
         }
 
-        Bitmap result = loadAtLeast(new FileInputStream(path), new FileInputStream(path), width, height);
+        Bitmap result = loadAtLeast(new FileInputStream(path), width, height);
 
         if (orientation != 0) {
             result = rotateImage(result, orientation);
@@ -154,14 +156,15 @@ public class ImageResizer {
      * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
      * be enlarged and will instead be loaded at its original dimens.
      *
-     * @param is1 An inputStream for the image. Can't be is2
-     * @param is2 An inputStream for the image. Can't be is1
+     * @param is1 An inputStream for the image
      * @param width The minimum width of the returned Bitmap
      * @param height The minimum height of the returned Bitmap
      * @return A Bitmap containing the image
      */
-    public Bitmap loadAtLeast(InputStream is1, InputStream is2, int width, int height) {
-        final int[] dimens = getDimensions(is1);
+    public Bitmap loadAtLeast(InputStream is1, int width, int height) {
+        byte[] bytes = getTempBytes();
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is1, bytes);
+        final int[] dimens = getDimensions(bis);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
@@ -171,7 +174,9 @@ public class ImageResizer {
         final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
-        return decodeStream(is2, decodeBitmapOptions);
+        Bitmap result = decodeStream(bis, decodeBitmapOptions);
+        releaseTempBytes(bytes);
+        return result;
     }
 
     /**
@@ -211,8 +216,10 @@ public class ImageResizer {
      * @param height The maximum height
      * @return A bitmap containing the image
      */
-    public Bitmap loadAtMost(InputStream is1, InputStream is2, int width, int height) {
-        final int[] dimens = getDimensions(is1);
+    public Bitmap loadAtMost(InputStream is, int width, int height) {
+        byte[] bytes = getTempBytes();
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
+        final int[] dimens = getDimensions(bis);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
 
@@ -220,7 +227,9 @@ public class ImageResizer {
         final BitmapFactory.Options decodeBitmapOptions = getOptions();
         decodeBitmapOptions.inSampleSize = sampleSize;
 
-        return decodeStream(is2, decodeBitmapOptions);
+        Bitmap result = decodeStream(bis, decodeBitmapOptions);
+        releaseTempBytes(bytes);
+        return result;
     }
 
     /**
@@ -229,26 +238,23 @@ public class ImageResizer {
      * size. Use the second InputStream to actually load the image into a Bitmap. Note both InputStreams must represent
      * the same image and this method will close both InputStreams.
      *
-     * @param is1 The InputStream used to get the dimensions of the image
-     * @param is2 The InputStream used to load the image into memory
+     * @param is The InputStream used to get the dimensions of the image
      * @return The loaded image
      */
-    public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
-        int[] dimens = new int[] {-1, -1};
-        try {
-            dimens = getDimensions(is1);
-        } finally {
-            try {
-                is1.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-        return load(is2, getRecycled(dimens));
+    public Bitmap loadAsIs(final InputStream is) {
+        byte[] bytes = getTempBytes();
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
+        int[] dimens = getDimensions(bis);
+        Bitmap result = load(bis, getRecycled(dimens));
+        releaseTempBytes(bytes);
+        return result;
     }
 
     public Bitmap loadAsIs(InputStream is, int width, int height) {
-        return load(is, getRecycled(width, height));
+        byte[] bytes = getTempBytes();
+        Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
+        releaseTempBytes(bytes);
+        return result;
     }
 
     /**
@@ -311,7 +317,7 @@ public class ImageResizer {
      * @param recycle A Bitmap we can load the image into, or null
      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
      */
-    private Bitmap load(InputStream is, Bitmap recycle){
+    private Bitmap load(RecyclableBufferedInputStream is, Bitmap recycle){
         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
         return decodeStream(is, decodeBitmapOptions);
     }
@@ -335,7 +341,7 @@ public class ImageResizer {
      * @param is The InputStream representing the image
      * @return an array containing the dimensions of the image in the form {width, height}
      */
-    private int[] getDimensions(InputStream is) {
+    private int[] getDimensions(RecyclableBufferedInputStream is) {
         final BitmapFactory.Options decodeBoundsOptions = getOptions();
         decodeBoundsOptions.inJustDecodeBounds = true;
         decodeStream(is, decodeBoundsOptions);
@@ -343,11 +349,13 @@ public class ImageResizer {
     }
 
     private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) throws FileNotFoundException {
-        InputStream is = null;
+        RecyclableBufferedInputStream is = null;
         Bitmap result = null;
         try {
-            is = new FileInputStream(path);
+            byte[] bytes = getTempBytes();
+            is = new RecyclableBufferedInputStream(new FileInputStream(path), bytes);
             result = decodeStream(is, decodeBitmapOptions);
+            releaseTempBytes(bytes);
         } finally {
             if (is != null) {
                 try {
@@ -360,21 +368,31 @@ public class ImageResizer {
         return result;
     }
 
-    private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
-        final byte[][] tempBytes = getTempBytes();
-        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);
-        decodeBitmapOptions.inTempStorage = tempBytes[1];
-        Bitmap result = null;
-        try {
-            result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
-        } finally {
+    private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {
+        decodeBitmapOptions.inTempStorage = getTempBytes();
+
+        if (decodeBitmapOptions.inJustDecodeBounds) {
+            bis.mark(MARK_POSITION); //this is absurdly large, but jpeg headers are not size bounded so we need
+                                     //something large enough to minimize the possibility of not being able to fit
+                                     //enough of the header in the buffer to get the image size so that we don't fail
+                                     //to load images. The BufferedInputStream will create a new buffer of 2x the
+                                     //original size each time we use up the buffer space without passing the mark so
+                                     //this is a maximum bound on the buffer size, not a default. Most of the time we
+                                     //won't go past our pre-allocated 32kb
+        }
+        final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
         try {
+            if (decodeBitmapOptions.inJustDecodeBounds) {
+                bis.reset();
+            } else {
                 bis.close();
+            }
         } catch (IOException e) {
             e.printStackTrace();
         }
-            releaseTempBytes(tempBytes);
-        }
+
+        releaseTempBytes(decodeBitmapOptions.inTempStorage);
+
         return result;
     }
 
@@ -398,26 +416,21 @@ public class ImageResizer {
         return bitmapPool.get(width, height);
     }
 
-    private byte[][] getTempBytes() {
-        byte[][] result = new byte[2][];
+    private byte[] getTempBytes() {
+        byte[] result;
         synchronized (tempQueue) {
-            for (int i = 0; i < result.length; i++) {
-                if (tempQueue.size() > 0) {
-                    result[i] = tempQueue.remove();
-                } else {
-                    Log.d(""IR: created temp bytes"");
-                    result[i] = new byte[16 * 1024];
-                }
+            result = tempQueue.poll();
         }
+        if (result == null) {
+            result = new byte[TEMP_BYTES_SIZE];
+            Log.d(""IR: created temp bytes"");
         }
         return result;
     }
 
-    private void releaseTempBytes(byte[][] byteArrays) {
+    private void releaseTempBytes(byte[] bytes) {
         synchronized (tempQueue) {
-            for (byte[] bytes : byteArrays) {
-                tempQueue.add(bytes);
-            }
+            tempQueue.offer(bytes);
         }
     }
 
@@ -490,7 +503,7 @@ public class ImageResizer {
         } else {
             result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                             Bitmap.Config.ARGB_8888 : toCrop.getConfig());
-        };
+        }
         Canvas canvas = new Canvas(result);
         Paint paint = new Paint();
         //only if scaling up
","28     private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
29     private static final int MARK_POSITION = 5 * 1024 * 1024; //5mb
96     public Bitmap centerCrop(InputStream is1, int width, int height) {
97         final Bitmap streamed = loadAtLeast(is1, width, height);
116     public Bitmap fitInSpace(InputStream is1, int width, int height) {
117         final Bitmap streamed = loadAtLeast(is1, width > height ? 1 : width, height > width ? 1 : height);
144         Bitmap result = loadAtLeast(new FileInputStream(path), width, height);
159      * @param is1 An inputStream for the image
164     public Bitmap loadAtLeast(InputStream is1, int width, int height) {
165         byte[] bytes = getTempBytes();
166         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is1, bytes);
167         final int[] dimens = getDimensions(bis);
177         Bitmap result = decodeStream(bis, decodeBitmapOptions);
178         releaseTempBytes(bytes);
179         return result;
219     public Bitmap loadAtMost(InputStream is, int width, int height) {
220         byte[] bytes = getTempBytes();
221         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
222         final int[] dimens = getDimensions(bis);
230         Bitmap result = decodeStream(bis, decodeBitmapOptions);
231         releaseTempBytes(bytes);
232         return result;
241      * @param is The InputStream used to get the dimensions of the image
244     public Bitmap loadAsIs(final InputStream is) {
245         byte[] bytes = getTempBytes();
246         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
247         int[] dimens = getDimensions(bis);
248         Bitmap result = load(bis, getRecycled(dimens));
249         releaseTempBytes(bytes);
250         return result;
254         byte[] bytes = getTempBytes();
255         Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
256         releaseTempBytes(bytes);
257         return result;
320     private Bitmap load(RecyclableBufferedInputStream is, Bitmap recycle){
344     private int[] getDimensions(RecyclableBufferedInputStream is) {
352         RecyclableBufferedInputStream is = null;
355             byte[] bytes = getTempBytes();
356             is = new RecyclableBufferedInputStream(new FileInputStream(path), bytes);
358             releaseTempBytes(bytes);
371     private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {
372         decodeBitmapOptions.inTempStorage = getTempBytes();
373 
374         if (decodeBitmapOptions.inJustDecodeBounds) {
375             bis.mark(MARK_POSITION); //this is absurdly large, but jpeg headers are not size bounded so we need
376                                      //something large enough to minimize the possibility of not being able to fit
377                                      //enough of the header in the buffer to get the image size so that we don't fail
378                                      //to load images. The BufferedInputStream will create a new buffer of 2x the
379                                      //original size each time we use up the buffer space without passing the mark so
380                                      //this is a maximum bound on the buffer size, not a default. Most of the time we
381                                      //won't go past our pre-allocated 32kb
382         }
383         final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
385             if (decodeBitmapOptions.inJustDecodeBounds) {
386                 bis.reset();
387             } else {
389             }
393 
394         releaseTempBytes(decodeBitmapOptions.inTempStorage);
395 
419     private byte[] getTempBytes() {
420         byte[] result;
422             result = tempQueue.poll();
423         }
424         if (result == null) {
425             result = new byte[TEMP_BYTES_SIZE];
431     private void releaseTempBytes(byte[] bytes) {
433             tempQueue.offer(bytes);
506         }
94     public Bitmap centerCrop(InputStream is1, InputStream is2, int width, int height) {
95         final Bitmap streamed = loadAtLeast(is1, is2, width, height);
114     public Bitmap fitInSpace(InputStream is1, InputStream is2, int width, int height) {
115         final Bitmap streamed = loadAtLeast(is1, is2, width > height ? 1 : width, height > width ? 1 : height);
142         Bitmap result = loadAtLeast(new FileInputStream(path), new FileInputStream(path), width, height);
157      * @param is1 An inputStream for the image. Can't be is2
158      * @param is2 An inputStream for the image. Can't be is1
163     public Bitmap loadAtLeast(InputStream is1, InputStream is2, int width, int height) {
164         final int[] dimens = getDimensions(is1);
174         return decodeStream(is2, decodeBitmapOptions);
214     public Bitmap loadAtMost(InputStream is1, InputStream is2, int width, int height) {
215         final int[] dimens = getDimensions(is1);
223         return decodeStream(is2, decodeBitmapOptions);
232      * @param is1 The InputStream used to get the dimensions of the image
233      * @param is2 The InputStream used to load the image into memory
236     public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {
237         int[] dimens = new int[] {-1, -1};
238         try {
239             dimens = getDimensions(is1);
240         } finally {
241             try {
242                 is1.close();
243             } catch (IOException e) {
244                 e.printStackTrace();
245             }
246         }
247         return load(is2, getRecycled(dimens));
251         return load(is, getRecycled(width, height));
314     private Bitmap load(InputStream is, Bitmap recycle){
338     private int[] getDimensions(InputStream is) {
346         InputStream is = null;
349             is = new FileInputStream(path);
363     private Bitmap decodeStream(InputStream is, BitmapFactory.Options decodeBitmapOptions) {
364         final byte[][] tempBytes = getTempBytes();
365         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);
366         decodeBitmapOptions.inTempStorage = tempBytes[1];
367         Bitmap result = null;
368         try {
369             result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
370         } finally {
376             releaseTempBytes(tempBytes);
377         }
401     private byte[][] getTempBytes() {
402         byte[][] result = new byte[2][];
404             for (int i = 0; i < result.length; i++) {
405                 if (tempQueue.size() > 0) {
406                     result[i] = tempQueue.remove();
407                 } else {
409                     result[i] = new byte[16 * 1024];
410                 }
411             }
416     private void releaseTempBytes(byte[][] byteArrays) {
418             for (byte[] bytes : byteArrays) {
419                 tempQueue.add(bytes);
420             }
493         };",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,9d75fc15b0d774a5736edf1e0c4fda1826fa83bb,6ed6e22c7d4cbcf5b8269004ae37d72f0e0a5446,More graceful error handling,"@@ -523,9 +523,7 @@ public class ImageManager {
             if (cancelled) return;
             cancelled = true;
 
-            if (bgHandler != null) {
             bgHandler.removeCallbacks(this);
-            }
             if (future != null) {
                 future.cancel(false);
             }
@@ -600,6 +598,13 @@ public class ImageManager {
                         cb.onLoadCompleted(result);
                     }
                 });
+            } else {
+                mainHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        cb.onLoadFailed(null);
+                    }
+                });
             }
         }
 
","601             } else {
602                 mainHandler.post(new Runnable() {
603                     @Override
604                     public void run() {
605                         cb.onLoadFailed(null);
606                     }
607                 });
526             if (bgHandler != null) {
528             }",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,9d75fc15b0d774a5736edf1e0c4fda1826fa83bb,6ed6e22c7d4cbcf5b8269004ae37d72f0e0a5446,More graceful error handling,"@@ -389,9 +389,9 @@ public class ImageResizer {
             }
         } catch (IOException e) {
             e.printStackTrace();
-        }
-
+        } finally {
             releaseTempBytes(decodeBitmapOptions.inTempStorage);
+        }
 
         return result;
     }
","392         } finally {
394         }
392         }
393 ",No
library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,678c91747b4f8f201767a20f3e0c8beff235d2e3,9d75fc15b0d774a5736edf1e0c4fda1826fa83bb,"Throw a particular exception if mark is invalid

Will make logging easier","@@ -38,6 +38,13 @@ import java.io.InputStream;
  *
  */
 public class RecyclableBufferedInputStream extends FilterInputStream {
+
+    public static class InvalidMarkException extends RuntimeException {
+        public InvalidMarkException(String detailMessage) {
+            super(detailMessage);
+        }
+    }
+
     /**
      * The buffer containing the current bytes read from the target InputStream.
      */
@@ -353,7 +360,7 @@ public class RecyclableBufferedInputStream extends FilterInputStream {
             throw new IOException(""Stream is closed"");
         }
         if (-1 == markpos) {
-            throw new IOException(""Mark has been invalidated."");
+            throw new InvalidMarkException(""Mark has been invalidated"");
         }
         pos = markpos;
     }
","41 
42     public static class InvalidMarkException extends RuntimeException {
43         public InvalidMarkException(String detailMessage) {
44             super(detailMessage);
45         }
46     }
47 
363             throw new InvalidMarkException(""Mark has been invalidated"");
356             throw new IOException(""Mark has been invalidated."");",No
library\src\com\bumptech\glide\loader\model\BaseModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\BaseModelStreamLoader.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -11,16 +11,16 @@ import java.lang.ref.WeakReference;
  */
 public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
     /**
-     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
      */
     @Override
-    public final Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
-        doFetchModelStreams(model, width, height, new InternalModelStreamsReadyCallback(cb, model));
+    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {
+        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));
         return cb;
     }
 
     /**
-     * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
+     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
      */
     @Override
     public void clear() { }
@@ -35,7 +35,7 @@ public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
      * @param height The height of the view the image will be displayed in
      * @param cb The callback to call when the id and stream opener are ready, or when the load fails
      */
-    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
+    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);
 
     /**
      * A lifecycle method called after the requesting object is notifie that this loader failed to load the id and/or
@@ -49,29 +49,29 @@ public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
         return false;
     }
 
-    protected class InternalModelStreamsReadyCallback implements ModelStreamsReadyCallback {
+    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {
 
-        private final WeakReference<ModelStreamsReadyCallback> cbRef;
+        private final WeakReference<ModelStreamReadyCallback> cbRef;
         private final WeakReference<T> modelRef;
 
-        public InternalModelStreamsReadyCallback(ModelStreamsReadyCallback cb, T model) {
-            this.cbRef = new WeakReference<ModelStreamsReadyCallback>(cb);
+        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {
+            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);
             this.modelRef = new WeakReference<T>(model);
         }
 
         @Override
-        public boolean onStreamsReady(String id, StreamOpener streamOpener) {
-            ModelStreamsReadyCallback cb = cbRef.get();
+        public boolean onStreamReady(String id, StreamOpener streamOpener) {
+            ModelStreamReadyCallback cb = cbRef.get();
             boolean result = false;
             if (cb != null) {
-                result = cb.onStreamsReady(id, streamOpener);
+                result = cb.onStreamReady(id, streamOpener);
             }
             return result;
         }
 
         @Override
         public void onException(Exception e) {
-            ModelStreamsReadyCallback cb = cbRef.get();
+            ModelStreamReadyCallback cb = cbRef.get();
             T model = modelRef.get();
             if (cb != null && model != null) {
                 if (!BaseModelStreamLoader.this.onModelStreamFetchFailed(e, model)) {
","14      * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
17     public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {
18         doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));
23      * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
38     protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);
52     protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {
54         private final WeakReference<ModelStreamReadyCallback> cbRef;
57         public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {
58             this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);
63         public boolean onStreamReady(String id, StreamOpener streamOpener) {
64             ModelStreamReadyCallback cb = cbRef.get();
67                 result = cb.onStreamReady(id, streamOpener);
74             ModelStreamReadyCallback cb = cbRef.get();
14      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
17     public final Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
18         doFetchModelStreams(model, width, height, new InternalModelStreamsReadyCallback(cb, model));
23      * @see ModelStreamLoader#fetchModelStreams(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamsReadyCallback)
38     protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
52     protected class InternalModelStreamsReadyCallback implements ModelStreamsReadyCallback {
54         private final WeakReference<ModelStreamsReadyCallback> cbRef;
57         public InternalModelStreamsReadyCallback(ModelStreamsReadyCallback cb, T model) {
58             this.cbRef = new WeakReference<ModelStreamsReadyCallback>(cb);
63         public boolean onStreamsReady(String id, StreamOpener streamOpener) {
64             ModelStreamsReadyCallback cb = cbRef.get();
67                 result = cb.onStreamsReady(id, streamOpener);
74             ModelStreamsReadyCallback cb = cbRef.get();",No
library\src\com\bumptech\glide\loader\model\DirectModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\DirectModelStreamLoader.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -11,8 +11,8 @@ import com.bumptech.glide.loader.opener.StreamOpener;
  */
 public abstract class DirectModelStreamLoader<T> extends BaseModelStreamLoader<T> {
     @Override
-    protected void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
-        cb.onStreamsReady(getId(model), getStreamOpener(model, width, height));
+    protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {
+        cb.onStreamReady(getId(model), getStreamOpener(model, width, height));
     }
 
     @Override
","14     protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {
15         cb.onStreamReady(getId(model), getStreamOpener(model, width, height));
14     protected void doFetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb) {
15         cb.onStreamsReady(getId(model), getStreamOpener(model, width, height));",No
library\src\com\bumptech\glide\loader\model\ModelStreamLoader.java,library\src\com\bumptech\glide\loader\model\ModelStreamLoader.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -14,7 +14,7 @@ public interface ModelStreamLoader<T> {
      * and that should be called by the {@link ModelStreamLoader} when a load completes either successfully or
      * because of an exception
      */
-    public interface ModelStreamsReadyCallback {
+    public interface ModelStreamReadyCallback {
         /**
          * The method a loader should call when a load completes successfully
          *
@@ -22,7 +22,7 @@ public interface ModelStreamLoader<T> {
          * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
          * @return True iff the loaded streamOpener and id was used by the class that requested
          */
-        public boolean onStreamsReady(String id, StreamOpener streamOpener);
+        public boolean onStreamReady(String id, StreamOpener streamOpener);
 
         /**
          * The method a loader should call when a load fails
@@ -42,7 +42,7 @@ public interface ModelStreamLoader<T> {
      *
      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relavent
      */
-    public Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);
+    public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);
 
     /**
      * Called when the current load does not need to continue and any corresponding cleanup to save cpu or memory can be
","17     public interface ModelStreamReadyCallback {
25         public boolean onStreamReady(String id, StreamOpener streamOpener);
45     public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);
17     public interface ModelStreamsReadyCallback {
25         public boolean onStreamsReady(String id, StreamOpener streamOpener);
45     public Object fetchModelStreams(T model, int width, int height, ModelStreamsReadyCallback cb);",No
library\src\com\bumptech\glide\loader\opener\FileInputStreamsOpener.java,library\src\com\bumptech\glide\loader\opener\FileInputStreamOpener.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -3,6 +3,7 @@ package com.bumptech.glide.loader.opener;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 
 /**
  * Created with IntelliJ IDEA.
@@ -11,20 +12,20 @@ import java.io.IOException;
  * Time: 11:11 PM
  * To change this template use File | Settings | File Templates.
  */
-public class FileInputStreamsOpener implements StreamOpener {
+public class FileInputStreamOpener implements StreamOpener {
     private final File file;
 
-    public FileInputStreamsOpener(String path) {
+    public FileInputStreamOpener(String path) {
         this(new File(path));
     }
 
-    public FileInputStreamsOpener(File file) {
+    public FileInputStreamOpener(File file) {
         this.file = file;
     }
 
     @Override
-    public Streams openStreams() throws IOException {
-        return new Streams(new FileInputStream(file), new FileInputStream(file));
+    public InputStream openStream() throws IOException {
+        return new FileInputStream(file);
     }
 
     @Override
","6 import java.io.InputStream;
15 public class FileInputStreamOpener implements StreamOpener {
18     public FileInputStreamOpener(String path) {
22     public FileInputStreamOpener(File file) {
27     public InputStream openStream() throws IOException {
28         return new FileInputStream(file);
14 public class FileInputStreamsOpener implements StreamOpener {
17     public FileInputStreamsOpener(String path) {
21     public FileInputStreamsOpener(File file) {
26     public Streams openStreams() throws IOException {
27         return new Streams(new FileInputStream(file), new FileInputStream(file));",No
,library\src\com\bumptech\glide\loader\opener\HttpInputStreamOpener.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -0,0 +1,40 @@
+package com.bumptech.glide.loader.opener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/10/13
+ * Time: 11:21 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class HttpInputStreamOpener implements StreamOpener {
+    private final URL url;
+    private HttpURLConnection urlConnection = null;
+
+    public HttpInputStreamOpener(URL url) {
+        this.url = url;
+    }
+
+    @Override
+    public InputStream openStream() throws IOException {
+        urlConnection = (HttpURLConnection) url.openConnection();
+        urlConnection.setDoInput(true);
+        urlConnection.setDoOutput(false);
+        urlConnection.setUseCaches(false);
+        urlConnection.setRequestProperty(""Connection"", ""close"");
+        urlConnection.connect();
+        return urlConnection.getInputStream();
+    }
+
+    @Override
+    public void cleanup() {
+        if (urlConnection != null) {
+            urlConnection.disconnect();
+        }
+    }
+}
","1 package com.bumptech.glide.loader.opener;
2 
3 import java.io.IOException;
4 import java.io.InputStream;
5 import java.net.HttpURLConnection;
6 import java.net.URL;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/10/13
12  * Time: 11:21 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class HttpInputStreamOpener implements StreamOpener {
16     private final URL url;
17     private HttpURLConnection urlConnection = null;
18 
19     public HttpInputStreamOpener(URL url) {
20         this.url = url;
21     }
22 
23     @Override
24     public InputStream openStream() throws IOException {
25         urlConnection = (HttpURLConnection) url.openConnection();
26         urlConnection.setDoInput(true);
27         urlConnection.setDoOutput(false);
28         urlConnection.setUseCaches(false);
29         urlConnection.setRequestProperty(""Connection"", ""close"");
30         urlConnection.connect();
31         return urlConnection.getInputStream();
32     }
33 
34     @Override
35     public void cleanup() {
36         if (urlConnection != null) {
37             urlConnection.disconnect();
38         }
39     }
40 }",No
library\src\com\bumptech\glide\loader\opener\HttpInputStreamsOpener.java,,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -1,44 +0,0 @@
-package com.bumptech.glide.loader.opener;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/10/13
- * Time: 11:21 PM
- * To change this template use File | Settings | File Templates.
- */
-public class HttpInputStreamsOpener implements StreamOpener {
-    private final URL url;
-    private HttpURLConnection[] urlConnections = new HttpURLConnection[2];
-
-    public HttpInputStreamsOpener(URL url) {
-        this.url = url;
-    }
-
-    @Override
-    public Streams openStreams() throws IOException {
-        urlConnections = new HttpURLConnection[] {(HttpURLConnection) url.openConnection(), (HttpURLConnection) url.openConnection()};
-        for (HttpURLConnection urlConnection : urlConnections) {
-            urlConnection = (HttpURLConnection) url.openConnection();
-            urlConnection.setDoInput(true);
-            urlConnection.setDoOutput(false);
-            urlConnection.setUseCaches(false);
-            urlConnection.setRequestProperty(""Connection"", ""close"");
-            urlConnection.connect();
-        }
-        return new Streams(urlConnections[0].getInputStream(), urlConnections[1].getInputStream());
-    }
-
-    @Override
-    public void cleanup() {
-        for (HttpURLConnection urlConnection : urlConnections) {
-            if (urlConnection != null) {
-                urlConnection.disconnect();
-            }
-        }
-    }
-}
","1 package com.bumptech.glide.loader.opener;
2 
3 import java.io.IOException;
4 import java.net.HttpURLConnection;
5 import java.net.URL;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 7/10/13
11  * Time: 11:21 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public class HttpInputStreamsOpener implements StreamOpener {
15     private final URL url;
16     private HttpURLConnection[] urlConnections = new HttpURLConnection[2];
17 
18     public HttpInputStreamsOpener(URL url) {
19         this.url = url;
20     }
21 
22     @Override
23     public Streams openStreams() throws IOException {
24         urlConnections = new HttpURLConnection[] {(HttpURLConnection) url.openConnection(), (HttpURLConnection) url.openConnection()};
25         for (HttpURLConnection urlConnection : urlConnections) {
26             urlConnection = (HttpURLConnection) url.openConnection();
27             urlConnection.setDoInput(true);
28             urlConnection.setDoOutput(false);
29             urlConnection.setUseCaches(false);
30             urlConnection.setRequestProperty(""Connection"", ""close"");
31             urlConnection.connect();
32         }
33         return new Streams(urlConnections[0].getInputStream(), urlConnections[1].getInputStream());
34     }
35 
36     @Override
37     public void cleanup() {
38         for (HttpURLConnection urlConnection : urlConnections) {
39             if (urlConnection != null) {
40                 urlConnection.disconnect();
41             }
42         }
43     }
44 }",No
library\src\com\bumptech\glide\loader\opener\StreamOpener.java,library\src\com\bumptech\glide\loader\opener\StreamOpener.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -7,19 +7,6 @@ import java.io.InputStream;
  * An interface that encapsulates code to open InputStreams for an image.
  */
 public interface StreamOpener {
-    /**
-     * A simple class to reference two InputStreams
-     */
-    public static class Streams {
-        public final InputStream is1;
-        public final InputStream is2;
-
-        public Streams(InputStream is1, InputStream is2) {
-            this.is1 = is1;
-            this.is2 = is2;
-        }
-    }
-
     /**
      * A method to actually create InputStreams. It will always be called on a background thread and therefore it is
      * safe to perform long running requests in this method (like an http call). This method is used to load an image
@@ -28,7 +15,7 @@ public interface StreamOpener {
      * @return A holder containing both opened InputStreams
      * @throws IOException
      */
-    public Streams openStreams() throws IOException;
+    public InputStream openStream() throws IOException;
 
     /**
      * A method that is called after openStreams in a try/finally block to allow this object to cleanup anything
","18     public InputStream openStream() throws IOException;
10     /**
11      * A simple class to reference two InputStreams
12      */
13     public static class Streams {
14         public final InputStream is1;
15         public final InputStream is2;
16 
17         public Streams(InputStream is1, InputStream is2) {
18             this.is1 = is1;
19             this.is2 = is2;
20         }
21     }
22 
31     public Streams openStreams() throws IOException;",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -271,7 +271,7 @@ public class ImagePresenter<T> {
             sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
                 @Override
                 public void onSizeReady(int width, int height) {
-                    fetchModelStreams(model, width, height, loadCount);
+                    fetchModelStream(model, width, height, loadCount);
                 }
             });
 
@@ -310,10 +310,10 @@ public class ImagePresenter<T> {
         imageLoader.clear();
     }
 
-    private void fetchModelStreams(final T model, final int width, final int height, final int loadCount) {
-        modelStreamToken = modelStreamLoader.fetchModelStreams(model, width, height, new ModelStreamLoader.ModelStreamsReadyCallback() {
+    private void fetchModelStream(final T model, final int width, final int height, final int loadCount) {
+        modelStreamToken = modelStreamLoader.fetchModelStream(model, width, height, new ModelStreamLoader.ModelStreamReadyCallback() {
             @Override
-            public boolean onStreamsReady(String id, StreamOpener streamOpener) {
+            public boolean onStreamReady(String id, StreamOpener streamOpener) {
                 if (loadCount != currentCount) return false;
                 fetchImage(id, streamOpener, width, height, loadCount);
 
","274                     fetchModelStream(model, width, height, loadCount);
313     private void fetchModelStream(final T model, final int width, final int height, final int loadCount) {
314         modelStreamToken = modelStreamLoader.fetchModelStream(model, width, height, new ModelStreamLoader.ModelStreamReadyCallback() {
316             public boolean onStreamReady(String id, StreamOpener streamOpener) {
274                     fetchModelStreams(model, width, height, loadCount);
313     private void fetchModelStreams(final T model, final int width, final int height, final int loadCount) {
314         modelStreamToken = modelStreamLoader.fetchModelStreams(model, width, height, new ModelStreamLoader.ModelStreamsReadyCallback() {
316             public boolean onStreamsReady(String id, StreamOpener streamOpener) {",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -335,8 +335,8 @@ public class ImageManager {
         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
         return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException {
-                return resizer.loadAsIs(is1);
+            protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
+                return resizer.loadAsIs(is);
             }
         });
     }
@@ -355,8 +355,8 @@ public class ImageManager {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
-                return resizer.loadAsIs(is1, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
+                return resizer.loadAsIs(is, width, height);
             }
         });
     }
@@ -375,8 +375,8 @@ public class ImageManager {
         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
-                return resizer.loadAtLeast(is1, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
+                return resizer.loadAtLeast(is, width, height);
             }
         });
     }
@@ -396,8 +396,8 @@ public class ImageManager {
         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
-                return resizer.centerCrop(is1, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
+                return resizer.centerCrop(is, width, height);
             }
         });
     }
@@ -417,8 +417,8 @@ public class ImageManager {
         final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(streamOpener) {
             @Override
-            protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
-                return resizer.fitInSpace(is1, width, height);
+            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
+                return resizer.fitInSpace(is, width, height);
             }
         });
     }
@@ -568,8 +568,7 @@ public class ImageManager {
                     if (cancelled) return;
 
                     try {
-                        StreamOpener.Streams streams = streamOpener.openStreams();
-                        finishResize(resizeIfNotFound(streams.is1, streams.is2), false);
+                        finishResize(resizeIfNotFound(streamOpener.openStream()), false);
                     } catch (Exception e) {
                         cb.onLoadFailed(e);
                     } finally {
@@ -608,7 +607,7 @@ public class ImageManager {
             }
         }
 
-        protected abstract Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException;
+        protected abstract Bitmap resizeIfNotFound(InputStream is) throws IOException;
     }
 
 
","338             protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
339                 return resizer.loadAsIs(is);
358             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
359                 return resizer.loadAsIs(is, width, height);
378             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
379                 return resizer.loadAtLeast(is, width, height);
399             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
400                 return resizer.centerCrop(is, width, height);
420             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
421                 return resizer.fitInSpace(is, width, height);
571                         finishResize(resizeIfNotFound(streamOpener.openStream()), false);
610         protected abstract Bitmap resizeIfNotFound(InputStream is) throws IOException;
338             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException {
339                 return resizer.loadAsIs(is1);
358             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
359                 return resizer.loadAsIs(is1, width, height);
378             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
379                 return resizer.loadAtLeast(is1, width, height);
399             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException {
400                 return resizer.centerCrop(is1, width, height);
420             protected Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws FileNotFoundException{
421                 return resizer.fitInSpace(is1, width, height);
571                         StreamOpener.Streams streams = streamOpener.openStreams();
572                         finishResize(resizeIfNotFound(streams.is1, streams.is2), false);
611         protected abstract Bitmap resizeIfNotFound(InputStream is1, InputStream is2) throws IOException;",No
samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -3,7 +3,7 @@ package com.bumptech.flickr;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.loader.model.DirectModelStreamLoader;
-import com.bumptech.glide.loader.opener.HttpInputStreamsOpener;
+import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
 import com.bumptech.glide.loader.opener.StreamOpener;
 
 /**
@@ -20,7 +20,7 @@ public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
 
     @Override
     protected StreamOpener getStreamOpener(Photo model, int width, int height) {
-        return new HttpInputStreamsOpener(flickrApi.getPhotoURL(width, height, model));
+        return new HttpInputStreamOpener(flickrApi.getPhotoURL(width, height, model));
     }
 
     @Override
","6 import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
23         return new HttpInputStreamOpener(flickrApi.getPhotoURL(width, height, model));
6 import com.bumptech.glide.loader.opener.HttpInputStreamsOpener;
23         return new HttpInputStreamsOpener(flickrApi.getPhotoURL(width, height, model));",No
samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,3199de78a097f3aa7394a98a0d5528bb3170a043,678c91747b4f8f201767a20f3e0c8beff235d2e3,"StreamsOpener -> StreamOpener

Now returns a single InputStream instead of a pair
wrapped in an object","@@ -3,7 +3,7 @@ package com.bumptech.flickr;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.loader.model.BaseModelStreamLoader;
-import com.bumptech.glide.loader.opener.FileInputStreamsOpener;
+import com.bumptech.glide.loader.opener.FileInputStreamOpener;
 
 import java.io.File;
 import java.util.concurrent.Future;
@@ -25,12 +25,12 @@ public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
     }
 
     @Override
-    protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
+    protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamReadyCallback cb) {
         clear();
         current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
             @Override
             public void onDownloadComplete(String path) {
-                cb.onStreamsReady(model.id, new FileInputStreamsOpener(path));
+                cb.onStreamReady(model.id, new FileInputStreamOpener(path));
             }
         });
     }
","6 import com.bumptech.glide.loader.opener.FileInputStreamOpener;
28     protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamReadyCallback cb) {
33                 cb.onStreamReady(model.id, new FileInputStreamOpener(path));
6 import com.bumptech.glide.loader.opener.FileInputStreamsOpener;
28     protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamsReadyCallback cb) {
33                 cb.onStreamsReady(model.id, new FileInputStreamsOpener(path));",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,3199de78a097f3aa7394a98a0d5528bb3170a043,Prevent BitmapFactory from overriding mark size,"@@ -25,8 +25,8 @@ import java.util.Queue;
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
-    private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
-    private static final int MARK_POSITION = 5 * 1024 * 1024; //5mb
+    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
+    private static final int MARK_POSITION = 1024 * 1024; //1mb
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final BitmapPool bitmapPool;
@@ -372,13 +372,13 @@ public class ImageResizer {
         decodeBitmapOptions.inTempStorage = getTempBytes();
 
         if (decodeBitmapOptions.inJustDecodeBounds) {
-            bis.mark(MARK_POSITION); //this is absurdly large, but jpeg headers are not size bounded so we need
+            bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
                                      //something large enough to minimize the possibility of not being able to fit
                                      //enough of the header in the buffer to get the image size so that we don't fail
                                      //to load images. The BufferedInputStream will create a new buffer of 2x the
                                      //original size each time we use up the buffer space without passing the mark so
                                      //this is a maximum bound on the buffer size, not a default. Most of the time we
-                                     //won't go past our pre-allocated 32kb
+                                     //won't go past our pre-allocated 16kb
         }
         final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
         try {
","28     private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
29     private static final int MARK_POSITION = 1024 * 1024; //1mb
375             bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
381                                      //won't go past our pre-allocated 16kb
28     private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
29     private static final int MARK_POSITION = 5 * 1024 * 1024; //5mb
375             bis.mark(MARK_POSITION); //this is absurdly large, but jpeg headers are not size bounded so we need
381                                      //won't go past our pre-allocated 32kb",No
library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,3199de78a097f3aa7394a98a0d5528bb3170a043,Prevent BitmapFactory from overriding mark size,"@@ -198,7 +198,11 @@ public class RecyclableBufferedInputStream extends FilterInputStream {
      */
     @Override
     public synchronized void mark(int readlimit) {
-        marklimit = readlimit;
+        //This is stupid, but BitmapFactory.decodeStream calls mark(1024)
+        //which is too small for a substantial portion of images. This
+        //change (using Math.max) ensures that we don't overwrite readlimit
+        //with a smaller value
+        marklimit = Math.max(marklimit, readlimit);
         markpos = pos;
     }
 
","201         //This is stupid, but BitmapFactory.decodeStream calls mark(1024)
202         //which is too small for a substantial portion of images. This
203         //change (using Math.max) ensures that we don't overwrite readlimit
204         //with a smaller value
205         marklimit = Math.max(marklimit, readlimit);
201         marklimit = readlimit;",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,52207765f3e06c564f3d124bf4d6d14d1c6add3e,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,Make DiskCache interface return one InputStream,"@@ -536,16 +536,13 @@ public class ImageManager {
             final String stringKey = String.valueOf(key);
             Bitmap result = null;
             if (useDiskCache) {
-                result = diskCache.get(stringKey, new DiskCache.Reader() {
-                    @Override
-                    public Bitmap read(InputStream is1, InputStream is2) {
-                        Bitmap result = resizer.loadAsIs(is1);
+                final InputStream is = diskCache.get(stringKey);
+                if (is != null) {
+                    result = resizer.loadAsIs(is);
                     if (result == null) {
-                            diskCache.delete(stringKey);
+                        diskCache.delete(stringKey); //the image must have been corrupted
                     }
-                        return result;
                 }
-                });
             }
 
             if (result == null) {
","539                 final InputStream is = diskCache.get(stringKey);
540                 if (is != null) {
541                     result = resizer.loadAsIs(is);
543                         diskCache.delete(stringKey); //the image must have been corrupted
539                 result = diskCache.get(stringKey, new DiskCache.Reader() {
540                     @Override
541                     public Bitmap read(InputStream is1, InputStream is2) {
542                         Bitmap result = resizer.loadAsIs(is1);
544                             diskCache.delete(stringKey);
546                         return result;
548                 });",No
library\src\com\bumptech\glide\resize\cache\DiskCache.java,library\src\com\bumptech\glide\resize\cache\DiskCache.java,52207765f3e06c564f3d124bf4d6d14d1c6add3e,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,Make DiskCache interface return one InputStream,"@@ -1,7 +1,5 @@
 package com.bumptech.glide.resize.cache;
 
-import android.graphics.Bitmap;
-
 import java.io.InputStream;
 import java.io.OutputStream;
 
@@ -17,11 +15,7 @@ public interface DiskCache {
         public void write(OutputStream os);
     }
 
-    public interface Reader {
-        public Bitmap read(InputStream is1, InputStream is2);
-    }
-
-    public Bitmap get(String key, Reader reader);
+    public InputStream get(String key);
     public void put(String key, Writer writer);
     public void delete(String key);
 }
","18     public InputStream get(String key);
3 import android.graphics.Bitmap;
4 
20     public interface Reader {
21         public Bitmap read(InputStream is1, InputStream is2);
22     }
23 
24     public Bitmap get(String key, Reader reader);",No
library\src\com\bumptech\glide\resize\cache\DiskCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\DiskCacheAdapter.java,52207765f3e06c564f3d124bf4d6d14d1c6add3e,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,Make DiskCache interface return one InputStream,"@@ -1,6 +1,6 @@
 package com.bumptech.glide.resize.cache;
 
-import android.graphics.Bitmap;
+import java.io.InputStream;
 
 /**
  * Created with IntelliJ IDEA.
@@ -11,7 +11,7 @@ import android.graphics.Bitmap;
  */
 public class DiskCacheAdapter implements DiskCache {
     @Override
-    public Bitmap get(String key, Reader reader) {
+    public InputStream get(String key) {
         return null;
     }
 
","3 import java.io.InputStream;
14     public InputStream get(String key) {
3 import android.graphics.Bitmap;
14     public Bitmap get(String key, Reader reader) {",No
library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,52207765f3e06c564f3d124bf4d6d14d1c6add3e,a1ccb33c449424229fdcbfeb565cca7ba3b1de1d,Make DiskCache interface return one InputStream,"@@ -4,7 +4,6 @@
 
 package com.bumptech.glide.resize.cache;
 
-import android.graphics.Bitmap;
 import com.jakewharton.disklrucache.DiskLruCache;
 
 import java.io.File;
@@ -48,20 +47,15 @@ public class DiskLruCacheWrapper implements DiskCache {
     }
 
     @Override
-    public Bitmap get(String key, Reader reader) {
-        Bitmap result = null;
+    public InputStream get(String key) {
+        InputStream result = null;
         try {
             //It is possible that the there will be a put in between these two gets. If so that shouldn't be a problem
             //because we will always put the same value at the same key so our input streams will still represent
             //the same data
-            final DiskLruCache.Snapshot snapshot1 = diskLruCache.get(key);
-            if (snapshot1 != null) {
-                final DiskLruCache.Snapshot snapshot2 = diskLruCache.get(key);
-                if (snapshot2 != null) {
-                    final InputStream is1 = snapshot1.getInputStream(0);
-                    final InputStream is2 = snapshot2.getInputStream(0);
-                    result = reader.read(is1, is2);
-                }
+            final DiskLruCache.Snapshot snapshot = diskLruCache.get(key);
+            if (snapshot != null) {
+                result = snapshot.getInputStream(0);
             }
         } catch (IOException e) {
             e.printStackTrace();
","50     public InputStream get(String key) {
51         InputStream result = null;
56             final DiskLruCache.Snapshot snapshot = diskLruCache.get(key);
57             if (snapshot != null) {
58                 result = snapshot.getInputStream(0);
7 import android.graphics.Bitmap;
51     public Bitmap get(String key, Reader reader) {
52         Bitmap result = null;
57             final DiskLruCache.Snapshot snapshot1 = diskLruCache.get(key);
58             if (snapshot1 != null) {
59                 final DiskLruCache.Snapshot snapshot2 = diskLruCache.get(key);
60                 if (snapshot2 != null) {
61                     final InputStream is1 = snapshot1.getInputStream(0);
62                     final InputStream is2 = snapshot2.getInputStream(0);
63                     result = reader.read(is1, is2);
64                 }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,806522ed49bab96c11780a7986bd16767d1a0226,52207765f3e06c564f3d124bf4d6d14d1c6add3e,Pass model to exception handler,"@@ -218,7 +218,7 @@ public class ImagePresenter<T> {
     }
 
     public interface ExceptionHandler<T> {
-        public void onImageLoadException(Exception e, String id, boolean isCurrent);
+        public void onImageLoadException(Exception e, T model, boolean isCurrent);
         public void onModelStreamLoadException(Exception e, T model, boolean isCurrent);
     }
 
@@ -315,7 +315,7 @@ public class ImagePresenter<T> {
             @Override
             public boolean onStreamReady(String id, StreamOpener streamOpener) {
                 if (loadCount != currentCount) return false;
-                fetchImage(id, streamOpener, width, height, loadCount);
+                fetchImage(model, id, streamOpener, width, height, loadCount);
 
                 return true;
             }
@@ -329,7 +329,7 @@ public class ImagePresenter<T> {
         });
     }
 
-    private void fetchImage(final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
+    private void fetchImage(final T model, final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
         imageToken = imageLoader.fetchImage(id, streamOpener, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
@@ -345,7 +345,7 @@ public class ImagePresenter<T> {
             @Override
             public void onException(Exception e) {
                 if (exceptionHandler != null) {
-                    exceptionHandler.onImageLoadException(e, id, loadCount == currentCount);
+                    exceptionHandler.onImageLoadException(e, model, loadCount == currentCount);
                 }
             }
         });
","221         public void onImageLoadException(Exception e, T model, boolean isCurrent);
318                 fetchImage(model, id, streamOpener, width, height, loadCount);
332     private void fetchImage(final T model, final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
348                     exceptionHandler.onImageLoadException(e, model, loadCount == currentCount);
221         public void onImageLoadException(Exception e, String id, boolean isCurrent);
318                 fetchImage(id, streamOpener, width, height, loadCount);
332     private void fetchImage(final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
348                     exceptionHandler.onImageLoadException(e, id, loadCount == currentCount);",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,64b6d88e922b1818976a45ed30754b18e9b9e6e7,806522ed49bab96c11780a7986bd16767d1a0226,"Fix flickr api return url for incorrect image size

HashMap.keySet is not ordered :(","@@ -10,6 +10,7 @@ import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -37,20 +38,25 @@ public class Api {
         put(150, ""q"");
         put(240, ""m"");
         put(320, ""n"");
-        put(500, ""-"");
         put(640, ""z"");
         put(1024, ""b"");
-        put(Integer.MAX_VALUE, ""o"");
     }};
+
+    private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
+    static {
+        SORTED_SIZE_KEYS.addAll(EDGE_TO_SIZE_KEY.keySet());
+        Collections.sort(SORTED_SIZE_KEYS);
+    }
     private final String sizeKey;
 
     private static String getSizeKey(int width, int height) {
-        final int largestEdge = width > height ? width : height;
+        final int largestEdge = Math.max(width, height);
 
-        final String result = EDGE_TO_SIZE_KEY.get(Integer.MAX_VALUE);
-        for (int edge : EDGE_TO_SIZE_KEY.keySet()) {
+        String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
+        for (int edge : SORTED_SIZE_KEYS) {
             if (largestEdge <= edge) {
-                return EDGE_TO_SIZE_KEY.get(edge);
+                result = EDGE_TO_SIZE_KEY.get(edge);
+                break;
             }
         }
         return result;
","13 import java.util.Collections;
44 
45     private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
46     static {
47         SORTED_SIZE_KEYS.addAll(EDGE_TO_SIZE_KEY.keySet());
48         Collections.sort(SORTED_SIZE_KEYS);
49     }
53         final int largestEdge = Math.max(width, height);
55         String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
56         for (int edge : SORTED_SIZE_KEYS) {
58                 result = EDGE_TO_SIZE_KEY.get(edge);
59                 break;
40         put(500, ""-"");
43         put(Integer.MAX_VALUE, ""o"");
48         final int largestEdge = width > height ? width : height;
50         final String result = EDGE_TO_SIZE_KEY.get(Integer.MAX_VALUE);
51         for (int edge : EDGE_TO_SIZE_KEY.keySet()) {
53                 return EDGE_TO_SIZE_KEY.get(edge);",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,2eeb841d3f04c79d10517195318a93ac4056c86f,64b6d88e922b1818976a45ed30754b18e9b9e6e7,"Remove path interface in ImageResizer

Also update/correct the comments","@@ -14,8 +14,6 @@ import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.util.Log;
 
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.LinkedList;
@@ -80,90 +78,47 @@ public class ImageResizer {
     }
 
     /**
-     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
-     * and then crop the image down so that it fills the given dimensions
+     * Scale the image so that either the width of the image matches the given width and the height of the image is
+     * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
      *
-     * @param path The path where the image is located
-     * @param width The width the final image will fill
-     * @param height The height the final image will fill
+     * Does not maintain the image's aspect ratio
+     *
+     * @param is The InputStream for the image
+     * @param width The minimum width of the image
+     * @param height The minimum height of the image
      * @return The resized image
      */
-    public Bitmap centerCrop(final String path, final int width, final int height) throws FileNotFoundException {
-        final Bitmap streamed = loadAtLeast(path, width, height);
-        return centerCrop(getRecycled(width, height), streamed, width, height);
-    }
-
-    public Bitmap centerCrop(InputStream is1, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is1, width, height);
+    public Bitmap centerCrop(InputStream is, int width, int height) {
+        final Bitmap streamed = loadAtLeast(is, width, height);
         return centerCrop(getRecycled(width, height), streamed, width, height);
     }
 
     /**
-     * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
-     * and then shrink the image down, again maintaining the original proportions, so that it fits entirely within the
-     * given dimensions.
+     * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
+     * will be equal to the given dimension and the other will be less than the given dimension
      *
-     * @param path The path where the image is located
-     * @param width The width the final image will fit within
-     * @param height The height the final image will fit within
+     * @param is The InputStream for the image
+     * @param width The maximum width of the image
+     * @param height The maximum height of the image
      * @return The resized image
      */
-    public Bitmap fitInSpace(final String path, final int width, final int height) throws FileNotFoundException {
-        final Bitmap streamed = loadAtLeast(path, width > height ? 1 : width, height > width ? 1 : height);
+    public Bitmap fitInSpace(InputStream is, int width, int height) {
+        final Bitmap streamed = loadAtLeast(is, width > height ? 1 : width, height > width ? 1 : height);
         return fitInSpace(streamed, width, height);
     }
 
-    public Bitmap fitInSpace(InputStream is1, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is1, width > height ? 1 : width, height > width ? 1 : height);
-        return fitInSpace(streamed, width, height);
-    }
-
-    /**
-     * Load the image at the given path with dimens greater than or equal to the given dimens. If the image has a
-     * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
-     *
-     * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
-     * be enlarged and will instead be loaded at its original dimens.
-     *
-     * @param path The path to the image
-     * @param width The minimum width of the returned Bitmap
-     * @param height The minimum heght of the returned Bitmap
-     * @return
-     * @throws FileNotFoundException
-     */
-    public Bitmap loadAtLeast(String path, int width, int height) throws FileNotFoundException {
-        int orientation = getOrientation(path);
-        if(orientation == 90 || orientation == 270) {
-            //Swap width and height for initial downsample calculation if its oriented so.
-            //The image will then be rotated back to normal.
-            int w = width;
-            width = height;
-            height = w;
-        }
-
-        Bitmap result = loadAtLeast(new FileInputStream(path), width, height);
-
-        if (orientation != 0) {
-            result = rotateImage(result, orientation);
-        }
-        return result;
-    }
-
     /**
-     * Load the image represented by the given input streams with dimens greater than or equal to the given dimens.
-     * Maintains the original proportions.
+     * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
+     * greater than or equal to the given width and height.
      *
-     * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
-     * be enlarged and will instead be loaded at its original dimens.
-     *
-     * @param is1 An inputStream for the image
+     * @param is An inputStream for the image
      * @param width The minimum width of the returned Bitmap
      * @param height The minimum height of the returned Bitmap
      * @return A Bitmap containing the image
      */
-    public Bitmap loadAtLeast(InputStream is1, int width, int height) {
+    public Bitmap loadAtLeast(InputStream is, int width, int height) {
         byte[] bytes = getTempBytes();
-        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is1, bytes);
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
         final int[] dimens = getDimensions(bis);
         final int originalWidth = dimens[0];
         final int originalHeight = dimens[1];
@@ -180,38 +135,11 @@ public class ImageResizer {
     }
 
     /**
-     * Load the image at the given path with dimens less than or equal to the given dimens. If the image has a
-     * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
+     * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
+     * less than or equal to the given width and height. Unlike {@link #fitInSpace(android.graphics.Bitmap, int, int)},
+     * one or both dimensions may be less than the given dimensions.
      *
-     * @param path The path to the image
-     * @param width The maximum width of the returned Bitmap
-     * @param height The maximum height of the returned Bitmap
-     * @return A Bitmap containing the image
-     * @throws FileNotFoundException
-     */
-    public Bitmap loadAtMost(String path, int width, int height) throws FileNotFoundException {
-        int orientation = getOrientation(path);
-        if (orientation == 90 || orientation == 270) {
-            int w = width;
-            width = height;
-            height = w;
-        }
-
-        Bitmap result = loadAtMost(new FileInputStream(path), new FileInputStream(path), width, height);
-
-        if (orientation != 0) {
-            result = rotateImage(result, orientation);
-        }
-
-        return result;
-    }
-
-    /**
-     * Load the image represented by the given input streams with dimens less than or equal to the given dimens.
-     * Maintains the original proportions.
-     *
-     * @param is1 An InputStream for the image. Can't be is2
-     * @param is2 An InputStream for the image. Can't be ss1
+     * @param is An InputStream for the image.
      * @param width The maximum width
      * @param height The maximum height
      * @return A bitmap containing the image
@@ -233,12 +161,9 @@ public class ImageResizer {
     }
 
     /**
-     * Load the image represented by the given InputStreams at its original size. Use the first InputStream to
-     * try to determine the proportions of the image so that we can try to retrieve a recycled Bitmap of the correct
-     * size. Use the second InputStream to actually load the image into a Bitmap. Note both InputStreams must represent
-     * the same image and this method will close both InputStreams.
+     * Load the image at its original size
      *
-     * @param is The InputStream used to get the dimensions of the image
+     * @param is The InputStream for the image
      * @return The loaded image
      */
     public Bitmap loadAsIs(final InputStream is) {
@@ -250,68 +175,31 @@ public class ImageResizer {
         return result;
     }
 
-    public Bitmap loadAsIs(InputStream is, int width, int height) {
-        byte[] bytes = getTempBytes();
-        Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
-        releaseTempBytes(bytes);
-        return result;
-    }
-
     /**
-     * Load the image at the given path at its original size. Assume that the dimensions of the image at the given path
-     * will match the given dimensions and use the given dimensions to retrieve a recycled Bitmap of the correct size.
-     * Note this method will throw an exception if the dimensions of the image at the given path do not exactly match
-     * the given dimensions and there is a bitmap of the given dimensions available to be recycled.
+     * Load the image at its original size
      *
-     * The dimensions are given to avoid opening an InputStream specifically to determine the size of the image at the
-     * given path and should be used when the dimensions of the image are known.
+     * This is somewhat more efficient than {@link #loadAsIs(java.io.InputStream)} because it does not need to read
+     * the image header to determine the image's width and height. Instead, it assumes the given width and height
      *
-     * @param path The path where the image is stored
-     * @param width The width of the image at the given path
-     * @param height The height of the image at the given path
+     * @param is The InputStream for the image
+     * @param width The width of the image represented by the InputStream
+     * @param height The height of the image represented by the InputStream
      * @return The loaded image
      */
-    public Bitmap loadAsIs(final String path, final int width, final int height) throws FileNotFoundException {
-        return load(path, getRecycled(width, height));
-    }
-
-    /**
-     * Load the image at the given path at its original size. Will create a second InputStream to first try to determine
-     * the size of the image to attempt to retrieve a recycled Bitmap.
-     *
-     * @param path The path where the image is stored
-     * @return The loaded image
-     */
-    public Bitmap loadAsIs(final String path) throws FileNotFoundException {
-        final int[] dimens = getDimensions(path);
-        return load(path, getRecycled(dimens));
-    }
-
-    /**
-     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
-     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
-     * of memory.
-     *
-     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
-     * is provided.
-     *
-     * @param path The path where the image is stored
-     * @param recycle A Bitmap we can load the image into, or null
-     * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
-     */
-    private Bitmap load(String path, Bitmap recycle) throws FileNotFoundException {
-        final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
-        final Bitmap result = decodeStream(path, decodeBitmapOptions);
-        return result == null ? null : orientImage(path, result);
+    public Bitmap loadAsIs(InputStream is, int width, int height) {
+        byte[] bytes = getTempBytes();
+        Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
+        releaseTempBytes(bytes);
+        return result;
     }
 
     /**
-     * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
-     * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
-     * of memory.
+     * A potentially expensive operation to load the image for the given InputStream. If a recycled Bitmap whose
+     * dimensions exactly match those of the image for the given InputStream is available, the operation is much less
+     * expensive in terms of memory.
      *
-     * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
-     * is provided.
+     * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
+     * given InputStream is provided.
      *
      * @param is The InputStream representing the image data
      * @param recycle A Bitmap we can load the image into, or null
@@ -322,19 +210,6 @@ public class ImageResizer {
         return decodeStream(is, decodeBitmapOptions);
     }
 
-    /**
-     * A method for getting the dimensions of an image at the given path
-     *
-     * @param path The path where the image is stored
-     * @return an array containing the dimensions of the image in the form {width, height}
-     */
-    private int[] getDimensions(String path) throws FileNotFoundException {
-        final BitmapFactory.Options decodeBoundsOptions = getOptions();
-        decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(path, decodeBoundsOptions);
-        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
-    }
-
     /**
      * A method for getting the dimensions of an image from the given InputStream
      *
@@ -348,26 +223,6 @@ public class ImageResizer {
         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
     }
 
-    private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) throws FileNotFoundException {
-        RecyclableBufferedInputStream is = null;
-        Bitmap result = null;
-        try {
-            byte[] bytes = getTempBytes();
-            is = new RecyclableBufferedInputStream(new FileInputStream(path), bytes);
-            result = decodeStream(is, decodeBitmapOptions);
-            releaseTempBytes(bytes);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-        return result;
-    }
-
     private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {
         decodeBitmapOptions.inTempStorage = getTempBytes();
 
","81      * Scale the image so that either the width of the image matches the given width and the height of the image is
82      * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
84      * Does not maintain the image's aspect ratio
85      *
86      * @param is The InputStream for the image
87      * @param width The minimum width of the image
88      * @param height The minimum height of the image
91     public Bitmap centerCrop(InputStream is, int width, int height) {
92         final Bitmap streamed = loadAtLeast(is, width, height);
97      * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
98      * will be equal to the given dimension and the other will be less than the given dimension
100      * @param is The InputStream for the image
101      * @param width The maximum width of the image
102      * @param height The maximum height of the image
105     public Bitmap fitInSpace(InputStream is, int width, int height) {
106         final Bitmap streamed = loadAtLeast(is, width > height ? 1 : width, height > width ? 1 : height);
111      * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
112      * greater than or equal to the given width and height.
114      * @param is An inputStream for the image
119     public Bitmap loadAtLeast(InputStream is, int width, int height) {
121         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
138      * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
139      * less than or equal to the given width and height. Unlike {@link #fitInSpace(android.graphics.Bitmap, int, int)},
140      * one or both dimensions may be less than the given dimensions.
142      * @param is An InputStream for the image.
164      * Load the image at its original size
166      * @param is The InputStream for the image
178     /**
179      * Load the image at its original size
180      *
181      * This is somewhat more efficient than {@link #loadAsIs(java.io.InputStream)} because it does not need to read
182      * the image header to determine the image's width and height. Instead, it assumes the given width and height
183      *
184      * @param is The InputStream for the image
185      * @param width The width of the image represented by the InputStream
186      * @param height The height of the image represented by the InputStream
187      * @return The loaded image
188      */
197      * A potentially expensive operation to load the image for the given InputStream. If a recycled Bitmap whose
198      * dimensions exactly match those of the image for the given InputStream is available, the operation is much less
199      * expensive in terms of memory.
201      * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
202      * given InputStream is provided.
17 import java.io.FileInputStream;
18 import java.io.FileNotFoundException;
83      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
84      * and then crop the image down so that it fills the given dimensions
86      * @param path The path where the image is located
87      * @param width The width the final image will fill
88      * @param height The height the final image will fill
91     public Bitmap centerCrop(final String path, final int width, final int height) throws FileNotFoundException {
92         final Bitmap streamed = loadAtLeast(path, width, height);
93         return centerCrop(getRecycled(width, height), streamed, width, height);
94     }
95 
96     public Bitmap centerCrop(InputStream is1, int width, int height) {
97         final Bitmap streamed = loadAtLeast(is1, width, height);
102      * Load the image at the given path at approximately the given dimensions, maintaining the original proportions,
103      * and then shrink the image down, again maintaining the original proportions, so that it fits entirely within the
104      * given dimensions.
106      * @param path The path where the image is located
107      * @param width The width the final image will fit within
108      * @param height The height the final image will fit within
111     public Bitmap fitInSpace(final String path, final int width, final int height) throws FileNotFoundException {
112         final Bitmap streamed = loadAtLeast(path, width > height ? 1 : width, height > width ? 1 : height);
113         return fitInSpace(streamed, width, height);
114     }
115 
116     public Bitmap fitInSpace(InputStream is1, int width, int height) {
117         final Bitmap streamed = loadAtLeast(is1, width > height ? 1 : width, height > width ? 1 : height);
122      * Load the image at the given path with dimens greater than or equal to the given dimens. If the image has a
123      * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
125      * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
126      * be enlarged and will instead be loaded at its original dimens.
127      *
128      * @param path The path to the image
129      * @param width The minimum width of the returned Bitmap
130      * @param height The minimum heght of the returned Bitmap
131      * @return
132      * @throws FileNotFoundException
133      */
134     public Bitmap loadAtLeast(String path, int width, int height) throws FileNotFoundException {
135         int orientation = getOrientation(path);
136         if(orientation == 90 || orientation == 270) {
137             //Swap width and height for initial downsample calculation if its oriented so.
138             //The image will then be rotated back to normal.
139             int w = width;
140             width = height;
141             height = w;
142         }
143 
144         Bitmap result = loadAtLeast(new FileInputStream(path), width, height);
145 
146         if (orientation != 0) {
147             result = rotateImage(result, orientation);
148         }
149         return result;
150     }
151 
152     /**
153      * Load the image represented by the given input streams with dimens greater than or equal to the given dimens.
154      * Maintains the original proportions.
155      *
156      * Note - if the image at the path has dimens less than or equal to the given dimens, the image will not
157      * be enlarged and will instead be loaded at its original dimens.
158      *
159      * @param is1 An inputStream for the image
164     public Bitmap loadAtLeast(InputStream is1, int width, int height) {
166         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is1, bytes);
183      * Load the image at the given path with dimens less than or equal to the given dimens. If the image has a
184      * rotation specified in EXIF data, rotates the image accordingly. Maintains the original proportions.
186      * @param path The path to the image
187      * @param width The maximum width of the returned Bitmap
188      * @param height The maximum height of the returned Bitmap
189      * @return A Bitmap containing the image
190      * @throws FileNotFoundException
191      */
192     public Bitmap loadAtMost(String path, int width, int height) throws FileNotFoundException {
193         int orientation = getOrientation(path);
194         if (orientation == 90 || orientation == 270) {
195             int w = width;
196             width = height;
197             height = w;
198         }
199 
200         Bitmap result = loadAtMost(new FileInputStream(path), new FileInputStream(path), width, height);
201 
202         if (orientation != 0) {
203             result = rotateImage(result, orientation);
204         }
205 
206         return result;
207     }
208 
209     /**
210      * Load the image represented by the given input streams with dimens less than or equal to the given dimens.
211      * Maintains the original proportions.
212      *
213      * @param is1 An InputStream for the image. Can't be is2
214      * @param is2 An InputStream for the image. Can't be ss1
236      * Load the image represented by the given InputStreams at its original size. Use the first InputStream to
237      * try to determine the proportions of the image so that we can try to retrieve a recycled Bitmap of the correct
238      * size. Use the second InputStream to actually load the image into a Bitmap. Note both InputStreams must represent
239      * the same image and this method will close both InputStreams.
241      * @param is The InputStream used to get the dimensions of the image
261      * Load the image at the given path at its original size. Assume that the dimensions of the image at the given path
262      * will match the given dimensions and use the given dimensions to retrieve a recycled Bitmap of the correct size.
263      * Note this method will throw an exception if the dimensions of the image at the given path do not exactly match
264      * the given dimensions and there is a bitmap of the given dimensions available to be recycled.
266      * The dimensions are given to avoid opening an InputStream specifically to determine the size of the image at the
267      * given path and should be used when the dimensions of the image are known.
268      *
269      * @param path The path where the image is stored
270      * @param width The width of the image at the given path
271      * @param height The height of the image at the given path
272      * @return The loaded image
273      */
274     public Bitmap loadAsIs(final String path, final int width, final int height) throws FileNotFoundException {
275         return load(path, getRecycled(width, height));
276     }
277 
278     /**
279      * Load the image at the given path at its original size. Will create a second InputStream to first try to determine
280      * the size of the image to attempt to retrieve a recycled Bitmap.
281      *
282      * @param path The path where the image is stored
283      * @return The loaded image
284      */
285     public Bitmap loadAsIs(final String path) throws FileNotFoundException {
286         final int[] dimens = getDimensions(path);
287         return load(path, getRecycled(dimens));
288     }
289 
290     /**
291      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
292      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
293      * of memory.
294      *
295      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
296      * is provided.
297      *
298      * @param path The path where the image is stored
299      * @param recycle A Bitmap we can load the image into, or null
300      * @return A new bitmap containing the image at the given path, or recycle if recycle is not null
301      */
302     private Bitmap load(String path, Bitmap recycle) throws FileNotFoundException {
303         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
304         final Bitmap result = decodeStream(path, decodeBitmapOptions);
305         return result == null ? null : orientImage(path, result);
306     }
307 
308     /**
309      * A potentially expensive operation to load the image at the given path. If a recycled Bitmap whose dimensions
310      * exactly match those of the image at the given path is provided, the operation is much less expensive in terms
311      * of memory.
312      *
313      * Note this method will throw an exception of a Bitmap with dimensions not matching those of the image at path
314      * is provided.
325     /**
326      * A method for getting the dimensions of an image at the given path
327      *
328      * @param path The path where the image is stored
329      * @return an array containing the dimensions of the image in the form {width, height}
330      */
331     private int[] getDimensions(String path) throws FileNotFoundException {
332         final BitmapFactory.Options decodeBoundsOptions = getOptions();
333         decodeBoundsOptions.inJustDecodeBounds = true;
334         decodeStream(path, decodeBoundsOptions);
335         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
336     }
337 
351     private Bitmap decodeStream(String path, BitmapFactory.Options decodeBitmapOptions) throws FileNotFoundException {
352         RecyclableBufferedInputStream is = null;
353         Bitmap result = null;
354         try {
355             byte[] bytes = getTempBytes();
356             is = new RecyclableBufferedInputStream(new FileInputStream(path), bytes);
357             result = decodeStream(is, decodeBitmapOptions);
358             releaseTempBytes(bytes);
359         } finally {
360             if (is != null) {
361                 try {
362                     is.close();
363                 } catch (IOException e) {
364                     e.printStackTrace();
365                 }
366             }
367         }
368         return result;
369     }
370 ",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,ea1722f9a4fd091493a4eb6e9d7b106df5e33dd3,2eeb841d3f04c79d10517195318a93ac4056c86f,"Fix mark position causing gcs

if mark position > bytes size, the input stream 
will eventually allocate a new buffer up to the 
mark position. This prevents those extra 
allocations.","@@ -23,8 +23,8 @@ import java.util.Queue;
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
-    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
-    private static final int MARK_POSITION = 1024 * 1024; //1mb
+    private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
+    private static final int MARK_POSITION = TEMP_BYTES_SIZE;//1024 * 1024; //1mb
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final BitmapPool bitmapPool;
","26     private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
27     private static final int MARK_POSITION = TEMP_BYTES_SIZE;//1024 * 1024; //1mb
26     private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
27     private static final int MARK_POSITION = 1024 * 1024; //1mb",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,3f76d6881419600d6721d51730701c86362d528a,ea1722f9a4fd091493a4eb6e9d7b106df5e33dd3,Stop load in ImagePresenter if id or opener = null,"@@ -314,7 +314,7 @@ public class ImagePresenter<T> {
         modelStreamToken = modelStreamLoader.fetchModelStream(model, width, height, new ModelStreamLoader.ModelStreamReadyCallback() {
             @Override
             public boolean onStreamReady(String id, StreamOpener streamOpener) {
-                if (loadCount != currentCount) return false;
+                if (loadCount != currentCount || id == null || streamOpener == null) return false;
                 fetchImage(model, id, streamOpener, width, height, loadCount);
 
                 return true;
","317                 if (loadCount != currentCount || id == null || streamOpener == null) return false;
317                 if (loadCount != currentCount) return false;",No
library\src\com\bumptech\glide\loader\opener\FileInputStreamOpener.java,library\src\com\bumptech\glide\loader\opener\FileInputStreamOpener.java,bf40ba3600e6204efe8870fbf1f065519f1478a5,3f76d6881419600d6721d51730701c86362d528a,Lazily create files from paths in FileOpener,"@@ -14,18 +14,21 @@ import java.io.InputStream;
  */
 public class FileInputStreamOpener implements StreamOpener {
     private final File file;
+    private final String path;
 
     public FileInputStreamOpener(String path) {
-        this(new File(path));
+        this.path = path;
+        this.file = null;
     }
 
     public FileInputStreamOpener(File file) {
         this.file = file;
+        this.path = null;
     }
 
     @Override
     public InputStream openStream() throws IOException {
-        return new FileInputStream(file);
+        return new FileInputStream(file != null ? file : new File(path));
     }
 
     @Override
","17     private final String path;
20         this.path = path;
21         this.file = null;
26         this.path = null;
31         return new FileInputStream(file != null ? file : new File(path));
19         this(new File(path));
28         return new FileInputStream(file);",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,9c3d34adfd233c305e878b53238e9cbbcbf11271,bf40ba3600e6204efe8870fbf1f065519f1478a5,"Fix extra allocations when marklimit > buffer size

BufferedInputStream would double the buffer size
each time it read from the input stream if
mark limit > buffer size, including the first time
before any data is read. This change prevents the
buffer size from being increased until after at
least one buffer worth of data is read. In turn
this reduces gcs with a large mark limit relative
to the buffer size.","@@ -239,6 +239,7 @@ public class ImageResizer {
         try {
             if (decodeBitmapOptions.inJustDecodeBounds) {
                 bis.reset();
+                bis.clearMark();
             } else {
                 bis.close();
             }
",242                 bis.clearMark();,No
library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,9c3d34adfd233c305e878b53238e9cbbcbf11271,bf40ba3600e6204efe8870fbf1f065519f1478a5,"Fix extra allocations when marklimit > buffer size

BufferedInputStream would double the buffer size
each time it read from the input stream if
mark limit > buffer size, including the first time
before any data is read. This change prevents the
buffer size from being increased until after at
least one buffer worth of data is read. In turn
this reduces gcs with a large mark limit relative
to the buffer size.","@@ -160,7 +160,11 @@ public class RecyclableBufferedInputStream extends FilterInputStream {
             }
             return result;
         }
-        if (markpos == 0 && marklimit > localBuf.length) {
+        //Added count != 0 so that we do not immediately double the buffer size before reading any data when
+        //marklimit > localBuf.length. Instead, we will double the buffer size only after reading the initial localBuf
+        //worth of data without finding what we're looking for in the stream. This allows us to set a relatively small
+        //initial buffer size and a large marklimit for safety without causing an allocation each time read is called.
+        if (markpos == 0 && marklimit > localBuf.length && count != 0) {
             /* Increase buffer size to accommodate the readlimit */
             int newLength = localBuf.length * 2;
             if (newLength > marklimit) {
@@ -206,6 +210,11 @@ public class RecyclableBufferedInputStream extends FilterInputStream {
         markpos = pos;
     }
 
+    public synchronized void clearMark() {
+        markpos = -1;
+        marklimit = 0;
+    }
+
     /**
      * Indicates whether {@code BufferedInputStream} supports the {@code mark()}
      * and {@code reset()} methods.
","163         //Added count != 0 so that we do not immediately double the buffer size before reading any data when
164         //marklimit > localBuf.length. Instead, we will double the buffer size only after reading the initial localBuf
165         //worth of data without finding what we're looking for in the stream. This allows us to set a relatively small
166         //initial buffer size and a large marklimit for safety without causing an allocation each time read is called.
167         if (markpos == 0 && marklimit > localBuf.length && count != 0) {
213     public synchronized void clearMark() {
214         markpos = -1;
215         marklimit = 0;
216     }
217 
163         if (markpos == 0 && marklimit > localBuf.length) {",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,ae2325db98f6703cae43c256c047c7a01bc787dc,9c3d34adfd233c305e878b53238e9cbbcbf11271,"Add a default exception handler to log exceptions

previously they were caught silently","@@ -15,6 +15,7 @@ import android.widget.ImageView;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.ModelStreamLoader;
 import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.util.Log;
 
 import java.lang.ref.WeakReference;
 
@@ -46,7 +47,26 @@ public class ImagePresenter<T> {
         private ImageSetCallback imageSetCallback;
         private ImagePresenterCoordinator coordinator;
         private ImageLoader imageLoader;
-        private ExceptionHandler<T> exceptionHandler;
+        private ExceptionHandler<T> exceptionHandler = new ExceptionHandler<T>() {
+            @Override
+            public void onImageLoadException(Exception e, T model, boolean isCurrent) {
+                if (e != null) {
+                    e.printStackTrace();
+                } else {
+                    Log.e(""IP: onImageLoadException model= "" + model);
+                }
+            }
+
+            @Override
+            public void onModelStreamLoadException(Exception e, T model, boolean isCurrent) {
+                if (e != null) {
+                    e.printStackTrace();
+                } else {
+                    Log.e(""IP: onModelStreamLoadException model= "" + model);
+                }
+            }
+        };
+
         private ModelStreamLoader<T> modelStreamLoader;
 
         /**
","18 import com.bumptech.glide.util.Log;
50         private ExceptionHandler<T> exceptionHandler = new ExceptionHandler<T>() {
51             @Override
52             public void onImageLoadException(Exception e, T model, boolean isCurrent) {
53                 if (e != null) {
54                     e.printStackTrace();
55                 } else {
56                     Log.e(""IP: onImageLoadException model= "" + model);
57                 }
58             }
59 
60             @Override
61             public void onModelStreamLoadException(Exception e, T model, boolean isCurrent) {
62                 if (e != null) {
63                     e.printStackTrace();
64                 } else {
65                     Log.e(""IP: onModelStreamLoadException model= "" + model);
66                 }
67             }
68         };
69 
49         private ExceptionHandler<T> exceptionHandler;",No
,library\src\com\bumptech\glide\resize\bitmap_recycle\SizedBitmapPool.java,ccadf8dc72fca1321df26468658cbdcec519df90,ae2325db98f6703cae43c256c047c7a01bc787dc,Add memory limited bitmap pool,"@@ -0,0 +1,103 @@
+package com.bumptech.glide.resize.bitmap_recycle;
+
+import android.graphics.Bitmap;
+import com.bumptech.glide.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/10/13
+ * Time: 1:47 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class SizedBitmapPool implements BitmapPool {
+    private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();
+    //Typically there should only be a handful of keys (often 1 or 2) so
+    //iterating over this list should be fast
+    private final LinkedList<Integer> keys = new LinkedList<Integer>();
+
+    private final int maxSize;
+    private int currentSize = 0;
+
+    public SizedBitmapPool(int maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    @Override
+    public synchronized boolean put(Bitmap bitmap) {
+        final int key = getKey(bitmap);
+        final int size = getSize(bitmap);
+
+        ArrayList<Bitmap> bitmaps = pool.get(key);
+        if (bitmaps == null) {
+            bitmaps = new ArrayList<Bitmap>();
+            pool.put(key, bitmaps);
+        } else {
+            removeKey(key);
+        }
+        keys.addFirst(key);
+        currentSize += size;
+
+        bitmaps.add(bitmap);
+
+        maybeEvict();
+
+        return true;
+    }
+
+    private void maybeEvict() {
+        while (currentSize > maxSize) {
+            final Integer key = keys.getLast();
+            List<Bitmap> toRemove = pool.get(key);
+            while (toRemove.size() > 0 && currentSize > maxSize) {
+                Bitmap removed = toRemove.remove(toRemove.size()-1);
+                currentSize -= getSize(removed);
+            }
+            if (toRemove.size() == 0) {
+                removeKey(key);
+            }
+        }
+    }
+
+    @Override
+    public synchronized Bitmap get(int width, int height) {
+        final int key = getKey(width, height);
+        final ArrayList<Bitmap> list = pool.get(key);
+        final Bitmap result;
+        if (list != null && list.size() > 0) {
+            result = list.remove(list.size()-1); //most efficient to remove from the end of an ArrayList
+            currentSize -= getSize(result);
+            removeKey(key);
+            if (list.size() > 0) {
+                keys.addFirst(key);
+            }
+        } else {
+            Log.d(""SBP: missing bitmap for width="" + width + "" height="" + height);
+            result = null;
+        }
+        return result;
+    }
+
+    //keys.remove(int) -> remove index int, not object int :(
+    private void removeKey(int key) {
+        keys.remove(new Integer(key));
+    }
+
+    private int getKey(Bitmap bitmap) {
+        return getKey(bitmap.getWidth(), bitmap.getHeight());
+    }
+
+    private int getKey(int width, int height) {
+        return width >= height ? width * width + width + height : width + height * height;
+   }
+
+    private int getSize(Bitmap bitmap) {
+        return bitmap.getHeight() * bitmap.getRowBytes();
+    }
+}
","1 package com.bumptech.glide.resize.bitmap_recycle;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.glide.util.Log;
5 
6 import java.util.ArrayList;
7 import java.util.HashMap;
8 import java.util.LinkedList;
9 import java.util.List;
10 import java.util.Map;
11 
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 7/10/13
16  * Time: 1:47 PM
17  * To change this template use File | Settings | File Templates.
18  */
19 public class SizedBitmapPool implements BitmapPool {
20     private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();
21     //Typically there should only be a handful of keys (often 1 or 2) so
22     //iterating over this list should be fast
23     private final LinkedList<Integer> keys = new LinkedList<Integer>();
24 
25     private final int maxSize;
26     private int currentSize = 0;
27 
28     public SizedBitmapPool(int maxSize) {
29         this.maxSize = maxSize;
30     }
31 
32     @Override
33     public synchronized boolean put(Bitmap bitmap) {
34         final int key = getKey(bitmap);
35         final int size = getSize(bitmap);
36 
37         ArrayList<Bitmap> bitmaps = pool.get(key);
38         if (bitmaps == null) {
39             bitmaps = new ArrayList<Bitmap>();
40             pool.put(key, bitmaps);
41         } else {
42             removeKey(key);
43         }
44         keys.addFirst(key);
45         currentSize += size;
46 
47         bitmaps.add(bitmap);
48 
49         maybeEvict();
50 
51         return true;
52     }
53 
54     private void maybeEvict() {
55         while (currentSize > maxSize) {
56             final Integer key = keys.getLast();
57             List<Bitmap> toRemove = pool.get(key);
58             while (toRemove.size() > 0 && currentSize > maxSize) {
59                 Bitmap removed = toRemove.remove(toRemove.size()-1);
60                 currentSize -= getSize(removed);
61             }
62             if (toRemove.size() == 0) {
63                 removeKey(key);
64             }
65         }
66     }
67 
68     @Override
69     public synchronized Bitmap get(int width, int height) {
70         final int key = getKey(width, height);
71         final ArrayList<Bitmap> list = pool.get(key);
72         final Bitmap result;
73         if (list != null && list.size() > 0) {
74             result = list.remove(list.size()-1); //most efficient to remove from the end of an ArrayList
75             currentSize -= getSize(result);
76             removeKey(key);
77             if (list.size() > 0) {
78                 keys.addFirst(key);
79             }
80         } else {
81             Log.d(""SBP: missing bitmap for width="" + width + "" height="" + height);
82             result = null;
83         }
84         return result;
85     }
86 
87     //keys.remove(int) -> remove index int, not object int :(
88     private void removeKey(int key) {
89         keys.remove(new Integer(key));
90     }
91 
92     private int getKey(Bitmap bitmap) {
93         return getKey(bitmap.getWidth(), bitmap.getHeight());
94     }
95 
96     private int getKey(int width, int height) {
97         return width >= height ? width * width + width + height : width + height * height;
98    }
99 
100     private int getSize(Bitmap bitmap) {
101         return bitmap.getHeight() * bitmap.getRowBytes();
102     }
103 }",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,9af835b6ca34692bbf437ec1ac0f0222db3232b9,ccadf8dc72fca1321df26468658cbdcec519df90,"Default to SizedBitmapPool

Also unify builder interface re bitmap pool so
it matches memory and disk cache (either default,
an implementation, or disabled)","@@ -14,10 +14,11 @@ import android.os.Handler;
 import android.os.HandlerThread;
 import com.bumptech.glide.loader.opener.StreamOpener;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
-import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapPool;
 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
+import com.bumptech.glide.resize.bitmap_recycle.SizedBitmapPool;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
@@ -152,9 +153,10 @@ public class ImageManager {
 
         private Bitmap.CompressFormat bitmapCompressFormat = Bitmap.CompressFormat.JPEG;
         private boolean recycleBitmaps = CAN_RECYCLE;
-        private int maxBitmapsPerSize = 20;
 
         public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();
+        private BitmapPool bitmapPool;
+        private BitmapReferenceCounter bitmapReferenceCounter;
 
         /**
          * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
@@ -164,6 +166,9 @@ public class ImageManager {
          */
         public Builder(Context context) {
             this.context = context;
+            if (!CAN_RECYCLE) {
+                bitmapPool = new BitmapPoolAdapter();
+            }
         }
 
         /**
@@ -206,15 +211,26 @@ public class ImageManager {
         }
 
         /**
-         * Set whether or not to recycle bitmaps. Defaults to enabled. If enabled, devices with SDK < 11 will not
-         * recycle bitmaps while those with SDK >= 11 will recycle bitmaps. See also
-         * {@link ImageManager.Builder#setMaxBitmapsPerSize(int)}
+         * Set the implementation of a {@link BitmapPool} to use to store and retrieve recycled bitmaps based on their
+         * width and height. Should be thread safe and size limited in some way to avoid OOM exceptions.
          *
-         * @param recycleBitmaps True to enable recycling bitmaps, false otherwise.
+         * @param bitmapPool The BitmapPool implementation to use
          * @return This Builder
          */
-        public Builder setRecycleBitmaps(boolean recycleBitmaps) {
-            this.recycleBitmaps = recycleBitmaps && CAN_RECYCLE;
+        public Builder setBitmapPool(BitmapPool bitmapPool) {
+            if (CAN_RECYCLE) {
+                this.bitmapPool = bitmapPool;
+            }
+            return this;
+        }
+
+        /**
+         * Call to prevent the ImageManager from recycling bitmaps.
+         *
+         * @return This Builder
+         */
+        public Builder disableBitmapRecycling() {
+            recycleBitmaps = false;
             return this;
         }
 
@@ -259,21 +275,6 @@ public class ImageManager {
             return setDiskCache(new DiskCacheAdapter());
         }
 
-        /**
-         * Set the maximum number of bitmaps for a given size to store in memory at one time. Defaults to 20. The larger
-         * the number, the more memory will be used to store recycled bitmaps but the smoother scrolling will be. Set
-         * this * number larger when loading lots of smaller photos and/or when you expect your users to scroll rapidly.
-         * Set this number smaller when loading larger images and/or a lot of different sizes of images and/or when you
-         * expect your users to scroll relatively slowly.
-         *
-         * @param maxBitmapsPerSize The maximum number of bitmaps of any given size to keep in the recycle pool
-         * @return This Builder
-         */
-        public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
-            this.maxBitmapsPerSize = maxBitmapsPerSize;
-            return this;
-        }
-
         private void setDefaults() {
             if (resizeService == null) {
                 resizeService = Executors.newFixedThreadPool(Math.max(1, Runtime.getRuntime().availableProcessors()), new ThreadFactory() {
@@ -293,6 +294,16 @@ public class ImageManager {
             if (diskCache == null) {
                 diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
             }
+
+            if (!recycleBitmaps) {
+                bitmapPool = new BitmapPoolAdapter();
+                bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
+            } else {
+                if (bitmapPool == null) {
+                    bitmapPool = new SizedBitmapPool(getSafeMemoryCacheSize(context));
+                }
+                bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool);
+            }
         }
     }
 
@@ -304,23 +315,15 @@ public class ImageManager {
         bitmapCompressFormat = builder.bitmapCompressFormat;
         memoryCache = builder.memoryCache;
         diskCache = builder.diskCache;
+        bitmapReferenceCounter = builder.bitmapReferenceCounter;
+        resizer = new ImageResizer(builder.bitmapPool, builder.decodeBitmapOptions);
 
-        final BitmapPool bitmapPool;
-        if (builder.recycleBitmaps) {
         memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
             @Override
             public void onImageRemoved(Bitmap removed) {
                 releaseBitmap(removed);
             }
         });
-            bitmapPool = new ConcurrentBitmapPool(builder.maxBitmapsPerSize);
-            bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, builder.maxBitmapsPerSize);
-        } else {
-            bitmapPool = null;
-            bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
-        }
-
-        this.resizer = new ImageResizer(bitmapPool, builder.decodeBitmapOptions);
     }
 
     /**
","17 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
21 import com.bumptech.glide.resize.bitmap_recycle.SizedBitmapPool;
158         private BitmapPool bitmapPool;
159         private BitmapReferenceCounter bitmapReferenceCounter;
169             if (!CAN_RECYCLE) {
170                 bitmapPool = new BitmapPoolAdapter();
171             }
214          * Set the implementation of a {@link BitmapPool} to use to store and retrieve recycled bitmaps based on their
215          * width and height. Should be thread safe and size limited in some way to avoid OOM exceptions.
217          * @param bitmapPool The BitmapPool implementation to use
220         public Builder setBitmapPool(BitmapPool bitmapPool) {
221             if (CAN_RECYCLE) {
222                 this.bitmapPool = bitmapPool;
223             }
224             return this;
225         }
226 
227         /**
228          * Call to prevent the ImageManager from recycling bitmaps.
229          *
230          * @return This Builder
231          */
232         public Builder disableBitmapRecycling() {
233             recycleBitmaps = false;
297 
298             if (!recycleBitmaps) {
299                 bitmapPool = new BitmapPoolAdapter();
300                 bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
301             } else {
302                 if (bitmapPool == null) {
303                     bitmapPool = new SizedBitmapPool(getSafeMemoryCacheSize(context));
304                 }
305                 bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool);
306             }
318         bitmapReferenceCounter = builder.bitmapReferenceCounter;
319         resizer = new ImageResizer(builder.bitmapPool, builder.decodeBitmapOptions);
19 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapPool;
155         private int maxBitmapsPerSize = 20;
209          * Set whether or not to recycle bitmaps. Defaults to enabled. If enabled, devices with SDK < 11 will not
210          * recycle bitmaps while those with SDK >= 11 will recycle bitmaps. See also
211          * {@link ImageManager.Builder#setMaxBitmapsPerSize(int)}
213          * @param recycleBitmaps True to enable recycling bitmaps, false otherwise.
216         public Builder setRecycleBitmaps(boolean recycleBitmaps) {
217             this.recycleBitmaps = recycleBitmaps && CAN_RECYCLE;
262         /**
263          * Set the maximum number of bitmaps for a given size to store in memory at one time. Defaults to 20. The larger
264          * the number, the more memory will be used to store recycled bitmaps but the smoother scrolling will be. Set
265          * this * number larger when loading lots of smaller photos and/or when you expect your users to scroll rapidly.
266          * Set this number smaller when loading larger images and/or a lot of different sizes of images and/or when you
267          * expect your users to scroll relatively slowly.
268          *
269          * @param maxBitmapsPerSize The maximum number of bitmaps of any given size to keep in the recycle pool
270          * @return This Builder
271          */
272         public Builder setMaxBitmapsPerSize(int maxBitmapsPerSize) {
273             this.maxBitmapsPerSize = maxBitmapsPerSize;
274             return this;
275         }
276 
308         final BitmapPool bitmapPool;
309         if (builder.recycleBitmaps) {
316             bitmapPool = new ConcurrentBitmapPool(builder.maxBitmapsPerSize);
317             bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool, builder.maxBitmapsPerSize);
318         } else {
319             bitmapPool = null;
320             bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
321         }
322 
323         this.resizer = new ImageResizer(bitmapPool, builder.decodeBitmapOptions);",No
library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,9af835b6ca34692bbf437ec1ac0f0222db3232b9,ccadf8dc72fca1321df26468658cbdcec519df90,"Default to SizedBitmapPool

Also unify builder interface re bitmap pool so
it matches memory and disk cache (either default,
an implementation, or disabled)","@@ -64,9 +64,9 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
     private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {
+    public ConcurrentBitmapReferenceCounter(BitmapPool target) {
         this.target = target;
-        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 12);
+        counter = new ConcurrentHashMap<Integer, InnerTracker>();
     }
 
     @Override
","67     public ConcurrentBitmapReferenceCounter(BitmapPool target) {
69         counter = new ConcurrentHashMap<Integer, InnerTracker>();
67     public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {
69         counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 12);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,9af835b6ca34692bbf437ec1ac0f0222db3232b9,ccadf8dc72fca1321df26468658cbdcec519df90,"Default to SizedBitmapPool

Also unify builder interface re bitmap pool so
it matches memory and disk cache (either default,
an implementation, or disabled)","@@ -49,7 +49,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
         imageManager = new ImageManager.Builder(this)
                 .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))
-                .setMaxBitmapsPerSize(40)
                 .build();
 
         final Resources res = getResources();
",52                 .setMaxBitmapsPerSize(40),No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,924d7d1fe10924e1a56bf00e84910eb658de4fbf,9af835b6ca34692bbf437ec1ac0f0222db3232b9,SizedBitmapPool -> LruBitmapPool,"@@ -18,7 +18,7 @@ import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
-import com.bumptech.glide.resize.bitmap_recycle.SizedBitmapPool;
+import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
@@ -300,7 +300,7 @@ public class ImageManager {
                 bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
             } else {
                 if (bitmapPool == null) {
-                    bitmapPool = new SizedBitmapPool(getSafeMemoryCacheSize(context));
+                    bitmapPool = new LruBitmapPool(getSafeMemoryCacheSize(context));
                 }
                 bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool);
             }
","21 import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
303                     bitmapPool = new LruBitmapPool(getSafeMemoryCacheSize(context));
21 import com.bumptech.glide.resize.bitmap_recycle.SizedBitmapPool;
303                     bitmapPool = new SizedBitmapPool(getSafeMemoryCacheSize(context));",No
library\src\com\bumptech\glide\resize\bitmap_recycle\SizedBitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\LruBitmapPool.java,924d7d1fe10924e1a56bf00e84910eb658de4fbf,9af835b6ca34692bbf437ec1ac0f0222db3232b9,SizedBitmapPool -> LruBitmapPool,"@@ -16,7 +16,7 @@ import java.util.Map;
  * Time: 1:47 PM
  * To change this template use File | Settings | File Templates.
  */
-public class SizedBitmapPool implements BitmapPool {
+public class LruBitmapPool implements BitmapPool {
     private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();
     //Typically there should only be a handful of keys (often 1 or 2) so
     //iterating over this list should be fast
@@ -25,7 +25,7 @@ public class SizedBitmapPool implements BitmapPool {
     private final int maxSize;
     private int currentSize = 0;
 
-    public SizedBitmapPool(int maxSize) {
+    public LruBitmapPool(int maxSize) {
         this.maxSize = maxSize;
     }
 
@@ -78,7 +78,7 @@ public class SizedBitmapPool implements BitmapPool {
                 keys.addFirst(key);
             }
         } else {
-            Log.d(""SBP: missing bitmap for width="" + width + "" height="" + height);
+            Log.d(""LBP: missing bitmap for width="" + width + "" height="" + height);
             result = null;
         }
         return result;
","19 public class LruBitmapPool implements BitmapPool {
28     public LruBitmapPool(int maxSize) {
81             Log.d(""LBP: missing bitmap for width="" + width + "" height="" + height);
19 public class SizedBitmapPool implements BitmapPool {
28     public SizedBitmapPool(int maxSize) {
81             Log.d(""SBP: missing bitmap for width="" + width + "" height="" + height);",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,c5d8fb140b19287943a0b67d7a766f51178d3813,924d7d1fe10924e1a56bf00e84910eb658de4fbf,"do bitmap ref management on a bg thread

Reduces the number of locks the main thread needs
to acquire and the amount of time they need to be
held (as well as the contention for said locks)","@@ -433,8 +433,13 @@ public class ImageManager {
      * @param b The rejected Bitmap
      */
     public void rejectBitmap(final Bitmap b) {
+        bgHandler.post(new Runnable() {
+            @Override
+            public void run() {
                 bitmapReferenceCounter.rejectBitmap(b);
             }
+        });
+    }
 
     /**
      * Notify the ImageManager that a Bitmap it loaded is going to be used and increment the reference counter for that
@@ -444,9 +449,14 @@ public class ImageManager {
      *
      * @param b The acquired Bitmap
      */
-    public void acquireBitmap(Bitmap b) {
+    public void acquireBitmap(final Bitmap b) {
+        bgHandler.post(new Runnable() {
+            @Override
+            public void run() {
                 bitmapReferenceCounter.acquireBitmap(b);
             }
+        });
+    }
 
     /**
      * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
@@ -457,8 +467,13 @@ public class ImageManager {
      * @param b The releasedBitmap
      */
     public void releaseBitmap(final Bitmap b) {
+        bgHandler.post(new Runnable() {
+            @Override
+            public void run() {
                 bitmapReferenceCounter.releaseBitmap(b);
             }
+        });
+    }
 
     /**
      * Cancel the task represented by the given token. If token is null this call will be ignored.
","436         bgHandler.post(new Runnable() {
437             @Override
438             public void run() {
441         });
442     }
452     public void acquireBitmap(final Bitmap b) {
453         bgHandler.post(new Runnable() {
454             @Override
455             public void run() {
458         });
459     }
470         bgHandler.post(new Runnable() {
471             @Override
472             public void run() {
475         });
476     }
447     public void acquireBitmap(Bitmap b) {",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,263522db1736bf9a60367cd5456689ce079ccb68,c5d8fb140b19287943a0b67d7a766f51178d3813,Update mark limit and buffer size in ImageResizer,"@@ -23,8 +23,8 @@ import java.util.Queue;
  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
  */
 public class ImageResizer {
-    private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
-    private static final int MARK_POSITION = TEMP_BYTES_SIZE;//1024 * 1024; //1mb
+    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
+    private static final int MARK_POSITION = 1024 * 1024; //1mb
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final BitmapPool bitmapPool;
","26     private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
27     private static final int MARK_POSITION = 1024 * 1024; //1mb
26     private static final int TEMP_BYTES_SIZE = 32 * 1024; //32kb
27     private static final int MARK_POSITION = TEMP_BYTES_SIZE;//1024 * 1024; //1mb",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,a4c32099c4041260ce386e9ec8d6f454387d2ee4,263522db1736bf9a60367cd5456689ce079ccb68,Simplify getPhotoCacheDir in ImageManager,"@@ -105,7 +105,7 @@ public class ImageManager {
      * @return A File representing the default disk cache directory
      */
     public static File getPhotoCacheDir(Context context, String cacheName) {
-        String cachePath = null;
+        File cacheDir = null;
 
         Boolean isExternalStorageRemoveable = null;
         if (Build.VERSION.SDK_INT >= 9) {
@@ -115,28 +115,16 @@ public class ImageManager {
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
                 (isExternalStorageRemoveable != null && !isExternalStorageRemoveable)) {
             //seems like this can still be null even if the above are true
-            final File externalCacheDir = context.getExternalCacheDir();
-            if (externalCacheDir != null) {
-                cachePath = externalCacheDir.getPath();
-            } else {
-                Log.e(""IM: external cache dir is null"");
-            }
+            cacheDir = context.getExternalCacheDir();
         }
 
-        if (cachePath == null) {
-            final File internalCacheDir = context.getCacheDir();
-            if (internalCacheDir != null) {
-                cachePath = internalCacheDir.getPath();
-            } else {
-                Log.e(""IM: internal cache dir is null"");
-            }
+        if (cacheDir == null) {
+            cacheDir = context.getCacheDir();
         }
 
-        if (cachePath != null) {
-            File result = new File(cachePath + File.separatorChar + cacheName);
-            if (!result.exists()) {
-                result.mkdir();
-            }
+        if (cacheDir != null) {
+            File result = new File(cacheDir, cacheName);
+            result.mkdirs();
             return result;
         } else {
             Log.d(""IM: default disk cache dir is null"");
","108         File cacheDir = null;
118             cacheDir = context.getExternalCacheDir();
121         if (cacheDir == null) {
122             cacheDir = context.getCacheDir();
125         if (cacheDir != null) {
126             File result = new File(cacheDir, cacheName);
127             result.mkdirs();
108         String cachePath = null;
118             final File externalCacheDir = context.getExternalCacheDir();
119             if (externalCacheDir != null) {
120                 cachePath = externalCacheDir.getPath();
121             } else {
122                 Log.e(""IM: external cache dir is null"");
123             }
126         if (cachePath == null) {
127             final File internalCacheDir = context.getCacheDir();
128             if (internalCacheDir != null) {
129                 cachePath = internalCacheDir.getPath();
130             } else {
131                 Log.e(""IM: internal cache dir is null"");
132             }
135         if (cachePath != null) {
136             File result = new File(cachePath + File.separatorChar + cacheName);
137             if (!result.exists()) {
138                 result.mkdir();
139             }",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,a4c32099c4041260ce386e9ec8d6f454387d2ee4,"Allow DiskLruCacheWrapper to throw IOException

Allows us to log and monitor the exception as well
as forcing us to handle the default case","@@ -280,7 +280,13 @@ public class ImageManager {
             }
 
             if (diskCache == null) {
+                try {
                     diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
+                } catch (IOException e) {
+                    //this is probably a corrupt or full sd card, so default to not using a disk cache
+                    e.printStackTrace();
+                    diskCache = new DiskCacheAdapter();
+                }
             }
 
             if (!recycleBitmaps) {
","283                 try {
285                 } catch (IOException e) {
286                     //this is probably a corrupt or full sd card, so default to not using a disk cache
287                     e.printStackTrace();
288                     diskCache = new DiskCacheAdapter();
289                 }",No
library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,a4c32099c4041260ce386e9ec8d6f454387d2ee4,"Allow DiskLruCacheWrapper to throw IOException

Allows us to log and monitor the exception as well
as forcing us to handle the default case","@@ -29,13 +29,9 @@ public class DiskLruCacheWrapper implements DiskCache {
         return CACHE;
     }
 
-    public static DiskLruCacheWrapper get(File directory, int maxSize) {
+    public synchronized static DiskCache get(File directory, int maxSize) throws IOException {
         if (WRAPPER == null) {
-            try {
             WRAPPER = new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
         }
         return WRAPPER;
     }
","32     public synchronized static DiskCache get(File directory, int maxSize) throws IOException {
32     public static DiskLruCacheWrapper get(File directory, int maxSize) {
34             try {
36             } catch (IOException e) {
37                 throw new RuntimeException(e);
38             }",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,a4c32099c4041260ce386e9ec8d6f454387d2ee4,"Allow DiskLruCacheWrapper to throw IOException

Allows us to log and monitor the exception as well
as forcing us to handle the default case","@@ -18,17 +18,19 @@ import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.cache.DiskCache;
+import com.bumptech.glide.resize.cache.DiskCacheAdapter;
 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
 import com.bumptech.glide.util.Log;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 public class FlickrSearchActivity extends SherlockFragmentActivity {
     private Api flickerApi;
     private ImageManager imageManager;
-    private File cacheDir;
     private int searchCount = 0;
 
     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
@@ -42,13 +44,18 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.flickr_search_activity);
         String cacheName = ""flickr_cache"";
-        cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
-        if (!cacheDir.exists()) {
-            cacheDir.mkdir();
+        File cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
+
+        DiskCache diskCache;
+        try {
+            diskCache = DiskLruCacheWrapper.get(cacheDir, 50 * 1024 * 1024);
+        } catch (IOException e) {
+            e.printStackTrace();
+            diskCache = new DiskCacheAdapter();
         }
 
         imageManager = new ImageManager.Builder(this)
-                .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))
+                .setDiskCache(diskCache)
                 .build();
 
         final Resources res = getResources();
","21 import com.bumptech.glide.resize.cache.DiskCache;
22 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
27 import java.io.IOException;
47         File cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
48 
49         DiskCache diskCache;
50         try {
51             diskCache = DiskLruCacheWrapper.get(cacheDir, 50 * 1024 * 1024);
52         } catch (IOException e) {
53             e.printStackTrace();
54             diskCache = new DiskCacheAdapter();
58                 .setDiskCache(diskCache)
31     private File cacheDir;
45         cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
46         if (!cacheDir.exists()) {
47             cacheDir.mkdir();
51                 .setDiskCache(DiskLruCacheWrapper.get(ImageManager.getPhotoCacheDir(this), 50 * 1024 * 1024))",No
,library\res\values\ids.xml,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<resources>
+  <item type=""id"" name=""image_presenter_id"" />
+</resources>
\ No newline at end of file
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <item type=""id"" name=""image_presenter_id"" />
4 </resources>",No
,library\src\com\bumptech\glide\Glide.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -0,0 +1,282 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageView;
+import com.bumptech.glide.loader.image.ImageLoader;
+import com.bumptech.glide.loader.model.FileStreamLoader;
+import com.bumptech.glide.loader.model.ModelStreamLoader;
+import com.bumptech.glide.loader.model.UrlStreamLoader;
+import com.bumptech.glide.presenter.ImagePresenter;
+import com.bumptech.glide.presenter.ImageSetCallback;
+import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.loader.Approximate;
+import com.bumptech.glide.resize.loader.CenterCrop;
+import com.bumptech.glide.resize.loader.FitCenter;
+
+import java.io.File;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
+ * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
+ * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
+ * starting point and example. This class is not thread safe.
+ */
+public class Glide {
+    private static final Glide GLIDE = new Glide();
+    private static final Map<Class, ModelStreamLoader> classToModelStream = new HashMap<Class, ModelStreamLoader>() {{
+        put(File.class, new FileStreamLoader());
+        put(URL.class, new UrlStreamLoader());
+    }};
+
+    private ImageManager imageManager;
+
+    public static Glide get() {
+        return GLIDE;
+    }
+
+    protected Glide() { }
+
+    /**
+     * Return the current {@link ImageManager} or create and return a new one if one is not currently set.
+     *
+     * @see #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)
+     * @see #isImageManagerSet()
+     *
+     * @param context Any {@link Context}. This will not be retained passed this call
+     * @return The current ImageManager
+     */
+    public ImageManager getImageManager(Context context) {
+        if (!isImageManagerSet()) {
+            setImageManager(new ImageManager.Builder(context));
+        }
+        return imageManager;
+    }
+
+    /**
+     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
+     * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
+     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)} to set an {@link ImageManager} with
+     * custom options for use with {@link Glide#load(Object)} and/or as an easily accessible singleton.
+     *
+     * @return true iff an {@link ImageManager} is currently set
+     */
+    public boolean isImageManagerSet() {
+        return imageManager != null;
+    }
+
+    /**
+     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
+     *
+     * @param builder The builder that will be used to construct a new ImageManager
+     */
+    public void setImageManager(ImageManager.Builder builder) {
+        setImageManager(builder.build());
+    }
+
+    /**
+     * Set the {@link ImageManager} to use with {@link Glide#load(Object)}. Replaces the current {@link ImageManager}
+     * if one has already been set.
+     *
+     * @see #isImageManagerSet()
+     *
+     * @param imageManager The ImageManager to use
+     */
+    public void setImageManager(ImageManager imageManager) {
+        this.imageManager = imageManager;
+    }
+
+    /**
+     * A builder for a request
+     *
+     * @param <T> The type of the model the request will be built for
+     */
+    public static class HalfRequest<T> {
+        private final T model;
+
+        public HalfRequest(T model) {
+            this.model = model;
+        }
+
+        /**
+         * Build a request object for the given ImageView and model
+         *
+         * @param imageView The ImageView the request will be wrapping
+         * @return A new {@link Request}
+         */
+        public Request<T> into(ImageView imageView) {
+            if (imageView == null) {
+                throw new IllegalArgumentException(""ImageView can't be null"");
+            }
+            return new Request<T>(model, imageView);
+        }
+    }
+
+    /**
+     * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
+     * @param <T> The type of model that will be loaded into the view
+     */
+    public static class Request<T> {
+        private final T model;
+        private final ImageView imageView;
+        private final Context context;
+
+        private ImagePresenter<T> presenter;
+        private ImagePresenter.Builder<T> builder;
+
+        public Request(T model, ImageView imageView) {
+            this.model = model;
+            this.imageView = imageView;
+            this.context = imageView.getContext();
+
+            presenter = (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
+            builder = new ImagePresenter.Builder<T>()
+                    .setImageView(imageView)
+                    .setImageLoader(new Approximate(getImageManager()));
+
+            ModelStreamLoader<T> loader = classToModelStream.get(model.getClass());
+            if (loader != null) {
+                builder.setModelStreamLoader(loader);
+            }
+        }
+
+        /**
+         * Set the {@link ModelStreamLoader} for the model. For URL models, defaults to {@link UrlStreamLoader},
+         * for File models, defaults to {@link FileStreamLoader}.
+         *
+         * @param modelStreamLoader The {@link ModelStreamLoader} to use. Replaces any existing loader
+         * @return This Request
+         */
+        public Request<T> with(ModelStreamLoader<T> modelStreamLoader) {
+            builder.setModelStreamLoader(modelStreamLoader);
+
+            return this;
+        }
+
+        /**
+         * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Replaces any existing resize style
+         *
+         * @return This Request
+         */
+        public Request<T> centerCrop() {
+            return resizeWith(new CenterCrop(getImageManager()));
+        }
+
+        /**
+         * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Replaces any existing resize style
+         *
+         * @return This Request
+         */
+        public Request<T> fitCenter() {
+            return resizeWith(new FitCenter(getImageManager()));
+        }
+
+        /**
+         * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Replaces any existing resize style
+         *
+         * @return This Request
+         */
+        public Request<T> approximate() {
+            return resizeWith(new Approximate(getImageManager()));
+        }
+
+        /**
+         * Set the {@link ImageLoader} to use to load images into memory
+         *
+         * @param imageLoader The {@link ImageLoader} to use
+         * @return This Request
+         */
+        public Request<T> resizeWith(ImageLoader imageLoader) {
+            if (presenter == null) {
+                builder.setImageLoader(imageLoader);
+            }
+
+            return this;
+        }
+
+        /**
+         * Sets an animation to run on the wrapped view when an image load finishes. Will only be run if the image
+         * was loaded asynchronously (ie was not in the memory cache)
+         *
+         * @param animation The Animation to run
+         * @return This Request
+         */
+        public Request<T> animate(final Animation animation) {
+            builder.setImageSetCallback(new ImageSetCallback() {
+                @Override
+                public void onImageSet(ImageView view, boolean fromCache) {
+                    view.clearAnimation();
+
+                    if (!fromCache) {
+                        view.startAnimation(animation);
+                    }
+                }
+            });
+
+            return this;
+        }
+
+        /**
+         * @see #animate(android.view.animation.Animation)
+         *
+         * @param animationId The resource id of the animation to run
+         * @return This Request
+         */
+        public Request<T> animate(int animationId) {
+            return animate(AnimationUtils.loadAnimation(context, animationId));
+        }
+
+        /**
+         * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
+         * the given model
+         *
+         * @see ImagePresenter#setModel(Object)
+         */
+        public void begin() {
+            build();
+            presenter.setModel(model);
+        }
+
+        private ImageManager getImageManager() {
+            return GLIDE.getImageManager(context);
+        }
+
+        /**
+         * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
+         * the view's tag for the id {@code R.id.image_presenter_id}.
+         *
+         * If a Request is completed with replaceAndBuild(), then an ImagePresenter will be created  but the image
+         * load will not actually be started until some subsequent Request is completed with {@link #begin()}
+         */
+        private void build() {
+            if (presenter == null) {
+                presenter = builder.build();
+                imageView.setTag(R.id.image_presenter_id, presenter);
+            }
+        }
+
+
+    }
+
+    /**
+     * Begins constructing a load for a given model.
+     *
+     * @param model The model to loa, must not be null
+     * @param <T> The type of the model to load
+     * @return A an unfinished Request that will be used to construct the components to load the model
+     */
+    public static <T> HalfRequest<T> load(T model) {
+        if (model == null) {
+            throw new IllegalArgumentException(""Model can't be null"");
+        }
+
+        return new HalfRequest<T>(model);
+    }
+}
","1 package com.bumptech.glide;
2 
3 import android.content.Context;
4 import android.view.animation.Animation;
5 import android.view.animation.AnimationUtils;
6 import android.widget.ImageView;
7 import com.bumptech.glide.loader.image.ImageLoader;
8 import com.bumptech.glide.loader.model.FileStreamLoader;
9 import com.bumptech.glide.loader.model.ModelStreamLoader;
10 import com.bumptech.glide.loader.model.UrlStreamLoader;
11 import com.bumptech.glide.presenter.ImagePresenter;
12 import com.bumptech.glide.presenter.ImageSetCallback;
13 import com.bumptech.glide.resize.ImageManager;
14 import com.bumptech.glide.resize.loader.Approximate;
15 import com.bumptech.glide.resize.loader.CenterCrop;
16 import com.bumptech.glide.resize.loader.FitCenter;
17 
18 import java.io.File;
19 import java.net.URL;
20 import java.util.HashMap;
21 import java.util.Map;
22 
23 /**
24  * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
25  * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
26  * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
27  * starting point and example. This class is not thread safe.
28  */
29 public class Glide {
30     private static final Glide GLIDE = new Glide();
31     private static final Map<Class, ModelStreamLoader> classToModelStream = new HashMap<Class, ModelStreamLoader>() {{
32         put(File.class, new FileStreamLoader());
33         put(URL.class, new UrlStreamLoader());
34     }};
35 
36     private ImageManager imageManager;
37 
38     public static Glide get() {
39         return GLIDE;
40     }
41 
42     protected Glide() { }
43 
44     /**
45      * Return the current {@link ImageManager} or create and return a new one if one is not currently set.
46      *
47      * @see #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)
48      * @see #isImageManagerSet()
49      *
50      * @param context Any {@link Context}. This will not be retained passed this call
51      * @return The current ImageManager
52      */
53     public ImageManager getImageManager(Context context) {
54         if (!isImageManagerSet()) {
55             setImageManager(new ImageManager.Builder(context));
56         }
57         return imageManager;
58     }
59 
60     /**
61      * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
62      * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
63      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)} to set an {@link ImageManager} with
64      * custom options for use with {@link Glide#load(Object)} and/or as an easily accessible singleton.
65      *
66      * @return true iff an {@link ImageManager} is currently set
67      */
68     public boolean isImageManagerSet() {
69         return imageManager != null;
70     }
71 
72     /**
73      * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
74      *
75      * @param builder The builder that will be used to construct a new ImageManager
76      */
77     public void setImageManager(ImageManager.Builder builder) {
78         setImageManager(builder.build());
79     }
80 
81     /**
82      * Set the {@link ImageManager} to use with {@link Glide#load(Object)}. Replaces the current {@link ImageManager}
83      * if one has already been set.
84      *
85      * @see #isImageManagerSet()
86      *
87      * @param imageManager The ImageManager to use
88      */
89     public void setImageManager(ImageManager imageManager) {
90         this.imageManager = imageManager;
91     }
92 
93     /**
94      * A builder for a request
95      *
96      * @param <T> The type of the model the request will be built for
97      */
98     public static class HalfRequest<T> {
99         private final T model;
100 
101         public HalfRequest(T model) {
102             this.model = model;
103         }
104 
105         /**
106          * Build a request object for the given ImageView and model
107          *
108          * @param imageView The ImageView the request will be wrapping
109          * @return A new {@link Request}
110          */
111         public Request<T> into(ImageView imageView) {
112             if (imageView == null) {
113                 throw new IllegalArgumentException(""ImageView can't be null"");
114             }
115             return new Request<T>(model, imageView);
116         }
117     }
118 
119     /**
120      * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
121      * @param <T> The type of model that will be loaded into the view
122      */
123     public static class Request<T> {
124         private final T model;
125         private final ImageView imageView;
126         private final Context context;
127 
128         private ImagePresenter<T> presenter;
129         private ImagePresenter.Builder<T> builder;
130 
131         public Request(T model, ImageView imageView) {
132             this.model = model;
133             this.imageView = imageView;
134             this.context = imageView.getContext();
135 
136             presenter = (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
137             builder = new ImagePresenter.Builder<T>()
138                     .setImageView(imageView)
139                     .setImageLoader(new Approximate(getImageManager()));
140 
141             ModelStreamLoader<T> loader = classToModelStream.get(model.getClass());
142             if (loader != null) {
143                 builder.setModelStreamLoader(loader);
144             }
145         }
146 
147         /**
148          * Set the {@link ModelStreamLoader} for the model. For URL models, defaults to {@link UrlStreamLoader},
149          * for File models, defaults to {@link FileStreamLoader}.
150          *
151          * @param modelStreamLoader The {@link ModelStreamLoader} to use. Replaces any existing loader
152          * @return This Request
153          */
154         public Request<T> with(ModelStreamLoader<T> modelStreamLoader) {
155             builder.setModelStreamLoader(modelStreamLoader);
156 
157             return this;
158         }
159 
160         /**
161          * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
162          * Replaces any existing resize style
163          *
164          * @return This Request
165          */
166         public Request<T> centerCrop() {
167             return resizeWith(new CenterCrop(getImageManager()));
168         }
169 
170         /**
171          * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
172          * Replaces any existing resize style
173          *
174          * @return This Request
175          */
176         public Request<T> fitCenter() {
177             return resizeWith(new FitCenter(getImageManager()));
178         }
179 
180         /**
181          * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
182          * Replaces any existing resize style
183          *
184          * @return This Request
185          */
186         public Request<T> approximate() {
187             return resizeWith(new Approximate(getImageManager()));
188         }
189 
190         /**
191          * Set the {@link ImageLoader} to use to load images into memory
192          *
193          * @param imageLoader The {@link ImageLoader} to use
194          * @return This Request
195          */
196         public Request<T> resizeWith(ImageLoader imageLoader) {
197             if (presenter == null) {
198                 builder.setImageLoader(imageLoader);
199             }
200 
201             return this;
202         }
203 
204         /**
205          * Sets an animation to run on the wrapped view when an image load finishes. Will only be run if the image
206          * was loaded asynchronously (ie was not in the memory cache)
207          *
208          * @param animation The Animation to run
209          * @return This Request
210          */
211         public Request<T> animate(final Animation animation) {
212             builder.setImageSetCallback(new ImageSetCallback() {
213                 @Override
214                 public void onImageSet(ImageView view, boolean fromCache) {
215                     view.clearAnimation();
216 
217                     if (!fromCache) {
218                         view.startAnimation(animation);
219                     }
220                 }
221             });
222 
223             return this;
224         }
225 
226         /**
227          * @see #animate(android.view.animation.Animation)
228          *
229          * @param animationId The resource id of the animation to run
230          * @return This Request
231          */
232         public Request<T> animate(int animationId) {
233             return animate(AnimationUtils.loadAnimation(context, animationId));
234         }
235 
236         /**
237          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
238          * the given model
239          *
240          * @see ImagePresenter#setModel(Object)
241          */
242         public void begin() {
243             build();
244             presenter.setModel(model);
245         }
246 
247         private ImageManager getImageManager() {
248             return GLIDE.getImageManager(context);
249         }
250 
251         /**
252          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
253          * the view's tag for the id {@code R.id.image_presenter_id}.
254          *
255          * If a Request is completed with replaceAndBuild(), then an ImagePresenter will be created  but the image
256          * load will not actually be started until some subsequent Request is completed with {@link #begin()}
257          */
258         private void build() {
259             if (presenter == null) {
260                 presenter = builder.build();
261                 imageView.setTag(R.id.image_presenter_id, presenter);
262             }
263         }
264 
265 
266     }
267 
268     /**
269      * Begins constructing a load for a given model.
270      *
271      * @param model The model to loa, must not be null
272      * @param <T> The type of the model to load
273      * @return A an unfinished Request that will be used to construct the components to load the model
274      */
275     public static <T> HalfRequest<T> load(T model) {
276         if (model == null) {
277             throw new IllegalArgumentException(""Model can't be null"");
278         }
279 
280         return new HalfRequest<T>(model);
281     }
282 }",No
,library\src\com\bumptech\glide\loader\model\FileStreamLoader.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -0,0 +1,26 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.opener.FileInputStreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
+
+import java.io.File;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/16/13
+ * Time: 12:50 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class FileStreamLoader extends DirectModelStreamLoader<File> {
+
+    @Override
+    protected StreamOpener getStreamOpener(File model, int width, int height) {
+        return new FileInputStreamOpener(model);
+    }
+
+    @Override
+    protected String getId(File model) {
+        return model.getAbsolutePath();
+    }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.FileInputStreamOpener;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 
6 import java.io.File;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/16/13
12  * Time: 12:50 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class FileStreamLoader extends DirectModelStreamLoader<File> {
16 
17     @Override
18     protected StreamOpener getStreamOpener(File model, int width, int height) {
19         return new FileInputStreamOpener(model);
20     }
21 
22     @Override
23     protected String getId(File model) {
24         return model.getAbsolutePath();
25     }
26 }",No
,library\src\com\bumptech\glide\loader\model\UrlStreamLoader.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -0,0 +1,26 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
+import com.bumptech.glide.loader.opener.StreamOpener;
+
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/16/13
+ * Time: 12:51 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class UrlStreamLoader extends DirectModelStreamLoader<URL> {
+
+    @Override
+    protected StreamOpener getStreamOpener(URL model, int width, int height) {
+        return new HttpInputStreamOpener(model);
+    }
+
+    @Override
+    protected String getId(URL model) {
+        return model.toString();
+    }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 
6 import java.net.URL;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/16/13
12  * Time: 12:51 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class UrlStreamLoader extends DirectModelStreamLoader<URL> {
16 
17     @Override
18     protected StreamOpener getStreamOpener(URL model, int width, int height) {
19         return new HttpInputStreamOpener(model);
20     }
21 
22     @Override
23     protected String getId(URL model) {
24         return model.toString();
25     }
26 }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -12,9 +12,9 @@ import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
-import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.io.File;
@@ -32,13 +32,11 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
     private PhotoAdapter adapter;
     private List<Photo> currentPhotos;
     private Api api;
-    private ImageManager imageManager;
     private File cacheDir;
     private int photoSize;
 
-    public void setup(Api api, ImageManager imageManager, File cacheDir, int photoSize) {
+    public void setup(Api api, File cacheDir, int photoSize) {
         this.api = api;
-        this.imageManager = imageManager;
         this.cacheDir = cacheDir;
         this.photoSize = photoSize;
     }
@@ -105,7 +103,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
                 presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
-                        .setImageLoader(new CenterCrop(imageManager))
+                        .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
","15 import com.bumptech.glide.Glide;
38     public void setup(Api api, File cacheDir, int photoSize) {
106                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
17 import com.bumptech.glide.resize.ImageManager;
35     private ImageManager imageManager;
39     public void setup(Api api, ImageManager imageManager, File cacheDir, int photoSize) {
41         this.imageManager = imageManager;
108                         .setImageLoader(new CenterCrop(imageManager))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -13,9 +13,9 @@ import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
-import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.util.ArrayList;
@@ -31,12 +31,10 @@ import java.util.List;
 public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
     private FlickrPhotoListAdapter adapter;
     private Api api;
-    private ImageManager imageManager;
     private List<Photo> currentPhotos;
 
-    public void setup(Api api, ImageManager imageManager) {
+    public void setup(Api api) {
         this.api = api;
-        this.imageManager = imageManager;
     }
 
     @Override
@@ -106,7 +104,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
                 ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
                         .setModelStreamLoader(new DirectFlickrStreamLoader(api))
-                        .setImageLoader(new CenterCrop(imageManager))
+                        .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
","16 import com.bumptech.glide.Glide;
36     public void setup(Api api) {
107                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
18 import com.bumptech.glide.resize.ImageManager;
34     private ImageManager imageManager;
37     public void setup(Api api, ImageManager imageManager) {
39         this.imageManager = imageManager;
109                         .setImageLoader(new CenterCrop(imageManager))",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,d76f655fc29c5b3858d6657f22a5c656c3143767,4d2a2db41999cb6f2c79a6b63a93ea6e2adc49b9,"Create a simple static interface for Glide

Allows most of the functionality of the library
without having to directly create and manage an
ImageManager and ImagePresenters.

Doesn't currently allow for all functionality and
is somewhat less efficient because it encourages
allocations of unneeded objects, but it is easier
to use and should cover enough cases to be useful.","@@ -17,6 +17,7 @@ import com.actionbarsherlock.app.ActionBar;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
@@ -30,7 +31,6 @@ import java.util.List;
 
 public class FlickrSearchActivity extends SherlockFragmentActivity {
     private Api flickerApi;
-    private ImageManager imageManager;
     private int searchCount = 0;
 
     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
@@ -54,9 +54,11 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             diskCache = new DiskCacheAdapter();
         }
 
-        imageManager = new ImageManager.Builder(this)
-                .setDiskCache(diskCache)
-                .build();
+        final Glide glide = Glide.get();
+        if (!glide.isImageManagerSet()) {
+            glide.setImageManager(new ImageManager.Builder(this)
+                    .setDiskCache(diskCache));
+        }
 
         final Resources res = getResources();
         flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
@@ -104,17 +106,17 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
 
         FlickrPhotoGrid small = new FlickrPhotoGrid();
-        small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
+        small.setup(flickerApi, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
         fragments.add(small);
         photoViewers.add(small);
 
         final FlickrPhotoGrid medium = new FlickrPhotoGrid();
-        medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
+        medium.setup(flickerApi,  cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
         fragments.add(medium);
         photoViewers.add(medium);
 
         FlickrPhotoList list =  new FlickrPhotoList();
-        list.setup(flickerApi, imageManager);
+        list.setup(flickerApi);
         fragments.add(list);
         photoViewers.add(list);
 
","20 import com.bumptech.glide.Glide;
57         final Glide glide = Glide.get();
58         if (!glide.isImageManagerSet()) {
59             glide.setImageManager(new ImageManager.Builder(this)
60                     .setDiskCache(diskCache));
61         }
109         small.setup(flickerApi, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
114         medium.setup(flickerApi,  cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
119         list.setup(flickerApi);
33     private ImageManager imageManager;
57         imageManager = new ImageManager.Builder(this)
58                 .setDiskCache(diskCache)
59                 .build();
107         small.setup(flickerApi, imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
112         medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
117         list.setup(flickerApi, imageManager);",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,e8c751e00464b2d230840b763cdf3fbd06b32264,d76f655fc29c5b3858d6657f22a5c656c3143767,Use the static Glide interface in the flickr demo,"@@ -92,7 +92,8 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
 
         @Override
         public View getView(int position, View view, ViewGroup container) {
-            final ImagePresenter<Photo> presenter;
+            final Photo current = photos.get(position);
+            final ImagePresenter<Photo> imagePresenter;
             if (view == null) {
                 ImageView imageView = (ImageView) inflater.inflate(R.layout.flickr_photo_grid_item, container, false);
                 ViewGroup.LayoutParams params = imageView.getLayoutParams();
@@ -100,7 +101,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
                 params.height = photoSize;
 
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
-                presenter = new ImagePresenter.Builder<Photo>()
+                imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
@@ -108,18 +109,21 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
                                 view.clearAnimation();
-                                if (!fromCache)
+
+                                if (!fromCache) {
                                     view.startAnimation(fadeIn);
                                 }
+                            }
                         })
                         .build();
-                imageView.setTag(presenter);
+
+                imageView.setTag(R.id.image_presenter_id, imagePresenter);
                 view = imageView;
             } else {
-                presenter = (ImagePresenter<Photo>) view.getTag();
+                imagePresenter = (ImagePresenter<Photo>) view.getTag(R.id.image_presenter_id);
             }
 
-            presenter.setModel(photos.get(position));
+            imagePresenter.setModel(current);
             return view;
         }
     }
","95             final Photo current = photos.get(position);
96             final ImagePresenter<Photo> imagePresenter;
104                 imagePresenter = new ImagePresenter.Builder<Photo>()
112 
113                                 if (!fromCache) {
116                             }
119 
120                 imageView.setTag(R.id.image_presenter_id, imagePresenter);
123                 imagePresenter = (ImagePresenter<Photo>) view.getTag(R.id.image_presenter_id);
126             imagePresenter.setModel(current);
95             final ImagePresenter<Photo> presenter;
103                 presenter = new ImagePresenter.Builder<Photo>()
111                                 if (!fromCache)
116                 imageView.setTag(presenter);
119                 presenter = (ImagePresenter<Photo>) view.getTag();
122             presenter.setModel(photos.get(position));",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,e8c751e00464b2d230840b763cdf3fbd06b32264,d76f655fc29c5b3858d6657f22a5c656c3143767,Use the static Glide interface in the flickr demo,"@@ -4,8 +4,6 @@ import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
 import android.widget.BaseAdapter;
 import android.widget.ImageView;
 import android.widget.ListView;
@@ -14,9 +12,6 @@ import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageSetCallback;
-import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -56,11 +51,11 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
     }
 
     private static class ViewHolder {
-        private final ImagePresenter<Photo> presenter;
+        private final ImageView imageView;
         private final TextView titleText;
 
-        public ViewHolder(ImagePresenter<Photo> presenter, TextView titleText) {
-            this.presenter = presenter;
+        public ViewHolder(ImageView imageView, TextView titleText) {
+            this.imageView = imageView;
             this.titleText = titleText;
         }
     }
@@ -85,44 +80,34 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
 
         @Override
         public Object getItem(int i) {
-            return null;  //To change body of implemented methods use File | Settings | File Templates.
+            return null;
         }
 
         @Override
         public long getItemId(int i) {
-            return 0;  //To change body of implemented methods use File | Settings | File Templates.
+            return 0;
         }
 
         @Override
         public View getView(int position, View view, ViewGroup container) {
+            final Photo current = photos.get(position);
             final ViewHolder viewHolder;
             if (view == null) {
                 view = inflater.inflate(R.layout.flickr_photo_list_item, container, false);
                 ImageView imageView = (ImageView) view.findViewById(R.id.photo_view);
-
-                final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
-                ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
-                        .setImageView(imageView)
-                        .setModelStreamLoader(new DirectFlickrStreamLoader(api))
-                        .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
-                        .setImageSetCallback(new ImageSetCallback() {
-                            @Override
-                            public void onImageSet(ImageView view, boolean fromCache) {
-                                view.clearAnimation();
-                                if (!fromCache)
-                                    view.startAnimation(fadeIn);
-                            }
-                        })
-                        .build();
                 TextView titleView = (TextView) view.findViewById(R.id.title_view);
-                viewHolder = new ViewHolder(presenter, titleView);
+                viewHolder = new ViewHolder(imageView, titleView);
                 view.setTag(viewHolder);
             } else {
                 viewHolder = (ViewHolder) view.getTag();
             }
+            Glide.load(current)
+                    .into(viewHolder.imageView)
+                    .with(new DirectFlickrStreamLoader(api))
+                    .centerCrop()
+                    .animate(R.anim.fade_in)
+                    .begin();
 
-            final Photo current = photos.get(position);
-            viewHolder.presenter.setModel(current);
             viewHolder.titleText.setText(current.title);
             return view;
         }
","54         private final ImageView imageView;
57         public ViewHolder(ImageView imageView, TextView titleText) {
58             this.imageView = imageView;
83             return null;
88             return 0;
93             final Photo current = photos.get(position);
99                 viewHolder = new ViewHolder(imageView, titleView);
104             Glide.load(current)
105                     .into(viewHolder.imageView)
106                     .with(new DirectFlickrStreamLoader(api))
107                     .centerCrop()
108                     .animate(R.anim.fade_in)
109                     .begin();
7 import android.view.animation.Animation;
8 import android.view.animation.AnimationUtils;
17 import com.bumptech.glide.presenter.ImagePresenter;
18 import com.bumptech.glide.presenter.ImageSetCallback;
19 import com.bumptech.glide.resize.loader.CenterCrop;
59         private final ImagePresenter<Photo> presenter;
62         public ViewHolder(ImagePresenter<Photo> presenter, TextView titleText) {
63             this.presenter = presenter;
88             return null;  //To change body of implemented methods use File | Settings | File Templates.
93             return 0;  //To change body of implemented methods use File | Settings | File Templates.
102 
103                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
104                 ImagePresenter<Photo> presenter = new ImagePresenter.Builder<Photo>()
105                         .setImageView(imageView)
106                         .setModelStreamLoader(new DirectFlickrStreamLoader(api))
107                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
108                         .setImageSetCallback(new ImageSetCallback() {
109                             @Override
110                             public void onImageSet(ImageView view, boolean fromCache) {
111                                 view.clearAnimation();
112                                 if (!fromCache)
113                                     view.startAnimation(fadeIn);
114                             }
115                         })
116                         .build();
118                 viewHolder = new ViewHolder(presenter, titleView);
124             final Photo current = photos.get(position);
125             viewHolder.presenter.setModel(current);",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,e8c751e00464b2d230840b763cdf3fbd06b32264,d76f655fc29c5b3858d6657f22a5c656c3143767,Use the static Glide interface in the flickr demo,"@@ -158,7 +158,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     @Override
     protected void onDestroy() {
         super.onDestroy();
-        imageManager.shutdown();
+        Glide.getImageManager().shutdown();
     }
 
     private static class TabListener implements ActionBar.TabListener {
","161         Glide.getImageManager().shutdown();
161         imageManager.shutdown();",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,2e20c9010e01a0abe4d87a2b2318dd7591f86a5f,e8c751e00464b2d230840b763cdf3fbd06b32264,Throw an exception if model stream loader not set,"@@ -127,6 +127,7 @@ public class Glide {
 
         private ImagePresenter<T> presenter;
         private ImagePresenter.Builder<T> builder;
+        private ModelStreamLoader<T> modelStreamLoader = null;
 
         public Request(T model, ImageView imageView) {
             this.model = model;
@@ -152,6 +153,7 @@ public class Glide {
          * @return This Request
          */
         public Request<T> with(ModelStreamLoader<T> modelStreamLoader) {
+            this.modelStreamLoader = modelStreamLoader;
             builder.setModelStreamLoader(modelStreamLoader);
 
             return this;
@@ -257,6 +259,10 @@ public class Glide {
          */
         private void build() {
             if (presenter == null) {
+                if (modelStreamLoader == null) {
+                    throw new IllegalArgumentException(""You must set a ModelStreamLoader for model class="" +
+                            model.getClass());
+                }
                 presenter = builder.build();
                 imageView.setTag(R.id.image_presenter_id, presenter);
             }
@@ -268,7 +274,7 @@ public class Glide {
     /**
      * Begins constructing a load for a given model.
      *
-     * @param model The model to loa, must not be null
+     * @param model The model to load, must not be null
      * @param <T> The type of the model to load
      * @return A an unfinished Request that will be used to construct the components to load the model
      */
","130         private ModelStreamLoader<T> modelStreamLoader = null;
156             this.modelStreamLoader = modelStreamLoader;
262                 if (modelStreamLoader == null) {
263                     throw new IllegalArgumentException(""You must set a ModelStreamLoader for model class="" +
264                             model.getClass());
265                 }
277      * @param model The model to load, must not be null
271      * @param model The model to loa, must not be null",No
samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,ee7dd443b1e92a36147f692c4b91b46d8202531a,2e20c9010e01a0abe4d87a2b2318dd7591f86a5f,Cleanup some of the sample app code,"@@ -12,15 +12,10 @@ import com.bumptech.glide.loader.opener.StreamOpener;
  * directly to the disk cache.
  */
 public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
-    private final Api flickrApi;
-
-    public DirectFlickrStreamLoader(Api flickApi) {
-        this.flickrApi = flickApi;
-    }
 
     @Override
     protected StreamOpener getStreamOpener(Photo model, int width, int height) {
-        return new HttpInputStreamOpener(flickrApi.getPhotoURL(width, height, model));
+        return new HttpInputStreamOpener(Api.getPhotoURL(model, width, height));
     }
 
     @Override
","18         return new HttpInputStreamOpener(Api.getPhotoURL(model, width, height));
15     private final Api flickrApi;
16 
17     public DirectFlickrStreamLoader(Api flickApi) {
18         this.flickrApi = flickApi;
19     }
23         return new HttpInputStreamOpener(flickrApi.getPhotoURL(width, height, model));",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,ee7dd443b1e92a36147f692c4b91b46d8202531a,2e20c9010e01a0abe4d87a2b2318dd7591f86a5f,Cleanup some of the sample app code,"@@ -9,7 +9,6 @@ import android.widget.ImageView;
 import android.widget.ListView;
 import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 
@@ -25,13 +24,8 @@ import java.util.List;
  */
 public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
     private FlickrPhotoListAdapter adapter;
-    private Api api;
     private List<Photo> currentPhotos;
 
-    public void setup(Api api) {
-        this.api = api;
-    }
-
     @Override
     public void onPhotosUpdated(List<Photo> photos) {
         currentPhotos = photos;
@@ -101,9 +95,10 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
             } else {
                 viewHolder = (ViewHolder) view.getTag();
             }
+
             Glide.load(current)
                     .into(viewHolder.imageView)
-                    .with(new DirectFlickrStreamLoader(api))
+                    .with(new DirectFlickrStreamLoader())
                     .centerCrop()
                     .animate(R.anim.fade_in)
                     .begin();
","98 
101                     .with(new DirectFlickrStreamLoader())
12 import com.bumptech.flickr.api.Api;
28     private Api api;
31     public void setup(Api api) {
32         this.api = api;
33     }
34 
106                     .with(new DirectFlickrStreamLoader(api))",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,ee7dd443b1e92a36147f692c4b91b46d8202531a,2e20c9010e01a0abe4d87a2b2318dd7591f86a5f,Cleanup some of the sample app code,"@@ -116,7 +116,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         photoViewers.add(medium);
 
         FlickrPhotoList list =  new FlickrPhotoList();
-        list.setup(flickerApi);
         fragments.add(list);
         photoViewers.add(list);
 
@@ -125,7 +124,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
 
         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments));
-
     }
 
     private void executeSearch() {
@@ -155,12 +153,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
     }
 
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        Glide.getImageManager().shutdown();
-    }
-
     private static class TabListener implements ActionBar.TabListener {
         private final ViewPager pager;
 
@@ -190,12 +182,12 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
         @Override
         public Fragment getItem(int i) {
-            return fragments.get(i);  //To change body of implemented methods use File | Settings | File Templates.
+            return fragments.get(i);
         }
 
         @Override
         public int getCount() {
-            return fragments.size();  //To change body of implemented methods use File | Settings | File Templates.
+            return fragments.size();
         }
     }
 }
","185             return fragments.get(i);
190             return fragments.size();
119         list.setup(flickerApi);
128 
158     @Override
159     protected void onDestroy() {
160         super.onDestroy();
161         Glide.getImageManager().shutdown();
162     }
163 
193             return fragments.get(i);  //To change body of implemented methods use File | Settings | File Templates.
198             return fragments.size();  //To change body of implemented methods use File | Settings | File Templates.",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,ee7dd443b1e92a36147f692c4b91b46d8202531a,2e20c9010e01a0abe4d87a2b2318dd7591f86a5f,Cleanup some of the sample app code,"@@ -75,7 +75,7 @@ public class Api {
         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
     }
 
-    public URL getPhotoURL(int width, int height, Photo photo) {
+    public static URL getPhotoURL(Photo photo, int width, int height) {
         try {
             return new URL(getPhotoUrl(photo, getSizeKey(width, height)));
         } catch (MalformedURLException e) {
","78     public static URL getPhotoURL(Photo photo, int width, int height) {
78     public URL getPhotoURL(int width, int height, Photo photo) {",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,ee7dd443b1e92a36147f692c4b91b46d8202531a,"Refactor example to handle fragments correctly

Should fix case where searches would complete
but no photos would be shown","@@ -29,20 +29,29 @@ import java.util.List;
  * To change this template use File | Settings | File Templates.
  */
 public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
+    private static final String CACHE_PATH_KEY = ""cache_path"";
+    private static final String IMAGE_SIZE_KEY = ""image_size"";
+
     private PhotoAdapter adapter;
     private List<Photo> currentPhotos;
-    private Api api;
     private File cacheDir;
     private int photoSize;
 
-    public void setup(Api api, File cacheDir, int photoSize) {
-        this.api = api;
-        this.cacheDir = cacheDir;
-        this.photoSize = photoSize;
+    public static FlickrPhotoGrid newInstance(File cacheDir, int size) {
+        FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
+        Bundle args = new Bundle();
+        args.putString(CACHE_PATH_KEY, cacheDir.getAbsolutePath());
+        args.putInt(IMAGE_SIZE_KEY, size);
+        photoGrid.setArguments(args);
+        return photoGrid;
     }
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        Bundle args = getArguments();
+        cacheDir = new File(args.getString(CACHE_PATH_KEY));
+        photoSize = args.getInt(IMAGE_SIZE_KEY);
+
         final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
         GridView grid = (GridView) result.findViewById(R.id.images);
         grid.setColumnWidth(photoSize);
@@ -103,7 +112,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer{
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))
+                        .setModelStreamLoader(new FlickrStreamLoader(Api.get(getActivity()), cacheDir))
                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
","32     private static final String CACHE_PATH_KEY = ""cache_path"";
33     private static final String IMAGE_SIZE_KEY = ""image_size"";
34 
40     public static FlickrPhotoGrid newInstance(File cacheDir, int size) {
41         FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
42         Bundle args = new Bundle();
43         args.putString(CACHE_PATH_KEY, cacheDir.getAbsolutePath());
44         args.putInt(IMAGE_SIZE_KEY, size);
45         photoGrid.setArguments(args);
46         return photoGrid;
51         Bundle args = getArguments();
52         cacheDir = new File(args.getString(CACHE_PATH_KEY));
53         photoSize = args.getInt(IMAGE_SIZE_KEY);
54 
115                         .setModelStreamLoader(new FlickrStreamLoader(Api.get(getActivity()), cacheDir))
34     private Api api;
38     public void setup(Api api, File cacheDir, int photoSize) {
39         this.api = api;
40         this.cacheDir = cacheDir;
41         this.photoSize = photoSize;
106                         .setModelStreamLoader(new FlickrStreamLoader(api, cacheDir))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,ee7dd443b1e92a36147f692c4b91b46d8202531a,"Refactor example to handle fragments correctly

Should fix case where searches would complete
but no photos would be shown","@@ -26,6 +26,10 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
     private FlickrPhotoListAdapter adapter;
     private List<Photo> currentPhotos;
 
+    public static FlickrPhotoList newInstance() {
+        return new FlickrPhotoList();
+    }
+
     @Override
     public void onPhotosUpdated(List<Photo> photos) {
         currentPhotos = photos;
","29     public static FlickrPhotoList newInstance() {
30         return new FlickrPhotoList();
31     }
32 ",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,ee7dd443b1e92a36147f692c4b91b46d8202531a,"Refactor example to handle fragments correctly

Should fix case where searches would complete
but no photos would be shown","@@ -1,6 +1,5 @@
 package com.bumptech.flickr;
 
-import android.content.res.Resources;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
@@ -27,16 +26,44 @@ import com.bumptech.glide.util.Log;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 public class FlickrSearchActivity extends SherlockFragmentActivity {
-    private Api flickerApi;
     private int searchCount = 0;
-
-    private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
     private EditText searchText;
     private View searching;
     private TextView searchTerm;
+    private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
+    private File cacheDir;
+    private List<Photo> currentPhotos = new ArrayList<Photo>();
+
+    private enum Page {
+        SMALL,
+        MEDIUM,
+        LIST
+    }
+
+    private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {{
+        put(Page.SMALL, R.string.small);
+        put(Page.MEDIUM, R.string.medium);
+        put(Page.LIST, R.string.list);
+    }};
+
+    @Override
+    public void onAttachFragment(Fragment fragment) {
+        super.onAttachFragment(fragment);
+        if (!(fragment instanceof PhotoViewer)) {
+            throw new IllegalStateException(""Fragment class "" + fragment.getClass() + "" does not implement PhotoViewer"");
+        } else {
+            PhotoViewer photoViewer = (PhotoViewer) fragment;
+            photoViewer.onPhotosUpdated(currentPhotos);
+            photoViewers.add(photoViewer);
+        }
+    }
 
     /** Called when the activity is first created. */
     @Override
@@ -44,7 +71,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.flickr_search_activity);
         String cacheName = ""flickr_cache"";
-        File cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
+        cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
 
         DiskCache diskCache;
         try {
@@ -60,9 +87,6 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                     .setDiskCache(diskCache));
         }
 
-        final Resources res = getResources();
-        flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
-
         searching = findViewById(R.id.searching);
         searchTerm = (TextView) findViewById(R.id.search_term);
 
@@ -101,29 +125,16 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             public void onPageScrollStateChanged(int i) { }
         });
 
-        final List<Fragment> fragments = new ArrayList<Fragment>();
+
         final ActionBar actionBar = getSupportActionBar();
         actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
 
-        FlickrPhotoGrid small = new FlickrPhotoGrid();
-        small.setup(flickerApi, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
-        fragments.add(small);
-        photoViewers.add(small);
-
-        final FlickrPhotoGrid medium = new FlickrPhotoGrid();
-        medium.setup(flickerApi,  cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
-        fragments.add(medium);
-        photoViewers.add(medium);
-
-        FlickrPhotoList list =  new FlickrPhotoList();
-        fragments.add(list);
-        photoViewers.add(list);
-
-        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener(pager)));
-        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener(pager)));
-        actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
+        for (Page page : Page.values()) {
+            final int textId = PAGE_TO_TITLE.get(page);
+            actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
+        }
 
-        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments));
+        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
     }
 
     private void executeSearch() {
@@ -137,7 +148,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         searching.setVisibility(View.VISIBLE);
         searchTerm.setText(getString(R.string.searching_for, searchString));
 
-        flickerApi.search(searchString, new Api.SearchCallback() {
+        Api.get(this).search(searchString, new Api.SearchCallback() {
             @Override
             public void onSearchCompleted(List<Photo> photos) {
                 if (currentSearch != searchCount) return;
@@ -148,9 +159,10 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                 for (PhotoViewer viewer : photoViewers) {
                     viewer.onPhotosUpdated(photos);
                 }
+
+                currentPhotos = photos;
             }
         });
-
     }
 
     private static class TabListener implements ActionBar.TabListener {
@@ -172,22 +184,40 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
     }
 
-    private static class FlickrPagerAdapter extends FragmentPagerAdapter {
-        private final List<Fragment> fragments;
+    private class FlickrPagerAdapter extends FragmentPagerAdapter {
 
-        public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments){
+        public FlickrPagerAdapter(FragmentManager fm) {
             super(fm);
-            this.fragments = fragments;
         }
 
         @Override
-        public Fragment getItem(int i) {
-            return fragments.get(i);
+        public Fragment getItem(int position) {
+            return pageToFragment(position);
         }
 
         @Override
         public int getCount() {
-            return fragments.size();
+            return Page.values().length;
+        }
+
+        private Fragment pageToFragment(int position) {
+            Page page = Page.values()[position];
+            if (page == Page.SMALL) {
+                int pageSize = getPageSize(R.dimen.small_photo_side);
+                return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
+
+            } else if (page == Page.MEDIUM) {
+                int pageSize = getPageSize(R.dimen.medium_photo_side);
+                return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
+            } else if (page == Page.LIST) {
+                return FlickrPhotoList.newInstance();
+            } else {
+                throw new IllegalArgumentException(""No fragment class for page="" + page);
+            }
+        }
+
+        private int getPageSize(int id) {
+            return getResources().getDimensionPixelSize(id);
         }
     }
 }
","29 import java.util.HashMap;
30 import java.util.HashSet;
32 import java.util.Map;
33 import java.util.Set;
40     private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
41     private File cacheDir;
42     private List<Photo> currentPhotos = new ArrayList<Photo>();
43 
44     private enum Page {
45         SMALL,
46         MEDIUM,
47         LIST
48     }
49 
50     private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {{
51         put(Page.SMALL, R.string.small);
52         put(Page.MEDIUM, R.string.medium);
53         put(Page.LIST, R.string.list);
54     }};
55 
56     @Override
57     public void onAttachFragment(Fragment fragment) {
58         super.onAttachFragment(fragment);
59         if (!(fragment instanceof PhotoViewer)) {
60             throw new IllegalStateException(""Fragment class "" + fragment.getClass() + "" does not implement PhotoViewer"");
61         } else {
62             PhotoViewer photoViewer = (PhotoViewer) fragment;
63             photoViewer.onPhotosUpdated(currentPhotos);
64             photoViewers.add(photoViewer);
65         }
66     }
74         cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
128 
132         for (Page page : Page.values()) {
133             final int textId = PAGE_TO_TITLE.get(page);
134             actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
135         }
137         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
151         Api.get(this).search(searchString, new Api.SearchCallback() {
162 
163                 currentPhotos = photos;
187     private class FlickrPagerAdapter extends FragmentPagerAdapter {
189         public FlickrPagerAdapter(FragmentManager fm) {
194         public Fragment getItem(int position) {
195             return pageToFragment(position);
200             return Page.values().length;
201         }
202 
203         private Fragment pageToFragment(int position) {
204             Page page = Page.values()[position];
205             if (page == Page.SMALL) {
206                 int pageSize = getPageSize(R.dimen.small_photo_side);
207                 return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
208 
209             } else if (page == Page.MEDIUM) {
210                 int pageSize = getPageSize(R.dimen.medium_photo_side);
211                 return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
212             } else if (page == Page.LIST) {
213                 return FlickrPhotoList.newInstance();
214             } else {
215                 throw new IllegalArgumentException(""No fragment class for page="" + page);
216             }
217         }
218 
219         private int getPageSize(int id) {
220             return getResources().getDimensionPixelSize(id);
3 import android.content.res.Resources;
33     private Api flickerApi;
35 
36     private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();
47         File cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
63         final Resources res = getResources();
64         flickerApi = new Api(res.getDimensionPixelSize(R.dimen.large_photo_side));
65 
104         final List<Fragment> fragments = new ArrayList<Fragment>();
108         FlickrPhotoGrid small = new FlickrPhotoGrid();
109         small.setup(flickerApi, cacheDir, res.getDimensionPixelSize(R.dimen.small_photo_side));
110         fragments.add(small);
111         photoViewers.add(small);
113         final FlickrPhotoGrid medium = new FlickrPhotoGrid();
114         medium.setup(flickerApi,  cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));
115         fragments.add(medium);
116         photoViewers.add(medium);
117 
118         FlickrPhotoList list =  new FlickrPhotoList();
119         fragments.add(list);
120         photoViewers.add(list);
121 
122         actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener(pager)));
123         actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener(pager)));
124         actionBar.addTab(actionBar.newTab().setText(R.string.list).setTabListener(new TabListener(pager)));
125 
126         pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments));
140         flickerApi.search(searchString, new Api.SearchCallback() {
153 
175     private static class FlickrPagerAdapter extends FragmentPagerAdapter {
176         private final List<Fragment> fragments;
178         public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments){
180             this.fragments = fragments;
184         public Fragment getItem(int i) {
185             return fragments.get(i);
190             return fragments.size();",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,ee7dd443b1e92a36147f692c4b91b46d8202531a,"Refactor example to handle fragments correctly

Should fix case where searches would complete
but no photos would be shown","@@ -1,5 +1,7 @@
 package com.bumptech.flickr.api;
 
+import android.content.Context;
+import com.bumptech.flickr.R;
 import com.bumptech.glide.util.Log;
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -26,11 +28,12 @@ import java.util.concurrent.Future;
  * To change this template use File | Settings | File Templates.
  */
 public class Api {
+    private static Api API;
+    public static final String SEARCH_COMPLETED_ACTION = ""search_completed"";
+
     private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
-    private final Downloader downloader;
-    private Set<String> downloadedFilesNames = new HashSet<String>();
 
     private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
         put(75, ""s"");
@@ -41,13 +44,11 @@ public class Api {
         put(640, ""z"");
         put(1024, ""b"");
     }};
-
     private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
     static {
         SORTED_SIZE_KEYS.addAll(EDGE_TO_SIZE_KEY.keySet());
         Collections.sort(SORTED_SIZE_KEYS);
     }
-    private final String sizeKey;
 
     private static String getSizeKey(int width, int height) {
         final int largestEdge = Math.max(width, height);
@@ -70,7 +71,18 @@ public class Api {
         public void onDownloadComplete(String path);
     }
 
-    public Api(int maxPhotoSize) {
+    private final Downloader downloader;
+    private Set<String> downloadedFilesNames = new HashSet<String>();
+    private final String sizeKey;
+
+    public static Api get(Context context) {
+        if (API == null) {
+            API = new Api(context.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
+        }
+        return API;
+    }
+
+    protected Api(int maxPhotoSize) {
         this.downloader = Downloader.get();
         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
     }
@@ -112,9 +124,9 @@ public class Api {
                     }
                     cb.onSearchCompleted(results);
                 } catch (JSONException e) {
-                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                    e.printStackTrace();
                 } catch (UnsupportedEncodingException e) {
-                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
+                    e.printStackTrace();
                 }
             }
         });
","3 import android.content.Context;
4 import com.bumptech.flickr.R;
31     private static Api API;
32     public static final String SEARCH_COMPLETED_ACTION = ""search_completed"";
33 
74     private final Downloader downloader;
75     private Set<String> downloadedFilesNames = new HashSet<String>();
76     private final String sizeKey;
77 
78     public static Api get(Context context) {
79         if (API == null) {
80             API = new Api(context.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
81         }
82         return API;
83     }
84 
85     protected Api(int maxPhotoSize) {
127                     e.printStackTrace();
129                     e.printStackTrace();
32     private final Downloader downloader;
33     private Set<String> downloadedFilesNames = new HashSet<String>();
44 
50     private final String sizeKey;
73     public Api(int maxPhotoSize) {
115                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
117                     e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.",No
.gitmodules,.gitmodules,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -1,3 +1,6 @@
 [submodule ""samples/flickr/ActionBarSherlock""]
 	path = samples/flickr/ActionBarSherlock
 	url = https://github.com/JakeWharton/ActionBarSherlock.git
+[submodule ""samples/flickr/volley""]
+	path = samples/flickr/volley
+	url = https://android.googlesource.com/platform/frameworks/volley
","4 [submodule ""samples/flickr/volley""]
5 	path = samples/flickr/volley
6 	url = https://android.googlesource.com/platform/frameworks/volley",No
samples\flickr\project.properties,samples\flickr\project.properties,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -14,3 +14,4 @@
 target=android-16
 android.library.reference.1=../../library
 android.library.reference.2=ActionBarSherlock/library
+android.library.reference.3=volley/
",17 android.library.reference.3=volley/,No
samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -1,12 +1,12 @@
 package com.bumptech.flickr;
 
+import com.android.volley.Request;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.loader.model.BaseModelStreamLoader;
 import com.bumptech.glide.loader.opener.FileInputStreamOpener;
 
 import java.io.File;
-import java.util.concurrent.Future;
 
 /**
  * An implementation of a ModelStreamLoader that uses a separate class to download images to disk and then uses
@@ -17,7 +17,7 @@ import java.util.concurrent.Future;
 public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
     private final Api flickrApi;
     private final File cacheDir;
-    private Future current = null;
+    private Request current = null;
 
     public FlickrStreamLoader(Api flickrApi, File cacheDir) {
         this.flickrApi = flickrApi;
@@ -38,7 +38,7 @@ public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
     @Override
     public void clear() {
         if (current != null) {
-            current.cancel(false);
+            current.cancel();
             current = null;
         }
     }
","3 import com.android.volley.Request;
20     private Request current = null;
41             current.cancel();
9 import java.util.concurrent.Future;
20     private Future current = null;
41             current.cancel(false);",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -1,6 +1,7 @@
 package com.bumptech.flickr.api;
 
 import android.content.Context;
+import com.android.volley.Request;
 import com.bumptech.flickr.R;
 import com.bumptech.glide.util.Log;
 import org.json.JSONArray;
@@ -8,7 +9,6 @@ import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.io.File;
-import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
@@ -18,7 +18,6 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.Future;
 
 /**
  * Created with IntelliJ IDEA.
@@ -75,15 +74,15 @@ public class Api {
     private Set<String> downloadedFilesNames = new HashSet<String>();
     private final String sizeKey;
 
-    public static Api get(Context context) {
+    public static Api get(Context applicationContext) {
         if (API == null) {
-            API = new Api(context.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
+            API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
         }
         return API;
     }
 
-    protected Api(int maxPhotoSize) {
-        this.downloader = Downloader.get();
+    protected Api(Context applicationContext, int maxPhotoSize) {
+        this.downloader = Downloader.get(applicationContext);
         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
     }
 
@@ -110,13 +109,12 @@ public class Api {
 
     public void search(String text, final SearchCallback cb) {
         Log.d(""API: searching"");
-        downloader.download(getSearchUrl(text), new Downloader.MemoryCallback() {
+        downloader.download(getSearchUrl(text), new Downloader.StringCallback() {
             @Override
-            public void onDownloadReady(byte[] data) {
+            public void onDownloadReady(String result) {
                 try {
-                    String stringResults = new String(data, ""UTF-8"");
                     //cut out initial flickJsonApi(
-                    JSONObject searchResults = new JSONObject(stringResults.substring(14, stringResults.length()-1));
+                    JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));
                     JSONArray photos = searchResults.getJSONObject(""photos"").getJSONArray(""photo"");
                     List<Photo> results = new ArrayList<Photo>(photos.length());
                     for (int i = 0; i < photos.length(); i++) {
@@ -125,17 +123,15 @@ public class Api {
                     cb.onSearchCompleted(results);
                 } catch (JSONException e) {
                     e.printStackTrace();
-                } catch (UnsupportedEncodingException e) {
-                    e.printStackTrace();
                 }
             }
         });
     }
 
-    public Future downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
+    public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
         final String path = out.getPath();
-        Future result = null;
+        Request result = null;
         if (downloadedFilesNames.contains(path)) {
             cb.onDownloadComplete(path);
         } else {
","4 import com.android.volley.Request;
77     public static Api get(Context applicationContext) {
79             API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
84     protected Api(Context applicationContext, int maxPhotoSize) {
85         this.downloader = Downloader.get(applicationContext);
112         downloader.download(getSearchUrl(text), new Downloader.StringCallback() {
114             public void onDownloadReady(String result) {
117                     JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));
131     public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
134         Request result = null;
11 import java.io.UnsupportedEncodingException;
21 import java.util.concurrent.Future;
78     public static Api get(Context context) {
80             API = new Api(context.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
85     protected Api(int maxPhotoSize) {
86         this.downloader = Downloader.get();
113         downloader.download(getSearchUrl(text), new Downloader.MemoryCallback() {
115             public void onDownloadReady(byte[] data) {
117                     String stringResults = new String(data, ""UTF-8"");
119                     JSONObject searchResults = new JSONObject(stringResults.substring(14, stringResults.length()-1));
128                 } catch (UnsupportedEncodingException e) {
129                     e.printStackTrace();
135     public Future downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
138         Future result = null;",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -1,21 +1,20 @@
 package com.bumptech.flickr.api;
 
-import android.os.Handler;
-import android.os.HandlerThread;
-
-import java.io.BufferedInputStream;
+import android.content.Context;
+import com.android.volley.NetworkResponse;
+import com.android.volley.Request;
+import com.android.volley.RequestQueue;
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+import com.android.volley.toolbox.StringRequest;
+import com.android.volley.toolbox.Volley;
+
+import java.io.BufferedOutputStream;
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 
 /**
  * Created with IntelliJ IDEA.
@@ -26,153 +25,73 @@ import java.util.concurrent.Future;
  */
 public class Downloader {
     private static Downloader DOWNLOADER;
-    private final Handler mainHandler;
-    private final ExecutorService executor;
+    private final RequestQueue queue;
 
-    static Downloader get() {
+    static Downloader get(Context context) {
         if (DOWNLOADER == null) {
-            DOWNLOADER = new Downloader();
+            DOWNLOADER = new Downloader(context);
         }
         return DOWNLOADER;
     }
 
-    public interface MemoryCallback {
-        public void onDownloadReady(byte[] data);
-    }
-
-    public interface DiskCallback {
-        public void onDownloadReady(String path);
-    }
-
-    protected Downloader() {
-        System.setProperty(""http.keepAlive"", ""false"");
-        HandlerThread workerThread = new HandlerThread(""downloader_thread"");
-        workerThread.start();
-        executor = Executors.newFixedThreadPool(6);
-        mainHandler = new Handler();
-    }
-
-    private Future post(Runnable runnable) {
-        return executor.submit(runnable);
-    }
-
-    public void download(String url, MemoryCallback cb) {
-        post(new MemoryDownloadWorker(url, cb));
+    public Downloader(Context context) {
+        queue = Volley.newRequestQueue(context);
     }
 
-    public Future download(String url, File out, DiskCallback cb) {
-        return post(new DiskDownloadWorker(url, out, cb));
+    public interface StringCallback {
+        public void onDownloadReady(String result);
     }
 
-    private class DiskDownloadWorker implements Runnable {
-        private final String url;
-        private final DiskCallback cb;
-        private final File output;
-
-        public DiskDownloadWorker(String url, File output, DiskCallback cb) {
-            this.url = url;
-            this.output = output;
-            this.cb = cb;
+    public interface DiskCallback {
+        public void onDownloadReady(String path);
     }
 
+    public void download(String url, final StringCallback cb) {
+        queue.add(new StringRequest(Request.Method.GET, url, new Response.Listener<String>() {
             @Override
-        public void run() {
-            if (output.exists()) {
-                mainHandler.post(new Runnable() {
+            public void onResponse(String response) {
+                cb.onDownloadReady(response);
+            }
+        }, new Response.ErrorListener() {
             @Override
-                    public void run() {
-                        cb.onDownloadReady(output.getPath());
+            public void onErrorResponse(VolleyError error) {
+                error.printStackTrace();
             }
-                });
-                return;
+        }));
     }
-            HttpURLConnection urlConnection = null;
-            try {
-                final URL targetUrl = new URL(url);
-                urlConnection = (HttpURLConnection) targetUrl.openConnection();
-                urlConnection.setDoInput(true);
-                urlConnection.setDoOutput(false);
-                urlConnection.setUseCaches(false);
-                urlConnection.setRequestProperty(""Connection"", ""close"");
 
-                urlConnection.connect();
-                InputStream in = new BufferedInputStream(urlConnection.getInputStream());
-                OutputStream out = new FileOutputStream(output);
-                writeToOutput(in, out);
-                out.close();
-                in.close();
-                mainHandler.post(new Runnable() {
+    public Request download(String url, final File out, final DiskCallback cb) {
+        return queue.add(new Request<String>(Request.Method.GET, url, new Response.ErrorListener() {
             @Override
-                    public void run() {
-                        cb.onDownloadReady(output.getPath());
+            public void onErrorResponse(VolleyError error) {
+                error.printStackTrace();
             }
-                });
+        }) {
+            @Override
+            protected Response<String> parseNetworkResponse(NetworkResponse response) {
+                OutputStream os = null;
+                try {
+                    os = new BufferedOutputStream(new FileOutputStream(out));
+                    os.write(response.data);
+                } catch (FileNotFoundException e) {
+                    e.printStackTrace();
                 } catch (IOException e) {
                     e.printStackTrace();
                 } finally {
-                if (urlConnection != null) {
-                    urlConnection.disconnect();
-                }
-            }
-        }
-
-        private void writeToOutput(InputStream in, OutputStream out) throws IOException {
-            byte[] buffer = new byte[1024];
-            int bytesRead;
-            while (((bytesRead = in.read(buffer)) != -1)) {
-                out.write(buffer, 0, bytesRead);
-            }
-        }
-    }
-
-    private class MemoryDownloadWorker implements Runnable {
-
-        private final String url;
-        private final MemoryCallback cb;
-
-        public MemoryDownloadWorker(String url, MemoryCallback cb) {
-            this.url = url;
-            this.cb = cb;
-        }
-
-        @Override
-        public void run() {
-            HttpURLConnection urlConnection = null;
+                    if (os != null) {
                         try {
-                final URL targetUrl = new URL(url);
-                urlConnection = (HttpURLConnection) targetUrl.openConnection();
-                urlConnection.setDoInput(true);
-                urlConnection.setDoOutput(false);
-                urlConnection.setUseCaches(false);
-                urlConnection.setRequestProperty(""Connection"", ""close"");
-
-                urlConnection.connect();
-                InputStream in = new BufferedInputStream(urlConnection.getInputStream());
-                final List<Byte> data = new ArrayList<Byte>(1024);
-                byte[] buffer = new byte[1024];
-                int bytesRead;
-                while (((bytesRead = in.read(buffer)) != -1)) {
-                    for (int i = 0; i < bytesRead; i++) {
-                        data.add(buffer[i]);
+                            os.close();
+                        } catch (IOException e) { }
                     }
                 }
-                final byte[] result = new byte[data.size()];
-                for (int i = 0; i < data.size(); i++) {
-                    result[i] = data.get(i);
+                return Response.success(out.getAbsolutePath(), getCacheEntry());
             }
-                mainHandler.post(new Runnable() {
+
             @Override
-                    public void run() {
-                        cb.onDownloadReady(result);
+            protected void deliverResponse(String response) {
+                cb.onDownloadReady(response);
             }
         });
-            } catch (IOException e) {
-                e.printStackTrace();
-            } finally {
-                if (urlConnection != null) {
-                    urlConnection.disconnect();
-                }
-            }
-        }
+
     }
 }
","3 import android.content.Context;
4 import com.android.volley.NetworkResponse;
5 import com.android.volley.Request;
6 import com.android.volley.RequestQueue;
7 import com.android.volley.Response;
8 import com.android.volley.VolleyError;
9 import com.android.volley.toolbox.StringRequest;
10 import com.android.volley.toolbox.Volley;
12 import java.io.BufferedOutputStream;
14 import java.io.FileNotFoundException;
28     private final RequestQueue queue;
30     static Downloader get(Context context) {
32             DOWNLOADER = new Downloader(context);
37     public Downloader(Context context) {
38         queue = Volley.newRequestQueue(context);
39     }
40 
41     public interface StringCallback {
42         public void onDownloadReady(String result);
49     public void download(String url, final StringCallback cb) {
50         queue.add(new StringRequest(Request.Method.GET, url, new Response.Listener<String>() {
52             public void onResponse(String response) {
53                 cb.onDownloadReady(response);
54             }
55         }, new Response.ErrorListener() {
57             public void onErrorResponse(VolleyError error) {
58                 error.printStackTrace();
60         }));
62 
63     public Request download(String url, final File out, final DiskCallback cb) {
64         return queue.add(new Request<String>(Request.Method.GET, url, new Response.ErrorListener() {
65             @Override
66             public void onErrorResponse(VolleyError error) {
67                 error.printStackTrace();
68             }
69         }) {
70             @Override
71             protected Response<String> parseNetworkResponse(NetworkResponse response) {
72                 OutputStream os = null;
74                     os = new BufferedOutputStream(new FileOutputStream(out));
75                     os.write(response.data);
76                 } catch (FileNotFoundException e) {
77                     e.printStackTrace();
81                     if (os != null) {
83                             os.close();
84                         } catch (IOException e) { }
85                     }
86                 }
87                 return Response.success(out.getAbsolutePath(), getCacheEntry());
88             }
91             protected void deliverResponse(String response) {
92                 cb.onDownloadReady(response);
95 
3 import android.os.Handler;
4 import android.os.HandlerThread;
6 import java.io.BufferedInputStream;
10 import java.io.InputStream;
12 import java.net.HttpURLConnection;
13 import java.net.URL;
14 import java.util.ArrayList;
15 import java.util.List;
16 import java.util.concurrent.ExecutorService;
17 import java.util.concurrent.Executors;
18 import java.util.concurrent.Future;
29     private final Handler mainHandler;
30     private final ExecutorService executor;
32     static Downloader get() {
34             DOWNLOADER = new Downloader();
39     public interface MemoryCallback {
40         public void onDownloadReady(byte[] data);
47     protected Downloader() {
48         System.setProperty(""http.keepAlive"", ""false"");
49         HandlerThread workerThread = new HandlerThread(""downloader_thread"");
50         workerThread.start();
51         executor = Executors.newFixedThreadPool(6);
52         mainHandler = new Handler();
53     }
54 
55     private Future post(Runnable runnable) {
56         return executor.submit(runnable);
57     }
58 
59     public void download(String url, MemoryCallback cb) {
60         post(new MemoryDownloadWorker(url, cb));
61     }
62 
63     public Future download(String url, File out, DiskCallback cb) {
64         return post(new DiskDownloadWorker(url, out, cb));
65     }
66 
67     private class DiskDownloadWorker implements Runnable {
68         private final String url;
69         private final DiskCallback cb;
70         private final File output;
71 
72         public DiskDownloadWorker(String url, File output, DiskCallback cb) {
73             this.url = url;
74             this.output = output;
75             this.cb = cb;
76         }
77 
79         public void run() {
80             if (output.exists()) {
81                 mainHandler.post(new Runnable() {
83                     public void run() {
84                         cb.onDownloadReady(output.getPath());
86                 });
87                 return;
89             HttpURLConnection urlConnection = null;
91                 final URL targetUrl = new URL(url);
92                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
93                 urlConnection.setDoInput(true);
94                 urlConnection.setDoOutput(false);
95                 urlConnection.setUseCaches(false);
96                 urlConnection.setRequestProperty(""Connection"", ""close"");
97 
98                 urlConnection.connect();
99                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
100                 OutputStream out = new FileOutputStream(output);
101                 writeToOutput(in, out);
102                 out.close();
103                 in.close();
104                 mainHandler.post(new Runnable() {
105                     @Override
106                     public void run() {
107                         cb.onDownloadReady(output.getPath());
108                     }
109                 });
113                 if (urlConnection != null) {
114                     urlConnection.disconnect();
115                 }
116             }
117         }
118 
119         private void writeToOutput(InputStream in, OutputStream out) throws IOException {
120             byte[] buffer = new byte[1024];
121             int bytesRead;
122             while (((bytesRead = in.read(buffer)) != -1)) {
123                 out.write(buffer, 0, bytesRead);
124             }
125         }
126     }
127 
128     private class MemoryDownloadWorker implements Runnable {
129 
130         private final String url;
131         private final MemoryCallback cb;
132 
133         public MemoryDownloadWorker(String url, MemoryCallback cb) {
134             this.url = url;
135             this.cb = cb;
136         }
137 
138         @Override
139         public void run() {
140             HttpURLConnection urlConnection = null;
142                 final URL targetUrl = new URL(url);
143                 urlConnection = (HttpURLConnection) targetUrl.openConnection();
144                 urlConnection.setDoInput(true);
145                 urlConnection.setDoOutput(false);
146                 urlConnection.setUseCaches(false);
147                 urlConnection.setRequestProperty(""Connection"", ""close"");
149                 urlConnection.connect();
150                 InputStream in = new BufferedInputStream(urlConnection.getInputStream());
151                 final List<Byte> data = new ArrayList<Byte>(1024);
152                 byte[] buffer = new byte[1024];
153                 int bytesRead;
154                 while (((bytesRead = in.read(buffer)) != -1)) {
155                     for (int i = 0; i < bytesRead; i++) {
156                         data.add(buffer[i]);
157                     }
158                 }
159                 final byte[] result = new byte[data.size()];
160                 for (int i = 0; i < data.size(); i++) {
161                     result[i] = data.get(i);
162                 }
163                 mainHandler.post(new Runnable() {
165                     public void run() {
166                         cb.onDownloadReady(result);
169             } catch (IOException e) {
170                 e.printStackTrace();
171             } finally {
172                 if (urlConnection != null) {
173                     urlConnection.disconnect();
174                 }
175             }
176         }",No
,samples\flickr\volley,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,a8186fb26cb4eec77182935578dd6cdbe7ffdda8,Convert flickr sample to use Volley,"@@ -0,0 +1 @@
+Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798
",1 Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798,Yes
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,samples\flickr\src\com\bumptech\flickr\api\Downloader.java,c02e315e8021c520780066b82d1063fc9137099a,bd2bd139f4b2246924dc5546140c97fc14b3c8b5,Expose downloader and volley request queue,"@@ -27,7 +27,7 @@ public class Downloader {
     private static Downloader DOWNLOADER;
     private final RequestQueue queue;
 
-    static Downloader get(Context context) {
+    public static Downloader get(Context context) {
         if (DOWNLOADER == null) {
             DOWNLOADER = new Downloader(context);
         }
@@ -38,6 +38,10 @@ public class Downloader {
         queue = Volley.newRequestQueue(context);
     }
 
+    public RequestQueue getQueue() {
+        return queue;
+    }
+
     public interface StringCallback {
         public void onDownloadReady(String result);
     }
","30     public static Downloader get(Context context) {
41     public RequestQueue getQueue() {
42         return queue;
43     }
44 
30     static Downloader get(Context context) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -5,9 +5,9 @@ import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
 import com.bumptech.glide.loader.image.ImageLoader;
-import com.bumptech.glide.loader.model.FileStreamLoader;
-import com.bumptech.glide.loader.model.ModelStreamLoader;
-import com.bumptech.glide.loader.model.UrlStreamLoader;
+import com.bumptech.glide.loader.model.FileLoader;
+import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.UrlLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
 import com.bumptech.glide.resize.ImageManager;
@@ -17,8 +17,6 @@ import com.bumptech.glide.resize.loader.FitCenter;
 
 import java.io.File;
 import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
@@ -28,10 +26,6 @@ import java.util.Map;
  */
 public class Glide {
     private static final Glide GLIDE = new Glide();
-    private static final Map<Class, ModelStreamLoader> classToModelStream = new HashMap<Class, ModelStreamLoader>() {{
-        put(File.class, new FileStreamLoader());
-        put(URL.class, new UrlStreamLoader());
-    }};
 
     private ImageManager imageManager;
 
@@ -39,6 +33,18 @@ public class Glide {
         return GLIDE;
     }
 
+    @SuppressWarnings(""unchecked"")
+    private static <T> ModelLoader<T> getModelFor(T model) {
+        if (model == URL.class) {
+            return (ModelLoader<T>) new UrlLoader();
+        } else if (model == File.class) {
+            return (ModelLoader<T>) new FileLoader();
+        } else {
+            throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
+                    "", you need to provide one by calling with()"");
+        }
+    }
+
     protected Glide() { }
 
     /**
@@ -127,8 +133,9 @@ public class Glide {
 
         private ImagePresenter<T> presenter;
         private ImagePresenter.Builder<T> builder;
-        private ModelStreamLoader<T> modelStreamLoader = null;
+        private ModelLoader<T> modelLoader = null;
 
+        @SuppressWarnings(""unchecked"")
         public Request(T model, ImageView imageView) {
             this.model = model;
             this.imageView = imageView;
@@ -138,29 +145,24 @@ public class Glide {
             builder = new ImagePresenter.Builder<T>()
                     .setImageView(imageView)
                     .setImageLoader(new Approximate(getImageManager()));
-
-            ModelStreamLoader<T> loader = classToModelStream.get(model.getClass());
-            if (loader != null) {
-                builder.setModelStreamLoader(loader);
-            }
         }
 
         /**
-         * Set the {@link ModelStreamLoader} for the model. For URL models, defaults to {@link UrlStreamLoader},
-         * for File models, defaults to {@link FileStreamLoader}.
+         * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
+         * for File models, defaults to {@link FileLoader}.
          *
-         * @param modelStreamLoader The {@link ModelStreamLoader} to use. Replaces any existing loader
+         * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
          * @return This Request
          */
-        public Request<T> with(ModelStreamLoader<T> modelStreamLoader) {
-            this.modelStreamLoader = modelStreamLoader;
-            builder.setModelStreamLoader(modelStreamLoader);
+        public Request<T> with(ModelLoader<T> modelLoader) {
+            this.modelLoader = modelLoader;
+            builder.setModelLoader(modelLoader);
 
             return this;
         }
 
         /**
-         * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -170,7 +172,7 @@ public class Glide {
         }
 
         /**
-         * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -180,7 +182,7 @@ public class Glide {
         }
 
         /**
-         * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -259,9 +261,8 @@ public class Glide {
          */
         private void build() {
             if (presenter == null) {
-                if (modelStreamLoader == null) {
-                    throw new IllegalArgumentException(""You must set a ModelStreamLoader for model class="" +
-                            model.getClass());
+                if (modelLoader == null) {
+                    modelLoader = getModelFor(model);
                 }
                 presenter = builder.build();
                 imageView.setTag(R.id.image_presenter_id, presenter);
","8 import com.bumptech.glide.loader.model.FileLoader;
9 import com.bumptech.glide.loader.model.ModelLoader;
10 import com.bumptech.glide.loader.model.UrlLoader;
36     @SuppressWarnings(""unchecked"")
37     private static <T> ModelLoader<T> getModelFor(T model) {
38         if (model == URL.class) {
39             return (ModelLoader<T>) new UrlLoader();
40         } else if (model == File.class) {
41             return (ModelLoader<T>) new FileLoader();
42         } else {
43             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
44                     "", you need to provide one by calling with()"");
45         }
46     }
47 
136         private ModelLoader<T> modelLoader = null;
138         @SuppressWarnings(""unchecked"")
151          * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
152          * for File models, defaults to {@link FileLoader}.
154          * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
157         public Request<T> with(ModelLoader<T> modelLoader) {
158             this.modelLoader = modelLoader;
159             builder.setModelLoader(modelLoader);
165          * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
175          * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
185          * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
264                 if (modelLoader == null) {
265                     modelLoader = getModelFor(model);
8 import com.bumptech.glide.loader.model.FileStreamLoader;
9 import com.bumptech.glide.loader.model.ModelStreamLoader;
10 import com.bumptech.glide.loader.model.UrlStreamLoader;
20 import java.util.HashMap;
21 import java.util.Map;
31     private static final Map<Class, ModelStreamLoader> classToModelStream = new HashMap<Class, ModelStreamLoader>() {{
32         put(File.class, new FileStreamLoader());
33         put(URL.class, new UrlStreamLoader());
34     }};
130         private ModelStreamLoader<T> modelStreamLoader = null;
141 
142             ModelStreamLoader<T> loader = classToModelStream.get(model.getClass());
143             if (loader != null) {
144                 builder.setModelStreamLoader(loader);
145             }
149          * Set the {@link ModelStreamLoader} for the model. For URL models, defaults to {@link UrlStreamLoader},
150          * for File models, defaults to {@link FileStreamLoader}.
152          * @param modelStreamLoader The {@link ModelStreamLoader} to use. Replaces any existing loader
155         public Request<T> with(ModelStreamLoader<T> modelStreamLoader) {
156             this.modelStreamLoader = modelStreamLoader;
157             builder.setModelStreamLoader(modelStreamLoader);
163          * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
173          * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
183          * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)}
262                 if (modelStreamLoader == null) {
263                     throw new IllegalArgumentException(""You must set a ModelStreamLoader for model class="" +
264                             model.getClass());",No
library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,7 +1,7 @@
 package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 
 import java.lang.ref.WeakReference;
 
@@ -12,8 +12,8 @@ import java.lang.ref.WeakReference;
  */
 public abstract class BaseImageLoader implements ImageLoader {
     @Override
-    public final Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
-        doFetchImage(id, streamOpener, width, height, new InternalImageReadyCallback(cb, id));
+    public final Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
+        doFetchImage(id, streamLoader, width, height, new InternalImageReadyCallback(cb, id));
         return cb;
     }
 
@@ -26,15 +26,16 @@ public abstract class BaseImageLoader implements ImageLoader {
      * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
      * image is ready.
      *
-     * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
+     * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The width of the view where the image will be displayed
      * @param height The height of the view where the image will be displayed
      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
      */
-    protected abstract void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
+    protected abstract void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
 
     /**
      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
","4 import com.bumptech.glide.loader.stream.StreamLoader;
15     public final Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
16         doFetchImage(id, streamLoader, width, height, new InternalImageReadyCallback(cb, id));
29      * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
31      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
32      *           is not required to do so
33      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
38     protected abstract void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
4 import com.bumptech.glide.loader.opener.StreamOpener;
15     public final Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
16         doFetchImage(id, streamOpener, width, height, new InternalImageReadyCallback(cb, id));
29      * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
31      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
32      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
37     protected abstract void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);",No
library\src\com\bumptech\glide\loader\image\ImageLoader.java,library\src\com\bumptech\glide\loader\image\ImageLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,7 +1,7 @@
 package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 
 /**
  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a bitmap for a given id and
@@ -35,15 +35,16 @@ public interface ImageLoader {
     /**
      * Load the image at the given path represented by the given model
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The width of the view where the image will be displayed
      * @param height The height of the view where the image will be displayed
      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
      *
      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
      */
-    public Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
+    public Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
 
     /**
      * Called when the current image load does not need to continue and any corresponding cleanup to save cpu
","4 import com.bumptech.glide.loader.stream.StreamLoader;
38      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
39      *           is not required to do so
40      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
47     public Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
4 import com.bumptech.glide.loader.opener.StreamOpener;
38      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
39      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
46     public Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);",No
library\src\com\bumptech\glide\loader\model\BaseModelStreamLoader.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,83 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-import java.lang.ref.WeakReference;
-
-/**
- * A base class for {@link ModelStreamLoader} that provides some lifecycle methods and prevents memory leaks if a load
- * stalls or takes a long time by only providing subclasses with a weak reference to the calling
- * {@link com.bumptech.glide.presenter.ImagePresenter}.
- */
-public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
-    /**
-     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
-     */
-    @Override
-    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {
-        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));
-        return cb;
-    }
-
-    /**
-     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
-     */
-    @Override
-    public void clear() { }
-
-    /**
-     * The method where subclasses should call into whatever external class is fetching the information necessary
-     * to build the id and stream opener. This method is run on the main thread so it is not safe to do long running
-     * tasks. Instead pass the callback to some other class that will run on a background thread
-     *
-     * @param model The model representing the image
-     * @param width The width of the view the image will be displayed in
-     * @param height The height of the view the image will be displayed in
-     * @param cb The callback to call when the id and stream opener are ready, or when the load fails
-     */
-    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);
-
-    /**
-     * A lifecycle method called after the requesting object is notifie that this loader failed to load the id and/or
-     * stream opener. Should be used to cleanup or update any data related to the failed loadg.
-     *
-     * @param e The exception that caused the failure, or null
-     * @param model The model
-     * @return True iff this model stream loader has handled the exception and the cb should not be notified
-     */
-    protected boolean onModelStreamFetchFailed(Exception e, T model) {
-        return false;
-    }
-
-    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {
-
-        private final WeakReference<ModelStreamReadyCallback> cbRef;
-        private final WeakReference<T> modelRef;
-
-        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {
-            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);
-            this.modelRef = new WeakReference<T>(model);
-        }
-
-        @Override
-        public boolean onStreamReady(String id, StreamOpener streamOpener) {
-            ModelStreamReadyCallback cb = cbRef.get();
-            boolean result = false;
-            if (cb != null) {
-                result = cb.onStreamReady(id, streamOpener);
-            }
-            return result;
-        }
-
-        @Override
-        public void onException(Exception e) {
-            ModelStreamReadyCallback cb = cbRef.get();
-            T model = modelRef.get();
-            if (cb != null && model != null) {
-                if (!BaseModelStreamLoader.this.onModelStreamFetchFailed(e, model)) {
-                    cb.onException(e);
-                }
-            }
-        }
-    }
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.StreamOpener;
4 
5 import java.lang.ref.WeakReference;
6 
7 /**
8  * A base class for {@link ModelStreamLoader} that provides some lifecycle methods and prevents memory leaks if a load
9  * stalls or takes a long time by only providing subclasses with a weak reference to the calling
10  * {@link com.bumptech.glide.presenter.ImagePresenter}.
11  */
12 public abstract class BaseModelStreamLoader<T> implements ModelStreamLoader<T> {
13     /**
14      * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
15      */
16     @Override
17     public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {
18         doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));
19         return cb;
20     }
21 
22     /**
23      * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback)
24      */
25     @Override
26     public void clear() { }
27 
28     /**
29      * The method where subclasses should call into whatever external class is fetching the information necessary
30      * to build the id and stream opener. This method is run on the main thread so it is not safe to do long running
31      * tasks. Instead pass the callback to some other class that will run on a background thread
32      *
33      * @param model The model representing the image
34      * @param width The width of the view the image will be displayed in
35      * @param height The height of the view the image will be displayed in
36      * @param cb The callback to call when the id and stream opener are ready, or when the load fails
37      */
38     protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);
39 
40     /**
41      * A lifecycle method called after the requesting object is notifie that this loader failed to load the id and/or
42      * stream opener. Should be used to cleanup or update any data related to the failed loadg.
43      *
44      * @param e The exception that caused the failure, or null
45      * @param model The model
46      * @return True iff this model stream loader has handled the exception and the cb should not be notified
47      */
48     protected boolean onModelStreamFetchFailed(Exception e, T model) {
49         return false;
50     }
51 
52     protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {
53 
54         private final WeakReference<ModelStreamReadyCallback> cbRef;
55         private final WeakReference<T> modelRef;
56 
57         public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {
58             this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);
59             this.modelRef = new WeakReference<T>(model);
60         }
61 
62         @Override
63         public boolean onStreamReady(String id, StreamOpener streamOpener) {
64             ModelStreamReadyCallback cb = cbRef.get();
65             boolean result = false;
66             if (cb != null) {
67                 result = cb.onStreamReady(id, streamOpener);
68             }
69             return result;
70         }
71 
72         @Override
73         public void onException(Exception e) {
74             ModelStreamReadyCallback cb = cbRef.get();
75             T model = modelRef.get();
76             if (cb != null && model != null) {
77                 if (!BaseModelStreamLoader.this.onModelStreamFetchFailed(e, model)) {
78                     cb.onException(e);
79                 }
80             }
81         }
82     }
83 }",No
library\src\com\bumptech\glide\loader\model\DirectModelStreamLoader.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,25 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/11/13
- * Time: 11:54 AM
- * To change this template use File | Settings | File Templates.
- */
-public abstract class DirectModelStreamLoader<T> extends BaseModelStreamLoader<T> {
-    @Override
-    protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {
-        cb.onStreamReady(getId(model), getStreamOpener(model, width, height));
-    }
-
-    @Override
-    protected boolean onModelStreamFetchFailed(Exception e, T model) {
-        return false;
-    }
-
-    protected abstract StreamOpener getStreamOpener(T model, int width, int height);
-    protected abstract String getId(T model);
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.StreamOpener;
4 
5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 7/11/13
9  * Time: 11:54 AM
10  * To change this template use File | Settings | File Templates.
11  */
12 public abstract class DirectModelStreamLoader<T> extends BaseModelStreamLoader<T> {
13     @Override
14     protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {
15         cb.onStreamReady(getId(model), getStreamOpener(model, width, height));
16     }
17 
18     @Override
19     protected boolean onModelStreamFetchFailed(Exception e, T model) {
20         return false;
21     }
22 
23     protected abstract StreamOpener getStreamOpener(T model, int width, int height);
24     protected abstract String getId(T model);
25 }",No
,library\src\com\bumptech\glide\loader\model\FileLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,26 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.stream.FileStreamLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+import java.io.File;
+
+/**
+ * A simple model loader for {@link File}
+ */
+public class FileLoader implements ModelLoader<File> {
+
+    @Override
+    public StreamLoader getStreamOpener(File model, int width, int height) {
+        return new FileStreamLoader(model);
+    }
+
+    @Override
+    public String getId(File model) {
+        //canonical is better, but also slower
+        return model.getAbsolutePath();
+    }
+
+    @Override
+    public void clear() { }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.stream.FileStreamLoader;
4 import com.bumptech.glide.loader.stream.StreamLoader;
5 
6 import java.io.File;
7 
8 /**
9  * A simple model loader for {@link File}
10  */
11 public class FileLoader implements ModelLoader<File> {
12 
13     @Override
14     public StreamLoader getStreamOpener(File model, int width, int height) {
15         return new FileStreamLoader(model);
16     }
17 
18     @Override
19     public String getId(File model) {
20         //canonical is better, but also slower
21         return model.getAbsolutePath();
22     }
23 
24     @Override
25     public void clear() { }
26 }",No
library\src\com\bumptech\glide\loader\model\FileStreamLoader.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,26 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.opener.FileInputStreamOpener;
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-import java.io.File;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/16/13
- * Time: 12:50 PM
- * To change this template use File | Settings | File Templates.
- */
-public class FileStreamLoader extends DirectModelStreamLoader<File> {
-
-    @Override
-    protected StreamOpener getStreamOpener(File model, int width, int height) {
-        return new FileInputStreamOpener(model);
-    }
-
-    @Override
-    protected String getId(File model) {
-        return model.getAbsolutePath();
-    }
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.FileInputStreamOpener;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 
6 import java.io.File;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/16/13
12  * Time: 12:50 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class FileStreamLoader extends DirectModelStreamLoader<File> {
16 
17     @Override
18     protected StreamOpener getStreamOpener(File model, int width, int height) {
19         return new FileInputStreamOpener(model);
20     }
21 
22     @Override
23     protected String getId(File model) {
24         return model.getAbsolutePath();
25     }
26 }",No
,library\src\com\bumptech\glide\loader\model\ModelLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,52 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+/**
+ * An interface for translating an arbitrarily complex data model into a concrete data type that can be
+ * used by an {@link StreamLoader} to obtain an {@link java.io.InputStream} for an image represented by the model.
+ *
+ * This interface has two objectives:
+ *   1. To translate a specific data model into something that can be used generically to open an
+ *      {@link java.io.InputStream}
+ *   2. To allow a data model to be combined with the dimensions of the view to fetch an image of a specific size.
+ *
+ *      This not only avoids having to duplicate dimensions in xml and in your code in order to determine the size of a
+ *      view on devices with different densities, but also allows you to use layout weights or otherwise
+ *      programatically set the dimensions of the view without forcing you to fetch a generic image size
+ *
+ *      The smaller the image you fetch, the less bandwidth and battery life you use, and the lower your memory
+ *      footprint per image.
+ *
+ *
+ * @param <T> The type of the data model
+ */
+public interface ModelLoader<T> {
+
+    /**
+     * Obtain an {@link StreamLoader} that can asynchronously load and open an InputStream for the image represented
+     * by this model. The {@link StreamLoader} will not be used if the image is already cached.
+     *
+     * @param model The model representing the image
+     * @param width The width of the view the image will be loaded into
+     * @param height The height of the view the image will be loaded into
+     * @return A {@link StreamLoader} that can obtain an InputStream for the image if it is not cached
+     */
+    public StreamLoader getStreamOpener(T model, int width, int height);
+
+
+    /**
+     * Get a unique id for a given model
+     *
+     * @param model The model
+     * @return A String that consistently and uniquely identifies this model. It can include width and height, but
+     * it does not have to.
+     */
+    public String getId(T model);
+
+    /**
+     * A method that allows the ModelLoader to cleanup any old or inprocess {@link StreamLoader}. Primarily oriented
+     * at allowing the model loader to call {@link com.bumptech.glide.loader.stream.StreamLoader#cancel()};
+     */
+    public void clear();
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.stream.StreamLoader;
4 
5 /**
6  * An interface for translating an arbitrarily complex data model into a concrete data type that can be
7  * used by an {@link StreamLoader} to obtain an {@link java.io.InputStream} for an image represented by the model.
8  *
9  * This interface has two objectives:
10  *   1. To translate a specific data model into something that can be used generically to open an
11  *      {@link java.io.InputStream}
12  *   2. To allow a data model to be combined with the dimensions of the view to fetch an image of a specific size.
13  *
14  *      This not only avoids having to duplicate dimensions in xml and in your code in order to determine the size of a
15  *      view on devices with different densities, but also allows you to use layout weights or otherwise
16  *      programatically set the dimensions of the view without forcing you to fetch a generic image size
17  *
18  *      The smaller the image you fetch, the less bandwidth and battery life you use, and the lower your memory
19  *      footprint per image.
20  *
21  *
22  * @param <T> The type of the data model
23  */
24 public interface ModelLoader<T> {
25 
26     /**
27      * Obtain an {@link StreamLoader} that can asynchronously load and open an InputStream for the image represented
28      * by this model. The {@link StreamLoader} will not be used if the image is already cached.
29      *
30      * @param model The model representing the image
31      * @param width The width of the view the image will be loaded into
32      * @param height The height of the view the image will be loaded into
33      * @return A {@link StreamLoader} that can obtain an InputStream for the image if it is not cached
34      */
35     public StreamLoader getStreamOpener(T model, int width, int height);
36 
37 
38     /**
39      * Get a unique id for a given model
40      *
41      * @param model The model
42      * @return A String that consistently and uniquely identifies this model. It can include width and height, but
43      * it does not have to.
44      */
45     public String getId(T model);
46 
47     /**
48      * A method that allows the ModelLoader to cleanup any old or inprocess {@link StreamLoader}. Primarily oriented
49      * at allowing the model loader to call {@link com.bumptech.glide.loader.stream.StreamLoader#cancel()};
50      */
51     public void clear();
52 }",No
library\src\com\bumptech\glide\loader\model\ModelStreamLoader.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,52 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-/**
- * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a unique id and a means of
- * obtaining input streams to an image represented by the given model
- *
- * @param <T> The type of the model that represents an image
- */
-public interface ModelStreamLoader<T> {
-    /**
-     * An interface defining a callback that will be passed to an {@link ModelStreamLoader}
-     * and that should be called by the {@link ModelStreamLoader} when a load completes either successfully or
-     * because of an exception
-     */
-    public interface ModelStreamReadyCallback {
-        /**
-         * The method a loader should call when a load completes successfully
-         *
-         * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-         * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
-         * @return True iff the loaded streamOpener and id was used by the class that requested
-         */
-        public boolean onStreamReady(String id, StreamOpener streamOpener);
-
-        /**
-         * The method a loader should call when a load fails
-         *
-         * @param e The exception that caused the load to fail, or null
-         */
-        public void onException(Exception e);
-    }
-
-    /**
-     * Obtain an id and {@link StreamOpener} represented by the given model at the given dimension
-     *
-     * @param model The model representing the image to be loaded
-     * @param width The width of the view the image will be displayed in
-     * @param height The height of the view the image will be displayed in
-     * @param cb The callback to call when the load completes
-     *
-     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relavent
-     */
-    public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);
-
-    /**
-     * Called when the current load does not need to continue and any corresponding cleanup to save cpu or memory can be
-     * done. Will not be called if a load completes successfully.
-     */
-    public void clear();
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.StreamOpener;
4 
5 /**
6  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a unique id and a means of
7  * obtaining input streams to an image represented by the given model
8  *
9  * @param <T> The type of the model that represents an image
10  */
11 public interface ModelStreamLoader<T> {
12     /**
13      * An interface defining a callback that will be passed to an {@link ModelStreamLoader}
14      * and that should be called by the {@link ModelStreamLoader} when a load completes either successfully or
15      * because of an exception
16      */
17     public interface ModelStreamReadyCallback {
18         /**
19          * The method a loader should call when a load completes successfully
20          *
21          * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
22          * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
23          * @return True iff the loaded streamOpener and id was used by the class that requested
24          */
25         public boolean onStreamReady(String id, StreamOpener streamOpener);
26 
27         /**
28          * The method a loader should call when a load fails
29          *
30          * @param e The exception that caused the load to fail, or null
31          */
32         public void onException(Exception e);
33     }
34 
35     /**
36      * Obtain an id and {@link StreamOpener} represented by the given model at the given dimension
37      *
38      * @param model The model representing the image to be loaded
39      * @param width The width of the view the image will be displayed in
40      * @param height The height of the view the image will be displayed in
41      * @param cb The callback to call when the load completes
42      *
43      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relavent
44      */
45     public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);
46 
47     /**
48      * Called when the current load does not need to continue and any corresponding cleanup to save cpu or memory can be
49      * done. Will not be called if a load completes successfully.
50      */
51     public void clear();
52 }",No
,library\src\com\bumptech\glide\loader\model\UrlLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,25 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.stream.HttpStreamLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+import java.net.URL;
+
+/**
+ * A simple model loader for urls
+ */
+public class UrlLoader implements ModelLoader<URL> {
+    @Override
+    public StreamLoader getStreamOpener(URL model, int width, int height) {
+        return new HttpStreamLoader(model);
+    }
+
+    //this may need to be overridden if multiple urls can be used to retrieve the same imgae
+    @Override
+    public String getId(URL model) {
+        return model.toString();
+    }
+
+    @Override
+    public void clear() { }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.stream.HttpStreamLoader;
4 import com.bumptech.glide.loader.stream.StreamLoader;
5 
6 import java.net.URL;
7 
8 /**
9  * A simple model loader for urls
10  */
11 public class UrlLoader implements ModelLoader<URL> {
12     @Override
13     public StreamLoader getStreamOpener(URL model, int width, int height) {
14         return new HttpStreamLoader(model);
15     }
16 
17     //this may need to be overridden if multiple urls can be used to retrieve the same imgae
18     @Override
19     public String getId(URL model) {
20         return model.toString();
21     }
22 
23     @Override
24     public void clear() { }
25 }",No
library\src\com\bumptech\glide\loader\model\UrlStreamLoader.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,26 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-import java.net.URL;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/16/13
- * Time: 12:51 PM
- * To change this template use File | Settings | File Templates.
- */
-public class UrlStreamLoader extends DirectModelStreamLoader<URL> {
-
-    @Override
-    protected StreamOpener getStreamOpener(URL model, int width, int height) {
-        return new HttpInputStreamOpener(model);
-    }
-
-    @Override
-    protected String getId(URL model) {
-        return model.toString();
-    }
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
4 import com.bumptech.glide.loader.opener.StreamOpener;
5 
6 import java.net.URL;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/16/13
12  * Time: 12:51 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class UrlStreamLoader extends DirectModelStreamLoader<URL> {
16 
17     @Override
18     protected StreamOpener getStreamOpener(URL model, int width, int height) {
19         return new HttpInputStreamOpener(model);
20     }
21 
22     @Override
23     protected String getId(URL model) {
24         return model.toString();
25     }
26 }",No
library\src\com\bumptech\glide\loader\opener\FileInputStreamOpener.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,36 +0,0 @@
-package com.bumptech.glide.loader.opener;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/10/13
- * Time: 11:11 PM
- * To change this template use File | Settings | File Templates.
- */
-public class FileInputStreamOpener implements StreamOpener {
-    private final File file;
-    private final String path;
-
-    public FileInputStreamOpener(String path) {
-        this.path = path;
-        this.file = null;
-    }
-
-    public FileInputStreamOpener(File file) {
-        this.file = file;
-        this.path = null;
-    }
-
-    @Override
-    public InputStream openStream() throws IOException {
-        return new FileInputStream(file != null ? file : new File(path));
-    }
-
-    @Override
-    public void cleanup() { }
-}
","1 package com.bumptech.glide.loader.opener;
2 
3 import java.io.File;
4 import java.io.FileInputStream;
5 import java.io.IOException;
6 import java.io.InputStream;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/10/13
12  * Time: 11:11 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class FileInputStreamOpener implements StreamOpener {
16     private final File file;
17     private final String path;
18 
19     public FileInputStreamOpener(String path) {
20         this.path = path;
21         this.file = null;
22     }
23 
24     public FileInputStreamOpener(File file) {
25         this.file = file;
26         this.path = null;
27     }
28 
29     @Override
30     public InputStream openStream() throws IOException {
31         return new FileInputStream(file != null ? file : new File(path));
32     }
33 
34     @Override
35     public void cleanup() { }
36 }",No
library\src\com\bumptech\glide\loader\opener\HttpInputStreamOpener.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,40 +0,0 @@
-package com.bumptech.glide.loader.opener;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/10/13
- * Time: 11:21 PM
- * To change this template use File | Settings | File Templates.
- */
-public class HttpInputStreamOpener implements StreamOpener {
-    private final URL url;
-    private HttpURLConnection urlConnection = null;
-
-    public HttpInputStreamOpener(URL url) {
-        this.url = url;
-    }
-
-    @Override
-    public InputStream openStream() throws IOException {
-        urlConnection = (HttpURLConnection) url.openConnection();
-        urlConnection.setDoInput(true);
-        urlConnection.setDoOutput(false);
-        urlConnection.setUseCaches(false);
-        urlConnection.setRequestProperty(""Connection"", ""close"");
-        urlConnection.connect();
-        return urlConnection.getInputStream();
-    }
-
-    @Override
-    public void cleanup() {
-        if (urlConnection != null) {
-            urlConnection.disconnect();
-        }
-    }
-}
","1 package com.bumptech.glide.loader.opener;
2 
3 import java.io.IOException;
4 import java.io.InputStream;
5 import java.net.HttpURLConnection;
6 import java.net.URL;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/10/13
12  * Time: 11:21 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class HttpInputStreamOpener implements StreamOpener {
16     private final URL url;
17     private HttpURLConnection urlConnection = null;
18 
19     public HttpInputStreamOpener(URL url) {
20         this.url = url;
21     }
22 
23     @Override
24     public InputStream openStream() throws IOException {
25         urlConnection = (HttpURLConnection) url.openConnection();
26         urlConnection.setDoInput(true);
27         urlConnection.setDoOutput(false);
28         urlConnection.setUseCaches(false);
29         urlConnection.setRequestProperty(""Connection"", ""close"");
30         urlConnection.connect();
31         return urlConnection.getInputStream();
32     }
33 
34     @Override
35     public void cleanup() {
36         if (urlConnection != null) {
37             urlConnection.disconnect();
38         }
39     }
40 }",No
library\src\com\bumptech\glide\loader\opener\StreamOpener.java,,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,29 +0,0 @@
-package com.bumptech.glide.loader.opener;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * An interface that encapsulates code to open InputStreams for an image.
- */
-public interface StreamOpener {
-    /**
-     * A method to actually create InputStreams. It will always be called on a background thread and therefore it is
-     * safe to perform long running requests in this method (like an http call). This method is used to load an image
-     * only if that image is not cached so this code may or may not be called
-     *
-     * @return A holder containing both opened InputStreams
-     * @throws IOException
-     */
-    public InputStream openStream() throws IOException;
-
-    /**
-     * A method that is called after openStreams in a try/finally block to allow this object to cleanup anything
-     * releated to the InputStreams. The InputStreams will be closed after the image load so it is not neccessary to
-     * close the InputStreams here. Instead this should be used for things like
-     * {@link java.net.HttpURLConnection#disconnect()} that must only be done after the streams are used.
-     *
-     * This method will not be called if openStreams is not called (ie if the image is cached)
-     */
-    public void cleanup();
-}
","1 package com.bumptech.glide.loader.opener;
2 
3 import java.io.IOException;
4 import java.io.InputStream;
5 
6 /**
7  * An interface that encapsulates code to open InputStreams for an image.
8  */
9 public interface StreamOpener {
10     /**
11      * A method to actually create InputStreams. It will always be called on a background thread and therefore it is
12      * safe to perform long running requests in this method (like an http call). This method is used to load an image
13      * only if that image is not cached so this code may or may not be called
14      *
15      * @return A holder containing both opened InputStreams
16      * @throws IOException
17      */
18     public InputStream openStream() throws IOException;
19 
20     /**
21      * A method that is called after openStreams in a try/finally block to allow this object to cleanup anything
22      * releated to the InputStreams. The InputStreams will be closed after the image load so it is not neccessary to
23      * close the InputStreams here. Instead this should be used for things like
24      * {@link java.net.HttpURLConnection#disconnect()} that must only be done after the streams are used.
25      *
26      * This method will not be called if openStreams is not called (ie if the image is cached)
27      */
28     public void cleanup();
29 }",No
,library\src\com\bumptech\glide\loader\stream\FileStreamLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,32 @@
+package com.bumptech.glide.loader.stream;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+
+/**
+ * A simple stream loader to retrieve an {@link java.io.InputStream} for a given path or {@link File}
+ */
+public class FileStreamLoader implements StreamLoader {
+    private final File file;
+
+    public FileStreamLoader(String path) {
+        this(new File(path));
+    }
+
+    public FileStreamLoader(File file) {
+        this.file = file;
+    }
+
+    @Override
+    public void loadStream(StreamReadyCallback cb) {
+        try {
+            cb.onStreamReady(new FileInputStream(file));
+        } catch (FileNotFoundException e) {
+            cb.onException(e);
+        }
+    }
+
+    @Override
+    public void cancel() { }
+}
","1 package com.bumptech.glide.loader.stream;
2 
3 import java.io.File;
4 import java.io.FileInputStream;
5 import java.io.FileNotFoundException;
6 
7 /**
8  * A simple stream loader to retrieve an {@link java.io.InputStream} for a given path or {@link File}
9  */
10 public class FileStreamLoader implements StreamLoader {
11     private final File file;
12 
13     public FileStreamLoader(String path) {
14         this(new File(path));
15     }
16 
17     public FileStreamLoader(File file) {
18         this.file = file;
19     }
20 
21     @Override
22     public void loadStream(StreamReadyCallback cb) {
23         try {
24             cb.onStreamReady(new FileInputStream(file));
25         } catch (FileNotFoundException e) {
26             cb.onException(e);
27         }
28     }
29 
30     @Override
31     public void cancel() { }
32 }",No
,library\src\com\bumptech\glide\loader\stream\HttpStreamLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,48 @@
+package com.bumptech.glide.loader.stream;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * A simple http stream loader for fetching a url
+ */
+public class HttpStreamLoader implements StreamLoader {
+    private final URL url;
+
+    public HttpStreamLoader(String url) throws MalformedURLException {
+        this(new URL(url));
+    }
+
+    public HttpStreamLoader(URL url) {
+        this.url = url;
+    }
+
+    @Override
+    public void loadStream(StreamReadyCallback cb) {
+        HttpURLConnection urlConnection = null;
+        try {
+            urlConnection = (HttpURLConnection) url.openConnection();
+            urlConnection.setDoInput(true);
+            urlConnection.setDoOutput(false);
+            urlConnection.setUseCaches(false);
+            urlConnection.setRequestProperty(""Connection"", ""close"");
+            urlConnection.connect();
+            cb.onStreamReady(urlConnection.getInputStream());
+        } catch (IOException e) {
+            cb.onException(e);
+        } finally {
+            if (urlConnection != null) {
+                urlConnection.disconnect();
+            }
+        }
+    }
+
+    /**
+     * Since {@link #loadStream(com.bumptech.glide.loader.stream.StreamLoader.StreamReadyCallback)} calls its
+     * callback synchronously, not much we can do here.
+     */
+    @Override
+    public void cancel() { }
+}
","1 package com.bumptech.glide.loader.stream;
2 
3 import java.io.IOException;
4 import java.net.HttpURLConnection;
5 import java.net.MalformedURLException;
6 import java.net.URL;
7 
8 /**
9  * A simple http stream loader for fetching a url
10  */
11 public class HttpStreamLoader implements StreamLoader {
12     private final URL url;
13 
14     public HttpStreamLoader(String url) throws MalformedURLException {
15         this(new URL(url));
16     }
17 
18     public HttpStreamLoader(URL url) {
19         this.url = url;
20     }
21 
22     @Override
23     public void loadStream(StreamReadyCallback cb) {
24         HttpURLConnection urlConnection = null;
25         try {
26             urlConnection = (HttpURLConnection) url.openConnection();
27             urlConnection.setDoInput(true);
28             urlConnection.setDoOutput(false);
29             urlConnection.setUseCaches(false);
30             urlConnection.setRequestProperty(""Connection"", ""close"");
31             urlConnection.connect();
32             cb.onStreamReady(urlConnection.getInputStream());
33         } catch (IOException e) {
34             cb.onException(e);
35         } finally {
36             if (urlConnection != null) {
37                 urlConnection.disconnect();
38             }
39         }
40     }
41 
42     /**
43      * Since {@link #loadStream(com.bumptech.glide.loader.stream.StreamLoader.StreamReadyCallback)} calls its
44      * callback synchronously, not much we can do here.
45      */
46     @Override
47     public void cancel() { }
48 }",No
,library\src\com\bumptech\glide\loader\stream\StreamLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -0,0 +1,60 @@
+package com.bumptech.glide.loader.stream;
+
+import java.io.InputStream;
+
+/**
+ * An interface for lazily and asynchronously opening an input stream that can be used to load an image.
+ * A new instance is created per image load by {@link com.bumptech.glide.loader.model.ModelLoader}. loadStream
+ * may or may not be called for any given load depending on whether or not the corresponding image is cached. Cancel
+ * also may or may not be called.
+ */
+public interface StreamLoader {
+
+    /**
+     * An interface defining a callback for when an InputStream has been opened successfully or the load
+     * has failed because of an exception. Any checked exceptions that prevent the InputStream from being opened
+     * should call {@link #onException(Exception)} and should not call {@code e.printStackTrace()} to avoid the
+     * stack trace being printed twice.
+     */
+    public interface StreamReadyCallback {
+        /**
+         * The method that should be called when a load completes successfully
+         *
+         * @param is The {@link InputStream} that will be used to load the image
+         * @return True iff the loaded streamOpener and id was used by the class that requested
+         */
+        public void onStreamReady(InputStream is);
+
+        /**
+         * The method that should be called when a load fails because of an exception. This may or may not
+         * be called on the main thread.
+         *
+         * @param e The exception that caused the load to fail
+         */
+        public void onException(Exception e);
+
+    }
+
+    /**
+     * Asynchronously fetch and open an InputStream representing an image. This will always be called on
+     * background thread so it is safe to perform long running tasks here. Any third party libraries called
+     * must be thread safe since this method will be called from a thread in a
+     * {@link java.util.concurrent.ExecutorService} that may have more than one background thread.
+     *
+     * This method will only be called when the corresponding image is not in the cache.
+     *
+     * @param cb The callback to call when the load completes or fails due to an exception
+     */
+    public void loadStream(StreamReadyCallback cb);
+
+    /**
+     * A method that will be called by an {@link com.bumptech.glide.presenter.ImagePresenter} when a load is no longer
+     * relevant (because we now want to load a different image into the view). This method does not need to guarantee
+     * that any in process loads do not finish. It also may be called before a load starts or after it finishes.
+     *
+     * The best way to use this method is to cancel any loads that have not yet started, but allow those that are in
+     * process to finish since its we typically will want to display the same image in a different view in
+     * the near future.
+     */
+    public void cancel();
+}
","1 package com.bumptech.glide.loader.stream;
2 
3 import java.io.InputStream;
4 
5 /**
6  * An interface for lazily and asynchronously opening an input stream that can be used to load an image.
7  * A new instance is created per image load by {@link com.bumptech.glide.loader.model.ModelLoader}. loadStream
8  * may or may not be called for any given load depending on whether or not the corresponding image is cached. Cancel
9  * also may or may not be called.
10  */
11 public interface StreamLoader {
12 
13     /**
14      * An interface defining a callback for when an InputStream has been opened successfully or the load
15      * has failed because of an exception. Any checked exceptions that prevent the InputStream from being opened
16      * should call {@link #onException(Exception)} and should not call {@code e.printStackTrace()} to avoid the
17      * stack trace being printed twice.
18      */
19     public interface StreamReadyCallback {
20         /**
21          * The method that should be called when a load completes successfully
22          *
23          * @param is The {@link InputStream} that will be used to load the image
24          * @return True iff the loaded streamOpener and id was used by the class that requested
25          */
26         public void onStreamReady(InputStream is);
27 
28         /**
29          * The method that should be called when a load fails because of an exception. This may or may not
30          * be called on the main thread.
31          *
32          * @param e The exception that caused the load to fail
33          */
34         public void onException(Exception e);
35 
36     }
37 
38     /**
39      * Asynchronously fetch and open an InputStream representing an image. This will always be called on
40      * background thread so it is safe to perform long running tasks here. Any third party libraries called
41      * must be thread safe since this method will be called from a thread in a
42      * {@link java.util.concurrent.ExecutorService} that may have more than one background thread.
43      *
44      * This method will only be called when the corresponding image is not in the cache.
45      *
46      * @param cb The callback to call when the load completes or fails due to an exception
47      */
48     public void loadStream(StreamReadyCallback cb);
49 
50     /**
51      * A method that will be called by an {@link com.bumptech.glide.presenter.ImagePresenter} when a load is no longer
52      * relevant (because we now want to load a different image into the view). This method does not need to guarantee
53      * that any in process loads do not finish. It also may be called before a load starts or after it finishes.
54      *
55      * The best way to use this method is to cancel any loads that have not yet started, but allow those that are in
56      * process to finish since its we typically will want to display the same image in a different view in
57      * the near future.
58      */
59     public void cancel();
60 }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -12,20 +12,20 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.image.ImageLoader;
-import com.bumptech.glide.loader.model.ModelStreamLoader;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.util.Log;
 
 import java.lang.ref.WeakReference;
 
 /**
- * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and loading bitmaps correctly
- * when views are being recycled. Uses {@link ModelStreamLoader} to download
- * an image or otherwise retrieve InputStreams for a given model and {@link ImageLoader} to load
- * a bitmap from a given path and/or model. Also determines the actual width and height of the wrapped
- * {@link android.widget.ImageView} and passes that information to the provided
- * {@link ModelStreamLoader} and {@link ImageLoader}.
+ * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
+ * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
+ * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load * a bitmap from a given
+ * {@link java.io.InputStream}. This class also determines the width and height of the wrapped
+ * {@link android.widget.ImageView} at runtime and passes that information to the provided {@link ModelLoader} and
+ * {@link ImageLoader}.
  *
  * @param <T> The type of the model that contains information necessary to display an image. Can be as simple
  *            as a String containing a path or a complex data type.
@@ -33,8 +33,9 @@ import java.lang.ref.WeakReference;
 public class ImagePresenter<T> {
 
     /**
-     * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
-     * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
+     * A builder for an {@link ImagePresenter}.
+     * {@see Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
+     * {@see Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
      * are required.
      *
      * @param <T> The type of the model that the presenter this builder will produce requires to load a path and an
@@ -67,7 +68,7 @@ public class ImagePresenter<T> {
             }
         };
 
-        private ModelStreamLoader<T> modelStreamLoader;
+        private ModelLoader<T> modelLoader;
 
         /**
          * Builds an ImagePresenter
@@ -81,15 +82,15 @@ public class ImagePresenter<T> {
             if (imageLoader == null) {
                 throw new IllegalArgumentException(""cannot create presenter without an image loader"");
             }
-            if (modelStreamLoader == null) {
-                throw new IllegalArgumentException(""cannot create presenter without a model stream loader"");
+            if (modelLoader == null) {
+                throw new IllegalArgumentException(""cannot create presenter without a model loader"");
             }
 
             return new ImagePresenter<T>(this);
         }
 
         /**
-         * Required sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
+         * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
          *
          * @param imageView The {@link android.widget.ImageView} to wrap
          * @return This Builder object
@@ -100,19 +101,19 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Required. Sets the {@link ModelStreamLoader} the presenter will use to obtain an Id and InputStreams to the
+         * Required - Sets the {@link ModelLoader} the presenter will use to obtain an id for and an InputStream to the
          * image represented by a given model
          *
-         * @param modelStreamLoader The {@link ModelStreamLoader} to use to obtain the id and InputStreams
+         * @param modelLoader The {@link ModelLoader} to use to obtain the id and InputStreams
          * @return This Builder object
          */
-        public Builder<T> setModelStreamLoader(ModelStreamLoader<T> modelStreamLoader) {
-            this.modelStreamLoader = modelStreamLoader;
+        public Builder<T> setModelLoader(ModelLoader<T> modelLoader) {
+            this.modelLoader = modelLoader;
             return this;
         }
 
         /**
-         * Required Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
+         * Required - Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
          * Bitmap from the given path and/or model
          *
          * @param imageLoader The {@link com.bumptech.glide.loader.image.ImageLoader} to use to load an image
@@ -124,7 +125,7 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Optional Sets a resource that will be displayed during loads and whenever
+         * Optional - Sets a resource that will be displayed during loads and whenever
          * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
          * {@link Builder ImagePresenter.Builder#setPlaceholderDrawable(android.graphics.drawable.Drawable)}, not both.
          *
@@ -141,7 +142,7 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Optional Sets a drawable that will be displayed during loads and whenever
+         * Optional - Sets a drawable that will be displayed during loads and whenever
          * {@link ImagePresenter#resetPlaceHolder()} is called. Only call either this method or
          * {@link Builder ImagePresenter.Builder#setPlaceholderResource(int)}, not both.
          *
@@ -158,7 +159,7 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Optional Sets a callback that will be called after an image is loaded by
+         * Optional - Sets a callback that will be called after an image is loaded by
          * {@link com.bumptech.glide.loader.image.ImageLoader} and immediately before
          * {@link android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)} is called by the presenter
          *
@@ -171,7 +172,7 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Optional Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
+         * Optional - Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
          * valid loads. See {@link com.bumptech.glide.presenter.ThumbImagePresenter}.
          *
          * @param coordinator The coordinator to set
@@ -183,7 +184,7 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Optional Sets a handler that will be notified if any path or image load causes an exception.
+         * Optional - Sets a handler that will be notified if any path or image load causes an exception.
          * See {@link com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler}.
          *
          * @param exceptionHandler The exception handler to set
@@ -196,9 +197,8 @@ public class ImagePresenter<T> {
     }
 
     private Object imageToken;
-    private Object modelStreamToken;
 
-    private final ModelStreamLoader<T> modelStreamLoader;
+    private final ModelLoader<T> modelLoader;
     private final ImageLoader imageLoader;
     private final Drawable placeholderDrawable;
     private final ImageSetCallback imageSetCallback;
@@ -245,7 +245,6 @@ public class ImagePresenter<T> {
     protected ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
-        this.modelStreamLoader = builder.modelStreamLoader;
         if (builder.placeholderResourceId != 0) {
             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
         } else {
@@ -254,6 +253,7 @@ public class ImagePresenter<T> {
         this.coordinator = builder.coordinator;
         this.imageSetCallback = builder.imageSetCallback;
         this.exceptionHandler = builder.exceptionHandler;
+        this.modelLoader = builder.modelLoader;
         sizeDeterminer = new SizeDeterminer(imageView);
     }
 
@@ -291,7 +291,7 @@ public class ImagePresenter<T> {
             sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
                 @Override
                 public void onSizeReady(int width, int height) {
-                    fetchModelStream(model, width, height, loadCount);
+                    fetchImage(model, width, height, loadCount);
                 }
             });
 
@@ -318,7 +318,7 @@ public class ImagePresenter<T> {
     /**
      * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from
      * being displayed and clears this presenter's {@link ImageLoader} and
-     * this presenter's {@link ModelStreamLoader}. Also displays the current placeholder if
+     * this presenter's {@link ModelLoader}. Also displays the current placeholder if
      * one is set
      */
     public void clear() {
@@ -326,31 +326,15 @@ public class ImagePresenter<T> {
         resetPlaceHolder();
         currentModel = null;
         isImageSet = false;
-        modelStreamLoader.clear();
+        modelLoader.clear();
         imageLoader.clear();
     }
 
-    private void fetchModelStream(final T model, final int width, final int height, final int loadCount) {
-        modelStreamToken = modelStreamLoader.fetchModelStream(model, width, height, new ModelStreamLoader.ModelStreamReadyCallback() {
-            @Override
-            public boolean onStreamReady(String id, StreamOpener streamOpener) {
-                if (loadCount != currentCount || id == null || streamOpener == null) return false;
-                fetchImage(model, id, streamOpener, width, height, loadCount);
-
-                return true;
-            }
-
-            @Override
-            public void onException(Exception e) {
-                if (exceptionHandler != null) {
-                    exceptionHandler.onModelStreamLoadException(e, model, loadCount == currentCount);
-                }
-            }
-        });
-    }
+    private void fetchImage(final T model, int width, int height, final int loadCount) {
+        final StreamLoader streamLoader = modelLoader.getStreamOpener(model, width, height);
+        final String id = modelLoader.getId(model);
 
-    private void fetchImage(final T model, final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
-        imageToken = imageLoader.fetchImage(id, streamOpener, width, height, new ImageLoader.ImageReadyCallback() {
+        imageToken = imageLoader.fetchImage(id, streamLoader, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
@@ -463,7 +447,8 @@ public class ImagePresenter<T> {
                 cb.onSizeReady(width, height);
             } else {
                 this.cb = cb;
-                handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
+                handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis()
+                        + PENDING_SIZE_CHANGE_DELAY);
             }
         }
 
","15 import com.bumptech.glide.loader.stream.StreamLoader;
17 import com.bumptech.glide.loader.model.ModelLoader;
23  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
24  * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
25  * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load * a bitmap from a given
26  * {@link java.io.InputStream}. This class also determines the width and height of the wrapped
27  * {@link android.widget.ImageView} at runtime and passes that information to the provided {@link ModelLoader} and
28  * {@link ImageLoader}.
36      * A builder for an {@link ImagePresenter}.
37      * {@see Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
38      * {@see Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
71         private ModelLoader<T> modelLoader;
85             if (modelLoader == null) {
86                 throw new IllegalArgumentException(""cannot create presenter without a model loader"");
93          * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
104          * Required - Sets the {@link ModelLoader} the presenter will use to obtain an id for and an InputStream to the
107          * @param modelLoader The {@link ModelLoader} to use to obtain the id and InputStreams
110         public Builder<T> setModelLoader(ModelLoader<T> modelLoader) {
111             this.modelLoader = modelLoader;
116          * Required - Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
128          * Optional - Sets a resource that will be displayed during loads and whenever
145          * Optional - Sets a drawable that will be displayed during loads and whenever
162          * Optional - Sets a callback that will be called after an image is loaded by
175          * Optional - Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
187          * Optional - Sets a handler that will be notified if any path or image load causes an exception.
201     private final ModelLoader<T> modelLoader;
256         this.modelLoader = builder.modelLoader;
294                     fetchImage(model, width, height, loadCount);
321      * this presenter's {@link ModelLoader}. Also displays the current placeholder if
329         modelLoader.clear();
333     private void fetchImage(final T model, int width, int height, final int loadCount) {
334         final StreamLoader streamLoader = modelLoader.getStreamOpener(model, width, height);
335         final String id = modelLoader.getId(model);
337         imageToken = imageLoader.fetchImage(id, streamLoader, width, height, new ImageLoader.ImageReadyCallback() {
450                 handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis()
451                         + PENDING_SIZE_CHANGE_DELAY);
16 import com.bumptech.glide.loader.model.ModelStreamLoader;
17 import com.bumptech.glide.loader.opener.StreamOpener;
23  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and loading bitmaps correctly
24  * when views are being recycled. Uses {@link ModelStreamLoader} to download
25  * an image or otherwise retrieve InputStreams for a given model and {@link ImageLoader} to load
26  * a bitmap from a given path and/or model. Also determines the actual width and height of the wrapped
27  * {@link android.widget.ImageView} and passes that information to the provided
28  * {@link ModelStreamLoader} and {@link ImageLoader}.
36      * A builder for an {@link ImagePresenter}. {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
37      * {@link Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
70         private ModelStreamLoader<T> modelStreamLoader;
84             if (modelStreamLoader == null) {
85                 throw new IllegalArgumentException(""cannot create presenter without a model stream loader"");
92          * Required sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
103          * Required. Sets the {@link ModelStreamLoader} the presenter will use to obtain an Id and InputStreams to the
106          * @param modelStreamLoader The {@link ModelStreamLoader} to use to obtain the id and InputStreams
109         public Builder<T> setModelStreamLoader(ModelStreamLoader<T> modelStreamLoader) {
110             this.modelStreamLoader = modelStreamLoader;
115          * Required Sets the {@link com.bumptech.glide.loader.image.ImageLoader} the presenter will use to load a
127          * Optional Sets a resource that will be displayed during loads and whenever
144          * Optional Sets a drawable that will be displayed during loads and whenever
161          * Optional Sets a callback that will be called after an image is loaded by
174          * Optional Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
186          * Optional Sets a handler that will be notified if any path or image load causes an exception.
199     private Object modelStreamToken;
201     private final ModelStreamLoader<T> modelStreamLoader;
248         this.modelStreamLoader = builder.modelStreamLoader;
294                     fetchModelStream(model, width, height, loadCount);
321      * this presenter's {@link ModelStreamLoader}. Also displays the current placeholder if
329         modelStreamLoader.clear();
333     private void fetchModelStream(final T model, final int width, final int height, final int loadCount) {
334         modelStreamToken = modelStreamLoader.fetchModelStream(model, width, height, new ModelStreamLoader.ModelStreamReadyCallback() {
335             @Override
336             public boolean onStreamReady(String id, StreamOpener streamOpener) {
337                 if (loadCount != currentCount || id == null || streamOpener == null) return false;
338                 fetchImage(model, id, streamOpener, width, height, loadCount);
340                 return true;
341             }
342 
343             @Override
344             public void onException(Exception e) {
345                 if (exceptionHandler != null) {
346                     exceptionHandler.onModelStreamLoadException(e, model, loadCount == currentCount);
347                 }
348             }
349         });
350     }
351 
352     private void fetchImage(final T model, final String id, StreamOpener streamOpener, int width, int height, final int loadCount) {
353         imageToken = imageLoader.fetchImage(id, streamOpener, width, height, new ImageLoader.ImageReadyCallback() {
466                 handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -12,7 +12,7 @@ import android.os.Build;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
@@ -77,7 +77,7 @@ public class ImageManager {
      * This is a conservative estimate that has been safe for 2.2+ devices consistnetly. It is probably rather small
      * for newer devices.
      *
-     * @param context
+     * @param context A context
      * @return The maximum safe size for the memory cache for this devices in bytes
      */
     public static int getSafeMemoryCacheSize(Context context){
@@ -323,14 +323,15 @@ public class ImageManager {
     /**
      * Loads the image at its original dimensions.
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImage(String id, final StreamOpener streamOpener, final LoadedCallback cb){
+    public Object getImage(String id, final StreamLoader streamLoader, final LoadedCallback cb){
         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
+        return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
                 return resizer.loadAsIs(is);
@@ -341,16 +342,17 @@ public class ImageManager {
     /**
      * Loads the image assuming its width and height are exactly those given.
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The width of the image on disk
      * @param height The height of the image on disk
      * @param cb The callback called when the load completes
      * @return A token tracking this request
      */
-    public Object getImageExact(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
+    public Object getImageExact(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(streamOpener) {
+        return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
                 return resizer.loadAsIs(is, width, height);
@@ -361,16 +363,17 @@ public class ImageManager {
     /**
      * Loads the image to nearly the given width and height maintaining the original proportions.
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The desired width in pixels
      * @param height The desired height of the slice
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object getImageApproximate(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
+    public Object getImageApproximate(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob(streamOpener) {
+        return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
                 return resizer.loadAtLeast(is, width, height);
@@ -382,16 +385,17 @@ public class ImageManager {
      * Loads the image, resizes it to be exactly width pixels wide keeping proportions,
      * and then returns a section from the center of image exactly height pixels tall.
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The desired width in pixels
      * @param height The desired height of the slice
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object centerCrop(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
+    public Object centerCrop(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob(streamOpener) {
+        return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
                 return resizer.centerCrop(is, width, height);
@@ -403,16 +407,17 @@ public class ImageManager {
      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
      * an area of width*height.
      *
-     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
-     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
      * @param width The width of the space
      * @param height The height of the space
      * @param cb The callback called when the task finishes
      * @return A token tracking this request
      */
-    public Object fitCenter(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb){
+    public Object fitCenter(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb){
         final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
-        return runJob(key, cb, new ImageManagerJob(streamOpener) {
+        return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
                 return resizer.fitInSpace(is, width, height);
@@ -513,15 +518,15 @@ public class ImageManager {
     }
 
     private abstract class ImageManagerJob implements Runnable {
-        private final StreamOpener streamOpener;
+        private final StreamLoader streamLoader;
         private int key;
         private LoadedCallback cb;
         private boolean useDiskCache;
         private Future future = null;
         private volatile boolean cancelled = false;
 
-        public ImageManagerJob(StreamOpener streamOpener) {
-            this.streamOpener = streamOpener;
+        public ImageManagerJob(StreamLoader streamLoader) {
+            this.streamLoader = streamLoader;
         }
 
         public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
@@ -576,14 +581,23 @@ public class ImageManager {
                 public void run() {
                     if (cancelled) return;
 
+                    streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
+                        @Override
+                        public void onStreamReady(InputStream is) {
                             try {
-                        finishResize(resizeIfNotFound(streamOpener.openStream()), false);
+                                final Bitmap result = resizeIfNotFound(is);
+                                finishResize(result, false);
                             } catch (Exception e) {
                                 cb.onLoadFailed(e);
-                    } finally {
-                        streamOpener.cleanup();
                             }
                         }
+
+                        @Override
+                        public void onException(Exception e) {
+                            cb.onLoadFailed(e);
+                        }
+                    });
+                }
             });
         }
 
","15 import com.bumptech.glide.loader.stream.StreamLoader;
80      * @param context A context
326      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
327      *           is not required to do so
328      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
332     public Object getImage(String id, final StreamLoader streamLoader, final LoadedCallback cb){
334         return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
345      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
346      *           is not required to do so
347      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
353     public Object getImageExact(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
355         return runJob(key, cb, new ImageManagerJob(streamLoader) {
366      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
367      *           is not required to do so
368      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
374     public Object getImageApproximate(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
376         return runJob(key, cb, new ImageManagerJob(streamLoader) {
388      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
389      *           is not required to do so
390      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
396     public Object centerCrop(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
398         return runJob(key, cb, new ImageManagerJob(streamLoader) {
410      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
411      *           is not required to do so
412      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
418     public Object fitCenter(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb){
420         return runJob(key, cb, new ImageManagerJob(streamLoader) {
521         private final StreamLoader streamLoader;
528         public ImageManagerJob(StreamLoader streamLoader) {
529             this.streamLoader = streamLoader;
584                     streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
585                         @Override
586                         public void onStreamReady(InputStream is) {
588                                 final Bitmap result = resizeIfNotFound(is);
589                                 finishResize(result, false);
594 
595                         @Override
596                         public void onException(Exception e) {
597                             cb.onLoadFailed(e);
598                         }
599                     });
600                 }
15 import com.bumptech.glide.loader.opener.StreamOpener;
80      * @param context
326      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
327      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
331     public Object getImage(String id, final StreamOpener streamOpener, final LoadedCallback cb){
333         return runJob(key, cb, false, new ImageManagerJob(streamOpener) {
344      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
345      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
351     public Object getImageExact(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
353         return runJob(key, cb, new ImageManagerJob(streamOpener) {
364      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
365      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
371     public Object getImageApproximate(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
373         return runJob(key, cb, new ImageManagerJob(streamOpener) {
385      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
386      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
392     public Object centerCrop(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb) {
394         return runJob(key, cb, new ImageManagerJob(streamOpener) {
406      * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key.
407      * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached
413     public Object fitCenter(final String id, StreamOpener streamOpener, final int width, final int height, final LoadedCallback cb){
415         return runJob(key, cb, new ImageManagerJob(streamOpener) {
516         private final StreamOpener streamOpener;
523         public ImageManagerJob(StreamOpener streamOpener) {
524             this.streamOpener = streamOpener;
580                         finishResize(resizeIfNotFound(streamOpener.openStream()), false);
583                     } finally {
584                         streamOpener.cleanup();",No
library\src\com\bumptech\glide\resize\loader\Approximate.java,library\src\com\bumptech\glide\resize\loader\Approximate.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -5,7 +5,7 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
@@ -14,7 +14,7 @@ import com.bumptech.glide.resize.LoadedCallback;
  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
  * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
  *
- * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
+ * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class Approximate extends ImageManagerLoader {
 
@@ -23,8 +23,8 @@ public class Approximate extends ImageManagerLoader {
     }
 
     @Override
-    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageApproximate(id, streamOpener, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageApproximate(id, streamLoader, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.glide.loader.stream.StreamLoader;
17  * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
26     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
27         return imageManager.getImageApproximate(id, streamLoader, width, height, new LoadedCallback() {
8 import com.bumptech.glide.loader.opener.StreamOpener;
17  * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
26     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
27         return imageManager.getImageApproximate(id, streamOpener, width, height, new LoadedCallback() {",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,7 +1,7 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
@@ -11,7 +11,7 @@ import com.bumptech.glide.resize.LoadedCallback;
  * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
  * other implementations
  *
- * @see ImageManager#getImage(String, com.bumptech.glide.loader.opener.StreamOpener, com.bumptech.glide.resize.LoadedCallback)
+ * @see ImageManager#getImage(String, com.bumptech.glide.loader.stream.StreamLoader, com.bumptech.glide.resize.LoadedCallback)
  */
 public class AsIs extends ImageManagerLoader {
 
@@ -20,8 +20,8 @@ public class AsIs extends ImageManagerLoader {
     }
 
     @Override
-    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImage(id, streamOpener, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImage(id, streamLoader, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","4 import com.bumptech.glide.loader.stream.StreamLoader;
14  * @see ImageManager#getImage(String, com.bumptech.glide.loader.stream.StreamLoader, com.bumptech.glide.resize.LoadedCallback)
23     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
24         return imageManager.getImage(id, streamLoader, new LoadedCallback() {
4 import com.bumptech.glide.loader.opener.StreamOpener;
14  * @see ImageManager#getImage(String, com.bumptech.glide.loader.opener.StreamOpener, com.bumptech.glide.resize.LoadedCallback)
23     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
24         return imageManager.getImage(id, streamOpener, new LoadedCallback() {",No
library\src\com\bumptech\glide\resize\loader\CenterCrop.java,library\src\com\bumptech\glide\resize\loader\CenterCrop.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -5,14 +5,14 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
  * An ImageLoader implementation that loads and crops in image down to the given width and height.
  *
- * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
+ * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class CenterCrop extends ImageManagerLoader {
 
@@ -21,8 +21,8 @@ public class CenterCrop extends ImageManagerLoader {
     }
 
     @Override
-    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.centerCrop(id, streamOpener, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.centerCrop(id, streamLoader, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.glide.loader.stream.StreamLoader;
15  * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
24     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
25         return imageManager.centerCrop(id, streamLoader, width, height, new LoadedCallback() {
8 import com.bumptech.glide.loader.opener.StreamOpener;
15  * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
24     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
25         return imageManager.centerCrop(id, streamOpener, width, height, new LoadedCallback() {",No
library\src\com\bumptech\glide\resize\loader\Exact.java,library\src\com\bumptech\glide\resize\loader\Exact.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -5,7 +5,7 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
@@ -15,7 +15,7 @@ import com.bumptech.glide.resize.LoadedCallback;
  * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
  * resize).
  *
- * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
+ * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class Exact extends ImageManagerLoader {
 
@@ -24,8 +24,8 @@ public class Exact extends ImageManagerLoader {
     }
 
     @Override
-    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageExact(id, streamOpener, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImageExact(id, streamLoader, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.glide.loader.stream.StreamLoader;
18  * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
27     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
28         return imageManager.getImageExact(id, streamLoader, width, height, new LoadedCallback() {
8 import com.bumptech.glide.loader.opener.StreamOpener;
18  * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
27     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
28         return imageManager.getImageExact(id, streamOpener, width, height, new LoadedCallback() {",No
library\src\com\bumptech\glide\resize\loader\FitCenter.java,library\src\com\bumptech\glide\resize\loader\FitCenter.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -5,7 +5,7 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
@@ -13,7 +13,7 @@ import com.bumptech.glide.resize.LoadedCallback;
  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
  * proportions
  *
- * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
+ * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
 public class FitCenter extends ImageManagerLoader {
 
@@ -22,8 +22,8 @@ public class FitCenter extends ImageManagerLoader {
     }
 
     @Override
-    protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.fitCenter(id, streamOpener, width, height, new LoadedCallback() {
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.fitCenter(id, streamLoader, width, height, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
                 cb.onImageReady(loaded);
","8 import com.bumptech.glide.loader.stream.StreamLoader;
16  * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
25     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.fitCenter(id, streamLoader, width, height, new LoadedCallback() {
8 import com.bumptech.glide.loader.opener.StreamOpener;
16  * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.resize.LoadedCallback)
25     protected Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, final ImageReadyCallback cb) {
26         return imageManager.fitCenter(id, streamOpener, width, height, new LoadedCallback() {",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,e13dcedf144c02927c122fae32179f460b21fef5,c02e315e8021c520780066b82d1063fc9137099a,"Synchronous StreamOpener -> Async StreamLoader

An extensive but relatively minor change to the
internal interfaces to allow for asynchronous 
InputStream opening in the ImageManager. This
allows us to use async http libraries (like 
Volley) without forcing us to always start a 
download and then check the ImageManager cache
only after the download completes.","@@ -1,7 +1,7 @@
 package com.bumptech.glide.resize.loader;
 
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.opener.StreamOpener;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.image.BaseImageLoader;
 import com.bumptech.glide.resize.ImageManager;
 
@@ -19,14 +19,24 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
         this.imageManager = imageManager;
     }
     @Override
-    protected final void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
+    protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
         clear();
-        if (streamOpener != null) {
-            loadToken = loadFromImageManager(id, streamOpener, width, height, cb);
-        }
+        loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
     }
 
-    protected abstract Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
+    /**
+     * An abstract method to make a specific resize call to the {@link ImageManager}
+     *
+     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
+     *           is not required to do so
+     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
+     *
+     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
+     */
+    protected abstract Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
 
     @Override
     protected void onImageReady(String id, Bitmap image, boolean isUsed) {
@@ -54,5 +64,4 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
             acquired = null;
         }
     }
-
 }
","4 import com.bumptech.glide.loader.stream.StreamLoader;
22     protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
24         loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
27     /**
28      * An abstract method to make a specific resize call to the {@link ImageManager}
29      *
30      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
31      *           is not required to do so
32      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
33      * @param width The width of the view where the image will be displayed
34      * @param height The height of the view where the image will be displayed
35      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
36      *
37      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
38      */
39     protected abstract Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
4 import com.bumptech.glide.loader.opener.StreamOpener;
22     protected final void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {
24         if (streamOpener != null) {
25             loadToken = loadFromImageManager(id, streamOpener, width, height, cb);
26         }
29     protected abstract Object loadFromImageManager(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);
57 ",No
samples\flickr\src\com\bumptech\flickr\DirectFlickrStreamLoader.java,,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -1,25 +0,0 @@
-package com.bumptech.flickr;
-
-import com.bumptech.flickr.api.Api;
-import com.bumptech.flickr.api.Photo;
-import com.bumptech.glide.loader.model.DirectModelStreamLoader;
-import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
-import com.bumptech.glide.loader.opener.StreamOpener;
-
-/**
- * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
- * ImageManager to download the image and resize it in memory before saving the resized version
- * directly to the disk cache.
- */
-public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
-
-    @Override
-    protected StreamOpener getStreamOpener(Photo model, int width, int height) {
-        return new HttpInputStreamOpener(Api.getPhotoURL(model, width, height));
-    }
-
-    @Override
-    protected String getId(Photo model) {
-        return model.id;
-    }
-}
","1 package com.bumptech.flickr;
2 
3 import com.bumptech.flickr.api.Api;
4 import com.bumptech.flickr.api.Photo;
5 import com.bumptech.glide.loader.model.DirectModelStreamLoader;
6 import com.bumptech.glide.loader.opener.HttpInputStreamOpener;
7 import com.bumptech.glide.loader.opener.StreamOpener;
8 
9 /**
10  * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
11  * ImageManager to download the image and resize it in memory before saving the resized version
12  * directly to the disk cache.
13  */
14 public class DirectFlickrStreamLoader extends DirectModelStreamLoader<Photo>{
15 
16     @Override
17     protected StreamOpener getStreamOpener(Photo model, int width, int height) {
18         return new HttpInputStreamOpener(Api.getPhotoURL(model, width, height));
19     }
20 
21     @Override
22     protected String getId(Photo model) {
23         return model.id;
24     }
25 }",No
,samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -0,0 +1,41 @@
+package com.bumptech.flickr;
+
+import com.android.volley.RequestQueue;
+import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.loader.model.ModelLoader;
+
+/**
+ * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
+ * ImageManager to download the image and resize it in memory before saving the resized version
+ * directly to the disk cache.
+ */
+public class FlickrModelLoader implements ModelLoader<Photo> {
+    private final RequestQueue requestQueue;
+    private StreamLoader current;
+
+    public FlickrModelLoader(RequestQueue requestQueue) {
+        this.requestQueue = requestQueue;
+    }
+
+    @Override
+    public StreamLoader getStreamOpener(Photo model, int width, int height) {
+        clear();
+        current = new VolleyStreamLoader(requestQueue, Api.getPhotoURL(model, width, height));
+        return current;
+    }
+
+    @Override
+    public String getId(Photo model) {
+        return model.id;
+    }
+
+    @Override
+    public void clear() {
+        if (current != null) {
+            current.cancel();
+            current = null;
+        }
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import com.android.volley.RequestQueue;
4 import com.bumptech.flickr.api.Api;
5 import com.bumptech.flickr.api.Photo;
6 import com.bumptech.glide.loader.stream.StreamLoader;
7 import com.bumptech.glide.loader.model.ModelLoader;
8 
9 /**
10  * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
11  * ImageManager to download the image and resize it in memory before saving the resized version
12  * directly to the disk cache.
13  */
14 public class FlickrModelLoader implements ModelLoader<Photo> {
15     private final RequestQueue requestQueue;
16     private StreamLoader current;
17 
18     public FlickrModelLoader(RequestQueue requestQueue) {
19         this.requestQueue = requestQueue;
20     }
21 
22     @Override
23     public StreamLoader getStreamOpener(Photo model, int width, int height) {
24         clear();
25         current = new VolleyStreamLoader(requestQueue, Api.getPhotoURL(model, width, height));
26         return current;
27     }
28 
29     @Override
30     public String getId(Photo model) {
31         return model.id;
32     }
33 
34     @Override
35     public void clear() {
36         if (current != null) {
37             current.cancel();
38             current = null;
39         }
40     }
41 }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -10,7 +10,7 @@ import android.widget.BaseAdapter;
 import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Api;
+import com.bumptech.flickr.api.Downloader;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.presenter.ImagePresenter;
@@ -112,7 +112,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setModelStreamLoader(new FlickrStreamLoader(Api.get(getActivity()), cacheDir))
+                        .setModelLoader(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
","13 import com.bumptech.flickr.api.Downloader;
115                         .setModelLoader(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
13 import com.bumptech.flickr.api.Api;
115                         .setModelStreamLoader(new FlickrStreamLoader(Api.get(getActivity()), cacheDir))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -9,6 +9,7 @@ import android.widget.ImageView;
 import android.widget.ListView;
 import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
+import com.bumptech.flickr.api.Downloader;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 
@@ -102,7 +103,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
 
             Glide.load(current)
                     .into(viewHolder.imageView)
-                    .with(new DirectFlickrStreamLoader())
+                    .with(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
                     .centerCrop()
                     .animate(R.anim.fade_in)
                     .begin();
","12 import com.bumptech.flickr.api.Downloader;
106                     .with(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
105                     .with(new DirectFlickrStreamLoader())",No
samples\flickr\src\com\bumptech\flickr\FlickrStreamLoader.java,,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -1,45 +0,0 @@
-package com.bumptech.flickr;
-
-import com.android.volley.Request;
-import com.bumptech.flickr.api.Api;
-import com.bumptech.flickr.api.Photo;
-import com.bumptech.glide.loader.model.BaseModelStreamLoader;
-import com.bumptech.glide.loader.opener.FileInputStreamOpener;
-
-import java.io.File;
-
-/**
- * An implementation of a ModelStreamLoader that uses a separate class to download images to disk and then uses
- * the path where the image is downloaded to create an input stream opener. Demonstrates one way of integrating this
- * library with existing apis for download or otherwise retrieving images
- *
- */
-public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
-    private final Api flickrApi;
-    private final File cacheDir;
-    private Request current = null;
-
-    public FlickrStreamLoader(Api flickrApi, File cacheDir) {
-        this.flickrApi = flickrApi;
-        this.cacheDir = cacheDir;
-    }
-
-    @Override
-    protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamReadyCallback cb) {
-        clear();
-        current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
-            @Override
-            public void onDownloadComplete(String path) {
-                cb.onStreamReady(model.id, new FileInputStreamOpener(path));
-            }
-        });
-    }
-
-    @Override
-    public void clear() {
-        if (current != null) {
-            current.cancel();
-            current = null;
-        }
-    }
-}
","1 package com.bumptech.flickr;
2 
3 import com.android.volley.Request;
4 import com.bumptech.flickr.api.Api;
5 import com.bumptech.flickr.api.Photo;
6 import com.bumptech.glide.loader.model.BaseModelStreamLoader;
7 import com.bumptech.glide.loader.opener.FileInputStreamOpener;
8 
9 import java.io.File;
10 
11 /**
12  * An implementation of a ModelStreamLoader that uses a separate class to download images to disk and then uses
13  * the path where the image is downloaded to create an input stream opener. Demonstrates one way of integrating this
14  * library with existing apis for download or otherwise retrieving images
15  *
16  */
17 public class FlickrStreamLoader extends BaseModelStreamLoader<Photo>{
18     private final Api flickrApi;
19     private final File cacheDir;
20     private Request current = null;
21 
22     public FlickrStreamLoader(Api flickrApi, File cacheDir) {
23         this.flickrApi = flickrApi;
24         this.cacheDir = cacheDir;
25     }
26 
27     @Override
28     protected void doFetchModelStreams(final Photo model, int width, int height, final ModelStreamReadyCallback cb) {
29         clear();
30         current = flickrApi.downloadPhoto(model, cacheDir, new Api.PhotoCallback() {
31             @Override
32             public void onDownloadComplete(String path) {
33                 cb.onStreamReady(model.id, new FileInputStreamOpener(path));
34             }
35         });
36     }
37 
38     @Override
39     public void clear() {
40         if (current != null) {
41             current.cancel();
42             current = null;
43         }
44     }
45 }",No
,samples\flickr\src\com\bumptech\flickr\VolleyStreamLoader.java,c717f77320080cf52eae84f740f40911b5bf0733,e13dcedf144c02927c122fae32179f460b21fef5,Update the flickr sample for the new interface,"@@ -0,0 +1,57 @@
+package com.bumptech.flickr;
+
+import com.android.volley.NetworkResponse;
+import com.android.volley.Request;
+import com.android.volley.RequestQueue;
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+import java.io.ByteArrayInputStream;
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/19/13
+ * Time: 8:51 AM
+ * To change this template use File | Settings | File Templates.
+ */
+public class VolleyStreamLoader implements StreamLoader {
+    private final RequestQueue requestQueue;
+    private final URL url;
+    private Request current = null;
+
+    public VolleyStreamLoader(RequestQueue requestQueue, URL url) {
+        this.requestQueue = requestQueue;
+        this.url = url;
+    }
+
+    @Override
+    public void loadStream(final StreamReadyCallback cb) {
+        current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url.toString(), new Response.ErrorListener() {
+            @Override
+            public void onErrorResponse(VolleyError error) {
+                cb.onException(error);
+            }
+        }) {
+            @Override
+            protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
+                return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
+            }
+
+            @Override
+            protected void deliverResponse(ByteArrayInputStream response) {
+                cb.onStreamReady(response);
+            }
+        });
+    }
+
+    @Override
+    public void cancel() {
+        if (current != null) {
+            current.cancel();
+            current = null;
+        }
+    }
+}
","1 package com.bumptech.flickr;
2 
3 import com.android.volley.NetworkResponse;
4 import com.android.volley.Request;
5 import com.android.volley.RequestQueue;
6 import com.android.volley.Response;
7 import com.android.volley.VolleyError;
8 import com.bumptech.glide.loader.stream.StreamLoader;
9 
10 import java.io.ByteArrayInputStream;
11 import java.net.URL;
12 
13 /**
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 7/19/13
17  * Time: 8:51 AM
18  * To change this template use File | Settings | File Templates.
19  */
20 public class VolleyStreamLoader implements StreamLoader {
21     private final RequestQueue requestQueue;
22     private final URL url;
23     private Request current = null;
24 
25     public VolleyStreamLoader(RequestQueue requestQueue, URL url) {
26         this.requestQueue = requestQueue;
27         this.url = url;
28     }
29 
30     @Override
31     public void loadStream(final StreamReadyCallback cb) {
32         current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url.toString(), new Response.ErrorListener() {
33             @Override
34             public void onErrorResponse(VolleyError error) {
35                 cb.onException(error);
36             }
37         }) {
38             @Override
39             protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
40                 return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
41             }
42 
43             @Override
44             protected void deliverResponse(ByteArrayInputStream response) {
45                 cb.onStreamReady(response);
46             }
47         });
48     }
49 
50     @Override
51     public void cancel() {
52         if (current != null) {
53             current.cancel();
54             current = null;
55         }
56     }
57 }",No
.gitmodules,.gitmodules,2e68b553b87ea27caadc67e0561dd1b7d52ed962,c717f77320080cf52eae84f740f40911b5bf0733,remove volley sumodule from flickr sample,"@@ -1,6 +1,3 @@
 [submodule ""samples/flickr/ActionBarSherlock""]
 	path = samples/flickr/ActionBarSherlock
 	url = https://github.com/JakeWharton/ActionBarSherlock.git
-[submodule ""samples/flickr/volley""]
-	path = samples/flickr/volley
-	url = https://android.googlesource.com/platform/frameworks/volley
","4 [submodule ""samples/flickr/volley""]
5 	path = samples/flickr/volley
6 	url = https://android.googlesource.com/platform/frameworks/volley",No
samples\flickr\volley,,2e68b553b87ea27caadc67e0561dd1b7d52ed962,c717f77320080cf52eae84f740f40911b5bf0733,remove volley sumodule from flickr sample,"@@ -1 +0,0 @@
-Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798
",1 Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798,Yes
.gitmodules,.gitmodules,8470694e1bc5f232d39b52740f5fda2ca3f00d29,2e68b553b87ea27caadc67e0561dd1b7d52ed962,Add Volley as a submodule of Glide,"@@ -1,3 +1,6 @@
 [submodule ""samples/flickr/ActionBarSherlock""]
 	path = samples/flickr/ActionBarSherlock
 	url = https://github.com/JakeWharton/ActionBarSherlock.git
+[submodule ""library/volley""]
+	path = library/volley
+	url = https://android.googlesource.com/platform/frameworks/volley
","4 [submodule ""library/volley""]
5 	path = library/volley
6 	url = https://android.googlesource.com/platform/frameworks/volley",No
library\project.properties,library\project.properties,8470694e1bc5f232d39b52740f5fda2ca3f00d29,2e68b553b87ea27caadc67e0561dd1b7d52ed962,Add Volley as a submodule of Glide,"@@ -13,3 +13,4 @@
 android.library=true
 # Project target.
 target=android-16
+android.library.reference=volley
",16 android.library.reference=volley,No
,library\volley,8470694e1bc5f232d39b52740f5fda2ca3f00d29,2e68b553b87ea27caadc67e0561dd1b7d52ed962,Add Volley as a submodule of Glide,"@@ -0,0 +1 @@
+Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798
",1 Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798,Yes
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,633966f8087dc4ef5e52ef0f559ec8090fbbc945,8470694e1bc5f232d39b52740f5fda2ca3f00d29,Make Volley default Model/Stream loader for http,"@@ -4,10 +4,13 @@ import android.content.Context;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
+import com.android.volley.RequestQueue;
+import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
+import com.bumptech.glide.loader.model.VolleyModelLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
 import com.bumptech.glide.resize.ImageManager;
@@ -27,25 +30,52 @@ import java.net.URL;
 public class Glide {
     private static final Glide GLIDE = new Glide();
 
-    private ImageManager imageManager;
+    private ImageManager imageManager = null;
+    private RequestQueue requestQueue = null;
 
     public static Glide get() {
         return GLIDE;
     }
 
-    @SuppressWarnings(""unchecked"")
-    private static <T> ModelLoader<T> getModelFor(T model) {
-        if (model == URL.class) {
-            return (ModelLoader<T>) new UrlLoader();
-        } else if (model == File.class) {
-            return (ModelLoader<T>) new FileLoader();
-        } else {
-            throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
-                    "", you need to provide one by calling with()"");
+    protected Glide() { }
+
+    /**
+     * Return the current {@link RequestQueue} or create and return a new one if one is not currently set
+     *
+     * @see #setRequestQueue(com.android.volley.RequestQueue)
+     * @see #isRequestQueueSet()
+     *
+     * @param context
+     * @return The {@link RequestQueue}
+     */
+    public RequestQueue getRequestQueue(Context context) {
+        if (!isRequestQueueSet()) {
+            setRequestQueue(Volley.newRequestQueue(context));
         }
+        return requestQueue;
     }
 
-    protected Glide() { }
+    /**
+     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
+     * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
+     * {@link #setRequestQueue(com.android.volley.RequestQueue)} to set a {@link RequestQueue} with custom options
+     * for use with {@link Glide#load(Object)}} and/or as an easily accessible singleton
+     *
+     * @return true iff a {@link RequestQueue} has already been set
+     */
+    public boolean isRequestQueueSet() {
+        return requestQueue != null;
+    }
+
+    /**
+     * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
+     * if one has already been set
+     *
+     * @param requestQueue
+     */
+    public void setRequestQueue(RequestQueue requestQueue) {
+        this.requestQueue = requestQueue;
+    }
 
     /**
      * Return the current {@link ImageManager} or create and return a new one if one is not currently set.
@@ -96,6 +126,43 @@ public class Glide {
         this.imageManager = imageManager;
     }
 
+    /**
+     * Begins constructing a load for a given model.
+     *
+     * @param model The model to load, must not be null
+     * @param <T> The type of the model to load
+     * @return A an unfinished Request that will be used to construct the components to load the model
+     */
+    public static <T> HalfRequest<T> load(T model) {
+        if (model == null) {
+            throw new IllegalArgumentException(""Model can't be null"");
+        }
+
+        return new HalfRequest<T>(model);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private static <T> ModelLoader<T> getModelFor(T model, Context context) {
+        if (model == URL.class) {
+            return (ModelLoader<T>) new VolleyModelLoader<URL>(GLIDE.getRequestQueue(context)) {
+                @Override
+                protected String getUrl(URL model, int width, int height) {
+                    return model.toString();
+                }
+
+                @Override
+                public String getId(URL model) {
+                    return model.toString();
+                }
+            };
+        } else if (model == File.class) {
+            return (ModelLoader<T>) new FileLoader();
+        } else {
+            throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
+                    "", you need to provide one by calling with()"");
+        }
+    }
+
      /**
      * A builder for a request
      *
@@ -262,28 +329,11 @@ public class Glide {
         private void build() {
             if (presenter == null) {
                 if (modelLoader == null) {
-                    modelLoader = getModelFor(model);
+                    modelLoader = getModelFor(model, context);
                 }
                 presenter = builder.build();
                 imageView.setTag(R.id.image_presenter_id, presenter);
             }
         }
-
-
-    }
-
-    /**
-     * Begins constructing a load for a given model.
-     *
-     * @param model The model to load, must not be null
-     * @param <T> The type of the model to load
-     * @return A an unfinished Request that will be used to construct the components to load the model
-     */
-    public static <T> HalfRequest<T> load(T model) {
-        if (model == null) {
-            throw new IllegalArgumentException(""Model can't be null"");
-        }
-
-        return new HalfRequest<T>(model);
     }
 }
","7 import com.android.volley.RequestQueue;
8 import com.android.volley.toolbox.Volley;
13 import com.bumptech.glide.loader.model.VolleyModelLoader;
33     private ImageManager imageManager = null;
34     private RequestQueue requestQueue = null;
40     protected Glide() { }
41 
42     /**
43      * Return the current {@link RequestQueue} or create and return a new one if one is not currently set
44      *
45      * @see #setRequestQueue(com.android.volley.RequestQueue)
46      * @see #isRequestQueueSet()
47      *
48      * @param context
49      * @return The {@link RequestQueue}
50      */
51     public RequestQueue getRequestQueue(Context context) {
52         if (!isRequestQueueSet()) {
53             setRequestQueue(Volley.newRequestQueue(context));
55         return requestQueue;
58     /**
59      * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
60      * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
61      * {@link #setRequestQueue(com.android.volley.RequestQueue)} to set a {@link RequestQueue} with custom options
62      * for use with {@link Glide#load(Object)}} and/or as an easily accessible singleton
63      *
64      * @return true iff a {@link RequestQueue} has already been set
65      */
66     public boolean isRequestQueueSet() {
67         return requestQueue != null;
68     }
69 
70     /**
71      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
72      * if one has already been set
73      *
74      * @param requestQueue
75      */
76     public void setRequestQueue(RequestQueue requestQueue) {
77         this.requestQueue = requestQueue;
78     }
129     /**
130      * Begins constructing a load for a given model.
131      *
132      * @param model The model to load, must not be null
133      * @param <T> The type of the model to load
134      * @return A an unfinished Request that will be used to construct the components to load the model
135      */
136     public static <T> HalfRequest<T> load(T model) {
137         if (model == null) {
138             throw new IllegalArgumentException(""Model can't be null"");
139         }
140 
141         return new HalfRequest<T>(model);
142     }
143 
144     @SuppressWarnings(""unchecked"")
145     private static <T> ModelLoader<T> getModelFor(T model, Context context) {
146         if (model == URL.class) {
147             return (ModelLoader<T>) new VolleyModelLoader<URL>(GLIDE.getRequestQueue(context)) {
148                 @Override
149                 protected String getUrl(URL model, int width, int height) {
150                     return model.toString();
151                 }
152 
153                 @Override
154                 public String getId(URL model) {
155                     return model.toString();
156                 }
157             };
158         } else if (model == File.class) {
159             return (ModelLoader<T>) new FileLoader();
160         } else {
161             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
162                     "", you need to provide one by calling with()"");
163         }
164     }
165 
332                     modelLoader = getModelFor(model, context);
30     private ImageManager imageManager;
36     @SuppressWarnings(""unchecked"")
37     private static <T> ModelLoader<T> getModelFor(T model) {
38         if (model == URL.class) {
39             return (ModelLoader<T>) new UrlLoader();
40         } else if (model == File.class) {
41             return (ModelLoader<T>) new FileLoader();
42         } else {
43             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
44                     "", you need to provide one by calling with()"");
48     protected Glide() { }
265                     modelLoader = getModelFor(model);
271 
272 
273     }
274 
275     /**
276      * Begins constructing a load for a given model.
277      *
278      * @param model The model to load, must not be null
279      * @param <T> The type of the model to load
280      * @return A an unfinished Request that will be used to construct the components to load the model
281      */
282     public static <T> HalfRequest<T> load(T model) {
283         if (model == null) {
284             throw new IllegalArgumentException(""Model can't be null"");
285         }
286 
287         return new HalfRequest<T>(model);",No
,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,633966f8087dc4ef5e52ef0f559ec8090fbbc945,8470694e1bc5f232d39b52740f5fda2ca3f00d29,Make Volley default Model/Stream loader for http,"@@ -0,0 +1,38 @@
+package com.bumptech.glide.loader.model;
+
+import com.android.volley.RequestQueue;
+import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.loader.stream.VolleyStreamLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/19/13
+ * Time: 5:34 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public abstract class VolleyModelLoader<T> implements ModelLoader<T>{
+    private final RequestQueue requestQueue;
+    private VolleyStreamLoader current = null;
+
+    public VolleyModelLoader(RequestQueue requestQueue) {
+        this.requestQueue = requestQueue;
+    }
+
+    @Override
+    public StreamLoader getStreamOpener(T model, int width, int height) {
+        clear();
+        current = new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
+        return current;
+    }
+
+    @Override
+    public void clear() {
+        if (current != null) {
+            current.cancel();
+            current = null;
+        }
+    }
+
+    protected abstract String getUrl(T model, int width, int height);
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.android.volley.RequestQueue;
4 import com.bumptech.glide.loader.stream.StreamLoader;
5 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 7/19/13
11  * Time: 5:34 PM
12  * To change this template use File | Settings | File Templates.
13  */
14 public abstract class VolleyModelLoader<T> implements ModelLoader<T>{
15     private final RequestQueue requestQueue;
16     private VolleyStreamLoader current = null;
17 
18     public VolleyModelLoader(RequestQueue requestQueue) {
19         this.requestQueue = requestQueue;
20     }
21 
22     @Override
23     public StreamLoader getStreamOpener(T model, int width, int height) {
24         clear();
25         current = new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
26         return current;
27     }
28 
29     @Override
30     public void clear() {
31         if (current != null) {
32             current.cancel();
33             current = null;
34         }
35     }
36 
37     protected abstract String getUrl(T model, int width, int height);
38 }",No
,library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,633966f8087dc4ef5e52ef0f559ec8090fbbc945,8470694e1bc5f232d39b52740f5fda2ca3f00d29,Make Volley default Model/Stream loader for http,"@@ -0,0 +1,53 @@
+package com.bumptech.glide.loader.stream;
+
+import com.android.volley.NetworkResponse;
+import com.android.volley.Request;
+import com.android.volley.RequestQueue;
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+
+import java.io.ByteArrayInputStream;
+
+/**
+ * A StreamLoader backed by volley for fetching images via http.
+ */
+public class VolleyStreamLoader implements StreamLoader {
+    private final RequestQueue requestQueue;
+    private final String url;
+    private Request current = null;
+
+    public VolleyStreamLoader(RequestQueue requestQueue, String url) {
+        this.requestQueue = requestQueue;
+        this.url = url;
+    }
+
+    @Override
+    public void loadStream(final StreamReadyCallback cb) {
+        current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url, new Response.ErrorListener() {
+            @Override
+            public void onErrorResponse(VolleyError error) {
+                cb.onException(error);
+            }
+        }) {
+            @Override
+            protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
+                //this may be less than ideal, since we can't downsample the image as it is read,
+                //but we don't have a choice if we want to use Volley
+                return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
+            }
+
+            @Override
+            protected void deliverResponse(ByteArrayInputStream response) {
+                cb.onStreamReady(response);
+            }
+        });
+    }
+
+    @Override
+    public void cancel() {
+        if (current != null) {
+            current.cancel();
+            current = null;
+        }
+    }
+}
","1 package com.bumptech.glide.loader.stream;
2 
3 import com.android.volley.NetworkResponse;
4 import com.android.volley.Request;
5 import com.android.volley.RequestQueue;
6 import com.android.volley.Response;
7 import com.android.volley.VolleyError;
8 
9 import java.io.ByteArrayInputStream;
10 
11 /**
12  * A StreamLoader backed by volley for fetching images via http.
13  */
14 public class VolleyStreamLoader implements StreamLoader {
15     private final RequestQueue requestQueue;
16     private final String url;
17     private Request current = null;
18 
19     public VolleyStreamLoader(RequestQueue requestQueue, String url) {
20         this.requestQueue = requestQueue;
21         this.url = url;
22     }
23 
24     @Override
25     public void loadStream(final StreamReadyCallback cb) {
26         current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url, new Response.ErrorListener() {
27             @Override
28             public void onErrorResponse(VolleyError error) {
29                 cb.onException(error);
30             }
31         }) {
32             @Override
33             protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
34                 //this may be less than ideal, since we can't downsample the image as it is read,
35                 //but we don't have a choice if we want to use Volley
36                 return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
37             }
38 
39             @Override
40             protected void deliverResponse(ByteArrayInputStream response) {
41                 cb.onStreamReady(response);
42             }
43         });
44     }
45 
46     @Override
47     public void cancel() {
48         if (current != null) {
49             current.cancel();
50             current = null;
51         }
52     }
53 }",No
samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -3,27 +3,16 @@ package com.bumptech.flickr;
 import com.android.volley.RequestQueue;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.VolleyModelLoader;
 
 /**
  * An implementation of ModelStreamLoader that leverages the StreamOpener class and the ExecutorService backing the
  * ImageManager to download the image and resize it in memory before saving the resized version
  * directly to the disk cache.
  */
-public class FlickrModelLoader implements ModelLoader<Photo> {
-    private final RequestQueue requestQueue;
-    private StreamLoader current;
-
+public class FlickrModelLoader extends VolleyModelLoader<Photo> {
     public FlickrModelLoader(RequestQueue requestQueue) {
-        this.requestQueue = requestQueue;
-    }
-
-    @Override
-    public StreamLoader getStreamOpener(Photo model, int width, int height) {
-        clear();
-        current = new VolleyStreamLoader(requestQueue, Api.getPhotoURL(model, width, height));
-        return current;
+        super(requestQueue);
     }
 
     @Override
@@ -32,10 +21,7 @@ public class FlickrModelLoader implements ModelLoader<Photo> {
     }
 
     @Override
-    public void clear() {
-        if (current != null) {
-            current.cancel();
-            current = null;
-        }
+    protected String getUrl(Photo model, int width, int height) {
+        return Api.getPhotoURL(model, width, height);
     }
 }
","6 import com.bumptech.glide.loader.model.VolleyModelLoader;
13 public class FlickrModelLoader extends VolleyModelLoader<Photo> {
15         super(requestQueue);
24     protected String getUrl(Photo model, int width, int height) {
25         return Api.getPhotoURL(model, width, height);
6 import com.bumptech.glide.loader.stream.StreamLoader;
7 import com.bumptech.glide.loader.model.ModelLoader;
14 public class FlickrModelLoader implements ModelLoader<Photo> {
15     private final RequestQueue requestQueue;
16     private StreamLoader current;
17 
19         this.requestQueue = requestQueue;
20     }
21 
22     @Override
23     public StreamLoader getStreamOpener(Photo model, int width, int height) {
24         clear();
25         current = new VolleyStreamLoader(requestQueue, Api.getPhotoURL(model, width, height));
26         return current;
35     public void clear() {
36         if (current != null) {
37             current.cancel();
38             current = null;
39         }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -10,7 +10,6 @@ import android.widget.BaseAdapter;
 import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Downloader;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.presenter.ImagePresenter;
@@ -112,7 +111,7 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setModelLoader(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
+                        .setModelLoader(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
","114                         .setModelLoader(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
13 import com.bumptech.flickr.api.Downloader;
115                         .setModelLoader(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -9,7 +9,6 @@ import android.widget.ImageView;
 import android.widget.ListView;
 import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Downloader;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 
@@ -103,7 +102,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
 
             Glide.load(current)
                     .into(viewHolder.imageView)
-                    .with(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))
+                    .with(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
                     .centerCrop()
                     .animate(R.anim.fade_in)
                     .begin();
","105                     .with(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
12 import com.bumptech.flickr.api.Downloader;
106                     .with(new FlickrModelLoader(Downloader.get(getActivity()).getQueue()))",No
samples\flickr\src\com\bumptech\flickr\VolleyStreamLoader.java,,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -1,57 +0,0 @@
-package com.bumptech.flickr;
-
-import com.android.volley.NetworkResponse;
-import com.android.volley.Request;
-import com.android.volley.RequestQueue;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-import com.bumptech.glide.loader.stream.StreamLoader;
-
-import java.io.ByteArrayInputStream;
-import java.net.URL;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/19/13
- * Time: 8:51 AM
- * To change this template use File | Settings | File Templates.
- */
-public class VolleyStreamLoader implements StreamLoader {
-    private final RequestQueue requestQueue;
-    private final URL url;
-    private Request current = null;
-
-    public VolleyStreamLoader(RequestQueue requestQueue, URL url) {
-        this.requestQueue = requestQueue;
-        this.url = url;
-    }
-
-    @Override
-    public void loadStream(final StreamReadyCallback cb) {
-        current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url.toString(), new Response.ErrorListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                cb.onException(error);
-            }
-        }) {
-            @Override
-            protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
-                return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
-            }
-
-            @Override
-            protected void deliverResponse(ByteArrayInputStream response) {
-                cb.onStreamReady(response);
-            }
-        });
-    }
-
-    @Override
-    public void cancel() {
-        if (current != null) {
-            current.cancel();
-            current = null;
-        }
-    }
-}
","1 package com.bumptech.flickr;
2 
3 import com.android.volley.NetworkResponse;
4 import com.android.volley.Request;
5 import com.android.volley.RequestQueue;
6 import com.android.volley.Response;
7 import com.android.volley.VolleyError;
8 import com.bumptech.glide.loader.stream.StreamLoader;
9 
10 import java.io.ByteArrayInputStream;
11 import java.net.URL;
12 
13 /**
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 7/19/13
17  * Time: 8:51 AM
18  * To change this template use File | Settings | File Templates.
19  */
20 public class VolleyStreamLoader implements StreamLoader {
21     private final RequestQueue requestQueue;
22     private final URL url;
23     private Request current = null;
24 
25     public VolleyStreamLoader(RequestQueue requestQueue, URL url) {
26         this.requestQueue = requestQueue;
27         this.url = url;
28     }
29 
30     @Override
31     public void loadStream(final StreamReadyCallback cb) {
32         current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url.toString(), new Response.ErrorListener() {
33             @Override
34             public void onErrorResponse(VolleyError error) {
35                 cb.onException(error);
36             }
37         }) {
38             @Override
39             protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
40                 return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
41             }
42 
43             @Override
44             protected void deliverResponse(ByteArrayInputStream response) {
45                 cb.onStreamReady(response);
46             }
47         });
48     }
49 
50     @Override
51     public void cancel() {
52         if (current != null) {
53             current.cancel();
54             current = null;
55         }
56     }
57 }",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -2,22 +2,21 @@ package com.bumptech.flickr.api;
 
 import android.content.Context;
 import com.android.volley.Request;
-import com.bumptech.flickr.R;
+import com.android.volley.RequestQueue;
+import com.android.volley.Response;
+import com.android.volley.VolleyError;
+import com.android.volley.toolbox.StringRequest;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.util.Log;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.File;
-import java.net.MalformedURLException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * Created with IntelliJ IDEA.
@@ -28,8 +27,6 @@ import java.util.Set;
  */
 public class Api {
     private static Api API;
-    public static final String SEARCH_COMPLETED_ACTION = ""search_completed"";
-
     private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
@@ -49,6 +46,8 @@ public class Api {
         Collections.sort(SORTED_SIZE_KEYS);
     }
 
+    private final RequestQueue requestQueue;
+
     private static String getSizeKey(int width, int height) {
         final int largestEdge = Math.max(width, height);
 
@@ -66,33 +65,19 @@ public class Api {
         public void onSearchCompleted(List<Photo> photos);
     }
 
-    public interface PhotoCallback {
-        public void onDownloadComplete(String path);
-    }
-
-    private final Downloader downloader;
-    private Set<String> downloadedFilesNames = new HashSet<String>();
-    private final String sizeKey;
-
     public static Api get(Context applicationContext) {
         if (API == null) {
-            API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
+            API = new Api(applicationContext);
         }
         return API;
     }
 
-    protected Api(Context applicationContext, int maxPhotoSize) {
-        this.downloader = Downloader.get(applicationContext);
-        this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
+    protected Api(Context applicationContext) {
+        this.requestQueue = Glide.get().getRequestQueue(applicationContext);
     }
 
-    public static URL getPhotoURL(Photo photo, int width, int height) {
-        try {
-            return new URL(getPhotoUrl(photo, getSizeKey(width, height)));
-        } catch (MalformedURLException e) {
-            e.printStackTrace();
-            return null;
-        }
+    public static String getPhotoURL(Photo photo, int width, int height) {
+        return getPhotoUrl(photo, getSizeKey(width, height));
     }
 
     private static String getUrlForMethod(String method) {
@@ -109,12 +94,12 @@ public class Api {
 
     public void search(String text, final SearchCallback cb) {
         Log.d(""API: searching"");
-        downloader.download(getSearchUrl(text), new Downloader.StringCallback() {
+        requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
             @Override
-            public void onDownloadReady(String result) {
+            public void onResponse(String response) {
                 try {
                     //cut out initial flickJsonApi(
-                    JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));
+                    JSONObject searchResults = new JSONObject(response.substring(14, response.length()-1));
                     JSONArray photos = searchResults.getJSONObject(""photos"").getJSONArray(""photo"");
                     List<Photo> results = new ArrayList<Photo>(photos.length());
                     for (int i = 0; i < photos.length(); i++) {
@@ -125,25 +110,11 @@ public class Api {
                     e.printStackTrace();
                 }
             }
-        });
-    }
-
-    public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
-        File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
-        final String path = out.getPath();
-        Request result = null;
-        if (downloadedFilesNames.contains(path)) {
-            cb.onDownloadComplete(path);
-        } else {
-            Log.d(""API: missing photo, downloading"");
-            result = downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
+        }, new Response.ErrorListener() {
             @Override
-                public void onDownloadReady(String path) {
-                    downloadedFilesNames.add(path);
-                    cb.onDownloadComplete(path);
-                }
-            });
+            public void onErrorResponse(VolleyError error) {
+                error.printStackTrace();
             }
-        return result;
+        }));
     }
 }
","5 import com.android.volley.RequestQueue;
6 import com.android.volley.Response;
7 import com.android.volley.VolleyError;
8 import com.android.volley.toolbox.StringRequest;
9 import com.bumptech.glide.Glide;
49     private final RequestQueue requestQueue;
50 
70             API = new Api(applicationContext);
75     protected Api(Context applicationContext) {
76         this.requestQueue = Glide.get().getRequestQueue(applicationContext);
79     public static String getPhotoURL(Photo photo, int width, int height) {
80         return getPhotoUrl(photo, getSizeKey(width, height));
97         requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
99             public void onResponse(String response) {
102                     JSONObject searchResults = new JSONObject(response.substring(14, response.length()-1));
113         }, new Response.ErrorListener() {
115             public void onErrorResponse(VolleyError error) {
116                 error.printStackTrace();
118         }));
5 import com.bumptech.flickr.R;
11 import java.io.File;
12 import java.net.MalformedURLException;
13 import java.net.URL;
17 import java.util.HashSet;
20 import java.util.Set;
31     public static final String SEARCH_COMPLETED_ACTION = ""search_completed"";
32 
69     public interface PhotoCallback {
70         public void onDownloadComplete(String path);
71     }
72 
73     private final Downloader downloader;
74     private Set<String> downloadedFilesNames = new HashSet<String>();
75     private final String sizeKey;
76 
79             API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));
84     protected Api(Context applicationContext, int maxPhotoSize) {
85         this.downloader = Downloader.get(applicationContext);
86         this.sizeKey = getSizeKey(maxPhotoSize, maxPhotoSize);
89     public static URL getPhotoURL(Photo photo, int width, int height) {
90         try {
91             return new URL(getPhotoUrl(photo, getSizeKey(width, height)));
92         } catch (MalformedURLException e) {
93             e.printStackTrace();
94             return null;
95         }
112         downloader.download(getSearchUrl(text), new Downloader.StringCallback() {
114             public void onDownloadReady(String result) {
117                     JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));
128         });
129     }
130 
131     public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {
132         File out = new File(cacheDir.getPath() + File.separator + photo.id + photo.secret + sizeKey);
133         final String path = out.getPath();
134         Request result = null;
135         if (downloadedFilesNames.contains(path)) {
136             cb.onDownloadComplete(path);
137         } else {
138             Log.d(""API: missing photo, downloading"");
139             result = downloader.download(getPhotoUrl(photo, sizeKey), out, new Downloader.DiskCallback() {
141                 public void onDownloadReady(String path) {
142                     downloadedFilesNames.add(path);
143                     cb.onDownloadComplete(path);
145             });
146        }
147         return result;",No
samples\flickr\src\com\bumptech\flickr\api\Downloader.java,,ffecc1458c51228061cfed14d7f81c7b59db3f61,633966f8087dc4ef5e52ef0f559ec8090fbbc945,Use Glide's Volley api in flickr sample,"@@ -1,101 +0,0 @@
-package com.bumptech.flickr.api;
-
-import android.content.Context;
-import com.android.volley.NetworkResponse;
-import com.android.volley.Request;
-import com.android.volley.RequestQueue;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-import com.android.volley.toolbox.StringRequest;
-import com.android.volley.toolbox.Volley;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/6/13
- * Time: 10:36 AM
- * To change this template use File | Settings | File Templates.
- */
-public class Downloader {
-    private static Downloader DOWNLOADER;
-    private final RequestQueue queue;
-
-    public static Downloader get(Context context) {
-        if (DOWNLOADER == null) {
-            DOWNLOADER = new Downloader(context);
-        }
-        return DOWNLOADER;
-    }
-
-    public Downloader(Context context) {
-        queue = Volley.newRequestQueue(context);
-    }
-
-    public RequestQueue getQueue() {
-        return queue;
-    }
-
-    public interface StringCallback {
-        public void onDownloadReady(String result);
-    }
-
-    public interface DiskCallback {
-        public void onDownloadReady(String path);
-    }
-
-    public void download(String url, final StringCallback cb) {
-        queue.add(new StringRequest(Request.Method.GET, url, new Response.Listener<String>() {
-            @Override
-            public void onResponse(String response) {
-                cb.onDownloadReady(response);
-            }
-        }, new Response.ErrorListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                error.printStackTrace();
-            }
-        }));
-    }
-
-    public Request download(String url, final File out, final DiskCallback cb) {
-        return queue.add(new Request<String>(Request.Method.GET, url, new Response.ErrorListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                error.printStackTrace();
-            }
-        }) {
-            @Override
-            protected Response<String> parseNetworkResponse(NetworkResponse response) {
-                OutputStream os = null;
-                try {
-                    os = new BufferedOutputStream(new FileOutputStream(out));
-                    os.write(response.data);
-                } catch (FileNotFoundException e) {
-                    e.printStackTrace();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                } finally {
-                    if (os != null) {
-                        try {
-                            os.close();
-                        } catch (IOException e) { }
-                    }
-                }
-                return Response.success(out.getAbsolutePath(), getCacheEntry());
-            }
-
-            @Override
-            protected void deliverResponse(String response) {
-                cb.onDownloadReady(response);
-            }
-        });
-
-    }
-}
","1 package com.bumptech.flickr.api;
2 
3 import android.content.Context;
4 import com.android.volley.NetworkResponse;
5 import com.android.volley.Request;
6 import com.android.volley.RequestQueue;
7 import com.android.volley.Response;
8 import com.android.volley.VolleyError;
9 import com.android.volley.toolbox.StringRequest;
10 import com.android.volley.toolbox.Volley;
11 
12 import java.io.BufferedOutputStream;
13 import java.io.File;
14 import java.io.FileNotFoundException;
15 import java.io.FileOutputStream;
16 import java.io.IOException;
17 import java.io.OutputStream;
18 
19 /**
20  * Created with IntelliJ IDEA.
21  * User: sam
22  * Date: 1/6/13
23  * Time: 10:36 AM
24  * To change this template use File | Settings | File Templates.
25  */
26 public class Downloader {
27     private static Downloader DOWNLOADER;
28     private final RequestQueue queue;
29 
30     public static Downloader get(Context context) {
31         if (DOWNLOADER == null) {
32             DOWNLOADER = new Downloader(context);
33         }
34         return DOWNLOADER;
35     }
36 
37     public Downloader(Context context) {
38         queue = Volley.newRequestQueue(context);
39     }
40 
41     public RequestQueue getQueue() {
42         return queue;
43     }
44 
45     public interface StringCallback {
46         public void onDownloadReady(String result);
47     }
48 
49     public interface DiskCallback {
50         public void onDownloadReady(String path);
51     }
52 
53     public void download(String url, final StringCallback cb) {
54         queue.add(new StringRequest(Request.Method.GET, url, new Response.Listener<String>() {
55             @Override
56             public void onResponse(String response) {
57                 cb.onDownloadReady(response);
58             }
59         }, new Response.ErrorListener() {
60             @Override
61             public void onErrorResponse(VolleyError error) {
62                 error.printStackTrace();
63             }
64         }));
65     }
66 
67     public Request download(String url, final File out, final DiskCallback cb) {
68         return queue.add(new Request<String>(Request.Method.GET, url, new Response.ErrorListener() {
69             @Override
70             public void onErrorResponse(VolleyError error) {
71                 error.printStackTrace();
72             }
73         }) {
74             @Override
75             protected Response<String> parseNetworkResponse(NetworkResponse response) {
76                 OutputStream os = null;
77                 try {
78                     os = new BufferedOutputStream(new FileOutputStream(out));
79                     os.write(response.data);
80                 } catch (FileNotFoundException e) {
81                     e.printStackTrace();
82                 } catch (IOException e) {
83                     e.printStackTrace();
84                 } finally {
85                     if (os != null) {
86                         try {
87                             os.close();
88                         } catch (IOException e) { }
89                     }
90                 }
91                 return Response.success(out.getAbsolutePath(), getCacheEntry());
92             }
93 
94             @Override
95             protected void deliverResponse(String response) {
96                 cb.onDownloadReady(response);
97             }
98         });
99 
100     }
101 }",No
samples\flickr\res\layout\flickr_search_activity.xml,samples\flickr\res\layout\flickr_search_activity.xml,f52e773c00be9c7b5ac244e0575cc75a4671750e,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -54,6 +54,7 @@
           android:textSize=""16sp""
           android:layout_marginBottom=""10dp""/>
         <ProgressBar
+          android:id=""@+id/search_loading""
           android:layout_width=""wrap_content""
           android:layout_height=""wrap_content""
           android:indeterminate=""true"" />
","57           android:id=""@+id/search_loading""",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,f52e773c00be9c7b5ac244e0575cc75a4671750e,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -3,6 +3,7 @@
     <string name=""app_name"">MyActivity</string>
     <string name=""search"">Search</string>
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
+  <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>
   <string name=""small"">Small</string>
   <string name=""medium"">Medium</string>
   <string name=""list"">List</string>
","6   <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,f52e773c00be9c7b5ac244e0575cc75a4671750e,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -40,6 +40,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
     private File cacheDir;
     private List<Photo> currentPhotos = new ArrayList<Photo>();
+    private View searchLoading;
 
     private enum Page {
         SMALL,
@@ -88,6 +89,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         }
 
         searching = findViewById(R.id.searching);
+        searchLoading = findViewById(R.id.search_loading);
         searchTerm = (TextView) findViewById(R.id.search_term);
 
         searchText = (EditText) findViewById(R.id.search_text);
@@ -146,6 +148,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         final int currentSearch = ++searchCount;
 
         searching.setVisibility(View.VISIBLE);
+        searchLoading.setVisibility(View.VISIBLE);
         searchTerm.setText(getString(R.string.searching_for, searchString));
 
         Api.get(this).search(searchString, new Api.SearchCallback() {
@@ -162,6 +165,17 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
                 currentPhotos = photos;
             }
+
+            @Override
+            public void onSearchFailed(Exception e) {
+                if (currentSearch != searchCount) return;
+                e.printStackTrace();
+
+                Log.d(""SEARCH: failed :("");
+                searching.setVisibility(View.VISIBLE);
+                searchLoading.setVisibility(View.INVISIBLE);
+                searchTerm.setText(getString(R.string.search_failed, searchString));
+            }
         });
     }
 
","43     private View searchLoading;
92         searchLoading = findViewById(R.id.search_loading);
151         searchLoading.setVisibility(View.VISIBLE);
168 
169             @Override
170             public void onSearchFailed(Exception e) {
171                 if (currentSearch != searchCount) return;
172                 e.printStackTrace();
173 
174                 Log.d(""SEARCH: failed :("");
175                 searching.setVisibility(View.VISIBLE);
176                 searchLoading.setVisibility(View.INVISIBLE);
177                 searchTerm.setText(getString(R.string.search_failed, searchString));
178             }",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,f52e773c00be9c7b5ac244e0575cc75a4671750e,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -63,6 +63,7 @@ public class Api {
 
     public interface SearchCallback {
         public void onSearchCompleted(List<Photo> photos);
+        public void onSearchFailed(Exception e);
     }
 
     public static Api get(Context applicationContext) {
@@ -93,7 +94,6 @@ public class Api {
     }
 
     public void search(String text, final SearchCallback cb) {
-        Log.d(""API: searching"");
         requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
             @Override
             public void onResponse(String response) {
@@ -113,7 +113,7 @@ public class Api {
         }, new Response.ErrorListener() {
             @Override
             public void onErrorResponse(VolleyError error) {
-                error.printStackTrace();
+                cb.onSearchFailed(error);
             }
         }));
     }
","66         public void onSearchFailed(Exception e);
116                 cb.onSearchFailed(error);
96         Log.d(""API: searching"");
116                 error.printStackTrace();",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,ffecc1458c51228061cfed14d7f81c7b59db3f61,"Run resize tasks in our thread pool

Previously would have run them on whatever thread
the callback was called on, which may have been
some external library's thread.","@@ -583,7 +583,10 @@ public class ImageManager {
 
                     streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
                         @Override
-                        public void onStreamReady(InputStream is) {
+                        public void onStreamReady(final InputStream is) {
+                            future = executor.submit(new Runnable() {
+                                @Override
+                                public void run() {
                                     try {
                                         final Bitmap result = resizeIfNotFound(is);
                                         finishResize(result, false);
@@ -591,6 +594,8 @@ public class ImageManager {
                                         cb.onLoadFailed(e);
                                     }
                                 }
+                            });
+                        }
 
                         @Override
                         public void onException(Exception e) {
","586                         public void onStreamReady(final InputStream is) {
587                             future = executor.submit(new Runnable() {
588                                 @Override
589                                 public void run() {
597                             });
598                         }
586                         public void onStreamReady(InputStream is) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,42dde938ba8adeb26321f6205091a8923c4fe53b,f52e773c00be9c7b5ac244e0575cc75a4671750e,Update the comments in the Glide singleton,"@@ -25,7 +25,9 @@ import java.net.URL;
  * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
  * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
  * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
- * starting point and example. This class is not thread safe.
+ * starting point and example.
+ *
+ * Note - This class is not thread safe.
  */
 public class Glide {
     private static final Glide GLIDE = new Glide();
@@ -33,6 +35,11 @@ public class Glide {
     private ImageManager imageManager = null;
     private RequestQueue requestQueue = null;
 
+    /**
+     * Get the singleton.
+     *
+     * @return the singleton
+     */
     public static Glide get() {
         return GLIDE;
     }
@@ -71,7 +78,7 @@ public class Glide {
      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
      * if one has already been set
      *
-     * @param requestQueue
+     * @param requestQueue The {@link RequestQueue} to set
      */
     public void setRequestQueue(RequestQueue requestQueue) {
         this.requestQueue = requestQueue;
@@ -129,6 +136,20 @@ public class Glide {
     /**
      * Begins constructing a load for a given model.
      *
+     * Note - If an {@link ImageManager} has not yet been set via
+     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
+     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
+     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
+     *
+     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
+     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
+     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
+     *
+     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
+     * @see #setRequestQueue(com.android.volley.RequestQueue)
+     * @see #isImageManagerSet()
+     * @see #isRequestQueueSet()
+     *
      * @param model The model to load, must not be null
      * @param <T> The type of the model to load
      * @return A an unfinished Request that will be used to construct the components to load the model
@@ -191,6 +212,7 @@ public class Glide {
 
     /**
      * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
+     *
      * @param <T> The type of model that will be loaded into the view
      */
     public static class Request<T> {
@@ -215,8 +237,12 @@ public class Glide {
         }
 
         /**
-         * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
-         * for File models, defaults to {@link FileLoader}.
+         * Set the {@link ModelLoader} for the model.
+         *
+         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
+         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
+         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
+         * defaults to {@link FileLoader}.
          *
          * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
          * @return This Request
@@ -306,7 +332,7 @@ public class Glide {
 
         /**
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
-         * the given model
+         * the given model. This must be called on the main thread.
          *
          * @see ImagePresenter#setModel(Object)
          */
","28  * starting point and example.
29  *
30  * Note - This class is not thread safe.
38     /**
39      * Get the singleton.
40      *
41      * @return the singleton
42      */
81      * @param requestQueue The {@link RequestQueue} to set
139      * Note - If an {@link ImageManager} has not yet been set via
140      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
141      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
142      * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
143      *
144      * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
145      * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
146      * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
147      *
148      * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
149      * @see #setRequestQueue(com.android.volley.RequestQueue)
150      * @see #isImageManagerSet()
151      * @see #isRequestQueueSet()
152      *
215      *
240          * Set the {@link ModelLoader} for the model.
241          *
242          * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
243          * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
244          * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
245          * defaults to {@link FileLoader}.
335          * the given model. This must be called on the main thread.
28  * starting point and example. This class is not thread safe.
74      * @param requestQueue
218          * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
219          * for File models, defaults to {@link FileLoader}.
309          * the given model",No
samples\flickr\res\layout\flickr_search_activity.xml,samples\flickr\res\layout\flickr_search_activity.xml,0f38de643fb07ae6761ad4d3e28586ab5e42e9b7,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -54,6 +54,7 @@
           android:textSize=""16sp""
           android:layout_marginBottom=""10dp""/>
         <ProgressBar
+          android:id=""@+id/search_loading""
           android:layout_width=""wrap_content""
           android:layout_height=""wrap_content""
           android:indeterminate=""true"" />
","57           android:id=""@+id/search_loading""",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,0f38de643fb07ae6761ad4d3e28586ab5e42e9b7,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -3,6 +3,7 @@
     <string name=""app_name"">MyActivity</string>
     <string name=""search"">Search</string>
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
+  <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>
   <string name=""small"">Small</string>
   <string name=""medium"">Medium</string>
   <string name=""list"">List</string>
","6   <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,0f38de643fb07ae6761ad4d3e28586ab5e42e9b7,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -40,6 +40,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
     private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
     private File cacheDir;
     private List<Photo> currentPhotos = new ArrayList<Photo>();
+    private View searchLoading;
 
     private enum Page {
         SMALL,
@@ -88,6 +89,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         }
 
         searching = findViewById(R.id.searching);
+        searchLoading = findViewById(R.id.search_loading);
         searchTerm = (TextView) findViewById(R.id.search_term);
 
         searchText = (EditText) findViewById(R.id.search_text);
@@ -146,6 +148,7 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         final int currentSearch = ++searchCount;
 
         searching.setVisibility(View.VISIBLE);
+        searchLoading.setVisibility(View.VISIBLE);
         searchTerm.setText(getString(R.string.searching_for, searchString));
 
         Api.get(this).search(searchString, new Api.SearchCallback() {
@@ -162,6 +165,17 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
 
                 currentPhotos = photos;
             }
+
+            @Override
+            public void onSearchFailed(Exception e) {
+                if (currentSearch != searchCount) return;
+                e.printStackTrace();
+
+                Log.d(""SEARCH: failed :("");
+                searching.setVisibility(View.VISIBLE);
+                searchLoading.setVisibility(View.INVISIBLE);
+                searchTerm.setText(getString(R.string.search_failed, searchString));
+            }
         });
     }
 
","43     private View searchLoading;
92         searchLoading = findViewById(R.id.search_loading);
151         searchLoading.setVisibility(View.VISIBLE);
168 
169             @Override
170             public void onSearchFailed(Exception e) {
171                 if (currentSearch != searchCount) return;
172                 e.printStackTrace();
173 
174                 Log.d(""SEARCH: failed :("");
175                 searching.setVisibility(View.VISIBLE);
176                 searchLoading.setVisibility(View.INVISIBLE);
177                 searchTerm.setText(getString(R.string.search_failed, searchString));
178             }",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,0f38de643fb07ae6761ad4d3e28586ab5e42e9b7,8a7822194beb73ad7ea4a0a8dc1fa3e42eb6128d,Gracefully handle search failure in flickr sample,"@@ -63,6 +63,7 @@ public class Api {
 
     public interface SearchCallback {
         public void onSearchCompleted(List<Photo> photos);
+        public void onSearchFailed(Exception e);
     }
 
     public static Api get(Context applicationContext) {
@@ -93,7 +94,6 @@ public class Api {
     }
 
     public void search(String text, final SearchCallback cb) {
-        Log.d(""API: searching"");
         requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
             @Override
             public void onResponse(String response) {
@@ -107,13 +107,14 @@ public class Api {
                     }
                     cb.onSearchCompleted(results);
                 } catch (JSONException e) {
-                    e.printStackTrace();
+                    cb.onSearchFailed(e);
+                    Log.d(""ERROR: response="" + response);
                 }
             }
         }, new Response.ErrorListener() {
             @Override
             public void onErrorResponse(VolleyError error) {
-                error.printStackTrace();
+                cb.onSearchFailed(error);
             }
         }));
     }
","66         public void onSearchFailed(Exception e);
110                     cb.onSearchFailed(e);
111                     Log.d(""ERROR: response="" + response);
117                 cb.onSearchFailed(error);
96         Log.d(""API: searching"");
110                     e.printStackTrace();
116                 error.printStackTrace();",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,56e62046cf9e1bd2d341b6455a9b81b5757e269c,0f38de643fb07ae6761ad4d3e28586ab5e42e9b7,Update the comments in the Glide singleton,"@@ -25,7 +25,9 @@ import java.net.URL;
  * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
  * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
  * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
- * starting point and example. This class is not thread safe.
+ * starting point and example.
+ *
+ * Note - This class is not thread safe.
  */
 public class Glide {
     private static final Glide GLIDE = new Glide();
@@ -33,6 +35,11 @@ public class Glide {
     private ImageManager imageManager = null;
     private RequestQueue requestQueue = null;
 
+    /**
+     * Get the singleton.
+     *
+     * @return the singleton
+     */
     public static Glide get() {
         return GLIDE;
     }
@@ -71,7 +78,7 @@ public class Glide {
      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
      * if one has already been set
      *
-     * @param requestQueue
+     * @param requestQueue The {@link RequestQueue} to set
      */
     public void setRequestQueue(RequestQueue requestQueue) {
         this.requestQueue = requestQueue;
@@ -129,6 +136,20 @@ public class Glide {
     /**
      * Begins constructing a load for a given model.
      *
+     * Note - If an {@link ImageManager} has not yet been set via
+     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
+     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
+     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
+     *
+     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
+     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
+     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
+     *
+     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
+     * @see #setRequestQueue(com.android.volley.RequestQueue)
+     * @see #isImageManagerSet()
+     * @see #isRequestQueueSet()
+     *
      * @param model The model to load, must not be null
      * @param <T> The type of the model to load
      * @return A an unfinished Request that will be used to construct the components to load the model
@@ -191,6 +212,7 @@ public class Glide {
 
     /**
      * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
+     *
      * @param <T> The type of model that will be loaded into the view
      */
     public static class Request<T> {
@@ -215,8 +237,12 @@ public class Glide {
         }
 
         /**
-         * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
-         * for File models, defaults to {@link FileLoader}.
+         * Set the {@link ModelLoader} for the model.
+         *
+         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
+         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
+         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
+         * defaults to {@link FileLoader}.
          *
          * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
          * @return This Request
@@ -306,7 +332,7 @@ public class Glide {
 
         /**
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
-         * the given model
+         * the given model. This must be called on the main thread.
          *
          * @see ImagePresenter#setModel(Object)
          */
","28  * starting point and example.
29  *
30  * Note - This class is not thread safe.
38     /**
39      * Get the singleton.
40      *
41      * @return the singleton
42      */
81      * @param requestQueue The {@link RequestQueue} to set
139      * Note - If an {@link ImageManager} has not yet been set via
140      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
141      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
142      * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
143      *
144      * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
145      * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
146      * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
147      *
148      * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
149      * @see #setRequestQueue(com.android.volley.RequestQueue)
150      * @see #isImageManagerSet()
151      * @see #isRequestQueueSet()
152      *
215      *
240          * Set the {@link ModelLoader} for the model.
241          *
242          * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
243          * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
244          * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
245          * defaults to {@link FileLoader}.
335          * the given model. This must be called on the main thread.
28  * starting point and example. This class is not thread safe.
74      * @param requestQueue
218          * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
219          * for File models, defaults to {@link FileLoader}.
309          * the given model",No
,library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,78d7c407e08dd6167fa8d3a3f8bc4b435a841ca0,56e62046cf9e1bd2d341b6455a9b81b5757e269c,"Add a BaseModelLoader

Allows us to remove the repetitive
ModelLoader.close() -> StreamOpener.cancel()","@@ -0,0 +1,27 @@
+package com.bumptech.glide.loader.model;
+
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+/**
+ * A base class that handles canceling any existing {@link StreamLoader} when
+ * cleared
+ */
+public abstract class BaseModelLoader<T> implements ModelLoader<T> {
+    private StreamLoader current;
+
+    @Override
+    public final StreamLoader getStreamOpener(T model, int width, int height) {
+        current = buildStreamOpener(model, width, height);
+        return current;
+    }
+
+    protected abstract StreamLoader buildStreamOpener(T model, int width, int height);
+
+    @Override
+    public void clear() {
+        if (current != null) {
+            current.cancel();
+            current = null;
+        }
+    }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.stream.StreamLoader;
4 
5 /**
6  * A base class that handles canceling any existing {@link StreamLoader} when
7  * cleared
8  */
9 public abstract class BaseModelLoader<T> implements ModelLoader<T> {
10     private StreamLoader current;
11 
12     @Override
13     public final StreamLoader getStreamOpener(T model, int width, int height) {
14         current = buildStreamOpener(model, width, height);
15         return current;
16     }
17 
18     protected abstract StreamLoader buildStreamOpener(T model, int width, int height);
19 
20     @Override
21     public void clear() {
22         if (current != null) {
23             current.cancel();
24             current = null;
25         }
26     }
27 }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,b76f0ab40cb6c420eea98f0e22aefb84595e2c43,78d7c407e08dd6167fa8d3a3f8bc4b435a841ca0,"Clear loaders before load in ImagePresenter

Allows us not to call clear before new loads in
all of the loaders","@@ -331,6 +331,8 @@ public class ImagePresenter<T> {
     }
 
     private void fetchImage(final T model, int width, int height, final int loadCount) {
+        modelLoader.clear();
+        imageLoader.clear();
         final StreamLoader streamLoader = modelLoader.getStreamOpener(model, width, height);
         final String id = modelLoader.getId(model);
 
","334         modelLoader.clear();
335         imageLoader.clear();",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,b76f0ab40cb6c420eea98f0e22aefb84595e2c43,78d7c407e08dd6167fa8d3a3f8bc4b435a841ca0,"Clear loaders before load in ImagePresenter

Allows us not to call clear before new loads in
all of the loaders","@@ -20,7 +20,6 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
     }
     @Override
     protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
-        clear();
         loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
     }
 
",23         clear();,No
library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,e52b12cbd7528e8c483115f271bb891cc64d3ab3,b76f0ab40cb6c420eea98f0e22aefb84595e2c43,update VolleyModelLoader to remove repeated code,"@@ -5,34 +5,28 @@ import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/19/13
- * Time: 5:34 PM
- * To change this template use File | Settings | File Templates.
+ * A base ModelLoader for using Volley to fetch an image from a model that
+ * can readily be converted into a url
  */
-public abstract class VolleyModelLoader<T> implements ModelLoader<T>{
+public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
     private final RequestQueue requestQueue;
-    private VolleyStreamLoader current = null;
 
     public VolleyModelLoader(RequestQueue requestQueue) {
         this.requestQueue = requestQueue;
     }
 
     @Override
-    public StreamLoader getStreamOpener(T model, int width, int height) {
-        clear();
-        current = new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
-        return current;
-    }
-
-    @Override
-    public void clear() {
-        if (current != null) {
-            current.cancel();
-            current = null;
-        }
+    protected StreamLoader buildStreamOpener(T model, int width, int height) {
+        return new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
     }
 
+    /**
+     * Get the url to load the image from
+     *
+     * @param model The model representing the image
+     * @param width The width of the view where the image will be displayed
+     * @param height The height of the view where the image will be displayed
+     * @return A String url
+     */
     protected abstract String getUrl(T model, int width, int height);
 }
","8  * A base ModelLoader for using Volley to fetch an image from a model that
9  * can readily be converted into a url
11 public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
19     protected StreamLoader buildStreamOpener(T model, int width, int height) {
20         return new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
23     /**
24      * Get the url to load the image from
25      *
26      * @param model The model representing the image
27      * @param width The width of the view where the image will be displayed
28      * @param height The height of the view where the image will be displayed
29      * @return A String url
30      */
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 7/19/13
11  * Time: 5:34 PM
12  * To change this template use File | Settings | File Templates.
14 public abstract class VolleyModelLoader<T> implements ModelLoader<T>{
16     private VolleyStreamLoader current = null;
23     public StreamLoader getStreamOpener(T model, int width, int height) {
24         clear();
25         current = new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
26         return current;
27     }
28 
29     @Override
30     public void clear() {
31         if (current != null) {
32             current.cancel();
33             current = null;
34         }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,cce6b7feba2da45e9b4506ad8da78bcd93d7f3b1,e52b12cbd7528e8c483115f271bb891cc64d3ab3,Simplify the exception handler in ImagePresenter,"@@ -50,22 +50,13 @@ public class ImagePresenter<T> {
         private ImageLoader imageLoader;
         private ExceptionHandler<T> exceptionHandler = new ExceptionHandler<T>() {
             @Override
-            public void onImageLoadException(Exception e, T model, boolean isCurrent) {
+            public void onException(Exception e, T model, boolean isCurrent) {
                 if (e != null) {
                     e.printStackTrace();
                 } else {
                     Log.e(""IP: onImageLoadException model= "" + model);
                 }
             }
-
-            @Override
-            public void onModelStreamLoadException(Exception e, T model, boolean isCurrent) {
-                if (e != null) {
-                    e.printStackTrace();
-                } else {
-                    Log.e(""IP: onModelStreamLoadException model= "" + model);
-                }
-            }
         };
 
         private ModelLoader<T> modelLoader;
@@ -238,8 +229,7 @@ public class ImagePresenter<T> {
     }
 
     public interface ExceptionHandler<T> {
-        public void onImageLoadException(Exception e, T model, boolean isCurrent);
-        public void onModelStreamLoadException(Exception e, T model, boolean isCurrent);
+        public void onException(Exception e, T model, boolean isCurrent);
     }
 
     protected ImagePresenter(Builder<T> builder) {
@@ -351,7 +341,7 @@ public class ImagePresenter<T> {
             @Override
             public void onException(Exception e) {
                 if (exceptionHandler != null) {
-                    exceptionHandler.onImageLoadException(e, model, loadCount == currentCount);
+                    exceptionHandler.onException(e, model, loadCount == currentCount);
                 }
             }
         });
","53             public void onException(Exception e, T model, boolean isCurrent) {
232         public void onException(Exception e, T model, boolean isCurrent);
344                     exceptionHandler.onException(e, model, loadCount == currentCount);
53             public void onImageLoadException(Exception e, T model, boolean isCurrent) {
60 
61             @Override
62             public void onModelStreamLoadException(Exception e, T model, boolean isCurrent) {
63                 if (e != null) {
64                     e.printStackTrace();
65                 } else {
66                     Log.e(""IP: onModelStreamLoadException model= "" + model);
67                 }
68             }
241         public void onImageLoadException(Exception e, T model, boolean isCurrent);
242         public void onModelStreamLoadException(Exception e, T model, boolean isCurrent);
354                     exceptionHandler.onImageLoadException(e, model, loadCount == currentCount);",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,5a2292b67fb8a9765e20782141705cdff8d46228,cce6b7feba2da45e9b4506ad8da78bcd93d7f3b1,"Make compression quality to diskcache configurable

Also decrease the default from 100 to 90.","@@ -51,10 +51,12 @@ import java.util.concurrent.ThreadFactory;
 public class ImageManager {
     private static final String DEFAULT_DISK_CACHE_DIR = ""image_manager_disk_cache"";
     private static final int DEFAULT_DISK_CACHE_SIZE = 30 * 1024 * 1024;
+    private static final int DEFAULT_BITMAP_COMPRESS_QUALITY = 90;
     private static final float MEMORY_SIZE_RATIO = 1f/10f;
     public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
 
     private final BitmapReferenceCounter bitmapReferenceCounter;
+    private final int bitmapCompressQuality;
     private boolean shutdown = false;
 
     private final Handler mainHandler = new Handler();
@@ -145,6 +147,7 @@ public class ImageManager {
         public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();
         private BitmapPool bitmapPool;
         private BitmapReferenceCounter bitmapReferenceCounter;
+        private int bitmapCompressQuality = DEFAULT_BITMAP_COMPRESS_QUALITY;
 
         /**
          * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
@@ -188,6 +191,8 @@ public class ImageManager {
          * Sets the format that will be used to write bitmaps to disk in the disk cache (if one is present). Defaults
          * to JPEG. Set to PNG if you need transparency
          *
+         * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
+         *
          * @param bitmapCompressFormat The format to pass to
          *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
          *  to the disk cache
@@ -198,6 +203,24 @@ public class ImageManager {
             return this;
         }
 
+        /**
+         * Set the compression quality for Bitmaps when writing them out to the disk cache.
+         *
+         * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
+         * @see {@link #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)}
+         *
+         * @param quality Hint for compression in range 0-100 with 0 being lowest and 100 being highest quality. Will
+         *                only be applied for certain lossy compression formats
+         * @return This Builder
+         */
+        public Builder setBitmapCompressQuality(int quality) {
+            if (quality < 0) {
+                throw new IllegalArgumentException(""Bitmap compression quality must be >= 0"");
+            }
+            this.bitmapCompressQuality = quality;
+            return this;
+        }
+
         /**
          * Set the implementation of a {@link BitmapPool} to use to store and retrieve recycled bitmaps based on their
          * width and height. Should be thread safe and size limited in some way to avoid OOM exceptions.
@@ -307,6 +330,7 @@ public class ImageManager {
         bgHandler = new Handler(bgThread.getLooper());
         executor = builder.resizeService;
         bitmapCompressFormat = builder.bitmapCompressFormat;
+        bitmapCompressQuality = builder.bitmapCompressQuality;
         memoryCache = builder.memoryCache;
         diskCache = builder.diskCache;
         bitmapReferenceCounter = builder.bitmapReferenceCounter;
@@ -612,7 +636,7 @@ public class ImageManager {
                     diskCache.put(String.valueOf(key), new DiskCache.Writer() {
                         @Override
                         public void write(OutputStream os) {
-                            result.compress(bitmapCompressFormat, 100, os);
+                            result.compress(bitmapCompressFormat, bitmapCompressQuality, os);
                         }
                     });
                 }
","54     private static final int DEFAULT_BITMAP_COMPRESS_QUALITY = 90;
59     private final int bitmapCompressQuality;
150         private int bitmapCompressQuality = DEFAULT_BITMAP_COMPRESS_QUALITY;
194          * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
195          *
206         /**
207          * Set the compression quality for Bitmaps when writing them out to the disk cache.
208          *
209          * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
210          * @see {@link #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)}
211          *
212          * @param quality Hint for compression in range 0-100 with 0 being lowest and 100 being highest quality. Will
213          *                only be applied for certain lossy compression formats
214          * @return This Builder
215          */
216         public Builder setBitmapCompressQuality(int quality) {
217             if (quality < 0) {
218                 throw new IllegalArgumentException(""Bitmap compression quality must be >= 0"");
219             }
220             this.bitmapCompressQuality = quality;
221             return this;
222         }
223 
333         bitmapCompressQuality = builder.bitmapCompressQuality;
639                             result.compress(bitmapCompressFormat, bitmapCompressQuality, os);
615                             result.compress(bitmapCompressFormat, 100, os);",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,058ef77ccc7fd40a80a2da72dc97695c7dda2c0b,5a2292b67fb8a9765e20782141705cdff8d46228,Javadoc fixes and updates,"@@ -27,7 +27,9 @@ import java.net.URL;
  * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
  * starting point and example.
  *
+ * <p>
  * Note - This class is not thread safe.
+ * </p>
  */
 public class Glide {
     private static final Glide GLIDE = new Glide();
@@ -49,7 +51,7 @@ public class Glide {
     /**
      * Return the current {@link RequestQueue} or create and return a new one if one is not currently set
      *
-     * @see #setRequestQueue(com.android.volley.RequestQueue)
+     * @see #setRequestQueue(RequestQueue)
      * @see #isRequestQueueSet()
      *
      * @param context
@@ -63,10 +65,10 @@ public class Glide {
     }
 
     /**
-     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
-     * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
-     * {@link #setRequestQueue(com.android.volley.RequestQueue)} to set a {@link RequestQueue} with custom options
-     * for use with {@link Glide#load(Object)}} and/or as an easily accessible singleton
+     * Use to check whether or not an {@link RequestQueue} has been set yet. Can be used in
+     * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
+     * {@link #setRequestQueue(RequestQueue) setRequestQueue} to set a {@link RequestQueue} with custom options
+     * for use with {@link Glide#load(Object) load} and/or as an easily accessible singleton
      *
      * @return true iff a {@link RequestQueue} has already been set
      */
@@ -75,8 +77,8 @@ public class Glide {
     }
 
     /**
-     * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
-     * if one has already been set
+     * Set the {@link RequestQueue} to use with {@link Glide#load(Object)} load}. Replaces the current
+     * {@link RequestQueue} if one has already been set
      *
      * @param requestQueue The {@link RequestQueue} to set
      */
@@ -102,9 +104,10 @@ public class Glide {
 
     /**
      * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
-     * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
-     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)} to set an {@link ImageManager} with
-     * custom options for use with {@link Glide#load(Object)} and/or as an easily accessible singleton.
+     * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
+     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder) setImageManager} to set an
+     * {@link ImageManager} with custom options for use with {@link Glide#load(Object) load} and/or as an easily
+     * accessible singleton.
      *
      * @return true iff an {@link ImageManager} is currently set
      */
@@ -122,8 +125,8 @@ public class Glide {
     }
 
     /**
-     * Set the {@link ImageManager} to use with {@link Glide#load(Object)}. Replaces the current {@link ImageManager}
-     * if one has already been set.
+     * Set the {@link ImageManager} to use with {@link Glide#load(Object) load}. Replaces the current
+     * {@link ImageManager} if one has already been set.
      *
      * @see #isImageManagerSet()
      *
@@ -136,14 +139,18 @@ public class Glide {
     /**
      * Begins constructing a load for a given model.
      *
+     * <p>
      * Note - If an {@link ImageManager} has not yet been set via
-     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
-     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
-     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
+     * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
+     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
+     * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
+     * </p>
      *
-     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
-     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
-     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
+     * <p>
+     * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
+     * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
+     * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
+     * </p>
      *
      * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
      * @see #setRequestQueue(com.android.volley.RequestQueue)
","30  * <p>
32  * </p>
54      * @see #setRequestQueue(RequestQueue)
68      * Use to check whether or not an {@link RequestQueue} has been set yet. Can be used in
69      * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
70      * {@link #setRequestQueue(RequestQueue) setRequestQueue} to set a {@link RequestQueue} with custom options
71      * for use with {@link Glide#load(Object) load} and/or as an easily accessible singleton
80      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)} load}. Replaces the current
81      * {@link RequestQueue} if one has already been set
107      * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
108      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder) setImageManager} to set an
109      * {@link ImageManager} with custom options for use with {@link Glide#load(Object) load} and/or as an easily
110      * accessible singleton.
128      * Set the {@link ImageManager} to use with {@link Glide#load(Object) load}. Replaces the current
129      * {@link ImageManager} if one has already been set.
142      * <p>
144      * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
145      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
146      * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
147      * </p>
149      * <p>
150      * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
151      * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
152      * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
153      * </p>
52      * @see #setRequestQueue(com.android.volley.RequestQueue)
66      * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
67      * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
68      * {@link #setRequestQueue(com.android.volley.RequestQueue)} to set a {@link RequestQueue} with custom options
69      * for use with {@link Glide#load(Object)}} and/or as an easily accessible singleton
78      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)}}. Replaces the current {@link RequestQueue}
79      * if one has already been set
105      * {@link android.app.Activity#onCreate(android.os.Bundle)} along with
106      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)} to set an {@link ImageManager} with
107      * custom options for use with {@link Glide#load(Object)} and/or as an easily accessible singleton.
125      * Set the {@link ImageManager} to use with {@link Glide#load(Object)}. Replaces the current {@link ImageManager}
126      * if one has already been set.
140      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
141      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
142      * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
144      * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
145      * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
146      * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.",No
library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,058ef77ccc7fd40a80a2da72dc97695c7dda2c0b,5a2292b67fb8a9765e20782141705cdff8d46228,Javadoc fixes and updates,"@@ -5,6 +5,8 @@ import com.bumptech.glide.loader.stream.StreamLoader;
 /**
  * A base class that handles canceling any existing {@link StreamLoader} when
  * cleared
+ *
+ * @param <T> The type of model for this loader
  */
 public abstract class BaseModelLoader<T> implements ModelLoader<T> {
     private StreamLoader current;
","8  *
9  * @param <T> The type of model for this loader",No
library\src\com\bumptech\glide\loader\stream\StreamLoader.java,library\src\com\bumptech\glide\loader\stream\StreamLoader.java,058ef77ccc7fd40a80a2da72dc97695c7dda2c0b,5a2292b67fb8a9765e20782141705cdff8d46228,Javadoc fixes and updates,"@@ -21,7 +21,6 @@ public interface StreamLoader {
          * The method that should be called when a load completes successfully
          *
          * @param is The {@link InputStream} that will be used to load the image
-         * @return True iff the loaded streamOpener and id was used by the class that requested
          */
         public void onStreamReady(InputStream is);
 
",24          * @return True iff the loaded streamOpener and id was used by the class that requested,No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,058ef77ccc7fd40a80a2da72dc97695c7dda2c0b,5a2292b67fb8a9765e20782141705cdff8d46228,Javadoc fixes and updates,"@@ -22,7 +22,7 @@ import java.lang.ref.WeakReference;
 /**
  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
  * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
- * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load * a bitmap from a given
+ * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load a bitmap from a given
  * {@link java.io.InputStream}. This class also determines the width and height of the wrapped
  * {@link android.widget.ImageView} at runtime and passes that information to the provided {@link ModelLoader} and
  * {@link ImageLoader}.
@@ -34,9 +34,11 @@ public class ImagePresenter<T> {
 
     /**
      * A builder for an {@link ImagePresenter}.
-     * {@see Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
-     * {@see Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
-     * are required.
+     *
+     * <p> {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView) setImageView},
+     * {@link Builder ImagePresenter.Builder#setPathLoader setPathLoader}, and
+     * {@link Builder ImagePresenter.Builder#setImageLoader setIamgeLoader}
+     * are required. </p>
      *
      * @param <T> The type of the model that the presenter this builder will produce requires to load a path and an
      *           image from that path.
@@ -195,7 +197,7 @@ public class ImagePresenter<T> {
     private final ImageSetCallback imageSetCallback;
     private final ImagePresenterCoordinator coordinator;
     private final ExceptionHandler<T> exceptionHandler;
-    protected final ImageView imageView;
+    private final ImageView imageView;
 
     private T currentModel;
     private int currentCount;
@@ -228,7 +230,19 @@ public class ImagePresenter<T> {
         public boolean canSetPlaceholder(ImagePresenter<T> presenter);
     }
 
+    /**
+     * An interface for logging or otherwise handling exceptions that may occur during an image load
+     *
+     * @param <T> The type of the model
+     */
     public interface ExceptionHandler<T> {
+        /**
+         * Called whenever a load causes an exception
+         *
+         * @param e The exception
+         * @param model The model that was being loaded
+         * @param isCurrent true iff the presenter currently wants to display the image from the load that failed
+         */
         public void onException(Exception e, T model, boolean isCurrent);
     }
 
@@ -248,8 +262,12 @@ public class ImagePresenter<T> {
     }
 
     /**
-     * A method to get the wrapped {@link android.widget.ImageView}. Note that setting any image or drawable on the view
-     * directly may or may not be overridden at any point by the wrapper presenter.
+     * A method to get the wrapped {@link android.widget.ImageView}.
+     *
+     * <p>
+     *     Note - Setting any image or drawable on the view
+     * directly may be overridden at any point by the wrapping presenter.
+     * </p>
      *
      * @return The {@link android.widget.ImageView} this {@link ImagePresenter} object wraps
      */
@@ -263,9 +281,11 @@ public class ImagePresenter<T> {
      * image being displayed at the time of this call will be replaced either by the placeholder or by the new image
      * if the load completes synchronously (ie it was in an in memory cache)
      *
-     * <p>Note that a load will not begin before the ImagePresenter has determined the width and height of the wrapped
+     * <p>
+     *     Note - A load will not begin before the ImagePresenter has determined the width and height of the wrapped
      * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until
-     * then the current load is stored. Subsequent calls will replace the stored load</p>
+     * then the current load is stored. Subsequent calls will replace the stored load
+     * </p>
      *
      * @param model The model containing the information required to load a path and/or bitmap
      */
@@ -297,7 +317,7 @@ public class ImagePresenter<T> {
     /**
      * Sets the placeholder as the current image for the {@link android.widget.ImageView}. Does not cancel any previous
      * loads, so the placeholder could be replaced with a loaded bitmap at any time. To cancel a load and display a
-     * placeholder call {@link com.bumptech.glide.presenter.ImagePresenter#clear()}.
+     * placeholder call {@link #clear()}.
      */
     public void resetPlaceHolder() {
         if (!canSetPlaceholder()) return;
@@ -306,7 +326,7 @@ public class ImagePresenter<T> {
     }
 
     /**
-     * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from
+     * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object) setModel} from
      * being displayed and clears this presenter's {@link ImageLoader} and
      * this presenter's {@link ModelLoader}. Also displays the current placeholder if
      * one is set
","25  * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load a bitmap from a given
37      *
38      * <p> {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView) setImageView},
39      * {@link Builder ImagePresenter.Builder#setPathLoader setPathLoader}, and
40      * {@link Builder ImagePresenter.Builder#setImageLoader setIamgeLoader}
41      * are required. </p>
200     private final ImageView imageView;
233     /**
234      * An interface for logging or otherwise handling exceptions that may occur during an image load
235      *
236      * @param <T> The type of the model
237      */
239         /**
240          * Called whenever a load causes an exception
241          *
242          * @param e The exception
243          * @param model The model that was being loaded
244          * @param isCurrent true iff the presenter currently wants to display the image from the load that failed
245          */
265      * A method to get the wrapped {@link android.widget.ImageView}.
266      *
267      * <p>
268      *     Note - Setting any image or drawable on the view
269      * directly may be overridden at any point by the wrapping presenter.
270      * </p>
284      * <p>
285      *     Note - A load will not begin before the ImagePresenter has determined the width and height of the wrapped
287      * then the current load is stored. Subsequent calls will replace the stored load
288      * </p>
320      * placeholder call {@link #clear()}.
329      * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object) setModel} from
25  * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load * a bitmap from a given
37      * {@see Builder ImagePresenter.Builder#setImageView(android.widget.ImageView)},
38      * {@see Builder ImagePresenter.Builder#setPathLoader}, and {@link Builder ImagePresenter.Builder#setImageLoader}
39      * are required.
198     protected final ImageView imageView;
251      * A method to get the wrapped {@link android.widget.ImageView}. Note that setting any image or drawable on the view
252      * directly may or may not be overridden at any point by the wrapper presenter.
266      * <p>Note that a load will not begin before the ImagePresenter has determined the width and height of the wrapped
268      * then the current load is stored. Subsequent calls will replace the stored load</p>
300      * placeholder call {@link com.bumptech.glide.presenter.ImagePresenter#clear()}.
309      * Prevents any bitmaps being loaded from previous calls to {@link ImagePresenter#setModel(Object)} from",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,058ef77ccc7fd40a80a2da72dc97695c7dda2c0b,5a2292b67fb8a9765e20782141705cdff8d46228,Javadoc fixes and updates,"@@ -42,11 +42,12 @@ import java.util.concurrent.ThreadFactory;
 /**
  * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
  * sdk version, uses a combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
- * load and resize * operations performed and to maximize the number of times Bitmaps are recycled as opposed to
- * allocated.
+ * load and resize operations performed and to maximize the number of times Bitmaps are recycled as opposed to
+ * allocated. If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible.
  *
- * If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible. Note
- * that Bitmap recycling is only available on Honeycomb and up.
+ * <p>
+ * Note that Bitmap recycling is only available on Honeycomb and up.
+ * </p>
  */
 public class ImageManager {
     private static final String DEFAULT_DISK_CACHE_DIR = ""image_manager_disk_cache"";
@@ -76,7 +77,7 @@ public class ImageManager {
 
     /**
      * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
-     * This is a conservative estimate that has been safe for 2.2+ devices consistnetly. It is probably rather small
+     * This is a conservative estimate that has been safe for 2.2+ devices consistently. It is probably rather small
      * for newer devices.
      *
      * @param context A context
@@ -191,7 +192,7 @@ public class ImageManager {
          * Sets the format that will be used to write bitmaps to disk in the disk cache (if one is present). Defaults
          * to JPEG. Set to PNG if you need transparency
          *
-         * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
+         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
          *
          * @param bitmapCompressFormat The format to pass to
          *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
@@ -206,8 +207,8 @@ public class ImageManager {
         /**
          * Set the compression quality for Bitmaps when writing them out to the disk cache.
          *
-         * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
-         * @see {@link #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)}
+         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
+         * @see #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)
          *
          * @param quality Hint for compression in range 0-100 with 0 being lowest and 100 being highest quality. Will
          *                only be applied for certain lossy compression formats
","45  * load and resize operations performed and to maximize the number of times Bitmaps are recycled as opposed to
46  * allocated. If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible.
48  * <p>
49  * Note that Bitmap recycling is only available on Honeycomb and up.
50  * </p>
80      * This is a conservative estimate that has been safe for 2.2+ devices consistently. It is probably rather small
195          * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
210          * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
211          * @see #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)
45  * load and resize * operations performed and to maximize the number of times Bitmaps are recycled as opposed to
46  * allocated.
48  * If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if possible. Note
49  * that Bitmap recycling is only available on Honeycomb and up.
79      * This is a conservative estimate that has been safe for 2.2+ devices consistnetly. It is probably rather small
194          * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
209          * @see {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)}
210          * @see {@link #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)}",No
library\project.properties,library\project.properties,6cdb8ce663c94e8b338179dca5f63da87058e2b3,b08f94d1c2e5b9d6fae4fd015567d7c0c74b0e9a,fix project properties,"@@ -13,4 +13,4 @@
 android.library=true
 # Project target.
 target=android-16
-android.library.reference=volley
+android.library.reference.1=volley
","16 android.library.reference.1=volley
16 android.library.reference=volley",No
,Makefile,523c00b11a3eae589ef205d1e0ea0e05502dee95,6cdb8ce663c94e8b338179dca5f63da87058e2b3,add Makefile to setup glide,"@@ -0,0 +1,5 @@
+setup:
+	git submodule init
+	git submodule update
+	echo android.library=true >> library/volley/project.properties
+	android update project --path .. --library glide/library
","1 setup:
2 	git submodule init
3 	git submodule update
4 	echo android.library=true >> library/volley/project.properties
5 	android update project --path .. --library glide/library",Yes
library\res\layout\main.xml,,c5f07ae8fa45ff992839993cbb1a2c9fb8e09bbe,523c00b11a3eae589ef205d1e0ea0e05502dee95,remove unused resources,"@@ -1,13 +0,0 @@
-<?xml version=""1.0"" encoding=""utf-8""?>
-<LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
-              android:orientation=""vertical""
-              android:layout_width=""fill_parent""
-              android:layout_height=""fill_parent""
-  >
-  <TextView
-    android:layout_width=""fill_parent""
-    android:layout_height=""wrap_content""
-    android:text=""Hello World, ACTIVITY_ENTRY_NAME""
-    />
-</LinearLayout>
-
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
3               android:orientation=""vertical""
4               android:layout_width=""fill_parent""
5               android:layout_height=""fill_parent""
6   >
7   <TextView
8     android:layout_width=""fill_parent""
9     android:layout_height=""wrap_content""
10     android:text=""Hello World, ACTIVITY_ENTRY_NAME""
11     />
12 </LinearLayout>
13 ",No
library\res\values\strings.xml,,c5f07ae8fa45ff992839993cbb1a2c9fb8e09bbe,523c00b11a3eae589ef205d1e0ea0e05502dee95,remove unused resources,"@@ -1,4 +0,0 @@
-<?xml version=""1.0"" encoding=""utf-8""?>
-<resources>
-  <string name=""app_name"">ACTIVITY_ENTRY_NAME</string>
-</resources>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <string name=""app_name"">ACTIVITY_ENTRY_NAME</string>
4 </resources>",Yes
README.md,README.md,ac0a0f206f0761e283fb89aa205f02255b234ff3,c5f07ae8fa45ff992839993cbb1a2c9fb8e09bbe,Update and simplify readme,"@@ -1,80 +1,39 @@
 Glide
 =====
-Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface.
+Glide is an all in one image download and resizing library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
 
 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
 
-Who shouldn't use Glide?
-------------------------
-If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
-
-Also you probably shouldn't bother if you're not writing an Android app...
-
-Who should use Glide?
----------------------
-Anyone who displays large numbers of images can benefit from Glide.
-
-Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
-
-Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
-
-Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
-
 How do I use Glide?
 -------------------
-The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
+The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 1.0+ will also be available via a link on the wiki.
 
-```Java
-
-public class MyAdapter extends BaseAdapter {
-    private final ImageManager imageManager;
+Simple use cases will look something like this:
 
-    public MyAdapter(Context context) {
-         imageManager = new ImageManager.Builder(context).build();
-    }
+```Java
 
-    ...
 @Override
 public View getView(int position, View recycled, ViewGroup container) {
-        final MyModel current = myModels.get(position);
-        final ImagePresenter<MyModel> presenter;
+    final ImageView myImageView;
     if (recycled == null) {
-            recycled = myInflater.inflate(R.layout.my_image_view, container, false);
-
-            presenter = new ImagePresenter.Builder<MyModel>()
-                    .setImageView((ImageView) recycled)
-                    .setPathLoader(new MyPathLoader())
-                    .setImageLoader(new CenterCrop(imageManager))
-                    .build();
-            recycled.setTag(presenter);
+        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
     } else {
-            presenter = (ImagePresenter<MyModel>) recycled.getTag();
-        }
-        presenter.setModel(current);
+        myImageView = (ImageView) recycled);
     }
-}
-
-```
-
-The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
-
-This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
-
-Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
 
-Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
+    URL myUrl = myUrls.get(position);
 
+    Glide.load(myUrl).into(myImageView).centerCrop().animate(R.anim.fade_in).begin();
 
-How do I add Glide to my project?
---------------------------------
-Glide is an Android library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
-
-Intellij and Eclipse instructions coming soon.
-
-Great, but how do I actually use Glide in my code?
------------------------------------------------------
-For more concrete examples see the wiki for tutorials and/or the sample flickr app.
+    return myImageView;
+}
+```
 
 Status
 ------
-Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
+Glide has been in use at Bump for about six months in two of our Android apps. The API after 1.0 is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
+
+Thanks
+------
+Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide.
+Thanks also to Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
","3 Glide is an all in one image download and resizing library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
9 The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 1.0+ will also be available via a link on the wiki.
10 
11 Simple use cases will look something like this:
17     final ImageView myImageView;
19         myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
21         myImageView = (ImageView) recycled);
24     URL myUrl = myUrls.get(position);
25 
26     Glide.load(myUrl).into(myImageView).centerCrop().animate(R.anim.fade_in).begin();
27 
28     return myImageView;
29 }
34 Glide has been in use at Bump for about six months in two of our Android apps. The API after 1.0 is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
35 
36 Thanks
37 ------
38 Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide.
39 Thanks also to Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
3 Glide is an image loading library for Android that wraps image loading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface.
7 Who shouldn't use Glide?
8 ------------------------
9 If you only have local assets or very infrequently display remote assets and never display remote or resized assets in a list, then Glide is probably overkill for you.
10 
11 Also you probably shouldn't bother if you're not writing an Android app...
12 
13 Who should use Glide?
14 ---------------------
15 Anyone who displays large numbers of images can benefit from Glide.
16 
17 Glide abstracts away most of the complications with image view recycling in lists, as well as resizing and caching images.
18 
19 Glide is also unobtrusive. It doesn't require you to change any xml or create any subclasses.
20 
21 Finally Glide is performant. Image loading is fast without using lots of cpu or causing jerk inducing garbage collections.
22 
25 The only thing you need to implement is a simple interface that fetches a path for a given model. You then need an ImageManager instance which manages loading images from paths in the background, and an ImagePresenter instance per image view. To use Glide in an adapter for a list, your code will look something like this:
29 public class MyAdapter extends BaseAdapter {
30     private final ImageManager imageManager;
31 
32     public MyAdapter(Context context) {
33          imageManager = new ImageManager.Builder(context).build();
34     }
35 
36     ...
39         final MyModel current = myModels.get(position);
40         final ImagePresenter<MyModel> presenter;
42             recycled = myInflater.inflate(R.layout.my_image_view, container, false);
43 
44             presenter = new ImagePresenter.Builder<MyModel>()
45                     .setImageView((ImageView) recycled)
46                     .setPathLoader(new MyPathLoader())
47                     .setImageLoader(new CenterCrop(imageManager))
48                     .build();
49             recycled.setTag(presenter);
51             presenter = (ImagePresenter<MyModel>) recycled.getTag();
52         }
53         presenter.setModel(current);
54     }
59 The ImagePresenter will ensure that the view only displays the most recent model. It also determines the exact size of the image and passes that to both the PathLoader and the ImageLoader.
60 
61 This means that you can fetch the correctly sized image directly or Glide can resize each image to the right size even if you don't know the size at compile time (because you're using layout weights for example).
62 
63 Behind the scenes the ImageManager will load resize the image from disk using a background thread and then cache that resized image in memory and on disk. This means that you don't have to waste cpu and memory displaying images that are larger than your view. On newer devices (SDK >= 11), the ImageManager will also recycle bitmaps and prevent the garbage collection pauses that typically go along with bitmap allocation.
64 
65 Fewer garbage collections, less memory per image, and less cpu time dedicated to resizing each image on the fly means dramatically smoother scrolling and faster image loading.
66 
67 
68 How do I add Glide to my project?
69 --------------------------------
70 Glide is an Android library project so its fairly straightforward to add it. Either add this repo as a submodule or otherwise check out this repository in your project and then follow the steps in the Android docs to add it as a library project: http://developer.android.com/tools/projects/projects-cmdline.html#ReferencingLibraryProject
71 
72 Intellij and Eclipse instructions coming soon.
73 
74 Great, but how do I actually use Glide in my code?
75 -----------------------------------------------------
76 For more concrete examples see the wiki for tutorials and/or the sample flickr app.
77 
80 Glide has been in use at Bump for about six months in two of our Android apps. The API is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!",No
README.md,README.md,87c14759ce42401877f5e61d5349b91dd6ece99a,ac0a0f206f0761e283fb89aa205f02255b234ff3,Fix a typo in readme,"@@ -36,4 +36,4 @@ Glide has been in use at Bump for about six months in two of our Android apps. T
 Thanks
 ------
 Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide.
-Thanks also to Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
+Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
","39 Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
39 Thanks also to Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,4afd69b78f36a0523be19185a3a3b4a1f72b771f,87c14759ce42401877f5e61d5349b91dd6ece99a,"Use instanceof not class comparison

Also fixes bug where we were comparing objects
to classes","@@ -171,7 +171,7 @@ public class Glide {
 
     @SuppressWarnings(""unchecked"")
     private static <T> ModelLoader<T> getModelFor(T model, Context context) {
-        if (model == URL.class) {
+        if (model instanceof URL) {
             return (ModelLoader<T>) new VolleyModelLoader<URL>(GLIDE.getRequestQueue(context)) {
                 @Override
                 protected String getUrl(URL model, int width, int height) {
@@ -183,7 +183,7 @@ public class Glide {
                     return model.toString();
                 }
             };
-        } else if (model == File.class) {
+        } else if (model instanceof File) {
             return (ModelLoader<T>) new FileLoader();
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
","174         if (model instanceof URL) {
186         } else if (model instanceof File) {
174         if (model == URL.class) {
186         } else if (model == File.class) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,5855e3a115f40e2d44dca044768470a8e5b71bb5,4afd69b78f36a0523be19185a3a3b4a1f72b771f,Always set default model loader in Glide.load,"@@ -256,7 +256,6 @@ public class Glide {
          */
         public Request<T> with(ModelLoader<T> modelLoader) {
             this.modelLoader = modelLoader;
-            builder.setModelLoader(modelLoader);
 
             return this;
         }
@@ -364,7 +363,7 @@ public class Glide {
                 if (modelLoader == null) {
                     modelLoader = getModelFor(model, context);
                 }
-                presenter = builder.build();
+                presenter = builder.setModelLoader(modelLoader).build();
                 imageView.setTag(R.id.image_presenter_id, presenter);
             }
         }
","366                 presenter = builder.setModelLoader(modelLoader).build();
259             builder.setModelLoader(modelLoader);
367                 presenter = builder.build();",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,4e8c4e61ae9f011c1bfccbace9c24aee61865bf0,5855e3a115f40e2d44dca044768470a8e5b71bb5,Add default loader for Uris for Glide.load,"@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+import android.net.Uri;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
@@ -9,6 +10,7 @@ import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
 import com.bumptech.glide.loader.model.VolleyModelLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
@@ -185,6 +187,8 @@ public class Glide {
             };
         } else if (model instanceof File) {
             return (ModelLoader<T>) new FileLoader();
+        } else if (model instanceof Uri) {
+            return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
","4 import android.net.Uri;
13 import com.bumptech.glide.loader.model.UriLoader;
190         } else if (model instanceof Uri) {
191             return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));",No
,library\src\com\bumptech\glide\loader\model\UriLoader.java,4e8c4e61ae9f011c1bfccbace9c24aee61865bf0,5855e3a115f40e2d44dca044768470a8e5b71bb5,Add default loader for Uris for Glide.load,"@@ -0,0 +1,52 @@
+package com.bumptech.glide.loader.model;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+import com.android.volley.RequestQueue;
+import com.bumptech.glide.loader.stream.LocalUriLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.loader.stream.VolleyStreamLoader;
+
+/**
+ * A model loader for trying to load Uris. Capable of handling 'http', 'android.resource', 'content', and 'file'
+ * schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
+ */
+public class UriLoader extends BaseModelLoader<Uri> {
+    private final Context context;
+    private final RequestQueue requestQueue;
+
+    public UriLoader(Context context, RequestQueue requestQueue) {
+        this.context = context;
+        this.requestQueue = requestQueue;
+    }
+
+    @Override
+    protected StreamLoader buildStreamOpener(Uri model, int width, int height) {
+        final String scheme = model.getScheme();
+
+        StreamLoader result = null;
+        if (isLocalUri(scheme)) {
+            result = new LocalUriLoader(context, model);
+        } else if (""http"".equals(scheme)) {
+            result = new VolleyStreamLoader(requestQueue, model.toString());
+        }
+
+        if (result == null) {
+            throw new IllegalArgumentException(""No stream loader for uri="" + model);
+        }
+
+        return result;
+    }
+
+    @Override
+    public String getId(Uri model) {
+        return model.toString();
+    }
+
+    private boolean isLocalUri(String scheme) {
+        return ContentResolver.SCHEME_FILE.equals(scheme)
+                || ContentResolver.SCHEME_CONTENT.equals(scheme)
+                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
+    }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import android.content.ContentResolver;
4 import android.content.Context;
5 import android.net.Uri;
6 import com.android.volley.RequestQueue;
7 import com.bumptech.glide.loader.stream.LocalUriLoader;
8 import com.bumptech.glide.loader.stream.StreamLoader;
9 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
10 
11 /**
12  * A model loader for trying to load Uris. Capable of handling 'http', 'android.resource', 'content', and 'file'
13  * schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
14  */
15 public class UriLoader extends BaseModelLoader<Uri> {
16     private final Context context;
17     private final RequestQueue requestQueue;
18 
19     public UriLoader(Context context, RequestQueue requestQueue) {
20         this.context = context;
21         this.requestQueue = requestQueue;
22     }
23 
24     @Override
25     protected StreamLoader buildStreamOpener(Uri model, int width, int height) {
26         final String scheme = model.getScheme();
27 
28         StreamLoader result = null;
29         if (isLocalUri(scheme)) {
30             result = new LocalUriLoader(context, model);
31         } else if (""http"".equals(scheme)) {
32             result = new VolleyStreamLoader(requestQueue, model.toString());
33         }
34 
35         if (result == null) {
36             throw new IllegalArgumentException(""No stream loader for uri="" + model);
37         }
38 
39         return result;
40     }
41 
42     @Override
43     public String getId(Uri model) {
44         return model.toString();
45     }
46 
47     private boolean isLocalUri(String scheme) {
48         return ContentResolver.SCHEME_FILE.equals(scheme)
49                 || ContentResolver.SCHEME_CONTENT.equals(scheme)
50                 || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
51     }
52 }",No
,library\src\com\bumptech\glide\loader\stream\LocalUriLoader.java,4e8c4e61ae9f011c1bfccbace9c24aee61865bf0,5855e3a115f40e2d44dca044768470a8e5b71bb5,Add default loader for Uris for Glide.load,"@@ -0,0 +1,49 @@
+package com.bumptech.glide.loader.stream;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+
+import java.io.FileNotFoundException;
+import java.lang.ref.WeakReference;
+
+/**
+ *
+ */
+public class LocalUriLoader implements StreamLoader {
+    private final WeakReference<Context> contextRef;
+    private final Uri uri;
+
+    /**
+     * Opens an input stream for a uri pointing to a local asset
+     *
+     * @see ContentResolver#openInputStream(android.net.Uri)
+     *
+     * @param context A context (this will be weakly referenced and the load will silently abort if the weak reference
+     *                is cleared before {@link #loadStream(StreamReadyCallback cb)} is called
+     * @param uri A Uri pointing to a local asset. This load will fail if the uri isn't openable by
+     *            {@link ContentResolver#openInputStream(android.net.Uri)}
+     */
+    public LocalUriLoader(Context context, Uri uri) {
+        contextRef = new WeakReference<Context>(context);
+        this.uri = uri;
+    }
+
+    @Override
+    public void loadStream(StreamReadyCallback cb) {
+        final Context context = contextRef.get();
+        if (context != null) {
+            final ContentResolver contentResolver = context.getContentResolver();
+            try {
+                cb.onStreamReady(contentResolver.openInputStream(uri));
+            } catch (FileNotFoundException e) {
+                cb.onException(e);
+            }
+        }
+
+    }
+
+    @Override
+    public void cancel() { }
+}
+
","1 package com.bumptech.glide.loader.stream;
2 
3 import android.content.ContentResolver;
4 import android.content.Context;
5 import android.net.Uri;
6 
7 import java.io.FileNotFoundException;
8 import java.lang.ref.WeakReference;
9 
10 /**
11  *
12  */
13 public class LocalUriLoader implements StreamLoader {
14     private final WeakReference<Context> contextRef;
15     private final Uri uri;
16 
17     /**
18      * Opens an input stream for a uri pointing to a local asset
19      *
20      * @see ContentResolver#openInputStream(android.net.Uri)
21      *
22      * @param context A context (this will be weakly referenced and the load will silently abort if the weak reference
23      *                is cleared before {@link #loadStream(StreamReadyCallback cb)} is called
24      * @param uri A Uri pointing to a local asset. This load will fail if the uri isn't openable by
25      *            {@link ContentResolver#openInputStream(android.net.Uri)}
26      */
27     public LocalUriLoader(Context context, Uri uri) {
28         contextRef = new WeakReference<Context>(context);
29         this.uri = uri;
30     }
31 
32     @Override
33     public void loadStream(StreamReadyCallback cb) {
34         final Context context = contextRef.get();
35         if (context != null) {
36             final ContentResolver contentResolver = context.getContentResolver();
37             try {
38                 cb.onStreamReady(contentResolver.openInputStream(uri));
39             } catch (FileNotFoundException e) {
40                 cb.onException(e);
41             }
42         }
43 
44     }
45 
46     @Override
47     public void cancel() { }
48 }
49 ",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,f4e3c7600c1698912a1a374c172e4dd9c40c2ede,4e8c4e61ae9f011c1bfccbace9c24aee61865bf0,Add default loader for Strings for Glide.load,"@@ -10,6 +10,7 @@ import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.StringLoader;
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
 import com.bumptech.glide.loader.model.VolleyModelLoader;
@@ -189,6 +190,8 @@ public class Glide {
             return (ModelLoader<T>) new FileLoader();
         } else if (model instanceof Uri) {
             return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));
+        } else if (model instanceof String) {
+            return (ModelLoader<T>) new StringLoader(context, GLIDE.getRequestQueue(context));
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
","13 import com.bumptech.glide.loader.model.StringLoader;
193         } else if (model instanceof String) {
194             return (ModelLoader<T>) new StringLoader(context, GLIDE.getRequestQueue(context));",No
,library\src\com\bumptech\glide\loader\model\StringLoader.java,f4e3c7600c1698912a1a374c172e4dd9c40c2ede,4e8c4e61ae9f011c1bfccbace9c24aee61865bf0,Add default loader for Strings for Glide.load,"@@ -0,0 +1,41 @@
+package com.bumptech.glide.loader.model;
+
+import android.content.Context;
+import android.net.Uri;
+import com.android.volley.RequestQueue;
+import com.bumptech.glide.loader.stream.FileStreamLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.util.Log;
+
+import java.io.File;
+
+/**
+ * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
+ * {@link android.content.ContentResolver#openInputStream(android.net.Uri)}.
+ */
+public class StringLoader extends BaseModelLoader<String> {
+
+    private final UriLoader uriLoader;
+
+    public StringLoader(Context context, RequestQueue requestQueue) {
+        uriLoader = new UriLoader(context, requestQueue);
+    }
+
+    @Override
+    protected StreamLoader buildStreamOpener(String model, int width, int height) {
+        final File file = new File(model);
+        if (file.exists() && !file.isDirectory()) {
+            Log.d(""TEST: string loader have file exists and not dir"");
+            return new FileStreamLoader(model);
+        } else {
+            final Uri uri = Uri.parse(model);
+            Log.d(""TEST: string loader parsed uri to: "" + uri);
+            return uriLoader.buildStreamOpener(uri, width, height);
+        }
+    }
+
+    @Override
+    public String getId(String model) {
+        return model;
+    }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import android.content.Context;
4 import android.net.Uri;
5 import com.android.volley.RequestQueue;
6 import com.bumptech.glide.loader.stream.FileStreamLoader;
7 import com.bumptech.glide.loader.stream.StreamLoader;
8 import com.bumptech.glide.util.Log;
9 
10 import java.io.File;
11 
12 /**
13  * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
14  * {@link android.content.ContentResolver#openInputStream(android.net.Uri)}.
15  */
16 public class StringLoader extends BaseModelLoader<String> {
17 
18     private final UriLoader uriLoader;
19 
20     public StringLoader(Context context, RequestQueue requestQueue) {
21         uriLoader = new UriLoader(context, requestQueue);
22     }
23 
24     @Override
25     protected StreamLoader buildStreamOpener(String model, int width, int height) {
26         final File file = new File(model);
27         if (file.exists() && !file.isDirectory()) {
28             Log.d(""TEST: string loader have file exists and not dir"");
29             return new FileStreamLoader(model);
30         } else {
31             final Uri uri = Uri.parse(model);
32             Log.d(""TEST: string loader parsed uri to: "" + uri);
33             return uriLoader.buildStreamOpener(uri, width, height);
34         }
35     }
36 
37     @Override
38     public String getId(String model) {
39         return model;
40     }
41 }",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,9d7d33af828f2b966c61b03bd78f11d67099369d,f4e3c7600c1698912a1a374c172e4dd9c40c2ede,Check if strings are paths on background thread,"@@ -5,7 +5,6 @@ import android.net.Uri;
 import com.android.volley.RequestQueue;
 import com.bumptech.glide.loader.stream.FileStreamLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.util.Log;
 
 import java.io.File;
 
@@ -22,16 +21,29 @@ public class StringLoader extends BaseModelLoader<String> {
     }
 
     @Override
-    protected StreamLoader buildStreamOpener(String model, int width, int height) {
+    protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {
+        return new StreamLoader() {
+            StreamLoader subStreamLoader = null;
+            @Override
+            public void loadStream(StreamReadyCallback cb) {
                 final File file = new File(model);
                 if (file.exists() && !file.isDirectory()) {
-            Log.d(""TEST: string loader have file exists and not dir"");
-            return new FileStreamLoader(model);
+                    subStreamLoader = new FileStreamLoader(model);
                 } else {
                     final Uri uri = Uri.parse(model);
-            Log.d(""TEST: string loader parsed uri to: "" + uri);
-            return uriLoader.buildStreamOpener(uri, width, height);
+                    subStreamLoader = uriLoader.buildStreamOpener(uri, width, height);
+                }
+
+                subStreamLoader.loadStream(cb);
+            }
+
+            @Override
+            public void cancel() {
+                if (subStreamLoader != null) {
+                    subStreamLoader.cancel();
+                }
             }
+        };
     }
 
     @Override
","24     protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {
25         return new StreamLoader() {
26             StreamLoader subStreamLoader = null;
27             @Override
28             public void loadStream(StreamReadyCallback cb) {
31                     subStreamLoader = new FileStreamLoader(model);
34                     subStreamLoader = uriLoader.buildStreamOpener(uri, width, height);
36 
37                 subStreamLoader.loadStream(cb);
38             }
39 
40             @Override
41             public void cancel() {
42                 if (subStreamLoader != null) {
43                     subStreamLoader.cancel();
44                 }
45             }
46         };
8 import com.bumptech.glide.util.Log;
25     protected StreamLoader buildStreamOpener(String model, int width, int height) {
28             Log.d(""TEST: string loader have file exists and not dir"");
29             return new FileStreamLoader(model);
32             Log.d(""TEST: string loader parsed uri to: "" + uri);
33             return uriLoader.buildStreamOpener(uri, width, height);",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,1f05d2b70d1deb5b13e48841894d400aaafe354f,9d7d33af828f2b966c61b03bd78f11d67099369d,Use Volley in UrlLoader,"@@ -13,7 +13,6 @@ import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.model.StringLoader;
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
-import com.bumptech.glide.loader.model.VolleyModelLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
 import com.bumptech.glide.resize.ImageManager;
@@ -175,17 +174,7 @@ public class Glide {
     @SuppressWarnings(""unchecked"")
     private static <T> ModelLoader<T> getModelFor(T model, Context context) {
         if (model instanceof URL) {
-            return (ModelLoader<T>) new VolleyModelLoader<URL>(GLIDE.getRequestQueue(context)) {
-                @Override
-                protected String getUrl(URL model, int width, int height) {
-                    return model.toString();
-                }
-
-                @Override
-                public String getId(URL model) {
-                    return model.toString();
-                }
-            };
+            return (ModelLoader<T>) new UrlLoader(GLIDE.getRequestQueue(context));
         } else if (model instanceof File) {
             return (ModelLoader<T>) new FileLoader();
         } else if (model instanceof Uri) {
","177             return (ModelLoader<T>) new UrlLoader(GLIDE.getRequestQueue(context));
16 import com.bumptech.glide.loader.model.VolleyModelLoader;
178             return (ModelLoader<T>) new VolleyModelLoader<URL>(GLIDE.getRequestQueue(context)) {
179                 @Override
180                 protected String getUrl(URL model, int width, int height) {
181                     return model.toString();
182                 }
183 
184                 @Override
185                 public String getId(URL model) {
186                     return model.toString();
187                 }
188             };",No
library\src\com\bumptech\glide\loader\model\UrlLoader.java,library\src\com\bumptech\glide\loader\model\UrlLoader.java,1f05d2b70d1deb5b13e48841894d400aaafe354f,9d7d33af828f2b966c61b03bd78f11d67099369d,Use Volley in UrlLoader,"@@ -1,7 +1,8 @@
 package com.bumptech.glide.loader.model;
 
-import com.bumptech.glide.loader.stream.HttpStreamLoader;
+import com.android.volley.RequestQueue;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.loader.stream.VolleyStreamLoader;
 
 import java.net.URL;
 
@@ -9,12 +10,18 @@ import java.net.URL;
  * A simple model loader for urls
  */
 public class UrlLoader implements ModelLoader<URL> {
+    private final RequestQueue requestQueue;
+
+    public UrlLoader(RequestQueue requestQueue) {
+        this.requestQueue = requestQueue;
+    }
+
     @Override
     public StreamLoader getStreamOpener(URL model, int width, int height) {
-        return new HttpStreamLoader(model);
+        return new VolleyStreamLoader(requestQueue, model.toString());
     }
 
-    //this may need to be overridden if multiple urls can be used to retrieve the same imgae
+    //this may need to be overridden if multiple urls can be used to retrieve the same image
     @Override
     public String getId(URL model) {
         return model.toString();
","3 import com.android.volley.RequestQueue;
5 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
13     private final RequestQueue requestQueue;
14 
15     public UrlLoader(RequestQueue requestQueue) {
16         this.requestQueue = requestQueue;
19     @Override
20     public StreamLoader getStreamOpener(URL model, int width, int height) {
21         return new VolleyStreamLoader(requestQueue, model.toString());
22     }
23 
24     //this may need to be overridden if multiple urls can be used to retrieve the same image
3 import com.bumptech.glide.loader.stream.HttpStreamLoader;
12     @Override
13     public StreamLoader getStreamOpener(URL model, int width, int height) {
14         return new HttpStreamLoader(model);
17     //this may need to be overridden if multiple urls can be used to retrieve the same imgae",No
library\src\com\bumptech\glide\loader\stream\HttpStreamLoader.java,,1f05d2b70d1deb5b13e48841894d400aaafe354f,9d7d33af828f2b966c61b03bd78f11d67099369d,Use Volley in UrlLoader,"@@ -1,48 +0,0 @@
-package com.bumptech.glide.loader.stream;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-/**
- * A simple http stream loader for fetching a url
- */
-public class HttpStreamLoader implements StreamLoader {
-    private final URL url;
-
-    public HttpStreamLoader(String url) throws MalformedURLException {
-        this(new URL(url));
-    }
-
-    public HttpStreamLoader(URL url) {
-        this.url = url;
-    }
-
-    @Override
-    public void loadStream(StreamReadyCallback cb) {
-        HttpURLConnection urlConnection = null;
-        try {
-            urlConnection = (HttpURLConnection) url.openConnection();
-            urlConnection.setDoInput(true);
-            urlConnection.setDoOutput(false);
-            urlConnection.setUseCaches(false);
-            urlConnection.setRequestProperty(""Connection"", ""close"");
-            urlConnection.connect();
-            cb.onStreamReady(urlConnection.getInputStream());
-        } catch (IOException e) {
-            cb.onException(e);
-        } finally {
-            if (urlConnection != null) {
-                urlConnection.disconnect();
-            }
-        }
-    }
-
-    /**
-     * Since {@link #loadStream(com.bumptech.glide.loader.stream.StreamLoader.StreamReadyCallback)} calls its
-     * callback synchronously, not much we can do here.
-     */
-    @Override
-    public void cancel() { }
-}
","1 package com.bumptech.glide.loader.stream;
2 
3 import java.io.IOException;
4 import java.net.HttpURLConnection;
5 import java.net.MalformedURLException;
6 import java.net.URL;
7 
8 /**
9  * A simple http stream loader for fetching a url
10  */
11 public class HttpStreamLoader implements StreamLoader {
12     private final URL url;
13 
14     public HttpStreamLoader(String url) throws MalformedURLException {
15         this(new URL(url));
16     }
17 
18     public HttpStreamLoader(URL url) {
19         this.url = url;
20     }
21 
22     @Override
23     public void loadStream(StreamReadyCallback cb) {
24         HttpURLConnection urlConnection = null;
25         try {
26             urlConnection = (HttpURLConnection) url.openConnection();
27             urlConnection.setDoInput(true);
28             urlConnection.setDoOutput(false);
29             urlConnection.setUseCaches(false);
30             urlConnection.setRequestProperty(""Connection"", ""close"");
31             urlConnection.connect();
32             cb.onStreamReady(urlConnection.getInputStream());
33         } catch (IOException e) {
34             cb.onException(e);
35         } finally {
36             if (urlConnection != null) {
37                 urlConnection.disconnect();
38             }
39         }
40     }
41 
42     /**
43      * Since {@link #loadStream(com.bumptech.glide.loader.stream.StreamLoader.StreamReadyCallback)} calls its
44      * callback synchronously, not much we can do here.
45      */
46     @Override
47     public void cancel() { }
48 }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,c5a59166fb420fd6a1595a69952092877b9a5c51,1f05d2b70d1deb5b13e48841894d400aaafe354f,"Fix an NPE if layout params not yet set in view

Can occur if you call new View(Context).","@@ -453,7 +453,7 @@ public class ImagePresenter<T> {
             handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
             this.cb = null;
             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (layoutParams.width > 0 && layoutParams.height > 0) {
+            if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {
                 cb.onSizeReady(layoutParams.width, layoutParams.height);
             } else if (valid) {
                 cb.onSizeReady(width, height);
","456             if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {
456             if (layoutParams.width > 0 && layoutParams.height > 0) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,c5a59166fb420fd6a1595a69952092877b9a5c51,"Remove a null check in Glide.resizeWith

Its not any more work to just pass through to the
builder, so we might as well (even if we don't
use the builder).","@@ -293,9 +293,7 @@ public class Glide {
          * @return This Request
          */
         public Request<T> resizeWith(ImageLoader imageLoader) {
-            if (presenter == null) {
             builder.setImageLoader(imageLoader);
-            }
 
             return this;
         }
","296             if (presenter == null) {
298             }",No
.gitignore,.gitignore,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -10,3 +10,4 @@ samples/flickr/.idea/*
 samples/flickr/gen/**/*
 samples/flickr/out/**/*
 samples/flickr/local.properties
+**/.idea/*
",13 **/.idea/*,No
,library\.gitignore,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -0,0 +1,4 @@
+tests/ant.properties
+tests/local.properties
+tests/gen/**/*
+
","1 tests/ant.properties
2 tests/local.properties
3 tests/gen/**/*
4 ",No
library\AndroidManifest.xml,library\AndroidManifest.xml,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -4,4 +4,5 @@
           android:versionCode=""1""
           android:versionName=""1.0"">
   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
+  <application />
 </manifest>
",7   <application />,No
,library\tests\AndroidManifest.xml,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -0,0 +1,22 @@
+<?xml version=""1.0"" encoding=""utf-8""?>
+<!-- package name must be unique so suffix with ""tests"" so package loader doesn't ignore us -->
+<manifest xmlns:android=""http://schemas.android.com/apk/res/android""
+          package=""com.bumptech.glide.tests""
+          android:versionCode=""1""
+          android:versionName=""1.0"">
+  <uses-sdk android:minSdkVersion=""8"" />
+  <!-- We add an application tag here just so that we can indicate that
+       this package needs to link against the android.test library,
+       which is needed when building test cases. -->
+  <application>
+    <uses-library android:name=""android.test.runner""/>
+  </application>
+  <!--
+  This declares that this application uses the instrumentation test runner targeting
+  the package of com.bumptech.glide.  To run the tests use the command:
+  ""adb shell am instrument -w com.bumptech.glide.tests/android.test.InstrumentationTestRunner""
+  -->
+  <instrumentation android:name=""android.test.InstrumentationTestRunner""
+                   android:targetPackage=""com.bumptech.glide""
+                   android:label=""Tests for com.bumptech.glide""/>
+</manifest>
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <!-- package name must be unique so suffix with ""tests"" so package loader doesn't ignore us -->
3 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
4           package=""com.bumptech.glide.tests""
5           android:versionCode=""1""
6           android:versionName=""1.0"">
7   <uses-sdk android:minSdkVersion=""8"" />
8   <!-- We add an application tag here just so that we can indicate that
9        this package needs to link against the android.test library,
10        which is needed when building test cases. -->
11   <application>
12     <uses-library android:name=""android.test.runner""/>
13   </application>
14   <!--
15   This declares that this application uses the instrumentation test runner targeting
16   the package of com.bumptech.glide.  To run the tests use the command:
17   ""adb shell am instrument -w com.bumptech.glide.tests/android.test.InstrumentationTestRunner""
18   -->
19   <instrumentation android:name=""android.test.InstrumentationTestRunner""
20                    android:targetPackage=""com.bumptech.glide""
21                    android:label=""Tests for com.bumptech.glide""/>
22 </manifest>",Yes
,library\tests\build.xml,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -0,0 +1,92 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project name=""tests"" default=""help"">
+
+  <!-- The local.properties file is created and updated by the 'android' tool.
+       It contains the path to the SDK. It should *NOT* be checked into
+       Version Control Systems. -->
+  <property file=""local.properties""/>
+
+  <!-- The ant.properties file can be created by you. It is only edited by the
+       'android' tool to add properties to it.
+       This is the place to change some Ant specific build properties.
+       Here are some properties you may want to change/update:
+
+       source.dir
+           The name of the source directory. Default is 'src'.
+       out.dir
+           The name of the output directory. Default is 'bin'.
+
+       For other overridable properties, look at the beginning of the rules
+       files in the SDK, at tools/ant/build.xml
+
+       Properties related to the SDK location or the project target should
+       be updated using the 'android' tool with the 'update' action.
+
+       This file is an integral part of the build system for your
+       application and should be checked into Version Control Systems.
+
+       -->
+  <property file=""ant.properties""/>
+
+  <!-- if sdk.dir was not set from one of the property file, then
+       get it from the ANDROID_HOME env var.
+       This must be done before we load project.properties since
+       the proguard config can use sdk.dir -->
+  <property environment=""env""/>
+  <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
+    <isset property=""env.ANDROID_HOME""/>
+  </condition>
+
+  <!-- The project.properties file is created and updated by the 'android'
+       tool, as well as ADT.
+
+       This contains project specific properties such as project target, and library
+       dependencies. Lower level build properties are stored in ant.properties
+       (or in .classpath for Eclipse projects).
+
+       This file is an integral part of the build system for your
+       application and should be checked into Version Control Systems. -->
+  <loadproperties srcFile=""project.properties""/>
+
+  <!-- quick check on sdk.dir -->
+  <fail
+    message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
+    unless=""sdk.dir""
+    />
+
+  <!--
+      Import per project custom build rules if present at the root of the project.
+      This is the place to put custom intermediary targets such as:
+          -pre-build
+          -pre-compile
+          -post-compile (This is typically used for code obfuscation.
+                         Compiled code location: ${out.classes.absolute.dir}
+                         If this is not done in place, override ${out.dex.input.absolute.dir})
+          -post-package
+          -post-build
+          -pre-clean
+  -->
+  <import file=""custom_rules.xml"" optional=""true""/>
+
+  <!-- Import the actual build file.
+
+       To customize existing targets, there are two options:
+       - Customize only one target:
+           - copy/paste the target into this file, *before* the
+             <import> task.
+           - customize it to your needs.
+       - Customize the whole content of build.xml
+           - copy/paste the content of the rules files (minus the top node)
+             into this file, replacing the <import> task.
+           - customize to your needs.
+
+       ***********************
+       ****** IMPORTANT ******
+       ***********************
+       In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+       in order to avoid having your file be overridden by tools such as ""android update project""
+  -->
+  <!-- version-tag: 1 -->
+  <import file=""${sdk.dir}/tools/ant/build.xml""/>
+
+</project>
","1 <?xml version=""1.0"" encoding=""UTF-8""?>
2 <project name=""tests"" default=""help"">
3 
4   <!-- The local.properties file is created and updated by the 'android' tool.
5        It contains the path to the SDK. It should *NOT* be checked into
6        Version Control Systems. -->
7   <property file=""local.properties""/>
8 
9   <!-- The ant.properties file can be created by you. It is only edited by the
10        'android' tool to add properties to it.
11        This is the place to change some Ant specific build properties.
12        Here are some properties you may want to change/update:
13 
14        source.dir
15            The name of the source directory. Default is 'src'.
16        out.dir
17            The name of the output directory. Default is 'bin'.
18 
19        For other overridable properties, look at the beginning of the rules
20        files in the SDK, at tools/ant/build.xml
21 
22        Properties related to the SDK location or the project target should
23        be updated using the 'android' tool with the 'update' action.
24 
25        This file is an integral part of the build system for your
26        application and should be checked into Version Control Systems.
27 
28        -->
29   <property file=""ant.properties""/>
30 
31   <!-- if sdk.dir was not set from one of the property file, then
32        get it from the ANDROID_HOME env var.
33        This must be done before we load project.properties since
34        the proguard config can use sdk.dir -->
35   <property environment=""env""/>
36   <condition property=""sdk.dir"" value=""${env.ANDROID_HOME}"">
37     <isset property=""env.ANDROID_HOME""/>
38   </condition>
39 
40   <!-- The project.properties file is created and updated by the 'android'
41        tool, as well as ADT.
42 
43        This contains project specific properties such as project target, and library
44        dependencies. Lower level build properties are stored in ant.properties
45        (or in .classpath for Eclipse projects).
46 
47        This file is an integral part of the build system for your
48        application and should be checked into Version Control Systems. -->
49   <loadproperties srcFile=""project.properties""/>
50 
51   <!-- quick check on sdk.dir -->
52   <fail
53     message=""sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable.""
54     unless=""sdk.dir""
55     />
56 
57   <!--
58       Import per project custom build rules if present at the root of the project.
59       This is the place to put custom intermediary targets such as:
60           -pre-build
61           -pre-compile
62           -post-compile (This is typically used for code obfuscation.
63                          Compiled code location: ${out.classes.absolute.dir}
64                          If this is not done in place, override ${out.dex.input.absolute.dir})
65           -post-package
66           -post-build
67           -pre-clean
68   -->
69   <import file=""custom_rules.xml"" optional=""true""/>
70 
71   <!-- Import the actual build file.
72 
73        To customize existing targets, there are two options:
74        - Customize only one target:
75            - copy/paste the target into this file, *before* the
76              <import> task.
77            - customize it to your needs.
78        - Customize the whole content of build.xml
79            - copy/paste the content of the rules files (minus the top node)
80              into this file, replacing the <import> task.
81            - customize to your needs.
82 
83        ***********************
84        ****** IMPORTANT ******
85        ***********************
86        In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
87        in order to avoid having your file be overridden by tools such as ""android update project""
88   -->
89   <!-- version-tag: 1 -->
90   <import file=""${sdk.dir}/tools/ant/build.xml""/>
91 
92 </project>",No
,library\tests\project.properties,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# ""ant.properties"", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-16
+android.library.reference.1=../../library
","1 # This file is automatically generated by Android Tools.
2 # Do not modify this file -- YOUR CHANGES WILL BE ERASED!
3 #
4 # This file must be checked in Version Control Systems.
5 #
6 # To customize properties used by the Ant build system edit
7 # ""ant.properties"", and override values to adapt the script to your
8 # project structure.
9 #
10 # To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
11 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
12 
13 # Project target.
14 target=android-16
15 android.library.reference.1=../../library",No
,library\tests\src\com\bumptech\glide\GlideTest.java,944080485b6f0b1f412ae9f33cc49088cc8e39a9,147888d6c7b21d9d401b8fcf2b1c6a4bfbb995aa,Add test project with basic Glide interface tests,"@@ -0,0 +1,90 @@
+package com.bumptech.glide;
+
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import com.bumptech.glide.presenter.ImagePresenter;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/25/13
+ * Time: 12:40 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class GlideTest extends AndroidTestCase {
+    private ImageView imageView;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        imageView = new ImageView(getContext());
+        imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    }
+
+    private <T> void checkImagePresenter(T model) {
+        Glide.load(model).into(imageView).begin();
+
+        ImagePresenter imagePresenter = getImagePresenterFromView();
+        imagePresenter.setModel(model);
+
+        boolean caughtException = false;
+        try {
+            imagePresenter.setModel(new Integer(4));
+        } catch (ClassCastException e) {
+            caughtException = true;
+        }
+
+        assertTrue(caughtException);
+    }
+
+    private ImagePresenter getImagePresenterFromView() {
+        return (ImagePresenter) imageView.getTag(R.id.image_presenter_id);
+    }
+
+    public void testFileDefaultLoader() {
+        checkImagePresenter(new File(""fake""));
+    }
+
+    public void testUrlDefaultLoader() throws MalformedURLException {
+        checkImagePresenter(new URL(""http://www.google.com""));
+    }
+
+    public void testUriDefaultLoader() {
+        checkImagePresenter(Uri.fromFile(new File(""Fake"")));
+    }
+
+    public void testStringDefaultLoader() {
+        checkImagePresenter(""http://www.google.com"");
+    }
+
+    public void testGlideDoesNotReplacePresenters() {
+        Glide.load(new File(""fake"")).into(imageView).begin();
+
+        ImagePresenter first = getImagePresenterFromView();
+
+        Glide.load(new File(""fake2"")).into(imageView).begin();
+
+        ImagePresenter second = getImagePresenterFromView();
+
+        assertEquals(first, second);
+    }
+
+    public void testLoadingTwoDifferentTypesOfModelsThrows() {
+        Glide.load(new File(""fake"")).into(imageView).begin();
+
+        boolean thrown = false;
+        try {
+            Glide.load(new Integer(4)).into(imageView).begin();
+        } catch (ClassCastException e) {
+            thrown = true;
+        }
+
+        assertTrue(thrown);
+    }
+}
","1 package com.bumptech.glide;
2 
3 import android.net.Uri;
4 import android.test.AndroidTestCase;
5 import android.view.ViewGroup;
6 import android.widget.ImageView;
7 import com.bumptech.glide.presenter.ImagePresenter;
8 
9 import java.io.File;
10 import java.net.MalformedURLException;
11 import java.net.URL;
12 
13 /**
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 7/25/13
17  * Time: 12:40 PM
18  * To change this template use File | Settings | File Templates.
19  */
20 public class GlideTest extends AndroidTestCase {
21     private ImageView imageView;
22 
23     @Override
24     protected void setUp() throws Exception {
25         super.setUp();
26         imageView = new ImageView(getContext());
27         imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
28     }
29 
30     private <T> void checkImagePresenter(T model) {
31         Glide.load(model).into(imageView).begin();
32 
33         ImagePresenter imagePresenter = getImagePresenterFromView();
34         imagePresenter.setModel(model);
35 
36         boolean caughtException = false;
37         try {
38             imagePresenter.setModel(new Integer(4));
39         } catch (ClassCastException e) {
40             caughtException = true;
41         }
42 
43         assertTrue(caughtException);
44     }
45 
46     private ImagePresenter getImagePresenterFromView() {
47         return (ImagePresenter) imageView.getTag(R.id.image_presenter_id);
48     }
49 
50     public void testFileDefaultLoader() {
51         checkImagePresenter(new File(""fake""));
52     }
53 
54     public void testUrlDefaultLoader() throws MalformedURLException {
55         checkImagePresenter(new URL(""http://www.google.com""));
56     }
57 
58     public void testUriDefaultLoader() {
59         checkImagePresenter(Uri.fromFile(new File(""Fake"")));
60     }
61 
62     public void testStringDefaultLoader() {
63         checkImagePresenter(""http://www.google.com"");
64     }
65 
66     public void testGlideDoesNotReplacePresenters() {
67         Glide.load(new File(""fake"")).into(imageView).begin();
68 
69         ImagePresenter first = getImagePresenterFromView();
70 
71         Glide.load(new File(""fake2"")).into(imageView).begin();
72 
73         ImagePresenter second = getImagePresenterFromView();
74 
75         assertEquals(first, second);
76     }
77 
78     public void testLoadingTwoDifferentTypesOfModelsThrows() {
79         Glide.load(new File(""fake"")).into(imageView).begin();
80 
81         boolean thrown = false;
82         try {
83             Glide.load(new Integer(4)).into(imageView).begin();
84         } catch (ClassCastException e) {
85             thrown = true;
86         }
87 
88         assertTrue(thrown);
89     }
90 }",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,944080485b6f0b1f412ae9f33cc49088cc8e39a9,"Base FileLoader on UriLoader

removes some duplicated code.","@@ -176,7 +176,7 @@ public class Glide {
         if (model instanceof URL) {
             return (ModelLoader<T>) new UrlLoader(GLIDE.getRequestQueue(context));
         } else if (model instanceof File) {
-            return (ModelLoader<T>) new FileLoader();
+            return (ModelLoader<T>) new FileLoader(context);
         } else if (model instanceof Uri) {
             return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));
         } else if (model instanceof String) {
","179             return (ModelLoader<T>) new FileLoader(context);
179             return (ModelLoader<T>) new FileLoader();",No
library\src\com\bumptech\glide\loader\model\FileLoader.java,library\src\com\bumptech\glide\loader\model\FileLoader.java,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,944080485b6f0b1f412ae9f33cc49088cc8e39a9,"Base FileLoader on UriLoader

removes some duplicated code.","@@ -1,6 +1,8 @@
 package com.bumptech.glide.loader.model;
 
-import com.bumptech.glide.loader.stream.FileStreamLoader;
+import android.content.Context;
+import android.net.Uri;
+import com.bumptech.glide.loader.stream.LocalUriLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 
 import java.io.File;
@@ -9,10 +11,15 @@ import java.io.File;
  * A simple model loader for {@link File}
  */
 public class FileLoader implements ModelLoader<File> {
+    private final Context context;
+
+    public FileLoader(Context context) {
+        this.context = context;
+    }
 
     @Override
     public StreamLoader getStreamOpener(File model, int width, int height) {
-        return new FileStreamLoader(model);
+        return new LocalUriLoader(context, Uri.fromFile(model));
     }
 
     @Override
","3 import android.content.Context;
4 import android.net.Uri;
5 import com.bumptech.glide.loader.stream.LocalUriLoader;
14     private final Context context;
15 
16     public FileLoader(Context context) {
17         this.context = context;
18     }
22         return new LocalUriLoader(context, Uri.fromFile(model));
3 import com.bumptech.glide.loader.stream.FileStreamLoader;
15         return new FileStreamLoader(model);",No
library\src\com\bumptech\glide\loader\stream\LocalUriLoader.java,library\src\com\bumptech\glide\loader\stream\LocalUriLoader.java,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,944080485b6f0b1f412ae9f33cc49088cc8e39a9,"Base FileLoader on UriLoader

removes some duplicated code.","@@ -15,7 +15,7 @@ public class LocalUriLoader implements StreamLoader {
     private final Uri uri;
 
     /**
-     * Opens an input stream for a uri pointing to a local asset
+     * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
      *
      * @see ContentResolver#openInputStream(android.net.Uri)
      *
","18      * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
18      * Opens an input stream for a uri pointing to a local asset",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,1361bbeef0d664e4613787346a3bd1d442fc9f4b,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,"Remove volley dependence in uri/string loaders

Also removes the now unused FileStreamLoader","@@ -178,9 +178,9 @@ public class Glide {
         } else if (model instanceof File) {
             return (ModelLoader<T>) new FileLoader(context);
         } else if (model instanceof Uri) {
-            return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));
+            return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
         } else if (model instanceof String) {
-            return (ModelLoader<T>) new StringLoader(context, GLIDE.getRequestQueue(context));
+            return (ModelLoader<T>) new StringLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
","181             return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
183             return (ModelLoader<T>) new StringLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
181             return (ModelLoader<T>) new UriLoader(context, GLIDE.getRequestQueue(context));
183             return (ModelLoader<T>) new StringLoader(context, GLIDE.getRequestQueue(context));",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,1361bbeef0d664e4613787346a3bd1d442fc9f4b,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,"Remove volley dependence in uri/string loaders

Also removes the now unused FileStreamLoader","@@ -2,11 +2,11 @@ package com.bumptech.glide.loader.model;
 
 import android.content.Context;
 import android.net.Uri;
-import com.android.volley.RequestQueue;
-import com.bumptech.glide.loader.stream.FileStreamLoader;
+import android.webkit.URLUtil;
 import com.bumptech.glide.loader.stream.StreamLoader;
 
 import java.io.File;
+import java.net.URL;
 
 /**
  * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
@@ -16,34 +16,20 @@ public class StringLoader extends BaseModelLoader<String> {
 
     private final UriLoader uriLoader;
 
-    public StringLoader(Context context, RequestQueue requestQueue) {
-        uriLoader = new UriLoader(context, requestQueue);
+    public StringLoader(Context context, ModelLoader<URL> urlLoader) {
+        uriLoader = new UriLoader(context, urlLoader);
     }
 
     @Override
     protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {
-        return new StreamLoader() {
-            StreamLoader subStreamLoader = null;
-            @Override
-            public void loadStream(StreamReadyCallback cb) {
-                final File file = new File(model);
-                if (file.exists() && !file.isDirectory()) {
-                    subStreamLoader = new FileStreamLoader(model);
+        final Uri uri;
+        if (!URLUtil.isValidUrl(model)) {
+            uri = Uri.fromFile(new File(model));
         } else {
-                    final Uri uri = Uri.parse(model);
-                    subStreamLoader = uriLoader.buildStreamOpener(uri, width, height);
-                }
-
-                subStreamLoader.loadStream(cb);
+            uri = Uri.parse(model);
         }
 
-            @Override
-            public void cancel() {
-                if (subStreamLoader != null) {
-                    subStreamLoader.cancel();
-                }
-            }
-        };
+        return uriLoader.buildStreamOpener(uri, width, height);
     }
 
     @Override
","5 import android.webkit.URLUtil;
9 import java.net.URL;
19     public StringLoader(Context context, ModelLoader<URL> urlLoader) {
20         uriLoader = new UriLoader(context, urlLoader);
25         final Uri uri;
26         if (!URLUtil.isValidUrl(model)) {
27             uri = Uri.fromFile(new File(model));
29             uri = Uri.parse(model);
32         return uriLoader.buildStreamOpener(uri, width, height);
5 import com.android.volley.RequestQueue;
6 import com.bumptech.glide.loader.stream.FileStreamLoader;
19     public StringLoader(Context context, RequestQueue requestQueue) {
20         uriLoader = new UriLoader(context, requestQueue);
25         return new StreamLoader() {
26             StreamLoader subStreamLoader = null;
27             @Override
28             public void loadStream(StreamReadyCallback cb) {
29                 final File file = new File(model);
30                 if (file.exists() && !file.isDirectory()) {
31                     subStreamLoader = new FileStreamLoader(model);
33                     final Uri uri = Uri.parse(model);
34                     subStreamLoader = uriLoader.buildStreamOpener(uri, width, height);
37                 subStreamLoader.loadStream(cb);
38             }
39 
40             @Override
41             public void cancel() {
42                 if (subStreamLoader != null) {
43                     subStreamLoader.cancel();
44                 }
45             }
46         };",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,1361bbeef0d664e4613787346a3bd1d442fc9f4b,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,"Remove volley dependence in uri/string loaders

Also removes the now unused FileStreamLoader","@@ -3,10 +3,11 @@ package com.bumptech.glide.loader.model;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-import com.android.volley.RequestQueue;
 import com.bumptech.glide.loader.stream.LocalUriLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.loader.stream.VolleyStreamLoader;
+
+import java.net.MalformedURLException;
+import java.net.URL;
 
 /**
  * A model loader for trying to load Uris. Capable of handling 'http', 'android.resource', 'content', and 'file'
@@ -14,11 +15,11 @@ import com.bumptech.glide.loader.stream.VolleyStreamLoader;
  */
 public class UriLoader extends BaseModelLoader<Uri> {
     private final Context context;
-    private final RequestQueue requestQueue;
+    private final ModelLoader<URL> urlLoader;
 
-    public UriLoader(Context context, RequestQueue requestQueue) {
+    public UriLoader(Context context, ModelLoader<URL> urlLoader) {
         this.context = context;
-        this.requestQueue = requestQueue;
+        this.urlLoader = urlLoader;
     }
 
     @Override
@@ -29,7 +30,11 @@ public class UriLoader extends BaseModelLoader<Uri> {
         if (isLocalUri(scheme)) {
             result = new LocalUriLoader(context, model);
         } else if (""http"".equals(scheme)) {
-            result = new VolleyStreamLoader(requestQueue, model.toString());
+            try {
+                result = urlLoader.getStreamOpener(new URL(model.toString()), width, height);
+            } catch (MalformedURLException e) {
+                e.printStackTrace();
+            }
         }
 
         if (result == null) {
@@ -44,6 +49,12 @@ public class UriLoader extends BaseModelLoader<Uri> {
         return model.toString();
     }
 
+    @Override
+    public void clear() {
+        super.clear();
+        urlLoader.clear();
+    }
+
     private boolean isLocalUri(String scheme) {
         return ContentResolver.SCHEME_FILE.equals(scheme)
                 || ContentResolver.SCHEME_CONTENT.equals(scheme)
","8 
9 import java.net.MalformedURLException;
10 import java.net.URL;
18     private final ModelLoader<URL> urlLoader;
20     public UriLoader(Context context, ModelLoader<URL> urlLoader) {
22         this.urlLoader = urlLoader;
33             try {
34                 result = urlLoader.getStreamOpener(new URL(model.toString()), width, height);
35             } catch (MalformedURLException e) {
36                 e.printStackTrace();
37             }
52     @Override
53     public void clear() {
54         super.clear();
55         urlLoader.clear();
56     }
57 
6 import com.android.volley.RequestQueue;
9 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
17     private final RequestQueue requestQueue;
19     public UriLoader(Context context, RequestQueue requestQueue) {
21         this.requestQueue = requestQueue;
32             result = new VolleyStreamLoader(requestQueue, model.toString());",No
library\src\com\bumptech\glide\loader\stream\FileStreamLoader.java,,1361bbeef0d664e4613787346a3bd1d442fc9f4b,93988c0256d2bbd47ca5d45b316efe9de7dbfd5f,"Remove volley dependence in uri/string loaders

Also removes the now unused FileStreamLoader","@@ -1,32 +0,0 @@
-package com.bumptech.glide.loader.stream;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-
-/**
- * A simple stream loader to retrieve an {@link java.io.InputStream} for a given path or {@link File}
- */
-public class FileStreamLoader implements StreamLoader {
-    private final File file;
-
-    public FileStreamLoader(String path) {
-        this(new File(path));
-    }
-
-    public FileStreamLoader(File file) {
-        this.file = file;
-    }
-
-    @Override
-    public void loadStream(StreamReadyCallback cb) {
-        try {
-            cb.onStreamReady(new FileInputStream(file));
-        } catch (FileNotFoundException e) {
-            cb.onException(e);
-        }
-    }
-
-    @Override
-    public void cancel() { }
-}
","1 package com.bumptech.glide.loader.stream;
2 
3 import java.io.File;
4 import java.io.FileInputStream;
5 import java.io.FileNotFoundException;
6 
7 /**
8  * A simple stream loader to retrieve an {@link java.io.InputStream} for a given path or {@link File}
9  */
10 public class FileStreamLoader implements StreamLoader {
11     private final File file;
12 
13     public FileStreamLoader(String path) {
14         this(new File(path));
15     }
16 
17     public FileStreamLoader(File file) {
18         this.file = file;
19     }
20 
21     @Override
22     public void loadStream(StreamReadyCallback cb) {
23         try {
24             cb.onStreamReady(new FileInputStream(file));
25         } catch (FileNotFoundException e) {
26             cb.onException(e);
27         }
28     }
29 
30     @Override
31     public void cancel() { }
32 }",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,b4f36c0e55facbe749e12501a920fde0316d74d2,1361bbeef0d664e4613787346a3bd1d442fc9f4b,"Simplify StringLoader to take UriLoader

eliminates the weird dependency on UrlLoader in
StringLoader","@@ -180,7 +180,7 @@ public class Glide {
         } else if (model instanceof Uri) {
             return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
         } else if (model instanceof String) {
-            return (ModelLoader<T>) new StringLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
+            return (ModelLoader<T>) new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
","183             return (ModelLoader<T>) new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
183             return (ModelLoader<T>) new StringLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,b4f36c0e55facbe749e12501a920fde0316d74d2,1361bbeef0d664e4613787346a3bd1d442fc9f4b,"Simplify StringLoader to take UriLoader

eliminates the weird dependency on UrlLoader in
StringLoader","@@ -1,12 +1,9 @@
 package com.bumptech.glide.loader.model;
 
-import android.content.Context;
 import android.net.Uri;
-import android.webkit.URLUtil;
 import com.bumptech.glide.loader.stream.StreamLoader;
 
 import java.io.File;
-import java.net.URL;
 
 /**
  * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
@@ -14,22 +11,22 @@ import java.net.URL;
  */
 public class StringLoader extends BaseModelLoader<String> {
 
-    private final UriLoader uriLoader;
+    private final ModelLoader<Uri> uriLoader;
 
-    public StringLoader(Context context, ModelLoader<URL> urlLoader) {
-        uriLoader = new UriLoader(context, urlLoader);
+    public StringLoader(ModelLoader<Uri> uriLoader) {
+        this.uriLoader = uriLoader;
     }
 
     @Override
     protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {
-        final Uri uri;
-        if (!URLUtil.isValidUrl(model)) {
+        Uri uri = Uri.parse(model);
+
+        final String scheme = uri.getScheme();
+        if (scheme == null) {
             uri = Uri.fromFile(new File(model));
-        } else {
-            uri = Uri.parse(model);
         }
 
-        return uriLoader.buildStreamOpener(uri, width, height);
+        return uriLoader.getStreamOpener(uri, width, height);
     }
 
     @Override
","14     private final ModelLoader<Uri> uriLoader;
16     public StringLoader(ModelLoader<Uri> uriLoader) {
17         this.uriLoader = uriLoader;
22         Uri uri = Uri.parse(model);
23 
24         final String scheme = uri.getScheme();
25         if (scheme == null) {
29         return uriLoader.getStreamOpener(uri, width, height);
3 import android.content.Context;
5 import android.webkit.URLUtil;
9 import java.net.URL;
17     private final UriLoader uriLoader;
19     public StringLoader(Context context, ModelLoader<URL> urlLoader) {
20         uriLoader = new UriLoader(context, urlLoader);
25         final Uri uri;
26         if (!URLUtil.isValidUrl(model)) {
28         } else {
29             uri = Uri.parse(model);
32         return uriLoader.buildStreamOpener(uri, width, height);",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,3e3790c166fc84352cef9c75c6037297d1b9fe64,b4f36c0e55facbe749e12501a920fde0316d74d2,Allow https uris in UriLoader,"@@ -10,8 +10,8 @@ import java.net.MalformedURLException;
 import java.net.URL;
 
 /**
- * A model loader for trying to load Uris. Capable of handling 'http', 'android.resource', 'content', and 'file'
- * schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
+ * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
+ * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
  */
 public class UriLoader extends BaseModelLoader<Uri> {
     private final Context context;
@@ -29,7 +29,7 @@ public class UriLoader extends BaseModelLoader<Uri> {
         StreamLoader result = null;
         if (isLocalUri(scheme)) {
             result = new LocalUriLoader(context, model);
-        } else if (""http"".equals(scheme)) {
+        } else if (""http"".equals(scheme) || ""https"".equals(scheme)) {
             try {
                 result = urlLoader.getStreamOpener(new URL(model.toString()), width, height);
             } catch (MalformedURLException e) {
","13  * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
14  * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
32         } else if (""http"".equals(scheme) || ""https"".equals(scheme)) {
13  * A model loader for trying to load Uris. Capable of handling 'http', 'android.resource', 'content', and 'file'
14  * schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
32         } else if (""http"".equals(scheme)) {",No
,library\tests\src\com\bumptech\glide\loader\StringLoaderTest.java,42c4c4267394404562146dcd0f8064e188a2fe06,3e3790c166fc84352cef9c75c6037297d1b9fe64,Add tests for string and uri loaders,"@@ -0,0 +1,85 @@
+package com.bumptech.glide.loader;
+
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.StringLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/25/13
+ * Time: 5:32 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class StringLoaderTest extends AndroidTestCase {
+
+    private StringLoader stringLoader;
+    private ModelLoader<Uri> uriLoader;
+    private Uri uri;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        uri = null;
+        uriLoader = new ModelLoader<Uri>() {
+
+            @Override
+            public StreamLoader getStreamOpener(Uri model, int width, int height) {
+                uri = model;
+                return null;
+            }
+
+            @Override
+            public String getId(Uri model) {
+                return null;
+            }
+
+            @Override
+            public void clear() {
+            }
+        };
+
+        stringLoader = new StringLoader(uriLoader);
+    }
+
+    public void testHandlesPaths() throws IOException {
+        File f = getContext().getCacheDir();
+        stringLoader.getStreamOpener(f.getAbsolutePath(), 100, 100);
+        assertEquals(""file"", uri.getScheme());
+    }
+
+    public void testHandlesFileUris() throws IOException {
+        File f = getContext().getCacheDir();
+        stringLoader.getStreamOpener(Uri.fromFile(f).toString(), 100, 100);
+        assertEquals(""file"", uri.getScheme());
+    }
+
+    public void testHandlesResourceUris() throws IOException {
+        Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");
+        stringLoader.getStreamOpener(resourceUri.toString(), 100, 100);
+        assertEquals(""android.resource"", uri.getScheme());
+    }
+
+    public void testHandlesHttp() {
+        String url = ""http://www.google.com"";
+        stringLoader.getStreamOpener(url, 100, 100);
+        assertEquals(""http"", uri.getScheme());
+    }
+
+    public void testHandlesHttps() {
+        String url = ""https://www.google.com"";
+        stringLoader.getStreamOpener(url, 100, 100);
+        assertEquals(""https"", uri.getScheme());
+    }
+
+    public void testHandlesContent() {
+        String content = ""content://com.bumptech.glide"";
+        stringLoader.getStreamOpener(content, 100, 100);
+        assertEquals(""content"", uri.getScheme());
+    }
+}
","1 package com.bumptech.glide.loader;
2 
3 import android.net.Uri;
4 import android.test.AndroidTestCase;
5 import com.bumptech.glide.loader.model.ModelLoader;
6 import com.bumptech.glide.loader.model.StringLoader;
7 import com.bumptech.glide.loader.stream.StreamLoader;
8 
9 import java.io.File;
10 import java.io.IOException;
11 
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 7/25/13
16  * Time: 5:32 PM
17  * To change this template use File | Settings | File Templates.
18  */
19 public class StringLoaderTest extends AndroidTestCase {
20 
21     private StringLoader stringLoader;
22     private ModelLoader<Uri> uriLoader;
23     private Uri uri;
24 
25     @Override
26     protected void setUp() throws Exception {
27         super.setUp();
28         uri = null;
29         uriLoader = new ModelLoader<Uri>() {
30 
31             @Override
32             public StreamLoader getStreamOpener(Uri model, int width, int height) {
33                 uri = model;
34                 return null;
35             }
36 
37             @Override
38             public String getId(Uri model) {
39                 return null;
40             }
41 
42             @Override
43             public void clear() {
44             }
45         };
46 
47         stringLoader = new StringLoader(uriLoader);
48     }
49 
50     public void testHandlesPaths() throws IOException {
51         File f = getContext().getCacheDir();
52         stringLoader.getStreamOpener(f.getAbsolutePath(), 100, 100);
53         assertEquals(""file"", uri.getScheme());
54     }
55 
56     public void testHandlesFileUris() throws IOException {
57         File f = getContext().getCacheDir();
58         stringLoader.getStreamOpener(Uri.fromFile(f).toString(), 100, 100);
59         assertEquals(""file"", uri.getScheme());
60     }
61 
62     public void testHandlesResourceUris() throws IOException {
63         Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");
64         stringLoader.getStreamOpener(resourceUri.toString(), 100, 100);
65         assertEquals(""android.resource"", uri.getScheme());
66     }
67 
68     public void testHandlesHttp() {
69         String url = ""http://www.google.com"";
70         stringLoader.getStreamOpener(url, 100, 100);
71         assertEquals(""http"", uri.getScheme());
72     }
73 
74     public void testHandlesHttps() {
75         String url = ""https://www.google.com"";
76         stringLoader.getStreamOpener(url, 100, 100);
77         assertEquals(""https"", uri.getScheme());
78     }
79 
80     public void testHandlesContent() {
81         String content = ""content://com.bumptech.glide"";
82         stringLoader.getStreamOpener(content, 100, 100);
83         assertEquals(""content"", uri.getScheme());
84     }
85 }",No
,library\tests\src\com\bumptech\glide\loader\UriLoaderTest.java,42c4c4267394404562146dcd0f8064e188a2fe06,3e3790c166fc84352cef9c75c6037297d1b9fe64,Add tests for string and uri loaders,"@@ -0,0 +1,85 @@
+package com.bumptech.glide.loader;
+
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.UriLoader;
+import com.bumptech.glide.loader.stream.LocalUriLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/25/13
+ * Time: 6:36 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class UriLoaderTest extends AndroidTestCase {
+
+    private UriLoader loader;
+    private StreamLoader urlLoader;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        urlLoader = new StreamLoader() {
+
+            @Override
+            public void loadStream(StreamReadyCallback cb) {
+            }
+
+            @Override
+            public void cancel() {
+            }
+        };
+        loader = new UriLoader(getContext(), new ModelLoader<URL>() {
+            @Override
+            public StreamLoader getStreamOpener(URL model, int width, int height) {
+                return urlLoader;
+            }
+
+            @Override
+            public String getId(URL model) {
+                return null;
+            }
+
+            @Override
+            public void clear() {
+            }
+        });
+    }
+
+    public void testHandlesFileUris() throws IOException {
+        Uri fileUri = Uri.fromFile(new File(""f""));
+        StreamLoader streamLoader = loader.getStreamOpener(fileUri, 0, 0);
+        assertTrue(streamLoader instanceof LocalUriLoader);
+    }
+
+    public void testHandlesResourceUris() throws IOException {
+        Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");// + R.raw.ic_launcher);
+        StreamLoader streamLoader = loader.getStreamOpener(resourceUri, 0, 0);
+        assertTrue(streamLoader instanceof LocalUriLoader);
+    }
+
+    public void testHandlesContentUris() {
+        Uri contentUri = Uri.parse(""content://com.bumptech.glide"");
+        StreamLoader streamLoader = loader.getStreamOpener(contentUri, 0, 0);
+        assertTrue(streamLoader instanceof LocalUriLoader);
+    }
+
+    public void testHandlesHttpUris() {
+        Uri httpUri = Uri.parse(""http://www.google.com"");
+        StreamLoader streamLoader = loader.getStreamOpener(httpUri, 0, 0);
+        assertEquals(urlLoader, streamLoader);
+    }
+
+    public void testHandlesHttpsUris() {
+        Uri httpsUri = Uri.parse(""https://www.google.com"");
+        StreamLoader streamLoader = loader.getStreamOpener(httpsUri, 0, 0);
+        assertEquals(urlLoader, streamLoader);
+    }
+}
","1 package com.bumptech.glide.loader;
2 
3 import android.net.Uri;
4 import android.test.AndroidTestCase;
5 import com.bumptech.glide.loader.model.ModelLoader;
6 import com.bumptech.glide.loader.model.UriLoader;
7 import com.bumptech.glide.loader.stream.LocalUriLoader;
8 import com.bumptech.glide.loader.stream.StreamLoader;
9 
10 import java.io.File;
11 import java.io.IOException;
12 import java.net.URL;
13 
14 /**
15  * Created with IntelliJ IDEA.
16  * User: sam
17  * Date: 7/25/13
18  * Time: 6:36 PM
19  * To change this template use File | Settings | File Templates.
20  */
21 public class UriLoaderTest extends AndroidTestCase {
22 
23     private UriLoader loader;
24     private StreamLoader urlLoader;
25 
26     @Override
27     protected void setUp() throws Exception {
28         super.setUp();
29         urlLoader = new StreamLoader() {
30 
31             @Override
32             public void loadStream(StreamReadyCallback cb) {
33             }
34 
35             @Override
36             public void cancel() {
37             }
38         };
39         loader = new UriLoader(getContext(), new ModelLoader<URL>() {
40             @Override
41             public StreamLoader getStreamOpener(URL model, int width, int height) {
42                 return urlLoader;
43             }
44 
45             @Override
46             public String getId(URL model) {
47                 return null;
48             }
49 
50             @Override
51             public void clear() {
52             }
53         });
54     }
55 
56     public void testHandlesFileUris() throws IOException {
57         Uri fileUri = Uri.fromFile(new File(""f""));
58         StreamLoader streamLoader = loader.getStreamOpener(fileUri, 0, 0);
59         assertTrue(streamLoader instanceof LocalUriLoader);
60     }
61 
62     public void testHandlesResourceUris() throws IOException {
63         Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");// + R.raw.ic_launcher);
64         StreamLoader streamLoader = loader.getStreamOpener(resourceUri, 0, 0);
65         assertTrue(streamLoader instanceof LocalUriLoader);
66     }
67 
68     public void testHandlesContentUris() {
69         Uri contentUri = Uri.parse(""content://com.bumptech.glide"");
70         StreamLoader streamLoader = loader.getStreamOpener(contentUri, 0, 0);
71         assertTrue(streamLoader instanceof LocalUriLoader);
72     }
73 
74     public void testHandlesHttpUris() {
75         Uri httpUri = Uri.parse(""http://www.google.com"");
76         StreamLoader streamLoader = loader.getStreamOpener(httpUri, 0, 0);
77         assertEquals(urlLoader, streamLoader);
78     }
79 
80     public void testHandlesHttpsUris() {
81         Uri httpsUri = Uri.parse(""https://www.google.com"");
82         StreamLoader streamLoader = loader.getStreamOpener(httpsUri, 0, 0);
83         assertEquals(urlLoader, streamLoader);
84     }
85 }",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,cb5e1eeb05e904c6175419247f528ac93f9f8e21,42c4c4267394404562146dcd0f8064e188a2fe06,Add default loader and support for drawable ids,"@@ -8,6 +8,7 @@ import android.widget.ImageView;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
+import com.bumptech.glide.loader.model.DrawableLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.model.StringLoader;
@@ -181,6 +182,8 @@ public class Glide {
             return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
         } else if (model instanceof String) {
             return (ModelLoader<T>) new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
+        } else if (model instanceof Integer) {
+            return (ModelLoader<T>) new DrawableLoader(context);
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
","11 import com.bumptech.glide.loader.model.DrawableLoader;
185         } else if (model instanceof Integer) {
186             return (ModelLoader<T>) new DrawableLoader(context);",No
,library\src\com\bumptech\glide\loader\model\DrawableLoader.java,cb5e1eeb05e904c6175419247f528ac93f9f8e21,42c4c4267394404562146dcd0f8064e188a2fe06,Add default loader and support for drawable ids,"@@ -0,0 +1,35 @@
+package com.bumptech.glide.loader.model;
+
+import android.content.Context;
+import android.net.Uri;
+import com.bumptech.glide.loader.stream.LocalUriLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/25/13
+ * Time: 11:07 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class DrawableLoader implements ModelLoader<Integer> {
+    private final Context context;
+
+    public DrawableLoader(Context context) {
+        this.context = context;
+    }
+
+    @Override
+    public StreamLoader getStreamOpener(Integer model, int width, int height) {
+        Uri uri = Uri.parse(""android.resource://"" + context.getPackageName() + ""/"" + model.toString());
+        return new LocalUriLoader(context, uri);
+    }
+
+    @Override
+    public String getId(Integer model) {
+        return model.toString();
+    }
+
+    @Override
+    public void clear() { }
+}
","1 package com.bumptech.glide.loader.model;
2 
3 import android.content.Context;
4 import android.net.Uri;
5 import com.bumptech.glide.loader.stream.LocalUriLoader;
6 import com.bumptech.glide.loader.stream.StreamLoader;
7 
8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/25/13
12  * Time: 11:07 PM
13  * To change this template use File | Settings | File Templates.
14  */
15 public class DrawableLoader implements ModelLoader<Integer> {
16     private final Context context;
17 
18     public DrawableLoader(Context context) {
19         this.context = context;
20     }
21 
22     @Override
23     public StreamLoader getStreamOpener(Integer model, int width, int height) {
24         Uri uri = Uri.parse(""android.resource://"" + context.getPackageName() + ""/"" + model.toString());
25         return new LocalUriLoader(context, uri);
26     }
27 
28     @Override
29     public String getId(Integer model) {
30         return model.toString();
31     }
32 
33     @Override
34     public void clear() { }
35 }",No
library\tests\res\raw\ic_launcher.png,library\tests\res\raw\ic_launcher.png,cb5e1eeb05e904c6175419247f528ac93f9f8e21,42c4c4267394404562146dcd0f8064e188a2fe06,Add default loader and support for drawable ids,"Binary files /dev/null and b/library/tests/res/raw/ic_launcher.png differ
",,No
library\tests\src\com\bumptech\glide\GlideTest.java,library\tests\src\com\bumptech\glide\GlideTest.java,cb5e1eeb05e904c6175419247f528ac93f9f8e21,42c4c4267394404562146dcd0f8064e188a2fe06,Add default loader and support for drawable ids,"@@ -35,7 +35,7 @@ public class GlideTest extends AndroidTestCase {
 
         boolean caughtException = false;
         try {
-            imagePresenter.setModel(new Integer(4));
+            imagePresenter.setModel(new Float(4.4f));
         } catch (ClassCastException e) {
             caughtException = true;
         }
@@ -63,6 +63,10 @@ public class GlideTest extends AndroidTestCase {
         checkImagePresenter(""http://www.google.com"");
     }
 
+    public void testIntegerDefaultLoader() {
+        checkImagePresenter(1234);
+    }
+
     public void testGlideDoesNotReplacePresenters() {
         Glide.load(new File(""fake"")).into(imageView).begin();
 
","38             imagePresenter.setModel(new Float(4.4f));
66     public void testIntegerDefaultLoader() {
67         checkImagePresenter(1234);
68     }
69 
38             imagePresenter.setModel(new Integer(4));",No
,library\tests\src\com\bumptech\glide\loader\DrawableLoaderTest.java,cb5e1eeb05e904c6175419247f528ac93f9f8e21,42c4c4267394404562146dcd0f8064e188a2fe06,Add default loader and support for drawable ids,"@@ -0,0 +1,47 @@
+package com.bumptech.glide.loader;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.test.ActivityTestCase;
+import com.bumptech.glide.loader.model.DrawableLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.tests.R;
+
+import java.io.InputStream;
+
+/**
+ * Created with IntelliJ IDEA.
+ * User: sam
+ * Date: 7/25/13
+ * Time: 11:13 PM
+ * To change this template use File | Settings | File Templates.
+ */
+public class DrawableLoaderTest extends ActivityTestCase {
+    private boolean cbCalled;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        cbCalled = false;
+    }
+
+    public void testCanHandleId() {
+        DrawableLoader drawableLoader = new DrawableLoader(getInstrumentation().getContext());
+        StreamLoader streamLoader = drawableLoader.getStreamOpener(R.raw.ic_launcher, 0, 0);
+        streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
+            @Override
+            public void onStreamReady(InputStream is) {
+                cbCalled = true;
+                Bitmap result = BitmapFactory.decodeStream(is);
+                assertNotNull(result);
+            }
+
+            @Override
+            public void onException(Exception e) {
+                cbCalled = true;
+                assertNull(e);
+            }
+        });
+        assertTrue(cbCalled);
+    }
+}
","1 package com.bumptech.glide.loader;
2 
3 import android.graphics.Bitmap;
4 import android.graphics.BitmapFactory;
5 import android.test.ActivityTestCase;
6 import com.bumptech.glide.loader.model.DrawableLoader;
7 import com.bumptech.glide.loader.stream.StreamLoader;
8 import com.bumptech.glide.tests.R;
9 
10 import java.io.InputStream;
11 
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 7/25/13
16  * Time: 11:13 PM
17  * To change this template use File | Settings | File Templates.
18  */
19 public class DrawableLoaderTest extends ActivityTestCase {
20     private boolean cbCalled;
21 
22     @Override
23     protected void setUp() throws Exception {
24         super.setUp();
25         cbCalled = false;
26     }
27 
28     public void testCanHandleId() {
29         DrawableLoader drawableLoader = new DrawableLoader(getInstrumentation().getContext());
30         StreamLoader streamLoader = drawableLoader.getStreamOpener(R.raw.ic_launcher, 0, 0);
31         streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
32             @Override
33             public void onStreamReady(InputStream is) {
34                 cbCalled = true;
35                 Bitmap result = BitmapFactory.decodeStream(is);
36                 assertNotNull(result);
37             }
38 
39             @Override
40             public void onException(Exception e) {
41                 cbCalled = true;
42                 assertNull(e);
43             }
44         });
45         assertTrue(cbCalled);
46     }
47 }",No
library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -12,7 +12,7 @@ public abstract class BaseModelLoader<T> implements ModelLoader<T> {
     private StreamLoader current;
 
     @Override
-    public final StreamLoader getStreamOpener(T model, int width, int height) {
+    public final StreamLoader getStreamLoader(T model, int width, int height) {
         current = buildStreamOpener(model, width, height);
         return current;
     }
","15     public final StreamLoader getStreamLoader(T model, int width, int height) {
15     public final StreamLoader getStreamOpener(T model, int width, int height) {",No
library\src\com\bumptech\glide\loader\model\DrawableLoader.java,library\src\com\bumptech\glide\loader\model\DrawableLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -20,7 +20,7 @@ public class DrawableLoader implements ModelLoader<Integer> {
     }
 
     @Override
-    public StreamLoader getStreamOpener(Integer model, int width, int height) {
+    public StreamLoader getStreamLoader(Integer model, int width, int height) {
         Uri uri = Uri.parse(""android.resource://"" + context.getPackageName() + ""/"" + model.toString());
         return new LocalUriLoader(context, uri);
     }
","23     public StreamLoader getStreamLoader(Integer model, int width, int height) {
23     public StreamLoader getStreamOpener(Integer model, int width, int height) {",No
library\src\com\bumptech\glide\loader\model\FileLoader.java,library\src\com\bumptech\glide\loader\model\FileLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -18,7 +18,7 @@ public class FileLoader implements ModelLoader<File> {
     }
 
     @Override
-    public StreamLoader getStreamOpener(File model, int width, int height) {
+    public StreamLoader getStreamLoader(File model, int width, int height) {
         return new LocalUriLoader(context, Uri.fromFile(model));
     }
 
","21     public StreamLoader getStreamLoader(File model, int width, int height) {
21     public StreamLoader getStreamOpener(File model, int width, int height) {",No
library\src\com\bumptech\glide\loader\model\ModelLoader.java,library\src\com\bumptech\glide\loader\model\ModelLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -32,7 +32,7 @@ public interface ModelLoader<T> {
      * @param height The height of the view the image will be loaded into
      * @return A {@link StreamLoader} that can obtain an InputStream for the image if it is not cached
      */
-    public StreamLoader getStreamOpener(T model, int width, int height);
+    public StreamLoader getStreamLoader(T model, int width, int height);
 
 
     /**
","35     public StreamLoader getStreamLoader(T model, int width, int height);
35     public StreamLoader getStreamOpener(T model, int width, int height);",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -26,7 +26,7 @@ public class StringLoader extends BaseModelLoader<String> {
             uri = Uri.fromFile(new File(model));
         }
 
-        return uriLoader.getStreamOpener(uri, width, height);
+        return uriLoader.getStreamLoader(uri, width, height);
     }
 
     @Override
","29         return uriLoader.getStreamLoader(uri, width, height);
29         return uriLoader.getStreamOpener(uri, width, height);",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -31,7 +31,7 @@ public class UriLoader extends BaseModelLoader<Uri> {
             result = new LocalUriLoader(context, model);
         } else if (""http"".equals(scheme) || ""https"".equals(scheme)) {
             try {
-                result = urlLoader.getStreamOpener(new URL(model.toString()), width, height);
+                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
             } catch (MalformedURLException e) {
                 e.printStackTrace();
             }
","34                 result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
34                 result = urlLoader.getStreamOpener(new URL(model.toString()), width, height);",No
library\src\com\bumptech\glide\loader\model\UrlLoader.java,library\src\com\bumptech\glide\loader\model\UrlLoader.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -17,7 +17,7 @@ public class UrlLoader implements ModelLoader<URL> {
     }
 
     @Override
-    public StreamLoader getStreamOpener(URL model, int width, int height) {
+    public StreamLoader getStreamLoader(URL model, int width, int height) {
         return new VolleyStreamLoader(requestQueue, model.toString());
     }
 
","20     public StreamLoader getStreamLoader(URL model, int width, int height) {
20     public StreamLoader getStreamOpener(URL model, int width, int height) {",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -343,7 +343,7 @@ public class ImagePresenter<T> {
     private void fetchImage(final T model, int width, int height, final int loadCount) {
         modelLoader.clear();
         imageLoader.clear();
-        final StreamLoader streamLoader = modelLoader.getStreamOpener(model, width, height);
+        final StreamLoader streamLoader = modelLoader.getStreamLoader(model, width, height);
         final String id = modelLoader.getId(model);
 
         imageToken = imageLoader.fetchImage(id, streamLoader, width, height, new ImageLoader.ImageReadyCallback() {
","346         final StreamLoader streamLoader = modelLoader.getStreamLoader(model, width, height);
346         final StreamLoader streamLoader = modelLoader.getStreamOpener(model, width, height);",No
library\tests\src\com\bumptech\glide\loader\DrawableLoaderTest.java,library\tests\src\com\bumptech\glide\loader\DrawableLoaderTest.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -27,7 +27,7 @@ public class DrawableLoaderTest extends ActivityTestCase {
 
     public void testCanHandleId() {
         DrawableLoader drawableLoader = new DrawableLoader(getInstrumentation().getContext());
-        StreamLoader streamLoader = drawableLoader.getStreamOpener(R.raw.ic_launcher, 0, 0);
+        StreamLoader streamLoader = drawableLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);
         streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
             @Override
             public void onStreamReady(InputStream is) {
","30         StreamLoader streamLoader = drawableLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);
30         StreamLoader streamLoader = drawableLoader.getStreamOpener(R.raw.ic_launcher, 0, 0);",No
library\tests\src\com\bumptech\glide\loader\StringLoaderTest.java,library\tests\src\com\bumptech\glide\loader\StringLoaderTest.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -29,7 +29,7 @@ public class StringLoaderTest extends AndroidTestCase {
         uriLoader = new ModelLoader<Uri>() {
 
             @Override
-            public StreamLoader getStreamOpener(Uri model, int width, int height) {
+            public StreamLoader getStreamLoader(Uri model, int width, int height) {
                 uri = model;
                 return null;
             }
@@ -49,37 +49,37 @@ public class StringLoaderTest extends AndroidTestCase {
 
     public void testHandlesPaths() throws IOException {
         File f = getContext().getCacheDir();
-        stringLoader.getStreamOpener(f.getAbsolutePath(), 100, 100);
+        stringLoader.getStreamLoader(f.getAbsolutePath(), 100, 100);
         assertEquals(""file"", uri.getScheme());
     }
 
     public void testHandlesFileUris() throws IOException {
         File f = getContext().getCacheDir();
-        stringLoader.getStreamOpener(Uri.fromFile(f).toString(), 100, 100);
+        stringLoader.getStreamLoader(Uri.fromFile(f).toString(), 100, 100);
         assertEquals(""file"", uri.getScheme());
     }
 
     public void testHandlesResourceUris() throws IOException {
         Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");
-        stringLoader.getStreamOpener(resourceUri.toString(), 100, 100);
+        stringLoader.getStreamLoader(resourceUri.toString(), 100, 100);
         assertEquals(""android.resource"", uri.getScheme());
     }
 
     public void testHandlesHttp() {
         String url = ""http://www.google.com"";
-        stringLoader.getStreamOpener(url, 100, 100);
+        stringLoader.getStreamLoader(url, 100, 100);
         assertEquals(""http"", uri.getScheme());
     }
 
     public void testHandlesHttps() {
         String url = ""https://www.google.com"";
-        stringLoader.getStreamOpener(url, 100, 100);
+        stringLoader.getStreamLoader(url, 100, 100);
         assertEquals(""https"", uri.getScheme());
     }
 
     public void testHandlesContent() {
         String content = ""content://com.bumptech.glide"";
-        stringLoader.getStreamOpener(content, 100, 100);
+        stringLoader.getStreamLoader(content, 100, 100);
         assertEquals(""content"", uri.getScheme());
     }
 }
","32             public StreamLoader getStreamLoader(Uri model, int width, int height) {
52         stringLoader.getStreamLoader(f.getAbsolutePath(), 100, 100);
58         stringLoader.getStreamLoader(Uri.fromFile(f).toString(), 100, 100);
64         stringLoader.getStreamLoader(resourceUri.toString(), 100, 100);
70         stringLoader.getStreamLoader(url, 100, 100);
76         stringLoader.getStreamLoader(url, 100, 100);
82         stringLoader.getStreamLoader(content, 100, 100);
32             public StreamLoader getStreamOpener(Uri model, int width, int height) {
52         stringLoader.getStreamOpener(f.getAbsolutePath(), 100, 100);
58         stringLoader.getStreamOpener(Uri.fromFile(f).toString(), 100, 100);
64         stringLoader.getStreamOpener(resourceUri.toString(), 100, 100);
70         stringLoader.getStreamOpener(url, 100, 100);
76         stringLoader.getStreamOpener(url, 100, 100);
82         stringLoader.getStreamOpener(content, 100, 100);",No
library\tests\src\com\bumptech\glide\loader\UriLoaderTest.java,library\tests\src\com\bumptech\glide\loader\UriLoaderTest.java,54bf8809a40a9c65321439b4189a8cc3c39d0700,cb5e1eeb05e904c6175419247f528ac93f9f8e21,getStreamOpener -> getStreamLoader,"@@ -38,7 +38,7 @@ public class UriLoaderTest extends AndroidTestCase {
         };
         loader = new UriLoader(getContext(), new ModelLoader<URL>() {
             @Override
-            public StreamLoader getStreamOpener(URL model, int width, int height) {
+            public StreamLoader getStreamLoader(URL model, int width, int height) {
                 return urlLoader;
             }
 
@@ -55,31 +55,31 @@ public class UriLoaderTest extends AndroidTestCase {
 
     public void testHandlesFileUris() throws IOException {
         Uri fileUri = Uri.fromFile(new File(""f""));
-        StreamLoader streamLoader = loader.getStreamOpener(fileUri, 0, 0);
+        StreamLoader streamLoader = loader.getStreamLoader(fileUri, 0, 0);
         assertTrue(streamLoader instanceof LocalUriLoader);
     }
 
     public void testHandlesResourceUris() throws IOException {
         Uri resourceUri = Uri.parse(""android.resource://com.bumptech.glide.tests/raw/ic_launcher"");// + R.raw.ic_launcher);
-        StreamLoader streamLoader = loader.getStreamOpener(resourceUri, 0, 0);
+        StreamLoader streamLoader = loader.getStreamLoader(resourceUri, 0, 0);
         assertTrue(streamLoader instanceof LocalUriLoader);
     }
 
     public void testHandlesContentUris() {
         Uri contentUri = Uri.parse(""content://com.bumptech.glide"");
-        StreamLoader streamLoader = loader.getStreamOpener(contentUri, 0, 0);
+        StreamLoader streamLoader = loader.getStreamLoader(contentUri, 0, 0);
         assertTrue(streamLoader instanceof LocalUriLoader);
     }
 
     public void testHandlesHttpUris() {
         Uri httpUri = Uri.parse(""http://www.google.com"");
-        StreamLoader streamLoader = loader.getStreamOpener(httpUri, 0, 0);
+        StreamLoader streamLoader = loader.getStreamLoader(httpUri, 0, 0);
         assertEquals(urlLoader, streamLoader);
     }
 
     public void testHandlesHttpsUris() {
         Uri httpsUri = Uri.parse(""https://www.google.com"");
-        StreamLoader streamLoader = loader.getStreamOpener(httpsUri, 0, 0);
+        StreamLoader streamLoader = loader.getStreamLoader(httpsUri, 0, 0);
         assertEquals(urlLoader, streamLoader);
     }
 }
","41             public StreamLoader getStreamLoader(URL model, int width, int height) {
58         StreamLoader streamLoader = loader.getStreamLoader(fileUri, 0, 0);
64         StreamLoader streamLoader = loader.getStreamLoader(resourceUri, 0, 0);
70         StreamLoader streamLoader = loader.getStreamLoader(contentUri, 0, 0);
76         StreamLoader streamLoader = loader.getStreamLoader(httpUri, 0, 0);
82         StreamLoader streamLoader = loader.getStreamLoader(httpsUri, 0, 0);
41             public StreamLoader getStreamOpener(URL model, int width, int height) {
58         StreamLoader streamLoader = loader.getStreamOpener(fileUri, 0, 0);
64         StreamLoader streamLoader = loader.getStreamOpener(resourceUri, 0, 0);
70         StreamLoader streamLoader = loader.getStreamOpener(contentUri, 0, 0);
76         StreamLoader streamLoader = loader.getStreamOpener(httpUri, 0, 0);
82         StreamLoader streamLoader = loader.getStreamOpener(httpsUri, 0, 0);",No
library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,6bbe4343c1e08c4b2fdb56a23b69c767b89962bc,54bf8809a40a9c65321439b4189a8cc3c39d0700,buildStreamOpener -> buildStreamLoader,"@@ -13,11 +13,11 @@ public abstract class BaseModelLoader<T> implements ModelLoader<T> {
 
     @Override
     public final StreamLoader getStreamLoader(T model, int width, int height) {
-        current = buildStreamOpener(model, width, height);
+        current = buildStreamLoader(model, width, height);
         return current;
     }
 
-    protected abstract StreamLoader buildStreamOpener(T model, int width, int height);
+    protected abstract StreamLoader buildStreamLoader(T model, int width, int height);
 
     @Override
     public void clear() {
","16         current = buildStreamLoader(model, width, height);
20     protected abstract StreamLoader buildStreamLoader(T model, int width, int height);
16         current = buildStreamOpener(model, width, height);
20     protected abstract StreamLoader buildStreamOpener(T model, int width, int height);",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,6bbe4343c1e08c4b2fdb56a23b69c767b89962bc,54bf8809a40a9c65321439b4189a8cc3c39d0700,buildStreamOpener -> buildStreamLoader,"@@ -18,7 +18,7 @@ public class StringLoader extends BaseModelLoader<String> {
     }
 
     @Override
-    protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {
+    protected StreamLoader buildStreamLoader(final String model, final int width, final int height) {
         Uri uri = Uri.parse(model);
 
         final String scheme = uri.getScheme();
","21     protected StreamLoader buildStreamLoader(final String model, final int width, final int height) {
21     protected StreamLoader buildStreamOpener(final String model, final int width, final int height) {",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,6bbe4343c1e08c4b2fdb56a23b69c767b89962bc,54bf8809a40a9c65321439b4189a8cc3c39d0700,buildStreamOpener -> buildStreamLoader,"@@ -11,7 +11,7 @@ import java.net.URL;
 
 /**
  * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
- * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
+ * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamLoader(android.net.Uri, int, int)}.
  */
 public class UriLoader extends BaseModelLoader<Uri> {
     private final Context context;
@@ -23,7 +23,7 @@ public class UriLoader extends BaseModelLoader<Uri> {
     }
 
     @Override
-    protected StreamLoader buildStreamOpener(Uri model, int width, int height) {
+    protected StreamLoader buildStreamLoader(Uri model, int width, int height) {
         final String scheme = model.getScheme();
 
         StreamLoader result = null;
","14  * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamLoader(android.net.Uri, int, int)}.
26     protected StreamLoader buildStreamLoader(Uri model, int width, int height) {
14  * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamOpener(android.net.Uri, int, int)}.
26     protected StreamLoader buildStreamOpener(Uri model, int width, int height) {",No
library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,6bbe4343c1e08c4b2fdb56a23b69c767b89962bc,54bf8809a40a9c65321439b4189a8cc3c39d0700,buildStreamOpener -> buildStreamLoader,"@@ -16,7 +16,7 @@ public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
     }
 
     @Override
-    protected StreamLoader buildStreamOpener(T model, int width, int height) {
+    protected StreamLoader buildStreamLoader(T model, int width, int height) {
         return new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
     }
 
","19     protected StreamLoader buildStreamLoader(T model, int width, int height) {
19     protected StreamLoader buildStreamOpener(T model, int width, int height) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,f80b960f9943234f88fc4707ad49b24e71840638,6bbe4343c1e08c4b2fdb56a23b69c767b89962bc,Remove redundant casts in getModelFor in Glide,"@@ -174,20 +174,22 @@ public class Glide {
 
     @SuppressWarnings(""unchecked"")
     private static <T> ModelLoader<T> getModelFor(T model, Context context) {
+        final ModelLoader result;
         if (model instanceof URL) {
-            return (ModelLoader<T>) new UrlLoader(GLIDE.getRequestQueue(context));
+            result = new UrlLoader(GLIDE.getRequestQueue(context));
         } else if (model instanceof File) {
-            return (ModelLoader<T>) new FileLoader(context);
+            result = new FileLoader(context);
         } else if (model instanceof Uri) {
-            return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
+            result = new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
         } else if (model instanceof String) {
-            return (ModelLoader<T>) new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
+            result = new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
         } else if (model instanceof Integer) {
-            return (ModelLoader<T>) new DrawableLoader(context);
+            result = new DrawableLoader(context);
         } else {
             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
                     "", you need to provide one by calling with()"");
         }
+        return result;
     }
 
      /**
","177         final ModelLoader result;
179             result = new UrlLoader(GLIDE.getRequestQueue(context));
181             result = new FileLoader(context);
183             result = new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
185             result = new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
187             result = new DrawableLoader(context);
192         return result;
178             return (ModelLoader<T>) new UrlLoader(GLIDE.getRequestQueue(context));
180             return (ModelLoader<T>) new FileLoader(context);
182             return (ModelLoader<T>) new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
184             return (ModelLoader<T>) new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
186             return (ModelLoader<T>) new DrawableLoader(context);",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,e705c76eb127df626b6c007292ce0699c5a65ba0,f80b960f9943234f88fc4707ad49b24e71840638,Add methods to set placeholders in Glide.load,"@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
@@ -335,6 +336,28 @@ public class Glide {
             return animate(AnimationUtils.loadAnimation(context, animationId));
         }
 
+        /**
+         * Sets a drawable to display while an image is loading
+         *
+         * @param drawable The drawable to use as a placeholder
+         * @return This Request
+         */
+        public Request<T> setPlaceholderDrawable(Drawable drawable) {
+            builder.setPlaceholderDrawable(drawable);
+            return this;
+        }
+
+        /**
+         * @see #setPlaceholderDrawable(android.graphics.drawable.Drawable)
+         *
+         * @param resourceId The id of the resource to use as a placeholder
+         * @return This Request
+         */
+        public Request<T> setPlaceholderResource(int resourceId) {
+            builder.setPlaceholderResource(resourceId);
+            return this;
+        }
+
         /**
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
          * the given model. This must be called on the main thread.
","4 import android.graphics.drawable.Drawable;
339         /**
340          * Sets a drawable to display while an image is loading
341          *
342          * @param drawable The drawable to use as a placeholder
343          * @return This Request
344          */
345         public Request<T> setPlaceholderDrawable(Drawable drawable) {
346             builder.setPlaceholderDrawable(drawable);
347             return this;
348         }
349 
350         /**
351          * @see #setPlaceholderDrawable(android.graphics.drawable.Drawable)
352          *
353          * @param resourceId The id of the resource to use as a placeholder
354          * @return This Request
355          */
356         public Request<T> setPlaceholderResource(int resourceId) {
357             builder.setPlaceholderResource(resourceId);
358             return this;
359         }
360 ",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,712e2931fb8d86e53cb4406d988d9b094aa1d98e,e705c76eb127df626b6c007292ce0699c5a65ba0,Update some of comments for Glide.load,"@@ -263,7 +263,7 @@ public class Glide {
         }
 
         /**
-         * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resize models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -273,7 +273,7 @@ public class Glide {
         }
 
         /**
-         * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resize models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -283,7 +283,7 @@ public class Glide {
         }
 
         /**
-         * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
+         * Resize models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
          * Replaces any existing resize style
          *
          * @return This Request
@@ -362,6 +362,16 @@ public class Glide {
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
          * the given model. This must be called on the main thread.
          *
+         * <p>
+         *     Note - If an existing ImagePresenter already exists for this view it will not be replaced. This means you
+         *     can set options once and only once the first time load and begin is called for any given view. For
+         *     example, if you call load and begin for a view with centerCrop the first time and then load a second time
+         *     for the same view but with fitCenter, the image will still be resized with centerCrop. If you need
+         *     to change options you can call <code> imageView.setTag(R.id.image_presenter_id, null) </code> prior to
+         *     calling this method, but it is inefficient to do so, particularly in lists.
+         * </p>
+         *
+         *
          * @see ImagePresenter#setModel(Object)
          */
         public void begin() {
@@ -376,9 +386,6 @@ public class Glide {
         /**
          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
          * the view's tag for the id {@code R.id.image_presenter_id}.
-         *
-         * If a Request is completed with replaceAndBuild(), then an ImagePresenter will be created  but the image
-         * load will not actually be started until some subsequent Request is completed with {@link #begin()}
          */
         private void build() {
             if (presenter == null) {
","266          * Resize models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
276          * Resize models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
286          * Resize models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
365          * <p>
366          *     Note - If an existing ImagePresenter already exists for this view it will not be replaced. This means you
367          *     can set options once and only once the first time load and begin is called for any given view. For
368          *     example, if you call load and begin for a view with centerCrop the first time and then load a second time
369          *     for the same view but with fitCenter, the image will still be resized with centerCrop. If you need
370          *     to change options you can call <code> imageView.setTag(R.id.image_presenter_id, null) </code> prior to
371          *     calling this method, but it is inefficient to do so, particularly in lists.
372          * </p>
373          *
374          *
266          * Resizes models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
276          * Resizes models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
286          * Resizes models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
379          *
380          * If a Request is completed with replaceAndBuild(), then an ImagePresenter will be created  but the image
381          * load will not actually be started until some subsequent Request is completed with {@link #begin()}",No
.gitignore,.gitignore,388a07251f6558aac332bab015193db9cadadd3f,712e2931fb8d86e53cb4406d988d9b094aa1d98e,Add gradle build file,"@@ -1,5 +1,6 @@
 library/bin/*
 library/gen/*
+library/build/*
 library/local.properties
 *.iml
 .idea/*
",3 library/build/*,No
,library\build.gradle,388a07251f6558aac332bab015193db9cadadd3f,712e2931fb8d86e53cb4406d988d9b094aa1d98e,Add gradle build file,"@@ -0,0 +1,39 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.5.+'
+    }
+}
+
+apply plugin: 'android-library'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    compile files('libs/disklrucache-2.0.2.jar')
+    compile 'com.android.support:support-v4:13.0.+'
+    compile project('volley')
+}
+
+
+android {
+    compileSdkVersion 17
+    buildToolsVersion = 17
+
+    sourceSets {
+        main {
+            assets.srcDirs       = ['assets']
+            res.srcDirs          = ['res']
+            aidl.srcDirs         = ['src']
+            resources.srcDirs    = ['src']
+            renderscript.srcDirs = ['src']
+            java.srcDirs         = ['src']
+            manifest.srcFile 'AndroidManifest.xml'
+
+        }
+    }
+}
\ No newline at end of file
","1 buildscript {
2     repositories {
3         mavenCentral()
4     }
5     dependencies {
6         classpath 'com.android.tools.build:gradle:0.5.+'
7     }
8 }
9 
10 apply plugin: 'android-library'
11 
12 repositories {
13     mavenCentral()
14 }
15 
16 dependencies {
17     compile files('libs/disklrucache-2.0.2.jar')
18     compile 'com.android.support:support-v4:13.0.+'
19     compile project('volley')
20 }
21 
22 
23 android {
24     compileSdkVersion 17
25     buildToolsVersion = 17
26 
27     sourceSets {
28         main {
29             assets.srcDirs       = ['assets']
30             res.srcDirs          = ['res']
31             aidl.srcDirs         = ['src']
32             resources.srcDirs    = ['src']
33             renderscript.srcDirs = ['src']
34             java.srcDirs         = ['src']
35             manifest.srcFile 'AndroidManifest.xml'
36 
37         }
38     }
39 }",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,612bb49c9045a723e2da145ef3647707b731b6c6,388a07251f6558aac332bab015193db9cadadd3f,"Tag views with ImagePresenters in constructor

This should be safe since we're using tag with
an id and it eliminates one extra step required
to use ImagePresenters.","@@ -239,7 +239,7 @@ public class Glide {
             this.imageView = imageView;
             this.context = imageView.getContext();
 
-            presenter = (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
+            presenter = ImagePresenter.getCurrent(imageView);
             builder = new ImagePresenter.Builder<T>()
                     .setImageView(imageView)
                     .setImageLoader(new Approximate(getImageManager()));
@@ -393,7 +393,6 @@ public class Glide {
                     modelLoader = getModelFor(model, context);
                 }
                 presenter = builder.setModelLoader(modelLoader).build();
-                imageView.setTag(R.id.image_presenter_id, presenter);
             }
         }
     }
","242             presenter = ImagePresenter.getCurrent(imageView);
242             presenter = (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
396                 imageView.setTag(R.id.image_presenter_id, presenter);",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,612bb49c9045a723e2da145ef3647707b731b6c6,388a07251f6558aac332bab015193db9cadadd3f,"Tag views with ImagePresenters in constructor

This should be safe since we're using tag with
an id and it eliminates one extra step required
to use ImagePresenters.","@@ -12,9 +12,10 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.R;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.util.Log;
 
 import java.lang.ref.WeakReference;
@@ -64,7 +65,15 @@ public class ImagePresenter<T> {
         private ModelLoader<T> modelLoader;
 
         /**
-         * Builds an ImagePresenter
+         * Builds an ImagePresenter.
+         *
+         * <p>
+         *     Note - If an ImagePresenter has already been set for this view, it will be silently replaced and will not
+         *     be cleared which could lead to undefined behavior. It is most efficient to set an ImagePresenter once and
+         *     then retrieve it for each subsequent load. If you need to replace an ImagePresenter you can do so by
+         *     setting the tag at <code>R.id.image_presenter_id</code> to null with
+         *     {@link View#setTag(int, Object)}
+         * </p>
          *
          * @return A new ImagePresenter
          */
@@ -246,6 +255,19 @@ public class ImagePresenter<T> {
         public void onException(Exception e, T model, boolean isCurrent);
     }
 
+    /**
+     * Retrieves the current ImagePresenter for the given view using {@link android.widget.ImageView#getTag()} and
+     * <code>R.id.image_presenter_id</code>
+     *
+     * @param imageView The view to get the ImagePresenter for
+     * @param <T> The type of model being displayed in the ImageView
+     * @return The current ImagePresenter, or null if one does not exist
+     */
+    @SuppressWarnings(""unchecked"")
+    public static <T> ImagePresenter<T> getCurrent(View imageView) {
+        return (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
+    }
+
     protected ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
@@ -259,6 +281,8 @@ public class ImagePresenter<T> {
         this.exceptionHandler = builder.exceptionHandler;
         this.modelLoader = builder.modelLoader;
         sizeDeterminer = new SizeDeterminer(imageView);
+
+        imageView.setTag(R.id.image_presenter_id, this);
     }
 
     /**
","15 import com.bumptech.glide.R;
18 import com.bumptech.glide.loader.stream.StreamLoader;
68          * Builds an ImagePresenter.
69          *
70          * <p>
71          *     Note - If an ImagePresenter has already been set for this view, it will be silently replaced and will not
72          *     be cleared which could lead to undefined behavior. It is most efficient to set an ImagePresenter once and
73          *     then retrieve it for each subsequent load. If you need to replace an ImagePresenter you can do so by
74          *     setting the tag at <code>R.id.image_presenter_id</code> to null with
75          *     {@link View#setTag(int, Object)}
76          * </p>
258     /**
259      * Retrieves the current ImagePresenter for the given view using {@link android.widget.ImageView#getTag()} and
260      * <code>R.id.image_presenter_id</code>
261      *
262      * @param imageView The view to get the ImagePresenter for
263      * @param <T> The type of model being displayed in the ImageView
264      * @return The current ImagePresenter, or null if one does not exist
265      */
266     @SuppressWarnings(""unchecked"")
267     public static <T> ImagePresenter<T> getCurrent(View imageView) {
268         return (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
269     }
270 
284 
285         imageView.setTag(R.id.image_presenter_id, this);
15 import com.bumptech.glide.loader.stream.StreamLoader;
67          * Builds an ImagePresenter",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,612bb49c9045a723e2da145ef3647707b731b6c6,388a07251f6558aac332bab015193db9cadadd3f,"Tag views with ImagePresenters in constructor

This should be safe since we're using tag with
an id and it eliminates one extra step required
to use ImagePresenters.","@@ -124,11 +124,9 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                             }
                         })
                         .build();
-
-                imageView.setTag(R.id.image_presenter_id, imagePresenter);
                 view = imageView;
             } else {
-                imagePresenter = (ImagePresenter<Photo>) view.getTag(R.id.image_presenter_id);
+                imagePresenter = ImagePresenter.getCurrent(view);
             }
 
             imagePresenter.setModel(current);
","129                 imagePresenter = ImagePresenter.getCurrent(view);
127 
128                 imageView.setTag(R.id.image_presenter_id, imagePresenter);
131                 imagePresenter = (ImagePresenter<Photo>) view.getTag(R.id.image_presenter_id);",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -26,10 +26,10 @@ import java.io.File;
 import java.net.URL;
 
 /**
- * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
- * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
- * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
- * starting point and example.
+ * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
+ * {@link ImageLoader} and {@link com.android.volley.RequestQueue}. This class provides most of the functionality of
+ * {@link ImagePresenter} with a simpler but less efficient interface. For more complicated cases it may be worth
+ * considering using {@link ImagePresenter} and {@link com.bumptech.glide.presenter.ImagePresenter.Builder} directly.
  *
  * <p>
  * Note - This class is not thread safe.
@@ -58,7 +58,7 @@ public class Glide {
      * @see #setRequestQueue(RequestQueue)
      * @see #isRequestQueueSet()
      *
-     * @param context
+     * @param context A context to use for Volley
      * @return The {@link RequestQueue}
      */
     public RequestQueue getRequestQueue(Context context) {
@@ -144,6 +144,12 @@ public class Glide {
      * Begins constructing a load for a given model.
      *
      * <p>
+     * Only certain models are supported by default. See
+     * {@link Glide.Request#with(com.bumptech.glide.loader.model.ModelLoader)} for models with default a
+     * {@link ModelLoader}.
+     * </p>
+     *
+     * <p>
      * Note - If an {@link ImageManager} has not yet been set via
      * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
@@ -224,9 +230,9 @@ public class Glide {
      *
      * @param <T> The type of model that will be loaded into the view
      */
+    @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
         private final T model;
-        private final ImageView imageView;
         private final Context context;
 
         private ImagePresenter<T> presenter;
@@ -236,7 +242,6 @@ public class Glide {
         @SuppressWarnings(""unchecked"")
         public Request(T model, ImageView imageView) {
             this.model = model;
-            this.imageView = imageView;
             this.context = imageView.getContext();
 
             presenter = ImagePresenter.getCurrent(imageView);
@@ -248,10 +253,28 @@ public class Glide {
         /**
          * Set the {@link ModelLoader} for the model.
          *
-         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
-         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
-         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
-         * defaults to {@link FileLoader}.
+         * <p>
+         *     Note - This method is required only if you are using a model for which there is no default
+         *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader} for
+         *     a model for which there is a default. The defaults are as follows:
+         * <ul>
+         *     <li>{@link String} - {@link StringLoader}. String must be a file path
+         *          (<code>/data/data/com.bumptech/glide/...</code>), a url (<code>http://www.google.com</code>), or a
+         *          uri. </li>
+         *     <li>{@link File} - {@link FileLoader}</li>
+         *     <li>{@link Integer} - {@link DrawableLoader}. Integer must be a resource id in your package</li>
+         *     <li>{@link Uri} - {@link UriLoader}. Uri must be a scheme handled by
+         *     {@link android.content.ContentResolver#openInputStream(android.net.Uri)}, http, or https</li>
+         * </ul>
+         * </p>
+         *
+         * <p>
+         *     Note - If you have the ability to fetch different sized images for a given model, you should supply a
+         *     {@link ModelLoader} here to do so. Fetching a smaller image means less bandwidth, battery, and memory
+         *     usage as well as faster image loads. To simply build a url to download an image using the width and
+         *     the height of the view, consider passing in a subclass of
+         *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
+         * </p>
          *
          * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
          * @return This Request
","29  * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
30  * {@link ImageLoader} and {@link com.android.volley.RequestQueue}. This class provides most of the functionality of
31  * {@link ImagePresenter} with a simpler but less efficient interface. For more complicated cases it may be worth
32  * considering using {@link ImagePresenter} and {@link com.bumptech.glide.presenter.ImagePresenter.Builder} directly.
61      * @param context A context to use for Volley
147      * Only certain models are supported by default. See
148      * {@link Glide.Request#with(com.bumptech.glide.loader.model.ModelLoader)} for models with default a
149      * {@link ModelLoader}.
150      * </p>
151      *
152      * <p>
233     @SuppressWarnings(""unused"") //public api
256          * <p>
257          *     Note - This method is required only if you are using a model for which there is no default
258          *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader} for
259          *     a model for which there is a default. The defaults are as follows:
260          * <ul>
261          *     <li>{@link String} - {@link StringLoader}. String must be a file path
262          *          (<code>/data/data/com.bumptech/glide/...</code>), a url (<code>http://www.google.com</code>), or a
263          *          uri. </li>
264          *     <li>{@link File} - {@link FileLoader}</li>
265          *     <li>{@link Integer} - {@link DrawableLoader}. Integer must be a resource id in your package</li>
266          *     <li>{@link Uri} - {@link UriLoader}. Uri must be a scheme handled by
267          *     {@link android.content.ContentResolver#openInputStream(android.net.Uri)}, http, or https</li>
268          * </ul>
269          * </p>
270          *
271          * <p>
272          *     Note - If you have the ability to fetch different sized images for a given model, you should supply a
273          *     {@link ModelLoader} here to do so. Fetching a smaller image means less bandwidth, battery, and memory
274          *     usage as well as faster image loads. To simply build a url to download an image using the width and
275          *     the height of the view, consider passing in a subclass of
276          *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
277          * </p>
29  * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%
30  * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable
31  * methods. For many users this should be enough to make effective use of the library. For others it can serve as a
32  * starting point and example.
61      * @param context
229         private final ImageView imageView;
239             this.imageView = imageView;
251          * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
252          * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
253          * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
254          * defaults to {@link FileLoader}.",No
library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -57,6 +57,7 @@ public abstract class BaseImageLoader implements ImageLoader {
      * @param id The unique id of the image
      * @return True iff this image loader has handled the exception and the cb should not be notified.
      */
+    @SuppressWarnings(""unused"")
     protected boolean onImageLoadFailed(Exception e, String id) {
         return false;
     }
","60     @SuppressWarnings(""unused"")",No
library\src\com\bumptech\glide\loader\model\DrawableLoader.java,library\src\com\bumptech\glide\loader\model\DrawableLoader.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -6,11 +6,8 @@ import com.bumptech.glide.loader.stream.LocalUriLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/25/13
- * Time: 11:07 PM
- * To change this template use File | Settings | File Templates.
+ * A model loader for handling resources. Model must be a resource id in the package of
+ * the given context.
  */
 public class DrawableLoader implements ModelLoader<Integer> {
     private final Context context;
","9  * A model loader for handling resources. Model must be a resource id in the package of
10  * the given context.
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 7/25/13
12  * Time: 11:07 PM
13  * To change this template use File | Settings | File Templates.",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -39,11 +39,13 @@ public class ImagePresenter<T> {
      * <p> {@link Builder ImagePresenter.Builder#setImageView(android.widget.ImageView) setImageView},
      * {@link Builder ImagePresenter.Builder#setPathLoader setPathLoader}, and
      * {@link Builder ImagePresenter.Builder#setImageLoader setIamgeLoader}
-     * are required. </p>
+     * are required.
+     * </p>
      *
      * @param <T> The type of the model that the presenter this builder will produce requires to load a path and an
      *           image from that path.
      */
+    @SuppressWarnings(""unused"")
     public static class Builder<T> {
         private ImageView imageView;
         private int placeholderResourceId;
@@ -198,7 +200,8 @@ public class ImagePresenter<T> {
         }
     }
 
-    private Object imageToken;
+    @SuppressWarnings(""all"")
+    private Object imageToken; //this is just a reference we may need to keep, otherwise unused
 
     private final ModelLoader<T> modelLoader;
     private final ImageLoader imageLoader;
@@ -331,13 +334,12 @@ public class ImagePresenter<T> {
 
             loadedFromCache = false;
 
-            if (!isImageSet()) {
+            if (!isImageSet) {
                 resetPlaceHolder();
             }
         }
     }
 
-
     /**
      * Sets the placeholder as the current image for the {@link android.widget.ImageView}. Does not cancel any previous
      * loads, so the placeholder could be replaced with a loaded bitmap at any time. To cancel a load and display a
","42      * are required.
43      * </p>
48     @SuppressWarnings(""unused"")
203     @SuppressWarnings(""all"")
204     private Object imageToken; //this is just a reference we may need to keep, otherwise unused
337             if (!isImageSet) {
42      * are required. </p>
201     private Object imageToken;
334             if (!isImageSet()) {
340 ",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.resize;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -107,16 +108,13 @@ public class ImageManager {
      * @param cacheName The name of the subdirectory in which to store the cache
      * @return A File representing the default disk cache directory
      */
+    @SuppressWarnings(""ResultOfMethodCallIgnored"")
     public static File getPhotoCacheDir(Context context, String cacheName) {
         File cacheDir = null;
 
-        Boolean isExternalStorageRemoveable = null;
-        if (Build.VERSION.SDK_INT >= 9) {
-            isExternalStorageRemoveable = Environment.isExternalStorageRemovable();
-        }
 
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
-                (isExternalStorageRemoveable != null && !isExternalStorageRemoveable)) {
+                !isExternalStorageRemovable()) {
             //seems like this can still be null even if the above are true
             cacheDir = context.getExternalCacheDir();
         }
@@ -129,12 +127,17 @@ public class ImageManager {
             File result = new File(cacheDir, cacheName);
             result.mkdirs();
             return result;
-        } else {
+        }
         Log.d(""IM: default disk cache dir is null"");
         return null;
     }
+
+    @TargetApi(9)
+    private static boolean isExternalStorageRemovable() {
+        return Build.VERSION.SDK_INT < 9 || Environment.isExternalStorageRemovable();
     }
 
+    @SuppressWarnings(""unused"")
     public static class Builder {
         private final Context context;
 
@@ -514,6 +517,7 @@ public class ImageManager {
     /**
      * Shuts down all of the background threads used by the ImageManager including the executor service
      */
+    @SuppressWarnings(""unused"")
     public void shutdown() {
         shutdown = true;
         executor.shutdown();
@@ -609,9 +613,11 @@ public class ImageManager {
                     streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
                         @Override
                         public void onStreamReady(final InputStream is) {
+                            if (cancelled) return;
                             future = executor.submit(new Runnable() {
                                 @Override
                                 public void run() {
+                                    if (cancelled) return;
                                     try {
                                         final Bitmap result = resizeIfNotFound(is);
                                         finishResize(result, false);
","7 import android.annotation.TargetApi;
111     @SuppressWarnings(""ResultOfMethodCallIgnored"")
117                 !isExternalStorageRemovable()) {
130         }
134 
135     @TargetApi(9)
136     private static boolean isExternalStorageRemovable() {
137         return Build.VERSION.SDK_INT < 9 || Environment.isExternalStorageRemovable();
140     @SuppressWarnings(""unused"")
520     @SuppressWarnings(""unused"")
616                             if (cancelled) return;
620                                     if (cancelled) return;
113         Boolean isExternalStorageRemoveable = null;
114         if (Build.VERSION.SDK_INT >= 9) {
115             isExternalStorageRemoveable = Environment.isExternalStorageRemovable();
116         }
119                 (isExternalStorageRemoveable != null && !isExternalStorageRemoveable)) {
132         } else {",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -3,6 +3,7 @@
  */
 package com.bumptech.glide.resize;
 
+import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Canvas;
@@ -20,7 +21,7 @@ import java.util.LinkedList;
 import java.util.Queue;
 
 /**
- * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
+ * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
  */
 public class ImageResizer {
     private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
@@ -31,6 +32,7 @@ public class ImageResizer {
 
     private final BitmapFactory.Options defaultOptions;
 
+    @TargetApi(11)
     public static BitmapFactory.Options getDefaultOptions() {
        BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
        decodeBitmapOptions.inDither = false;
@@ -46,14 +48,17 @@ public class ImageResizer {
     /**
      * Creates a new resizer that will not recycle Bitmaps
      */
+    @SuppressWarnings(""unused"")
     public ImageResizer() {
         this(null, null);
     }
 
+    @SuppressWarnings(""unused"")
     public ImageResizer(BitmapPool bitmapPool) {
         this(bitmapPool, null);
     }
 
+    @SuppressWarnings(""unused"")
     public ImageResizer(BitmapFactory.Options options) {
         this(null, options);
     }
@@ -144,6 +149,7 @@ public class ImageResizer {
      * @param height The maximum height
      * @return A bitmap containing the image
      */
+    @SuppressWarnings(""unused"")
     public Bitmap loadAtMost(InputStream is, int width, int height) {
         byte[] bytes = getTempBytes();
         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
@@ -258,9 +264,7 @@ public class ImageResizer {
 
     private BitmapFactory.Options getOptions(Bitmap recycle) {
         BitmapFactory.Options result = new BitmapFactory.Options();
-        copyOptions(defaultOptions, result);
-        if (CAN_RECYCLE)
-            result.inBitmap = recycle;
+        copyOptions(defaultOptions, result, recycle);
         return result;
     }
 
@@ -290,14 +294,33 @@ public class ImageResizer {
         }
     }
 
-    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
+    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
+        if (Build.VERSION.SDK_INT >= 11) {
+            copyOptionsHoneycomb(from, to, recycled);
+        } else if (Build.VERSION.SDK_INT >= 10) {
+            copyOptionsGingerbreadMr1(from, to);
+        } else {
+            copyOptionsFroyo(from, to);
+        }
+    }
+
+    @TargetApi(11)
+    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
+        copyOptionsGingerbreadMr1(from, to);
+        to.inMutable = from.inMutable;
+        to.inBitmap = recycled;
+    }
+
+    @TargetApi(10)
+    private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
+        copyOptionsFroyo(from, to);
+        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
+    }
+
+    private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
         to.inDensity = from.inDensity;
         to.inDither = from.inDither;
         to.inInputShareable = from.inInputShareable;
-        if (CAN_RECYCLE)
-            to.inMutable = from.inMutable;
-        if (Build.VERSION.SDK_INT >= 10)
-            to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
         to.inPreferredConfig = from.inPreferredConfig;
         to.inPurgeable = from.inPurgeable;
         to.inSampleSize = from.inSampleSize;
@@ -306,19 +329,6 @@ public class ImageResizer {
         to.inTargetDensity = from.inTargetDensity;
     }
 
-    /**
-     * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
-     * the original proportions of the image
-     *
-     * @param toCrop The Bitmap to crop
-     * @param width The width of the final Bitmap
-     * @param height The height of the final Bitmap
-     * @return The resized image
-     */
-    public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
-        return centerCrop(null, toCrop, width, height);
-    }
-
     /**
      * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
      * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
@@ -369,40 +379,6 @@ public class ImageResizer {
         return result;
     }
 
-    /**
-     * An expensive operation to crop the given Bitmap to the given width by removing equal amounts from either side
-     * so that the center of image remains
-     *
-     * @param toCrop The Bitmap to crop
-     * @param width The width to crop the Bitmap to
-     * @return A new Bitmap cropped to the given width, or toCrop if toCrop's width is equivalent to the given width
-     */
-    public static Bitmap cropToWidth(Bitmap toCrop, int width) {
-        Bitmap cropped = toCrop;
-        if (toCrop.getWidth() > width) {
-            int extraWidth = toCrop.getWidth() - width;
-            cropped = Bitmap.createBitmap(toCrop, extraWidth / 2, 0, width, toCrop.getHeight());
-        }
-        return cropped;
-    }
-
-    /**
-     * An expensive operation to crop the given Bitmap to the given height by removing equal amounts from the top and
-     * bottom so that the center of the image remains
-     *
-     * @param toCrop The Bitmap to crop
-     * @param height The height to crop the Bitmap to
-     * @return A new Bitmap cropped to the given height, or toCrop if toCrop's height is equivalent to the given height
-     */
-    public static Bitmap cropToHeight(Bitmap toCrop, int height){
-        Bitmap cropped = toCrop;
-        if (toCrop.getHeight() > height){
-            int extraHeight = toCrop.getHeight() - height;
-            cropped = Bitmap.createBitmap(toCrop, 0, extraHeight / 2, toCrop.getWidth(), height);
-        }
-        return cropped;
-    }
-
     /**
      * An expensive operation to resize the given image, maintaining the original proportions, so that its width
      * matches the given width
@@ -496,6 +472,7 @@ public class ImageResizer {
      * @param imageToOrient Image Bitmap to orient.
      * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
      */
+    @SuppressWarnings(""unused"")
     public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
         int degreesToRotate = getOrientation(pathToOriginal);
         return rotateImage(imageToOrient, degreesToRotate);
","6 import android.annotation.TargetApi;
24  * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
35     @TargetApi(11)
51     @SuppressWarnings(""unused"")
56     @SuppressWarnings(""unused"")
61     @SuppressWarnings(""unused"")
152     @SuppressWarnings(""unused"")
267         copyOptions(defaultOptions, result, recycle);
297     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
298         if (Build.VERSION.SDK_INT >= 11) {
299             copyOptionsHoneycomb(from, to, recycled);
300         } else if (Build.VERSION.SDK_INT >= 10) {
301             copyOptionsGingerbreadMr1(from, to);
302         } else {
303             copyOptionsFroyo(from, to);
304         }
305     }
306 
307     @TargetApi(11)
308     private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
309         copyOptionsGingerbreadMr1(from, to);
310         to.inMutable = from.inMutable;
311         to.inBitmap = recycled;
312     }
313 
314     @TargetApi(10)
315     private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
316         copyOptionsFroyo(from, to);
317         to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
318     }
319 
320     private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
475     @SuppressWarnings(""unused"")
23  * A class for synchronously resizing bitmaps with or without Bitmaps to recycle
261         copyOptions(defaultOptions, result);
262         if (CAN_RECYCLE)
263             result.inBitmap = recycle;
293     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
297         if (CAN_RECYCLE)
298             to.inMutable = from.inMutable;
299         if (Build.VERSION.SDK_INT >= 10)
300             to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
309     /**
310      * An expensive operation to crop the given Bitmap so that it fills the given dimensions. This will not maintain
311      * the original proportions of the image
312      *
313      * @param toCrop The Bitmap to crop
314      * @param width The width of the final Bitmap
315      * @param height The height of the final Bitmap
316      * @return The resized image
317      */
318     public static Bitmap centerCrop(Bitmap toCrop, int width, int height) {
319         return centerCrop(null, toCrop, width, height);
320     }
321 
372     /**
373      * An expensive operation to crop the given Bitmap to the given width by removing equal amounts from either side
374      * so that the center of image remains
375      *
376      * @param toCrop The Bitmap to crop
377      * @param width The width to crop the Bitmap to
378      * @return A new Bitmap cropped to the given width, or toCrop if toCrop's width is equivalent to the given width
379      */
380     public static Bitmap cropToWidth(Bitmap toCrop, int width) {
381         Bitmap cropped = toCrop;
382         if (toCrop.getWidth() > width) {
383             int extraWidth = toCrop.getWidth() - width;
384             cropped = Bitmap.createBitmap(toCrop, extraWidth / 2, 0, width, toCrop.getHeight());
385         }
386         return cropped;
387     }
388 
389     /**
390      * An expensive operation to crop the given Bitmap to the given height by removing equal amounts from the top and
391      * bottom so that the center of the image remains
392      *
393      * @param toCrop The Bitmap to crop
394      * @param height The height to crop the Bitmap to
395      * @return A new Bitmap cropped to the given height, or toCrop if toCrop's height is equivalent to the given height
396      */
397     public static Bitmap cropToHeight(Bitmap toCrop, int height){
398         Bitmap cropped = toCrop;
399         if (toCrop.getHeight() > height){
400             int extraHeight = toCrop.getHeight() - height;
401             cropped = Bitmap.createBitmap(toCrop, 0, extraHeight / 2, toCrop.getWidth(), height);
402         }
403         return cropped;
404     }
405 ",No
library\src\com\bumptech\glide\resize\LoadedCallback.java,library\src\com\bumptech\glide\resize\LoadedCallback.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -7,11 +7,7 @@ package com.bumptech.glide.resize;
 import android.graphics.Bitmap;
 
 /**
- * Created by IntelliJ IDEA.
- * User: sam
- * Date: 2/9/12
- * Time: 7:04 PM
- * To change this template use File | Settings | File Templates.
+ * An interface to handle loads completing successfully or failing
  */
 public interface LoadedCallback {
     public void onLoadCompleted(Bitmap loaded);
","10  * An interface to handle loads completing successfully or failing
10  * Created by IntelliJ IDEA.
11  * User: sam
12  * Date: 2/9/12
13  * Time: 7:04 PM
14  * To change this template use File | Settings | File Templates.",No
library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPool.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,15 +2,7 @@ package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 2:52 PM
- * To change this template use File | Settings | File Templates.
- */
 public interface BitmapPool {
     public boolean put(Bitmap bitmap);
     public Bitmap get(int width, int height);
-
 }
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 2:52 PM
10  * To change this template use File | Settings | File Templates.
11  */
15 ",No
library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPoolAdapter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapPoolAdapter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,13 +2,6 @@ package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 2:58 PM
- * To change this template use File | Settings | File Templates.
- */
 public class BitmapPoolAdapter implements BitmapPool {
     @Override
     public boolean put(Bitmap bitmap) {
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 2:58 PM
10  * To change this template use File | Settings | File Templates.
11  */",No
library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,13 +2,6 @@ package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 12:39 PM
- * To change this template use File | Settings | File Templates.
- */
 public interface BitmapReferenceCounter {
 
     public void initBitmap(Bitmap bitmap);
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 12:39 PM
10  * To change this template use File | Settings | File Templates.
11  */",No
library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounterAdapter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\BitmapReferenceCounterAdapter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,13 +2,6 @@ package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 3:22 PM
- * To change this template use File | Settings | File Templates.
- */
 public class BitmapReferenceCounterAdapter implements BitmapReferenceCounter {
     @Override
     public void initBitmap(Bitmap bitmap) { }
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 3:22 PM
10  * To change this template use File | Settings | File Templates.
11  */",No
library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapPool.java,,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.bitmap_recycle;
-
-import android.graphics.Bitmap;
-
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * A cache of Bitmaps made available by size used to manage recycled bitmaps
- */
-public class ConcurrentBitmapPool implements BitmapPool {
-    private static final int DEFAULT_MAX_PER_SIZE = 20;
-    private ConcurrentHashMap<Integer, Queue<Bitmap>> availableBitmaps = new ConcurrentHashMap<Integer, Queue<Bitmap>>();
-    private final int maxPerSize;
-
-    public ConcurrentBitmapPool(int maxPerSize) {
-        this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
-    }
-
-    @Override
-    public boolean put(Bitmap bitmap) {
-        final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
-        Queue<Bitmap> available = availableBitmaps.get(sizeKey);
-        if (available == null) {
-            synchronized (this) {
-                available = availableBitmaps.get(sizeKey);
-                if (available == null) {
-                    available = new LinkedList<Bitmap>();
-                    availableBitmaps.put(sizeKey, available);
-                }
-            }
-        }
-
-        final boolean result;
-        synchronized (available) {
-            result = available.size() < maxPerSize;
-            if (result) {
-                available.offer(bitmap);
-            }
-        }
-
-        return result;
-    }
-
-    @Override
-    public Bitmap get(int width, int height) {
-        final int sizeKey = getSizeKey(width, height);
-        final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
-        Bitmap result = null;
-        if (available != null) {
-            synchronized (available) {
-                result = available.poll();
-            }
-        }
-        return result;
-    }
-
-    //see http://szudzik.com/ElegantPairing.pdf
-    //assumes width <= Short.MAX_VALUE && height <= SHORT.MAX_VALUE && width >= 0 && height >= 0
-    private static int getSizeKey(int width, int height) {
-        return width >= height ? width * width + width + height : width + height * height;
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.bitmap_recycle;
6 
7 import android.graphics.Bitmap;
8 
9 import java.util.LinkedList;
10 import java.util.Queue;
11 import java.util.concurrent.ConcurrentHashMap;
12 
13 /**
14  * A cache of Bitmaps made available by size used to manage recycled bitmaps
15  */
16 public class ConcurrentBitmapPool implements BitmapPool {
17     private static final int DEFAULT_MAX_PER_SIZE = 20;
18     private ConcurrentHashMap<Integer, Queue<Bitmap>> availableBitmaps = new ConcurrentHashMap<Integer, Queue<Bitmap>>();
19     private final int maxPerSize;
20 
21     public ConcurrentBitmapPool(int maxPerSize) {
22         this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;
23     }
24 
25     @Override
26     public boolean put(Bitmap bitmap) {
27         final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());
28         Queue<Bitmap> available = availableBitmaps.get(sizeKey);
29         if (available == null) {
30             synchronized (this) {
31                 available = availableBitmaps.get(sizeKey);
32                 if (available == null) {
33                     available = new LinkedList<Bitmap>();
34                     availableBitmaps.put(sizeKey, available);
35                 }
36             }
37         }
38 
39         final boolean result;
40         synchronized (available) {
41             result = available.size() < maxPerSize;
42             if (result) {
43                 available.offer(bitmap);
44             }
45         }
46 
47         return result;
48     }
49 
50     @Override
51     public Bitmap get(int width, int height) {
52         final int sizeKey = getSizeKey(width, height);
53         final Queue<Bitmap> available = availableBitmaps.get(sizeKey);
54         Bitmap result = null;
55         if (available != null) {
56             synchronized (available) {
57                 result = available.poll();
58             }
59         }
60         return result;
61     }
62 
63     //see http://szudzik.com/ElegantPairing.pdf
64     //assumes width <= Short.MAX_VALUE && height <= SHORT.MAX_VALUE && width >= 0 && height >= 0
65     private static int getSizeKey(int width, int height) {
66         return width >= height ? width * width + width + height : width + height * height;
67     }
68 }",No
library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -5,13 +5,6 @@ import android.graphics.Bitmap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/4/13
- * Time: 9:54 AM
- * To change this template use File | Settings | File Templates.
- */
 public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter {
 
     private static class InnerTrackerPool {
","8 /**
9  * Created with IntelliJ IDEA.
10  * User: sam
11  * Date: 6/4/13
12  * Time: 9:54 AM
13  * To change this template use File | Settings | File Templates.
14  */",No
library\src\com\bumptech\glide\resize\bitmap_recycle\LruBitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\LruBitmapPool.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -1,23 +1,15 @@
 package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
+import android.util.SparseArray;
 import com.bumptech.glide.util.Log;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/10/13
- * Time: 1:47 PM
- * To change this template use File | Settings | File Templates.
- */
+
 public class LruBitmapPool implements BitmapPool {
-    private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();
+    private final SparseArray<ArrayList<Bitmap>> pool = new SparseArray<ArrayList<Bitmap>>();
     //Typically there should only be a handful of keys (often 1 or 2) so
     //iterating over this list should be fast
     private final LinkedList<Integer> keys = new LinkedList<Integer>();
@@ -85,8 +77,8 @@ public class LruBitmapPool implements BitmapPool {
     }
 
     //keys.remove(int) -> remove index int, not object int :(
-    private void removeKey(int key) {
-        keys.remove(new Integer(key));
+    private void removeKey(Integer key) {
+        keys.remove(key);
     }
 
     private int getKey(Bitmap bitmap) {
","4 import android.util.SparseArray;
12     private final SparseArray<ArrayList<Bitmap>> pool = new SparseArray<ArrayList<Bitmap>>();
80     private void removeKey(Integer key) {
81         keys.remove(key);
7 import java.util.HashMap;
10 import java.util.Map;
12 /**
13  * Created with IntelliJ IDEA.
14  * User: sam
15  * Date: 7/10/13
16  * Time: 1:47 PM
17  * To change this template use File | Settings | File Templates.
18  */
20     private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();
88     private void removeKey(int key) {
89         keys.remove(new Integer(key));",No
library\src\com\bumptech\glide\resize\cache\DiskCache.java,library\src\com\bumptech\glide\resize\cache\DiskCache.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -4,18 +4,38 @@ import java.io.InputStream;
 import java.io.OutputStream;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 10:21 AM
- * To change this template use File | Settings | File Templates.
+ * An interface for writing to and reading from a disk cache
  */
 public interface DiskCache {
+    /**
+     * An interface to actually write data to a key in
+     * the disk cache
+     */
     public interface Writer {
         public void write(OutputStream os);
     }
 
+    /**
+     * Get an InputStream for the value at the given key.
+     *
+     * @param key The key in the cache
+     * @return An InputStream representing the data at key at the time get is called
+     */
     public InputStream get(String key);
+
+    /**
+     * Write to a key in the cache. {@link Writer} is used so that the cache implementation
+     * can perform actions after the write finishes, like commit (via atomic file rename).
+     *
+     * @param key The key to write to
+     * @param writer An interface that will write data given an OutputStream for the key
+     */
     public void put(String key, Writer writer);
+
+    /**
+     * Remove the key and value from the cache
+     *
+     * @param key The key to remove
+     */
     public void delete(String key);
 }
","7  * An interface for writing to and reading from a disk cache
10     /**
11      * An interface to actually write data to a key in
12      * the disk cache
13      */
18     /**
19      * Get an InputStream for the value at the given key.
20      *
21      * @param key The key in the cache
22      * @return An InputStream representing the data at key at the time get is called
23      */
25 
26     /**
27      * Write to a key in the cache. {@link Writer} is used so that the cache implementation
28      * can perform actions after the write finishes, like commit (via atomic file rename).
29      *
30      * @param key The key to write to
31      * @param writer An interface that will write data given an OutputStream for the key
32      */
34 
35     /**
36      * Remove the key and value from the cache
37      *
38      * @param key The key to remove
39      */
7  * Created with IntelliJ IDEA.
8  * User: sam
9  * Date: 6/5/13
10  * Time: 10:21 AM
11  * To change this template use File | Settings | File Templates.",No
library\src\com\bumptech\glide\resize\cache\DiskCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\DiskCacheAdapter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,13 +2,6 @@ package com.bumptech.glide.resize.cache;
 
 import java.io.InputStream;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 10:24 AM
- * To change this template use File | Settings | File Templates.
- */
 public class DiskCacheAdapter implements DiskCache {
     @Override
     public InputStream get(String key) {
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 10:24 AM
10  * To change this template use File | Settings | File Templates.
11  */",No
library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,library\src\com\bumptech\glide\resize\cache\DiskLruCacheWrapper.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -11,11 +11,10 @@ import java.io.IOException;
 import java.io.InputStream;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 7/5/13
- * Time: 10:57 AM
- * To change this template use File | Settings | File Templates.
+ * The default DiskCache implementation. There must be no more than one active instance for a given
+ * directory at a time.
+ *
+ * @see #get(java.io.File, int)
  */
 public class DiskLruCacheWrapper implements DiskCache {
 
@@ -29,6 +28,16 @@ public class DiskLruCacheWrapper implements DiskCache {
         return CACHE;
     }
 
+    /**
+     * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
+     * a different directory and/or size, it will be returned instead and the new arguments
+     * will be ignored.
+     *
+     * @param directory The directory for the disk cache
+     * @param maxSize The max size for the disk cache
+     * @return The new disk cache with the given arguments, or the current cache if one already exists
+     * @throws IOException
+     */
     public synchronized static DiskCache get(File directory, int maxSize) throws IOException {
         if (WRAPPER == null) {
             WRAPPER = new DiskLruCacheWrapper(getDiskLruCache(directory, maxSize));
","14  * The default DiskCache implementation. There must be no more than one active instance for a given
15  * directory at a time.
16  *
17  * @see #get(java.io.File, int)
31     /**
32      * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
33      * a different directory and/or size, it will be returned instead and the new arguments
34      * will be ignored.
35      *
36      * @param directory The directory for the disk cache
37      * @param maxSize The max size for the disk cache
38      * @return The new disk cache with the given arguments, or the current cache if one already exists
39      * @throws IOException
40      */
14  * Created with IntelliJ IDEA.
15  * User: sam
16  * Date: 7/5/13
17  * Time: 10:57 AM
18  * To change this template use File | Settings | File Templates.",No
library\src\com\bumptech\glide\resize\cache\MemoryCache.java,library\src\com\bumptech\glide\resize\cache\MemoryCache.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -3,18 +3,28 @@ package com.bumptech.glide.resize.cache;
 import android.graphics.Bitmap;
 
 /**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 11:29 AM
- * To change this template use File | Settings | File Templates.
+ * An interface for adding and removing from an in memory cache
  */
 public interface MemoryCache {
+    /**
+     * An interface that will be called whenever a bitmap is removed from the cache.
+     */
     public interface ImageRemovedListener {
         public void onImageRemoved(Bitmap removed);
     }
 
+    /**
+     * Tell if cache contains key
+     * @param key The key
+     * @return true iff the key has a non null value in the cache
+     */
     public boolean contains(Integer key);
+
+    /**
+     * Get a value from the cache
+     * @param key The key
+     * @return The bitmap at key or null if the key is not present
+     */
     public Bitmap get(Integer key);
 
     /**
@@ -24,5 +34,10 @@ public interface MemoryCache {
      * @return The old value of key (null if key is not in map)
      */
     public Bitmap put(Integer key, Bitmap bitmap);
+
+    /**
+     * Set the listener to be called when a bitmap is removed from the cache
+     * @param listener The listener
+     */
     public void setImageRemovedListener(ImageRemovedListener listener);
 }
","6  * An interface for adding and removing from an in memory cache
9     /**
10      * An interface that will be called whenever a bitmap is removed from the cache.
11      */
16     /**
17      * Tell if cache contains key
18      * @param key The key
19      * @return true iff the key has a non null value in the cache
20      */
22 
23     /**
24      * Get a value from the cache
25      * @param key The key
26      * @return The bitmap at key or null if the key is not present
27      */
37 
38     /**
39      * Set the listener to be called when a bitmap is removed from the cache
40      * @param listener The listener
41      */
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 11:29 AM
10  * To change this template use File | Settings | File Templates.",No
library\src\com\bumptech\glide\resize\cache\MemoryCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\MemoryCacheAdapter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -2,13 +2,6 @@ package com.bumptech.glide.resize.cache;
 
 import android.graphics.Bitmap;
 
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 6/5/13
- * Time: 11:31 AM
- * To change this template use File | Settings | File Templates.
- */
 public class MemoryCacheAdapter implements MemoryCache {
     @Override
     public boolean contains(Integer key) {
","5 /**
6  * Created with IntelliJ IDEA.
7  * User: sam
8  * Date: 6/5/13
9  * Time: 11:31 AM
10  * To change this template use File | Settings | File Templates.
11  */",No
library\src\com\bumptech\glide\resize\loader\Approximate.java,library\src\com\bumptech\glide\resize\loader\Approximate.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -10,12 +10,17 @@ import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
- * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
- * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
- * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy
+ * Load an image at roughly the width and height of the view that will display it, maintaining its original aspect ratio
+ *
+ * <p>
+ * Should be used when the image is larger than the view that will display it and you don't want to alter the original
+ * aspect ratio. Can save a substantial amount of memory depending on the size discrepancy between the view and the
+ * image.
+ * </p>
  *
  * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
+@SuppressWarnings(""unused"")
 public class Approximate extends ImageManagerLoader {
 
     public Approximate(ImageManager imageManager) {
","13  * Load an image at roughly the width and height of the view that will display it, maintaining its original aspect ratio
14  *
15  * <p>
16  * Should be used when the image is larger than the view that will display it and you don't want to alter the original
17  * aspect ratio. Can save a substantial amount of memory depending on the size discrepancy between the view and the
18  * image.
19  * </p>
23 @SuppressWarnings(""unused"")
13  * An ImageLoader implementation that loads an image to roughly the width and height of the view that will display it.
14  * Should be used when the image is larger than the view that will display it but the expense of cropping or resizing
15  * the image more precisely is not worth it. Can save a substantial amount of memory depending on the size discrepancy",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -6,13 +6,16 @@ import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
- * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
- * when an image is roughly the same size as the view that will display it and you want to use some external process
- * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
- * other implementations
+ * Load an image at its original dimensions.
+ *
+ * <p> Should be used when an image is exactly the same size as the view that will display it
+ * or you want to use some external process (like the view) to do the resizing for you. This class is usually less
+ * efficient than other implementations if the image is not exactly the size of the view
+ * </p>
  *
  * @see ImageManager#getImage(String, com.bumptech.glide.loader.stream.StreamLoader, com.bumptech.glide.resize.LoadedCallback)
  */
+@SuppressWarnings(""unused"")
 public class AsIs extends ImageManagerLoader {
 
     public AsIs(ImageManager imageManager) {
","9  * Load an image at its original dimensions.
10  *
11  * <p> Should be used when an image is exactly the same size as the view that will display it
12  * or you want to use some external process (like the view) to do the resizing for you. This class is usually less
13  * efficient than other implementations if the image is not exactly the size of the view
14  * </p>
18 @SuppressWarnings(""unused"")
9  * An ImageLoader implementation that loads an image at the given path at its original dimensions. Should be used
10  * when an image is roughly the same size as the view that will display it and you want to use some external process
11  * (like the view) to do the resizing for you. Not memory efficient and more expensive to use recycled Bitmaps for than
12  * other implementations",No
library\src\com\bumptech\glide\resize\loader\CenterCrop.java,library\src\com\bumptech\glide\resize\loader\CenterCrop.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -10,10 +10,11 @@ import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
- * An ImageLoader implementation that loads and crops in image down to the given width and height.
+ * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
  *
  * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
+@SuppressWarnings(""unused"")
 public class CenterCrop extends ImageManagerLoader {
 
     public CenterCrop(ImageManager imageManager) {
","13  * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
17 @SuppressWarnings(""unused"")
13  * An ImageLoader implementation that loads and crops in image down to the given width and height.",No
library\src\com\bumptech\glide\resize\loader\Exact.java,library\src\com\bumptech\glide\resize\loader\Exact.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -10,13 +10,16 @@ import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
- * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
- * will exactly match the width and height of the view that will display it. Less expensive than other implementations,
- * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
- * resize).
+ * Load an image at its original dimensions.
+ *
+ * <p>
+ *     This class is almost identical to {@link AsIs} except that it assumes the image size is identical to the given
+ *     dimensions. This assumption means we don't first need to read the image header to obtain the dimensions.
+ * </p>
  *
  * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
+@SuppressWarnings(""unused"")
 public class Exact extends ImageManagerLoader {
 
     public Exact(ImageManager imageManager) {
","13  * Load an image at its original dimensions.
14  *
15  * <p>
16  *     This class is almost identical to {@link AsIs} except that it assumes the image size is identical to the given
17  *     dimensions. This assumption means we don't first need to read the image header to obtain the dimensions.
18  * </p>
22 @SuppressWarnings(""unused"")
13  * An ImageLoader implementation that loads an image at the given path and expects that the image at that path
14  * will exactly match the width and height of the view that will display it. Less expensive than other implementations,
15  * but requires some other process to make sure the image on disk matches the given dimension (for example a server side
16  * resize).",No
library\src\com\bumptech\glide\resize\loader\FitCenter.java,library\src\com\bumptech\glide\resize\loader\FitCenter.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -10,11 +10,12 @@ import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
 
 /**
- * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
- * proportions
+ * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
+ * of the image is smaller than or equal to the other given dimension.
  *
  * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
  */
+@SuppressWarnings(""Unused"")
 public class FitCenter extends ImageManagerLoader {
 
     public FitCenter(ImageManager imageManager) {
","13  * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
14  * of the image is smaller than or equal to the other given dimension.
18 @SuppressWarnings(""Unused"")
13  * An ImageLoader implementation that loads an image into within the given dimensions maintaining the original
14  * proportions",No
library\src\com\bumptech\glide\util\Log.java,library\src\com\bumptech\glide\util\Log.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -1,18 +1,15 @@
 package com.bumptech.glide.util;
 
+import android.annotation.SuppressLint;
+
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-/**
- * Created by IntelliJ IDEA.
- * User: sam
- * Date: 10/11/12
- * Time: 10:11 AM
- * To change this template use File | Settings | File Templates.
- */
 public class Log {
     private static final String TAG = ""BUMP_PHOTOS"";
+
+    @SuppressLint(""SimpleDateFormat"")
     private static final DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
 
     public static void e(String message, Object... args) {
","3 import android.annotation.SuppressLint;
4 
11 
12     @SuppressLint(""SimpleDateFormat"")
7 /**
8  * Created by IntelliJ IDEA.
9  * User: sam
10  * Date: 10/11/12
11  * Time: 10:11 AM
12  * To change this template use File | Settings | File Templates.
13  */",No
library\src\com\bumptech\glide\util\Util.java,library\src\com\bumptech\glide\util\Util.java,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"@@ -1,16 +1,5 @@
 package com.bumptech.glide.util;
 
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-/**
- * Created with IntelliJ IDEA.
- * User: sam
- * Date: 1/20/13
- * Time: 9:43 PM
- * To change this template use File | Settings | File Templates.
- */
 public class Util {
     private static final int PRIME = 31;
 
@@ -21,17 +10,4 @@ public class Util {
         }
         return result;
     }
-
-    public static String sha1Hash(String toHash) {
-        String hash = null;
-        try {
-            byte[] bytes = toHash.getBytes();
-            MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
-            digest.update(bytes, 0, bytes.length);
-            hash = new BigInteger(1, digest.digest()).toString(16);
-        } catch (NoSuchAlgorithmException e) {
-            e.printStackTrace();
-        }
-        return hash;
-    }
 }
","3 import java.math.BigInteger;
4 import java.security.MessageDigest;
5 import java.security.NoSuchAlgorithmException;
6 
7 /**
8  * Created with IntelliJ IDEA.
9  * User: sam
10  * Date: 1/20/13
11  * Time: 9:43 PM
12  * To change this template use File | Settings | File Templates.
13  */
24 
25     public static String sha1Hash(String toHash) {
26         String hash = null;
27         try {
28             byte[] bytes = toHash.getBytes();
29             MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
30             digest.update(bytes, 0, bytes.length);
31             hash = new BigInteger(1, digest.digest()).toString(16);
32         } catch (NoSuchAlgorithmException e) {
33             e.printStackTrace();
34         }
35         return hash;
36     }",No
samples\flickr\res\raw\ic_launcher.png,samples\flickr\res\raw\ic_launcher.png,d66ef49022858664841d3d60d0d531bdd13bd882,612bb49c9045a723e2da145ef3647707b731b6c6,Comment updates and fixes for various warnings,"Binary files /dev/null and b/samples/flickr/res/raw/ic_launcher.png differ
",,No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,5 +1,6 @@
 package com.bumptech.glide.loader.model;
 
+import android.content.Context;
 import android.net.Uri;
 import com.bumptech.glide.loader.stream.StreamLoader;
 
@@ -13,6 +14,15 @@ public class StringLoader extends BaseModelLoader<String> {
 
     private final ModelLoader<Uri> uriLoader;
 
+    /**
+     * A convenience constructor that defaults to {@link UriLoader} for loading uri strings
+     *
+     * @param context A context
+     */
+    public StringLoader(Context context) {
+        this(new UriLoader(context));
+    }
+
     public StringLoader(ModelLoader<Uri> uriLoader) {
         this.uriLoader = uriLoader;
     }
","3 import android.content.Context;
17     /**
18      * A convenience constructor that defaults to {@link UriLoader} for loading uri strings
19      *
20      * @param context A context
21      */
22     public StringLoader(Context context) {
23         this(new UriLoader(context));
24     }
25 ",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -17,6 +17,15 @@ public class UriLoader extends BaseModelLoader<Uri> {
     private final Context context;
     private final ModelLoader<URL> urlLoader;
 
+    /**
+     * A convenience constructor that defaults to {@link UrlLoader} for loading URLs
+     *
+     * @param context A context
+     */
+    public UriLoader(Context context) {
+        this(context, new UrlLoader(context));
+    }
+
     public UriLoader(Context context, ModelLoader<URL> urlLoader) {
         this.context = context;
         this.urlLoader = urlLoader;
","20     /**
21      * A convenience constructor that defaults to {@link UrlLoader} for loading URLs
22      *
23      * @param context A context
24      */
25     public UriLoader(Context context) {
26         this(context, new UrlLoader(context));
27     }
28 ",No
library\src\com\bumptech\glide\loader\model\UrlLoader.java,library\src\com\bumptech\glide\loader\model\UrlLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,24 +1,27 @@
 package com.bumptech.glide.loader.model;
 
+import android.content.Context;
 import com.android.volley.RequestQueue;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.loader.stream.VolleyStreamLoader;
 
 import java.net.URL;
 
 /**
  * A simple model loader for urls
  */
-public class UrlLoader implements ModelLoader<URL> {
-    private final RequestQueue requestQueue;
+public class UrlLoader extends VolleyModelLoader<URL> {
 
+    public UrlLoader(Context context) {
+        super(context);
+    }
+
+    @SuppressWarnings(""unused"")
     public UrlLoader(RequestQueue requestQueue) {
-        this.requestQueue = requestQueue;
+        super(requestQueue);
     }
 
     @Override
-    public StreamLoader getStreamLoader(URL model, int width, int height) {
-        return new VolleyStreamLoader(requestQueue, model.toString());
+    protected String getUrl(URL model, int width, int height) {
+        return model.toString();
     }
 
     //this may need to be overridden if multiple urls can be used to retrieve the same image
@@ -26,7 +29,4 @@ public class UrlLoader implements ModelLoader<URL> {
     public String getId(URL model) {
         return model.toString();
     }
-
-    @Override
-    public void clear() { }
 }
","3 import android.content.Context;
11 public class UrlLoader extends VolleyModelLoader<URL> {
13     public UrlLoader(Context context) {
14         super(context);
15     }
16 
17     @SuppressWarnings(""unused"")
19         super(requestQueue);
23     protected String getUrl(URL model, int width, int height) {
24         return model.toString();
4 import com.bumptech.glide.loader.stream.StreamLoader;
5 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
12 public class UrlLoader implements ModelLoader<URL> {
13     private final RequestQueue requestQueue;
16         this.requestQueue = requestQueue;
20     public StreamLoader getStreamLoader(URL model, int width, int height) {
21         return new VolleyStreamLoader(requestQueue, model.toString());
29 
30     @Override
31     public void clear() { }",No
library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,6 +1,8 @@
 package com.bumptech.glide.loader.model;
 
+import android.content.Context;
 import com.android.volley.RequestQueue;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
 
@@ -11,6 +13,16 @@ import com.bumptech.glide.loader.stream.VolleyStreamLoader;
 public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
     private final RequestQueue requestQueue;
 
+    /**
+     * A convenience constructor relying on the {@link Glide} singleton and it's {@link RequestQueue} via
+     * {@link Glide#getRequestQueue(android.content.Context)}}
+     *
+     * @param context A context
+     */
+    public VolleyModelLoader(Context context) {
+        this(Glide.get().getRequestQueue(context));
+    }
+
     public VolleyModelLoader(RequestQueue requestQueue) {
         this.requestQueue = requestQueue;
     }
","3 import android.content.Context;
5 import com.bumptech.glide.Glide;
16     /**
17      * A convenience constructor relying on the {@link Glide} singleton and it's {@link RequestQueue} via
18      * {@link Glide#getRequestQueue(android.content.Context)}}
19      *
20      * @param context A context
21      */
22     public VolleyModelLoader(Context context) {
23         this(Glide.get().getRequestQueue(context));
24     }
25 ",No
library\src\com\bumptech\glide\resize\loader\Approximate.java,library\src\com\bumptech\glide\resize\loader\Approximate.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
@@ -23,6 +24,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 @SuppressWarnings(""unused"")
 public class Approximate extends ImageManagerLoader {
 
+    public Approximate(Context context) {
+        super(context);
+    }
+
     public Approximate(ImageManager imageManager) {
         super(imageManager);
     }
","7 import android.content.Context;
27     public Approximate(Context context) {
28         super(context);
29     }
30 ",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,5 +1,6 @@
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
@@ -18,6 +19,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 @SuppressWarnings(""unused"")
 public class AsIs extends ImageManagerLoader {
 
+    public AsIs(Context context) {
+        super(context);
+    }
+
     public AsIs(ImageManager imageManager) {
         super(imageManager);
     }
","3 import android.content.Context;
22     public AsIs(Context context) {
23         super(context);
24     }
25 ",No
library\src\com\bumptech\glide\resize\loader\CenterCrop.java,library\src\com\bumptech\glide\resize\loader\CenterCrop.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
@@ -17,6 +18,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 @SuppressWarnings(""unused"")
 public class CenterCrop extends ImageManagerLoader {
 
+    public CenterCrop(Context context) {
+        super(context);
+    }
+
     public CenterCrop(ImageManager imageManager) {
         super(imageManager);
     }
","7 import android.content.Context;
21     public CenterCrop(Context context) {
22         super(context);
23     }
24 ",No
library\src\com\bumptech\glide\resize\loader\Exact.java,library\src\com\bumptech\glide\resize\loader\Exact.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
@@ -22,6 +23,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 @SuppressWarnings(""unused"")
 public class Exact extends ImageManagerLoader {
 
+    public Exact(Context context) {
+        super(context);
+    }
+
     public Exact(ImageManager imageManager) {
         super(imageManager);
     }
","7 import android.content.Context;
26     public Exact(Context context) {
27         super(context);
28     }
29 ",No
library\src\com\bumptech\glide\resize\loader\FitCenter.java,library\src\com\bumptech\glide\resize\loader\FitCenter.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
@@ -18,6 +19,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 @SuppressWarnings(""Unused"")
 public class FitCenter extends ImageManagerLoader {
 
+    public FitCenter(Context context) {
+        super(context);
+    }
+
     public FitCenter(ImageManager imageManager) {
         super(imageManager);
     }
","7 import android.content.Context;
22     public FitCenter(Context context) {
23         super(context);
24     }
25 ",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,8 +1,10 @@
 package com.bumptech.glide.resize.loader;
 
+import android.content.Context;
 import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.loader.image.BaseImageLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 
 /**
@@ -15,6 +17,10 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
     private Bitmap acquired;
     private Object loadToken;
 
+    public ImageManagerLoader(Context context) {
+        this(Glide.get().getImageManager(context));
+    }
+
     public ImageManagerLoader(ImageManager imageManager) {
         this.imageManager = imageManager;
     }
","3 import android.content.Context;
5 import com.bumptech.glide.Glide;
7 import com.bumptech.glide.loader.stream.StreamLoader;
20     public ImageManagerLoader(Context context) {
21         this(Glide.get().getImageManager(context));
22     }
23 
4 import com.bumptech.glide.loader.stream.StreamLoader;",No
samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,6 +1,6 @@
 package com.bumptech.flickr;
 
-import com.android.volley.RequestQueue;
+import android.content.Context;
 import com.bumptech.flickr.api.Api;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.loader.model.VolleyModelLoader;
@@ -11,8 +11,9 @@ import com.bumptech.glide.loader.model.VolleyModelLoader;
  * directly to the disk cache.
  */
 public class FlickrModelLoader extends VolleyModelLoader<Photo> {
-    public FlickrModelLoader(RequestQueue requestQueue) {
-        super(requestQueue);
+
+    public FlickrModelLoader(Context context) {
+        super(context);
     }
 
     @Override
","3 import android.content.Context;
14 
15     public FlickrModelLoader(Context context) {
16         super(context);
3 import com.android.volley.RequestQueue;
14     public FlickrModelLoader(RequestQueue requestQueue) {
15         super(requestQueue);",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -1,5 +1,6 @@
 package com.bumptech.flickr;
 
+import android.content.Context;
 import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -11,7 +12,6 @@ import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Photo;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageSetCallback;
 import com.bumptech.glide.resize.loader.CenterCrop;
@@ -108,11 +108,12 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 params.width = photoSize;
                 params.height = photoSize;
 
-                final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
+                final Context context = getActivity();
+                final Animation fadeIn = AnimationUtils.loadAnimation(context, R.anim.fade_in);
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
-                        .setModelLoader(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
-                        .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))
+                        .setModelLoader(new FlickrModelLoader(context))
+                        .setImageLoader(new CenterCrop(context))
                         .setImageSetCallback(new ImageSetCallback() {
                             @Override
                             public void onImageSet(ImageView view, boolean fromCache) {
","3 import android.content.Context;
111                 final Context context = getActivity();
112                 final Animation fadeIn = AnimationUtils.loadAnimation(context, R.anim.fade_in);
115                         .setModelLoader(new FlickrModelLoader(context))
116                         .setImageLoader(new CenterCrop(context))
14 import com.bumptech.glide.Glide;
111                 final Animation fadeIn = AnimationUtils.loadAnimation(getActivity(), R.anim.fade_in);
114                         .setModelLoader(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
115                         .setImageLoader(new CenterCrop(Glide.get().getImageManager(getActivity())))",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,8dcf3324d59efb354331f18089674fe1bcc3d4aa,d66ef49022858664841d3d60d0d531bdd13bd882,Add defaults for loaders using Glide singleton,"@@ -102,7 +102,7 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
 
             Glide.load(current)
                     .into(viewHolder.imageView)
-                    .with(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))
+                    .with(new FlickrModelLoader(getActivity()))
                     .centerCrop()
                     .animate(R.anim.fade_in)
                     .begin();
","105                     .with(new FlickrModelLoader(getActivity()))
105                     .with(new FlickrModelLoader(Glide.get().getRequestQueue(getActivity())))",No
library\res\values\ids.xml,library\res\values\ids.xml,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,8dcf3324d59efb354331f18089674fe1bcc3d4aa,"Cleaner and more efficient Glide api

Reduces the # of extraneous object allocations by
lazily creating objects only if a new presenter is
needed. Adds some metadata to view tags to
determine whether or not options for a view are
the same, so an existing presenter can be used
or have changed, so a new presenter has to be
created","@@ -1,4 +1,5 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <resources>
   <item type=""id"" name=""image_presenter_id"" />
+  <item type=""id"" name=""glide_metadata"" />
 </resources>
\ No newline at end of file
","4   <item type=""id"" name=""glide_metadata"" />",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,8dcf3324d59efb354331f18089674fe1bcc3d4aa,"Cleaner and more efficient Glide api

Reduces the # of extraneous object allocations by
lazily creating objects only if a new presenter is
needed. Adds some metadata to view tags to
determine whether or not options for a view are
the same, so an existing presenter can be used
or have changed, so a new presenter has to be
created","@@ -1,7 +1,6 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
@@ -37,7 +36,6 @@ import java.net.URL;
  */
 public class Glide {
     private static final Glide GLIDE = new Glide();
-
     private ImageManager imageManager = null;
     private RequestQueue requestQueue = null;
 
@@ -72,7 +70,7 @@ public class Glide {
      * Use to check whether or not an {@link RequestQueue} has been set yet. Can be used in
      * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
      * {@link #setRequestQueue(RequestQueue) setRequestQueue} to set a {@link RequestQueue} with custom options
-     * for use with {@link Glide#load(Object) load} and/or as an easily accessible singleton
+     * for use with {@link Glide.Request} and/or as an easily accessible singleton
      *
      * @return true iff a {@link RequestQueue} has already been set
      */
@@ -81,7 +79,7 @@ public class Glide {
     }
 
     /**
-     * Set the {@link RequestQueue} to use with {@link Glide#load(Object)} load}. Replaces the current
+     * Set the {@link RequestQueue} to use with {@link Glide.Request}. Replaces the current
      * {@link RequestQueue} if one has already been set
      *
      * @param requestQueue The {@link RequestQueue} to set
@@ -110,8 +108,8 @@ public class Glide {
      * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
      * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
      * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder) setImageManager} to set an
-     * {@link ImageManager} with custom options for use with {@link Glide#load(Object) load} and/or as an easily
-     * accessible singleton.
+     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an
+     * easily accessible singleton.
      *
      * @return true iff an {@link ImageManager} is currently set
      */
@@ -129,7 +127,7 @@ public class Glide {
     }
 
     /**
-     * Set the {@link ImageManager} to use with {@link Glide#load(Object) load}. Replaces the current
+     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current
      * {@link ImageManager} if one has already been set.
      *
      * @see #isImageManagerSet()
@@ -141,148 +139,226 @@ public class Glide {
     }
 
     /**
-     * Begins constructing a load for a given model.
+     * Set the {@link ModelLoader} for this view.
      *
      * <p>
-     * Only certain models are supported by default. See
-     * {@link Glide.Request#with(com.bumptech.glide.loader.model.ModelLoader)} for models with default a
-     * {@link ModelLoader}.
+     *     Note - You can use this method to set a {@link ModelLoader} for models that don't have a default
+     *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader}
+     *     for a model for which there is a default.
      * </p>
      *
      * <p>
-     * Note - If an {@link ImageManager} has not yet been set via
-     * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
-     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
-     * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
+     *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to
+     *     supply a custom {@link ModelLoader} here to do so, even if a default exists. Fetching a smaller image
+     *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to
+     *     download an image using the width and the height of the view, consider passing in a subclass of
+     *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
      * </p>
      *
-     * <p>
-     * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
-     * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
-     * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
-     * </p>
+     * @param modelLoader The {@link ModelRequest} to use to load an image from a given model
+     * @return A {@link ModelRequest} to set the specific model to load
+     */
+    public static <T> ModelRequest<T> using(ModelLoader<T> modelLoader) {
+        return new ModelRequest<T>(modelLoader);
+    }
+
+    /**
+     * Use {@link StringLoader} to load the given model
      *
-     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
-     * @see #setRequestQueue(com.android.volley.RequestQueue)
-     * @see #isImageManagerSet()
-     * @see #isRequestQueueSet()
+     * @see #using(com.bumptech.glide.loader.model.ModelLoader)
+     *
+     * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}
+     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     */
+    public static Request<String> load(String string) {
+        return new Request<String>(string);
+    }
+
+    /**
+     * Use {@link UriLoader} to load the given model
+     *
+     * @see #using(com.bumptech.glide.loader.model.ModelLoader)
+     *
+     * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}
+     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     */
+    public static Request<Uri> load(Uri uri) {
+        return new Request<Uri>(uri);
+    }
+
+    /**
+     * Use {@link UrlLoader} to load the given model
+     *
+     * @see #using(com.bumptech.glide.loader.model.ModelLoader)
+     *
+     * @param url The URL representing the image.
+     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     */
+    public static Request<URL> load(URL url) {
+        return new Request<URL>(url);
+    }
+
+    /**
+     * Use {@link FileLoader} to load the given model
+     *
+     * @see #using(com.bumptech.glide.loader.model.ModelLoader)
+     *
+     * @param file The File containing the image
+     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     */
+    public static Request<File> load(File file) {
+        return new Request<File>(file);
+    }
+
+    /**
+     * Use {@link DrawableLoader} to load the given model
+     *
+     * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
-     * @param model The model to load, must not be null
-     * @param <T> The type of the model to load
-     * @return A an unfinished Request that will be used to construct the components to load the model
+     * @param resourceId the id of the resource containing the image
+     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
      */
-    public static <T> HalfRequest<T> load(T model) {
-        if (model == null) {
-            throw new IllegalArgumentException(""Model can't be null"");
+    public static Request<Integer> load(Integer resourceId) {
+        return new Request<Integer>(resourceId);
+    }
+
+    private interface ModelLoaderFactory<T> {
+        public ModelLoader<T> build(Context context);
+        public Class<? extends ModelLoader<T>> loaderClass();
+    }
+
+    private static final ModelLoaderFactory<String> stringLoaderFactory = new ModelLoaderFactory<String>() {
+
+        @Override
+        public ModelLoader<String> build(Context context) {
+            return new StringLoader(context);
+        }
+
+        @Override
+        public Class<? extends ModelLoader<String>> loaderClass() {
+            return StringLoader.class;
+        }
+    };
+
+    private static final ModelLoaderFactory<Uri> uriLoaderFactory = new ModelLoaderFactory<Uri>() {
+        @Override
+        public ModelLoader<Uri> build(Context context) {
+            return new UriLoader(context);
+        }
+
+        @Override
+        public Class<? extends ModelLoader<Uri>> loaderClass() {
+            return UriLoader.class;
+        }
+    };
+
+    private static final ModelLoaderFactory<File> fileLoaderFactory = new ModelLoaderFactory<File>() {
+        @Override
+        public ModelLoader<File> build(Context context) {
+            return new FileLoader(context);
+        }
+
+        @Override
+        public Class<? extends ModelLoader<File>> loaderClass() {
+            return FileLoader.class;
+        }
+    };
+
+    private static final ModelLoaderFactory<URL> urlLoaderFactory = new ModelLoaderFactory<URL>() {
+        @Override
+        public ModelLoader<URL> build(Context context) {
+            return new UrlLoader(context);
+        }
+
+        @Override
+        public Class<? extends ModelLoader<URL>> loaderClass() {
+            return UrlLoader.class;
+        }
+    };
+
+    private static final ModelLoaderFactory<Integer> resourceLoaderFactory = new ModelLoaderFactory<Integer>() {
+        @Override
+        public ModelLoader<Integer> build(Context context) {
+            return new DrawableLoader(context);
         }
 
-        return new HalfRequest<T>(model);
+        @Override
+        public Class<? extends ModelLoader<Integer>> loaderClass() {
+            return DrawableLoader.class;
         }
+    };
 
     @SuppressWarnings(""unchecked"")
-    private static <T> ModelLoader<T> getModelFor(T model, Context context) {
-        final ModelLoader result;
-        if (model instanceof URL) {
-            result = new UrlLoader(GLIDE.getRequestQueue(context));
-        } else if (model instanceof File) {
-            result = new FileLoader(context);
+    private static <T> ModelLoaderFactory<T> getFactory(T model) {
+        final ModelLoaderFactory result;
+        if (model instanceof String) {
+            result = stringLoaderFactory;
         } else if (model instanceof Uri) {
-            result = new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
-        } else if (model instanceof String) {
-            result = new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
+            result = uriLoaderFactory;
+        } else if (model instanceof URL) {
+            result = urlLoaderFactory;
+        } else if (model instanceof File) {
+            result = fileLoaderFactory;
         } else if (model instanceof Integer) {
-            result = new DrawableLoader(context);
+            result = resourceLoaderFactory;
         } else {
-            throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
-                    "", you need to provide one by calling with()"");
+            throw new IllegalArgumentException(""No model factory for model class="" + model.getClass());
         }
         return result;
     }
 
     /**
-     * A builder for a request
+     * A helper class for building requests with custom {@link ModelLoader}s
      *
-     * @param <T> The type of the model the request will be built for
+     * @param <T> The type of the model (and {@link ModelLoader}
      */
-    public static class HalfRequest<T> {
-        private final T model;
+    public static class ModelRequest<T> {
+        private final ModelLoader<T> modelLoader;
 
-        public HalfRequest(T model) {
-            this.model = model;
+        public ModelRequest(ModelLoader<T> modelLoader) {
+            this.modelLoader = modelLoader;
         }
 
-        /**
-         * Build a request object for the given ImageView and model
-         *
-         * @param imageView The ImageView the request will be wrapping
-         * @return A new {@link Request}
-         */
-        public Request<T> into(ImageView imageView) {
-            if (imageView == null) {
-                throw new IllegalArgumentException(""ImageView can't be null"");
-            }
-            return new Request<T>(model, imageView);
+        public Request<T> load(T model) {
+            return new Request<T>(model, modelLoader);
         }
     }
 
     /**
-     * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
+     * Sets a variety of type independent options including resizing, animations, and placeholders. Responsible
+     * for building or retrieving an ImagePresenter for the given view and passing the ImagePresenter the given model.
      *
      * @param <T> The type of model that will be loaded into the view
      */
     @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
+
+        private enum ResizeOption {
+            APPROXIMATE,
+            CENTER_CROP,
+            FIT_CENTER,
+        }
+
+        private ModelLoaderFactory<T> modelLoaderFactory;
         private final T model;
-        private final Context context;
+        private final Class<? extends ModelLoader> modelLoaderClass;
+        private ModelLoader<T> modelLoader;
 
-        private ImagePresenter<T> presenter;
-        private ImagePresenter.Builder<T> builder;
-        private ModelLoader<T> modelLoader = null;
+        private int animationId = -1;
+        private int placeholderId = -1;
+        private ResizeOption resizeOption = ResizeOption.APPROXIMATE;
+        private ImageLoader imageLoader = null;
 
-        @SuppressWarnings(""unchecked"")
-        public Request(T model, ImageView imageView) {
+        public Request(T model) {
             this.model = model;
-            this.context = imageView.getContext();
-
-            presenter = ImagePresenter.getCurrent(imageView);
-            builder = new ImagePresenter.Builder<T>()
-                    .setImageView(imageView)
-                    .setImageLoader(new Approximate(getImageManager()));
+            this.modelLoaderFactory = getFactory(model);
+            this.modelLoaderClass = modelLoaderFactory.loaderClass();
         }
 
-        /**
-         * Set the {@link ModelLoader} for the model.
-         *
-         * <p>
-         *     Note - This method is required only if you are using a model for which there is no default
-         *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader} for
-         *     a model for which there is a default. The defaults are as follows:
-         * <ul>
-         *     <li>{@link String} - {@link StringLoader}. String must be a file path
-         *          (<code>/data/data/com.bumptech/glide/...</code>), a url (<code>http://www.google.com</code>), or a
-         *          uri. </li>
-         *     <li>{@link File} - {@link FileLoader}</li>
-         *     <li>{@link Integer} - {@link DrawableLoader}. Integer must be a resource id in your package</li>
-         *     <li>{@link Uri} - {@link UriLoader}. Uri must be a scheme handled by
-         *     {@link android.content.ContentResolver#openInputStream(android.net.Uri)}, http, or https</li>
-         * </ul>
-         * </p>
-         *
-         * <p>
-         *     Note - If you have the ability to fetch different sized images for a given model, you should supply a
-         *     {@link ModelLoader} here to do so. Fetching a smaller image means less bandwidth, battery, and memory
-         *     usage as well as faster image loads. To simply build a url to download an image using the width and
-         *     the height of the view, consider passing in a subclass of
-         *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
-         * </p>
-         *
-         * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
-         * @return This Request
-         */
-        public Request<T> with(ModelLoader<T> modelLoader) {
+        public Request(T model, ModelLoader<T> modelLoader) {
+            this.model = model;
             this.modelLoader = modelLoader;
-
-            return this;
+            this.modelLoaderClass = modelLoader.getClass();
         }
 
         /**
@@ -292,7 +368,10 @@ public class Glide {
          * @return This Request
          */
         public Request<T> centerCrop() {
-            return resizeWith(new CenterCrop(getImageManager()));
+            resizeOption = ResizeOption.CENTER_CROP;
+            imageLoader = null;
+
+            return this;
         }
 
         /**
@@ -302,7 +381,10 @@ public class Glide {
          * @return This Request
          */
         public Request<T> fitCenter() {
-            return resizeWith(new FitCenter(getImageManager()));
+            resizeOption = ResizeOption.FIT_CENTER;
+            imageLoader = null;
+
+            return this;
         }
 
         /**
@@ -312,7 +394,10 @@ public class Glide {
          * @return This Request
          */
         public Request<T> approximate() {
-            return resizeWith(new Approximate(getImageManager()));
+            resizeOption = ResizeOption.APPROXIMATE;
+            imageLoader = null;
+
+            return this;
         }
 
         /**
@@ -322,7 +407,8 @@ public class Glide {
          * @return This Request
          */
         public Request<T> resizeWith(ImageLoader imageLoader) {
-            builder.setImageLoader(imageLoader);
+            this.imageLoader = imageLoader;
+            resizeOption = null;
 
             return this;
         }
@@ -331,53 +417,24 @@ public class Glide {
          * Sets an animation to run on the wrapped view when an image load finishes. Will only be run if the image
          * was loaded asynchronously (ie was not in the memory cache)
          *
-         * @param animation The Animation to run
-         * @return This Request
-         */
-        public Request<T> animate(final Animation animation) {
-            builder.setImageSetCallback(new ImageSetCallback() {
-                @Override
-                public void onImageSet(ImageView view, boolean fromCache) {
-                    view.clearAnimation();
-
-                    if (!fromCache) {
-                        view.startAnimation(animation);
-                    }
-                }
-            });
-
-            return this;
-        }
-
-        /**
-         * @see #animate(android.view.animation.Animation)
-         *
          * @param animationId The resource id of the animation to run
          * @return This Request
          */
         public Request<T> animate(int animationId) {
-            return animate(AnimationUtils.loadAnimation(context, animationId));
-        }
+            this.animationId = animationId;
 
-        /**
-         * Sets a drawable to display while an image is loading
-         *
-         * @param drawable The drawable to use as a placeholder
-         * @return This Request
-         */
-        public Request<T> setPlaceholderDrawable(Drawable drawable) {
-            builder.setPlaceholderDrawable(drawable);
             return this;
         }
 
         /**
-         * @see #setPlaceholderDrawable(android.graphics.drawable.Drawable)
+         * Sets a drawable to display while an image is loading
          *
          * @param resourceId The id of the resource to use as a placeholder
          * @return This Request
          */
-        public Request<T> setPlaceholderResource(int resourceId) {
-            builder.setPlaceholderResource(resourceId);
+        public Request<T> placeholder(int resourceId) {
+            this.placeholderId = resourceId;
+
             return this;
         }
 
@@ -385,38 +442,158 @@ public class Glide {
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
          * the given model. This must be called on the main thread.
          *
-         * <p>
-         *     Note - If an existing ImagePresenter already exists for this view it will not be replaced. This means you
-         *     can set options once and only once the first time load and begin is called for any given view. For
-         *     example, if you call load and begin for a view with centerCrop the first time and then load a second time
-         *     for the same view but with fitCenter, the image will still be resized with centerCrop. If you need
-         *     to change options you can call <code> imageView.setTag(R.id.image_presenter_id, null) </code> prior to
-         *     calling this method, but it is inefficient to do so, particularly in lists.
-         * </p>
-         *
-         *
          * @see ImagePresenter#setModel(Object)
          */
-        public void begin() {
-            build();
-            presenter.setModel(model);
-        }
-
-        private ImageManager getImageManager() {
-            return GLIDE.getImageManager(context);
+        public void into(ImageView imageView) {
+            ImagePresenter<T> imagePresenter = getImagePresenter(imageView);
+            imagePresenter.setModel(model);
         }
 
         /**
          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
          * the view's tag for the id {@code R.id.image_presenter_id}.
          */
-        private void build() {
-            if (presenter == null) {
+        private ImagePresenter<T> getImagePresenter(ImageView imageView) {
+            Metadata previous = getMetadataFrom(imageView);
+            Metadata current = new Metadata(this);
+
+            ImagePresenter<T> result = ImagePresenter.getCurrent(imageView);
+
+            if (!current.equals(previous)) {
+                if (result != null) {
+                    result.clear();
+                }
+
+                result = buildImagePresenter(imageView);
+
+                setMetadata(imageView, current);
+            }
+
+            return result;
+        }
+
+        private ImagePresenter<T> buildImagePresenter(ImageView imageView) {
+            final Context context = imageView.getContext();
+
+            imageLoader = getFinalImageLoader(context);
+            modelLoader = getFinalModelLoader(context);
+
+            ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
+                    .setImageView(imageView)
+                    .setModelLoader(modelLoader)
+                    .setImageLoader(imageLoader);
+
+            if (animationId != -1) {
+                final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
+                builder.setImageSetCallback(new ImageSetCallback() {
+                    @Override
+                    public void onImageSet(ImageView view, boolean fromCache) {
+                        view.clearAnimation();
+
+                        if (!fromCache) {
+                            view.startAnimation(animation);
+                        }
+
+                    }
+                });
+            }
+
+            if (placeholderId != -1) {
+                builder.setPlaceholderResource(placeholderId);
+            }
+
+            return builder.build();
+        }
+
+        private ModelLoader<T> getFinalModelLoader(Context context) {
             if (modelLoader == null) {
-                    modelLoader = getModelFor(model, context);
+                return modelLoaderFactory.build(context);
+            } else {
+                return modelLoader;
             }
-                presenter = builder.setModelLoader(modelLoader).build();
+        }
+
+        private ImageLoader getFinalImageLoader(Context context) {
+            if (imageLoader == null) {
+                return getImageLoaderFromOptions(context);
+            } else {
+                return imageLoader;
             }
         }
+
+        private ImageLoader getImageLoaderFromOptions(Context context) {
+            final ImageLoader result;
+            switch (resizeOption) {
+                case APPROXIMATE:
+                    result = new Approximate(context);
+                    break;
+                case CENTER_CROP:
+                    result = new CenterCrop(context);
+                    break;
+                case FIT_CENTER:
+                    result = new FitCenter(context);
+                    break;
+                default:
+                    throw new IllegalArgumentException(""Unknown resize option "" + resizeOption);
+            }
+            return result;
+        }
+
+        private static Metadata getMetadataFrom(ImageView imageView) {
+            return (Metadata) imageView.getTag(R.id.glide_metadata);
+        }
+
+        private static void setMetadata(ImageView imageView, Metadata metadata) {
+            imageView.setTag(R.id.glide_metadata, metadata);
+        }
+
+        private static class Metadata {
+            public final Class modelClass;
+            public final Class modelLoaderClass;
+            public final Class imageLoaderClass;
+            public final int animationId;
+            public final int placeholderId;
+
+            public Metadata(Request request) {
+                modelClass = request.model.getClass();
+                modelLoaderClass = request.modelLoaderClass;
+                if (request.imageLoader != null) {
+                    imageLoaderClass = request.imageLoader.getClass();
+                } else {
+                    switch (request.resizeOption) {
+                        case APPROXIMATE:
+                            imageLoaderClass = Approximate.class;
+                            break;
+                        case CENTER_CROP:
+                            imageLoaderClass = CenterCrop.class;
+                            break;
+                        case FIT_CENTER:
+                            imageLoaderClass = FitCenter.class;
+                            break;
+                        default:
+                            throw new IllegalArgumentException(""Unknown resize option "" + request.resizeOption);
+                    }
+                }
+                animationId = request.animationId;
+                placeholderId = request.placeholderId;
+            }
+
+            @Override
+            public boolean equals(Object o) {
+                if (o == null || !(o instanceof Metadata)) {
+                    return false;
+                }
+
+                Metadata other = (Metadata) o;
+
+                return modelClass.equals(other.modelClass) &&
+                        modelLoaderClass.equals(other.modelLoaderClass) &&
+                        imageLoaderClass.equals(other.imageLoaderClass) &&
+                        animationId == other.animationId &&
+                        placeholderId == other.placeholderId;
+
+            }
+        }
+
     }
 }
","73      * for use with {@link Glide.Request} and/or as an easily accessible singleton
82      * Set the {@link RequestQueue} to use with {@link Glide.Request}. Replaces the current
111      * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an
112      * easily accessible singleton.
130      * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current
142      * Set the {@link ModelLoader} for this view.
145      *     Note - You can use this method to set a {@link ModelLoader} for models that don't have a default
146      *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader}
147      *     for a model for which there is a default.
151      *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to
152      *     supply a custom {@link ModelLoader} here to do so, even if a default exists. Fetching a smaller image
153      *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to
154      *     download an image using the width and the height of the view, consider passing in a subclass of
155      *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
158      * @param modelLoader The {@link ModelRequest} to use to load an image from a given model
159      * @return A {@link ModelRequest} to set the specific model to load
161     public static <T> ModelRequest<T> using(ModelLoader<T> modelLoader) {
162         return new ModelRequest<T>(modelLoader);
165     /**
166      * Use {@link StringLoader} to load the given model
167      *
168      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
169      *
170      * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}
171      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
172      */
173     public static Request<String> load(String string) {
174         return new Request<String>(string);
177     /**
178      * Use {@link UriLoader} to load the given model
179      *
180      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
181      *
182      * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}
183      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
184      */
185     public static Request<Uri> load(Uri uri) {
186         return new Request<Uri>(uri);
187     }
188 
189     /**
190      * Use {@link UrlLoader} to load the given model
191      *
192      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
193      *
194      * @param url The URL representing the image.
195      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
196      */
197     public static Request<URL> load(URL url) {
198         return new Request<URL>(url);
199     }
200 
201     /**
202      * Use {@link FileLoader} to load the given model
203      *
204      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
205      *
206      * @param file The File containing the image
207      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
208      */
209     public static Request<File> load(File file) {
210         return new Request<File>(file);
211     }
212 
213     /**
214      * Use {@link DrawableLoader} to load the given model
215      *
216      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
217      *
218      * @param resourceId the id of the resource containing the image
219      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
220      */
221     public static Request<Integer> load(Integer resourceId) {
222         return new Request<Integer>(resourceId);
223     }
224 
225     private interface ModelLoaderFactory<T> {
226         public ModelLoader<T> build(Context context);
227         public Class<? extends ModelLoader<T>> loaderClass();
228     }
229 
230     private static final ModelLoaderFactory<String> stringLoaderFactory = new ModelLoaderFactory<String>() {
231 
232         @Override
233         public ModelLoader<String> build(Context context) {
234             return new StringLoader(context);
235         }
236 
237         @Override
238         public Class<? extends ModelLoader<String>> loaderClass() {
239             return StringLoader.class;
240         }
241     };
242 
243     private static final ModelLoaderFactory<Uri> uriLoaderFactory = new ModelLoaderFactory<Uri>() {
244         @Override
245         public ModelLoader<Uri> build(Context context) {
246             return new UriLoader(context);
247         }
248 
249         @Override
250         public Class<? extends ModelLoader<Uri>> loaderClass() {
251             return UriLoader.class;
252         }
253     };
254 
255     private static final ModelLoaderFactory<File> fileLoaderFactory = new ModelLoaderFactory<File>() {
256         @Override
257         public ModelLoader<File> build(Context context) {
258             return new FileLoader(context);
259         }
260 
261         @Override
262         public Class<? extends ModelLoader<File>> loaderClass() {
263             return FileLoader.class;
264         }
265     };
266 
267     private static final ModelLoaderFactory<URL> urlLoaderFactory = new ModelLoaderFactory<URL>() {
268         @Override
269         public ModelLoader<URL> build(Context context) {
270             return new UrlLoader(context);
271         }
272 
273         @Override
274         public Class<? extends ModelLoader<URL>> loaderClass() {
275             return UrlLoader.class;
276         }
277     };
278 
279     private static final ModelLoaderFactory<Integer> resourceLoaderFactory = new ModelLoaderFactory<Integer>() {
280         @Override
281         public ModelLoader<Integer> build(Context context) {
282             return new DrawableLoader(context);
283         }
284 
285         @Override
286         public Class<? extends ModelLoader<Integer>> loaderClass() {
287             return DrawableLoader.class;
288         }
289     };
290 
292     private static <T> ModelLoaderFactory<T> getFactory(T model) {
293         final ModelLoaderFactory result;
294         if (model instanceof String) {
295             result = stringLoaderFactory;
297             result = uriLoaderFactory;
298         } else if (model instanceof URL) {
299             result = urlLoaderFactory;
300         } else if (model instanceof File) {
301             result = fileLoaderFactory;
303             result = resourceLoaderFactory;
305             throw new IllegalArgumentException(""No model factory for model class="" + model.getClass());
311      * A helper class for building requests with custom {@link ModelLoader}s
313      * @param <T> The type of the model (and {@link ModelLoader}
315     public static class ModelRequest<T> {
316         private final ModelLoader<T> modelLoader;
318         public ModelRequest(ModelLoader<T> modelLoader) {
319             this.modelLoader = modelLoader;
322         public Request<T> load(T model) {
323             return new Request<T>(model, modelLoader);
328      * Sets a variety of type independent options including resizing, animations, and placeholders. Responsible
329      * for building or retrieving an ImagePresenter for the given view and passing the ImagePresenter the given model.
336         private enum ResizeOption {
337             APPROXIMATE,
338             CENTER_CROP,
339             FIT_CENTER,
342         private ModelLoaderFactory<T> modelLoaderFactory;
343         private final T model;
344         private final Class<? extends ModelLoader> modelLoaderClass;
345         private ModelLoader<T> modelLoader;
347         private int animationId = -1;
348         private int placeholderId = -1;
349         private ResizeOption resizeOption = ResizeOption.APPROXIMATE;
350         private ImageLoader imageLoader = null;
351 
352         public Request(T model) {
353             this.model = model;
354             this.modelLoaderFactory = getFactory(model);
355             this.modelLoaderClass = modelLoaderFactory.loaderClass();
356         }
357 
358         public Request(T model, ModelLoader<T> modelLoader) {
359             this.model = model;
360             this.modelLoader = modelLoader;
361             this.modelLoaderClass = modelLoader.getClass();
371             resizeOption = ResizeOption.CENTER_CROP;
372             imageLoader = null;
373 
374             return this;
384             resizeOption = ResizeOption.FIT_CENTER;
385             imageLoader = null;
386 
387             return this;
397             resizeOption = ResizeOption.APPROXIMATE;
398             imageLoader = null;
399 
400             return this;
410             this.imageLoader = imageLoader;
411             resizeOption = null;
420          * @param animationId The resource id of the animation to run
423         public Request<T> animate(int animationId) {
424             this.animationId = animationId;
425 
426             return this;
427         }
428 
429         /**
430          * Sets a drawable to display while an image is loading
431          *
432          * @param resourceId The id of the resource to use as a placeholder
433          * @return This Request
434          */
435         public Request<T> placeholder(int resourceId) {
436             this.placeholderId = resourceId;
437 
438             return this;
439         }
440 
441         /**
442          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
443          * the given model. This must be called on the main thread.
444          *
445          * @see ImagePresenter#setModel(Object)
446          */
447         public void into(ImageView imageView) {
448             ImagePresenter<T> imagePresenter = getImagePresenter(imageView);
449             imagePresenter.setModel(model);
450         }
451 
452         /**
453          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
454          * the view's tag for the id {@code R.id.image_presenter_id}.
455          */
456         private ImagePresenter<T> getImagePresenter(ImageView imageView) {
457             Metadata previous = getMetadataFrom(imageView);
458             Metadata current = new Metadata(this);
459 
460             ImagePresenter<T> result = ImagePresenter.getCurrent(imageView);
461 
462             if (!current.equals(previous)) {
463                 if (result != null) {
464                     result.clear();
465                 }
466 
467                 result = buildImagePresenter(imageView);
468 
469                 setMetadata(imageView, current);
470             }
471 
472             return result;
473         }
474 
475         private ImagePresenter<T> buildImagePresenter(ImageView imageView) {
476             final Context context = imageView.getContext();
477 
478             imageLoader = getFinalImageLoader(context);
479             modelLoader = getFinalModelLoader(context);
480 
481             ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
482                     .setImageView(imageView)
483                     .setModelLoader(modelLoader)
484                     .setImageLoader(imageLoader);
485 
486             if (animationId != -1) {
487                 final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
496 
501             if (placeholderId != -1) {
502                 builder.setPlaceholderResource(placeholderId);
505             return builder.build();
508         private ModelLoader<T> getFinalModelLoader(Context context) {
510                 return modelLoaderFactory.build(context);
511             } else {
512                 return modelLoader;
515 
516         private ImageLoader getFinalImageLoader(Context context) {
517             if (imageLoader == null) {
518                 return getImageLoaderFromOptions(context);
519             } else {
520                 return imageLoader;
521             }
522         }
523 
524         private ImageLoader getImageLoaderFromOptions(Context context) {
525             final ImageLoader result;
526             switch (resizeOption) {
527                 case APPROXIMATE:
528                     result = new Approximate(context);
529                     break;
530                 case CENTER_CROP:
531                     result = new CenterCrop(context);
532                     break;
533                 case FIT_CENTER:
534                     result = new FitCenter(context);
535                     break;
536                 default:
537                     throw new IllegalArgumentException(""Unknown resize option "" + resizeOption);
538             }
539             return result;
540         }
541 
542         private static Metadata getMetadataFrom(ImageView imageView) {
543             return (Metadata) imageView.getTag(R.id.glide_metadata);
544         }
545 
546         private static void setMetadata(ImageView imageView, Metadata metadata) {
547             imageView.setTag(R.id.glide_metadata, metadata);
548         }
549 
550         private static class Metadata {
551             public final Class modelClass;
552             public final Class modelLoaderClass;
553             public final Class imageLoaderClass;
554             public final int animationId;
555             public final int placeholderId;
556 
557             public Metadata(Request request) {
558                 modelClass = request.model.getClass();
559                 modelLoaderClass = request.modelLoaderClass;
560                 if (request.imageLoader != null) {
561                     imageLoaderClass = request.imageLoader.getClass();
562                 } else {
563                     switch (request.resizeOption) {
564                         case APPROXIMATE:
565                             imageLoaderClass = Approximate.class;
566                             break;
567                         case CENTER_CROP:
568                             imageLoaderClass = CenterCrop.class;
569                             break;
570                         case FIT_CENTER:
571                             imageLoaderClass = FitCenter.class;
572                             break;
573                         default:
574                             throw new IllegalArgumentException(""Unknown resize option "" + request.resizeOption);
575                     }
576                 }
577                 animationId = request.animationId;
578                 placeholderId = request.placeholderId;
579             }
580 
581             @Override
582             public boolean equals(Object o) {
583                 if (o == null || !(o instanceof Metadata)) {
584                     return false;
585                 }
586 
587                 Metadata other = (Metadata) o;
588 
589                 return modelClass.equals(other.modelClass) &&
590                         modelLoaderClass.equals(other.modelLoaderClass) &&
591                         imageLoaderClass.equals(other.imageLoaderClass) &&
592                         animationId == other.animationId &&
593                         placeholderId == other.placeholderId;
594 
595             }
596         }
597 
4 import android.graphics.drawable.Drawable;
40 
75      * for use with {@link Glide#load(Object) load} and/or as an easily accessible singleton
84      * Set the {@link RequestQueue} to use with {@link Glide#load(Object)} load}. Replaces the current
113      * {@link ImageManager} with custom options for use with {@link Glide#load(Object) load} and/or as an easily
114      * accessible singleton.
132      * Set the {@link ImageManager} to use with {@link Glide#load(Object) load}. Replaces the current
144      * Begins constructing a load for a given model.
147      * Only certain models are supported by default. See
148      * {@link Glide.Request#with(com.bumptech.glide.loader.model.ModelLoader)} for models with default a
149      * {@link ModelLoader}.
153      * Note - If an {@link ImageManager} has not yet been set via
154      * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
155      * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
156      * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
159      * <p>
160      * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
161      * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
162      * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
163      * </p>
164      *
165      * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
166      * @see #setRequestQueue(com.android.volley.RequestQueue)
167      * @see #isImageManagerSet()
168      * @see #isRequestQueueSet()
169      *
170      * @param model The model to load, must not be null
171      * @param <T> The type of the model to load
172      * @return A an unfinished Request that will be used to construct the components to load the model
174     public static <T> HalfRequest<T> load(T model) {
175         if (model == null) {
176             throw new IllegalArgumentException(""Model can't be null"");
179         return new HalfRequest<T>(model);
183     private static <T> ModelLoader<T> getModelFor(T model, Context context) {
184         final ModelLoader result;
185         if (model instanceof URL) {
186             result = new UrlLoader(GLIDE.getRequestQueue(context));
187         } else if (model instanceof File) {
188             result = new FileLoader(context);
190             result = new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context)));
191         } else if (model instanceof String) {
192             result = new StringLoader(new UriLoader(context, new UrlLoader(GLIDE.getRequestQueue(context))));
194             result = new DrawableLoader(context);
196             throw new IllegalArgumentException(""No default ModelLoader for class="" + model.getClass() +
197                     "", you need to provide one by calling with()"");
203      * A builder for a request
205      * @param <T> The type of the model the request will be built for
207     public static class HalfRequest<T> {
208         private final T model;
210         public HalfRequest(T model) {
211             this.model = model;
214         /**
215          * Build a request object for the given ImageView and model
216          *
217          * @param imageView The ImageView the request will be wrapping
218          * @return A new {@link Request}
219          */
220         public Request<T> into(ImageView imageView) {
221             if (imageView == null) {
222                 throw new IllegalArgumentException(""ImageView can't be null"");
223             }
224             return new Request<T>(model, imageView);
229      * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model
235         private final T model;
236         private final Context context;
238         private ImagePresenter<T> presenter;
239         private ImagePresenter.Builder<T> builder;
240         private ModelLoader<T> modelLoader = null;
241 
242         @SuppressWarnings(""unchecked"")
243         public Request(T model, ImageView imageView) {
244             this.model = model;
245             this.context = imageView.getContext();
246 
247             presenter = ImagePresenter.getCurrent(imageView);
248             builder = new ImagePresenter.Builder<T>()
249                     .setImageView(imageView)
250                     .setImageLoader(new Approximate(getImageManager()));
253         /**
254          * Set the {@link ModelLoader} for the model.
255          *
256          * <p>
257          *     Note - This method is required only if you are using a model for which there is no default
258          *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader} for
259          *     a model for which there is a default. The defaults are as follows:
260          * <ul>
261          *     <li>{@link String} - {@link StringLoader}. String must be a file path
262          *          (<code>/data/data/com.bumptech/glide/...</code>), a url (<code>http://www.google.com</code>), or a
263          *          uri. </li>
264          *     <li>{@link File} - {@link FileLoader}</li>
265          *     <li>{@link Integer} - {@link DrawableLoader}. Integer must be a resource id in your package</li>
266          *     <li>{@link Uri} - {@link UriLoader}. Uri must be a scheme handled by
267          *     {@link android.content.ContentResolver#openInputStream(android.net.Uri)}, http, or https</li>
268          * </ul>
269          * </p>
270          *
271          * <p>
272          *     Note - If you have the ability to fetch different sized images for a given model, you should supply a
273          *     {@link ModelLoader} here to do so. Fetching a smaller image means less bandwidth, battery, and memory
274          *     usage as well as faster image loads. To simply build a url to download an image using the width and
275          *     the height of the view, consider passing in a subclass of
276          *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
277          * </p>
278          *
279          * @param modelLoader The {@link ModelLoader} to use. Replaces any existing loader
280          * @return This Request
281          */
282         public Request<T> with(ModelLoader<T> modelLoader) {
283             this.modelLoader = modelLoader;
285             return this;
295             return resizeWith(new CenterCrop(getImageManager()));
305             return resizeWith(new FitCenter(getImageManager()));
315             return resizeWith(new Approximate(getImageManager()));
325             builder.setImageLoader(imageLoader);
334          * @param animation The Animation to run
337         public Request<T> animate(final Animation animation) {
348 
349             return this;
352         /**
353          * @see #animate(android.view.animation.Animation)
354          *
355          * @param animationId The resource id of the animation to run
356          * @return This Request
357          */
358         public Request<T> animate(int animationId) {
359             return animate(AnimationUtils.loadAnimation(context, animationId));
362         /**
363          * Sets a drawable to display while an image is loading
364          *
365          * @param drawable The drawable to use as a placeholder
366          * @return This Request
367          */
368         public Request<T> setPlaceholderDrawable(Drawable drawable) {
369             builder.setPlaceholderDrawable(drawable);
370             return this;
373         /**
374          * @see #setPlaceholderDrawable(android.graphics.drawable.Drawable)
375          *
376          * @param resourceId The id of the resource to use as a placeholder
377          * @return This Request
378          */
379         public Request<T> setPlaceholderResource(int resourceId) {
380             builder.setPlaceholderResource(resourceId);
381             return this;
382         }
383 
384         /**
385          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
386          * the given model. This must be called on the main thread.
387          *
388          * <p>
389          *     Note - If an existing ImagePresenter already exists for this view it will not be replaced. This means you
390          *     can set options once and only once the first time load and begin is called for any given view. For
391          *     example, if you call load and begin for a view with centerCrop the first time and then load a second time
392          *     for the same view but with fitCenter, the image will still be resized with centerCrop. If you need
393          *     to change options you can call <code> imageView.setTag(R.id.image_presenter_id, null) </code> prior to
394          *     calling this method, but it is inefficient to do so, particularly in lists.
395          * </p>
396          *
397          *
398          * @see ImagePresenter#setModel(Object)
399          */
400         public void begin() {
401             build();
402             presenter.setModel(model);
403         }
404 
405         private ImageManager getImageManager() {
406             return GLIDE.getImageManager(context);
407         }
408 
409         /**
410          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
411          * the view's tag for the id {@code R.id.image_presenter_id}.
412          */
413         private void build() {
414             if (presenter == null) {
416                     modelLoader = getModelFor(model, context);
417                 }
418                 presenter = builder.setModelLoader(modelLoader).build();",No
library\tests\src\com\bumptech\glide\GlideTest.java,library\tests\src\com\bumptech\glide\GlideTest.java,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,8dcf3324d59efb354331f18089674fe1bcc3d4aa,"Cleaner and more efficient Glide api

Reduces the # of extraneous object allocations by
lazily creating objects only if a new presenter is
needed. Adds some metadata to view tags to
determine whether or not options for a view are
the same, so an existing presenter can be used
or have changed, so a new presenter has to be
created","@@ -1,9 +1,11 @@
 package com.bumptech.glide;
 
 import android.net.Uri;
-import android.test.AndroidTestCase;
+import android.test.ActivityTestCase;
 import android.view.ViewGroup;
 import android.widget.ImageView;
+import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 
 import java.io.File;
@@ -17,19 +19,18 @@ import java.net.URL;
  * Time: 12:40 PM
  * To change this template use File | Settings | File Templates.
  */
-public class GlideTest extends AndroidTestCase {
+public class GlideTest extends ActivityTestCase {
     private ImageView imageView;
 
     @Override
     protected void setUp() throws Exception {
         super.setUp();
-        imageView = new ImageView(getContext());
+        imageView = new ImageView(getInstrumentation().getContext());
+        //this is a quick hack to get the SizeDeterminer in ImagePresenter to think the view has been measured
         imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
     }
 
-    private <T> void checkImagePresenter(T model) {
-        Glide.load(model).into(imageView).begin();
-
+    private void checkImagePresenter(Object model) {
         ImagePresenter imagePresenter = getImagePresenterFromView();
         imagePresenter.setModel(model);
 
@@ -48,47 +49,150 @@ public class GlideTest extends AndroidTestCase {
     }
 
     public void testFileDefaultLoader() {
-        checkImagePresenter(new File(""fake""));
+        File file = new File(""fake"");
+        Glide.load(file).into(imageView);
+        checkImagePresenter(file);
     }
 
     public void testUrlDefaultLoader() throws MalformedURLException {
-        checkImagePresenter(new URL(""http://www.google.com""));
+        URL url = new URL(""http://www.google.com"");
+        Glide.load(url).into(imageView);
+        checkImagePresenter(url);
     }
 
     public void testUriDefaultLoader() {
-        checkImagePresenter(Uri.fromFile(new File(""Fake"")));
+        Uri uri = Uri.fromFile(new File(""Fake""));
+        Glide.load(uri).into(imageView);
+        checkImagePresenter(uri);
     }
 
     public void testStringDefaultLoader() {
-        checkImagePresenter(""http://www.google.com"");
+        String string = ""http://www.google.com"";
+        Glide.load(string).into(imageView);
+        checkImagePresenter(string);
     }
 
     public void testIntegerDefaultLoader() {
-        checkImagePresenter(1234);
+        int integer = 1234;
+        Glide.load(integer).into(imageView);
+        checkImagePresenter(integer);
     }
 
-    public void testGlideDoesNotReplacePresenters() {
-        Glide.load(new File(""fake"")).into(imageView).begin();
-
+    public void testGlideDoesNotReplaceIdenticalPresenters() {
+        Glide.load(""fake"")
+                .centerCrop()
+                .animate(android.R.anim.fade_in)
+                .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
+                .into(imageView);
         ImagePresenter first = getImagePresenterFromView();
 
-        Glide.load(new File(""fake2"")).into(imageView).begin();
-
+        Glide.load(""fake2"")
+                .centerCrop()
+                .animate(android.R.anim.fade_in)
+                .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
+                .into(imageView);
         ImagePresenter second = getImagePresenterFromView();
 
-        assertEquals(first, second);
+        assertSame(first, second);
     }
 
-    public void testLoadingTwoDifferentTypesOfModelsThrows() {
-        Glide.load(new File(""fake"")).into(imageView).begin();
+    public void testDifferentModlsReplacesPresenters() {
+        Glide.load(""fake"").into(imageView);
 
-        boolean thrown = false;
-        try {
-            Glide.load(new Integer(4)).into(imageView).begin();
-        } catch (ClassCastException e) {
-            thrown = true;
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        Glide.load(4).into(imageView);
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
     }
 
-        assertTrue(thrown);
+    public void testDifferentModelLoadersReplacesPresenter() {
+        Glide.using(new ModelLoader<Object>() {
+            @Override
+            public StreamLoader getStreamLoader(Object model, int width, int height) {
+                return new StreamLoader() {
+                    @Override
+                    public void loadStream(StreamReadyCallback cb) {
+                    }
+
+                    @Override
+                    public void cancel() {
+                    }
+                };
             }
+
+            @Override
+            public String getId(Object model) {
+                return String.valueOf(model.hashCode());
+            }
+
+            @Override
+            public void clear() {
+            }
+        }).load(new Object()).into(imageView);
+
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+
+        Glide.using(new ModelLoader<Object>() {
+            @Override
+            public StreamLoader getStreamLoader(Object model, int width, int height) {
+                return new StreamLoader() {
+                    @Override
+                    public void loadStream(StreamReadyCallback cb) {
+                    }
+
+                    @Override
+                    public void cancel() {
+                    }
+                };
+            }
+
+            @Override
+            public String getId(Object model) {
+                return String.valueOf(model.hashCode());
+            }
+
+            @Override
+            public void clear() {
+            }
+        }).load(new Object()).into(imageView);
+
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
+    }
+
+    public void testDifferentImageLoadersReplacesPresenter() {
+        final File file = new File(""fake"");
+        Glide.load(file).centerCrop().into(imageView);
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+
+        Glide.load(file).into(imageView);
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
+    }
+
+    public void testDifferentPlaceholdersReplacesPresenter() {
+        final File file = new File(""fake"");
+        Glide.load(file).placeholder(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+
+        Glide.load(file).into(imageView);
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
+    }
+
+    public void testDifferentAnimationsReplacesPresenter() {
+        final File file = new File(""fake"");
+        Glide.load(file).animate(android.R.anim.fade_in).into(imageView);
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+
+        Glide.load(file).into(imageView);
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
+    }
+
 }
","4 import android.test.ActivityTestCase;
7 import com.bumptech.glide.loader.model.ModelLoader;
8 import com.bumptech.glide.loader.stream.StreamLoader;
22 public class GlideTest extends ActivityTestCase {
28         imageView = new ImageView(getInstrumentation().getContext());
29         //this is a quick hack to get the SizeDeterminer in ImagePresenter to think the view has been measured
33     private void checkImagePresenter(Object model) {
52         File file = new File(""fake"");
53         Glide.load(file).into(imageView);
54         checkImagePresenter(file);
58         URL url = new URL(""http://www.google.com"");
59         Glide.load(url).into(imageView);
60         checkImagePresenter(url);
64         Uri uri = Uri.fromFile(new File(""Fake""));
65         Glide.load(uri).into(imageView);
66         checkImagePresenter(uri);
70         String string = ""http://www.google.com"";
71         Glide.load(string).into(imageView);
72         checkImagePresenter(string);
76         int integer = 1234;
77         Glide.load(integer).into(imageView);
78         checkImagePresenter(integer);
81     public void testGlideDoesNotReplaceIdenticalPresenters() {
82         Glide.load(""fake"")
83                 .centerCrop()
84                 .animate(android.R.anim.fade_in)
85                 .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
86                 .into(imageView);
89         Glide.load(""fake2"")
90                 .centerCrop()
91                 .animate(android.R.anim.fade_in)
92                 .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
93                 .into(imageView);
96         assertSame(first, second);
99     public void testDifferentModlsReplacesPresenters() {
100         Glide.load(""fake"").into(imageView);
102         ImagePresenter first = ImagePresenter.getCurrent(imageView);
103         Glide.load(4).into(imageView);
104         ImagePresenter second = ImagePresenter.getCurrent(imageView);
105 
106         assertNotSame(first, second);
109     public void testDifferentModelLoadersReplacesPresenter() {
110         Glide.using(new ModelLoader<Object>() {
111             @Override
112             public StreamLoader getStreamLoader(Object model, int width, int height) {
113                 return new StreamLoader() {
114                     @Override
115                     public void loadStream(StreamReadyCallback cb) {
117 
118                     @Override
119                     public void cancel() {
120                     }
121                 };
122             }
123 
124             @Override
125             public String getId(Object model) {
126                 return String.valueOf(model.hashCode());
127             }
128 
129             @Override
130             public void clear() {
131             }
132         }).load(new Object()).into(imageView);
133 
134         ImagePresenter first = ImagePresenter.getCurrent(imageView);
135 
136         Glide.using(new ModelLoader<Object>() {
137             @Override
138             public StreamLoader getStreamLoader(Object model, int width, int height) {
139                 return new StreamLoader() {
140                     @Override
141                     public void loadStream(StreamReadyCallback cb) {
142                     }
143 
144                     @Override
145                     public void cancel() {
146                     }
147                 };
148             }
149 
150             @Override
151             public String getId(Object model) {
152                 return String.valueOf(model.hashCode());
153             }
154 
155             @Override
156             public void clear() {
157             }
158         }).load(new Object()).into(imageView);
159 
160         ImagePresenter second = ImagePresenter.getCurrent(imageView);
161 
162         assertNotSame(first, second);
163     }
164 
165     public void testDifferentImageLoadersReplacesPresenter() {
166         final File file = new File(""fake"");
167         Glide.load(file).centerCrop().into(imageView);
168         ImagePresenter first = ImagePresenter.getCurrent(imageView);
169 
170         Glide.load(file).into(imageView);
171         ImagePresenter second = ImagePresenter.getCurrent(imageView);
172 
173         assertNotSame(first, second);
174     }
175 
176     public void testDifferentPlaceholdersReplacesPresenter() {
177         final File file = new File(""fake"");
178         Glide.load(file).placeholder(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
179         ImagePresenter first = ImagePresenter.getCurrent(imageView);
180 
181         Glide.load(file).into(imageView);
182         ImagePresenter second = ImagePresenter.getCurrent(imageView);
183 
184         assertNotSame(first, second);
185     }
186 
187     public void testDifferentAnimationsReplacesPresenter() {
188         final File file = new File(""fake"");
189         Glide.load(file).animate(android.R.anim.fade_in).into(imageView);
190         ImagePresenter first = ImagePresenter.getCurrent(imageView);
191 
192         Glide.load(file).into(imageView);
193         ImagePresenter second = ImagePresenter.getCurrent(imageView);
194 
195         assertNotSame(first, second);
196     }
197 
4 import android.test.AndroidTestCase;
20 public class GlideTest extends AndroidTestCase {
26         imageView = new ImageView(getContext());
30     private <T> void checkImagePresenter(T model) {
31         Glide.load(model).into(imageView).begin();
32 
51         checkImagePresenter(new File(""fake""));
55         checkImagePresenter(new URL(""http://www.google.com""));
59         checkImagePresenter(Uri.fromFile(new File(""Fake"")));
63         checkImagePresenter(""http://www.google.com"");
67         checkImagePresenter(1234);
70     public void testGlideDoesNotReplacePresenters() {
71         Glide.load(new File(""fake"")).into(imageView).begin();
72 
75         Glide.load(new File(""fake2"")).into(imageView).begin();
76 
79         assertEquals(first, second);
82     public void testLoadingTwoDifferentTypesOfModelsThrows() {
83         Glide.load(new File(""fake"")).into(imageView).begin();
85         boolean thrown = false;
86         try {
87             Glide.load(new Integer(4)).into(imageView).begin();
88         } catch (ClassCastException e) {
89             thrown = true;
92         assertTrue(thrown);",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,8dcf3324d59efb354331f18089674fe1bcc3d4aa,"Cleaner and more efficient Glide api

Reduces the # of extraneous object allocations by
lazily creating objects only if a new presenter is
needed. Adds some metadata to view tags to
determine whether or not options for a view are
the same, so an existing presenter can be used
or have changed, so a new presenter has to be
created","@@ -100,12 +100,11 @@ public class FlickrPhotoList extends SherlockFragment implements PhotoViewer {
                 viewHolder = (ViewHolder) view.getTag();
             }
 
-            Glide.load(current)
-                    .into(viewHolder.imageView)
-                    .with(new FlickrModelLoader(getActivity()))
+            Glide.using(new FlickrModelLoader(getActivity()))
+                    .load(current)
                     .centerCrop()
                     .animate(R.anim.fade_in)
-                    .begin();
+                    .into(viewHolder.imageView);
 
             viewHolder.titleText.setText(current.title);
             return view;
","103             Glide.using(new FlickrModelLoader(getActivity()))
104                     .load(current)
107                     .into(viewHolder.imageView);
103             Glide.load(current)
104                     .into(viewHolder.imageView)
105                     .with(new FlickrModelLoader(getActivity()))
108                     .begin();",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,7734c982edba8a11d04b1e3d2488b419de685ab8,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,DrawableLoader -> ResourceLoader,"@@ -8,7 +8,7 @@ import android.widget.ImageView;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
-import com.bumptech.glide.loader.model.DrawableLoader;
+import com.bumptech.glide.loader.model.ResourceLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.model.StringLoader;
@@ -211,7 +211,7 @@ public class Glide {
     }
 
     /**
-     * Use {@link DrawableLoader} to load the given model
+     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model
      *
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
@@ -279,12 +279,12 @@ public class Glide {
     private static final ModelLoaderFactory<Integer> resourceLoaderFactory = new ModelLoaderFactory<Integer>() {
         @Override
         public ModelLoader<Integer> build(Context context) {
-            return new DrawableLoader(context);
+            return new ResourceLoader(context);
         }
 
         @Override
         public Class<? extends ModelLoader<Integer>> loaderClass() {
-            return DrawableLoader.class;
+            return ResourceLoader.class;
         }
     };
 
","11 import com.bumptech.glide.loader.model.ResourceLoader;
214      * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model
282             return new ResourceLoader(context);
287             return ResourceLoader.class;
11 import com.bumptech.glide.loader.model.DrawableLoader;
214      * Use {@link DrawableLoader} to load the given model
282             return new DrawableLoader(context);
287             return DrawableLoader.class;",No
library\src\com\bumptech\glide\loader\model\DrawableLoader.java,library\src\com\bumptech\glide\loader\model\ResourceLoader.java,7734c982edba8a11d04b1e3d2488b419de685ab8,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,DrawableLoader -> ResourceLoader,"@@ -9,10 +9,10 @@ import com.bumptech.glide.loader.stream.StreamLoader;
  * A model loader for handling resources. Model must be a resource id in the package of
  * the given context.
  */
-public class DrawableLoader implements ModelLoader<Integer> {
+public class ResourceLoader implements ModelLoader<Integer> {
     private final Context context;
 
-    public DrawableLoader(Context context) {
+    public ResourceLoader(Context context) {
         this.context = context;
     }
 
","12 public class ResourceLoader implements ModelLoader<Integer> {
15     public ResourceLoader(Context context) {
12 public class DrawableLoader implements ModelLoader<Integer> {
15     public DrawableLoader(Context context) {",No
library\tests\src\com\bumptech\glide\loader\DrawableLoaderTest.java,library\tests\src\com\bumptech\glide\loader\ResourceLoaderTest.java,7734c982edba8a11d04b1e3d2488b419de685ab8,b1ef5cd4b890c9f5020f3f9a03f2bd24a2084d42,DrawableLoader -> ResourceLoader,"@@ -3,7 +3,7 @@ package com.bumptech.glide.loader;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.test.ActivityTestCase;
-import com.bumptech.glide.loader.model.DrawableLoader;
+import com.bumptech.glide.loader.model.ResourceLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.tests.R;
 
@@ -16,7 +16,7 @@ import java.io.InputStream;
  * Time: 11:13 PM
  * To change this template use File | Settings | File Templates.
  */
-public class DrawableLoaderTest extends ActivityTestCase {
+public class ResourceLoaderTest extends ActivityTestCase {
     private boolean cbCalled;
 
     @Override
@@ -26,8 +26,8 @@ public class DrawableLoaderTest extends ActivityTestCase {
     }
 
     public void testCanHandleId() {
-        DrawableLoader drawableLoader = new DrawableLoader(getInstrumentation().getContext());
-        StreamLoader streamLoader = drawableLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);
+        ResourceLoader resourceLoader = new ResourceLoader(getInstrumentation().getContext());
+        StreamLoader streamLoader = resourceLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);
         streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
             @Override
             public void onStreamReady(InputStream is) {
","6 import com.bumptech.glide.loader.model.ResourceLoader;
19 public class ResourceLoaderTest extends ActivityTestCase {
29         ResourceLoader resourceLoader = new ResourceLoader(getInstrumentation().getContext());
30         StreamLoader streamLoader = resourceLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);
6 import com.bumptech.glide.loader.model.DrawableLoader;
19 public class DrawableLoaderTest extends ActivityTestCase {
29         DrawableLoader drawableLoader = new DrawableLoader(getInstrumentation().getContext());
30         StreamLoader streamLoader = drawableLoader.getStreamLoader(R.raw.ic_launcher, 0, 0);",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,a27890fab33e5e12ecef00ef06f6b0daf2bf78a0,7734c982edba8a11d04b1e3d2488b419de685ab8,"Remove generics from ImagePresenterCoordinator

No reason why it can't coordinate presenters for
different types of models","@@ -182,7 +182,7 @@ public class ImagePresenter<T> {
          * @param coordinator The coordinator to set
          * @return This Builder object
          */
-        public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator<T> coordinator) {
+        public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator coordinator) {
             this.coordinator = coordinator;
             return this;
         }
@@ -220,10 +220,8 @@ public class ImagePresenter<T> {
 
     /**
      * An interface used to coordinate multiple {@link ImagePresenter} objects acting on the same view
-     *
-     * @param <T> The type of the {@link ImagePresenter} objects the implementation will be acting on
      */
-    public interface ImagePresenterCoordinator<T> {
+    public interface ImagePresenterCoordinator {
 
         /**
          * Determines if a presenter can display a loaded bitmap
@@ -231,7 +229,7 @@ public class ImagePresenter<T> {
          * @param presenter The presenter requesting permission to display a bitmap
          * @return True iff the presenter can display a bitmap
          */
-        public boolean canSetImage(ImagePresenter<T> presenter);
+        public boolean canSetImage(ImagePresenter presenter);
 
         /**
          * Determines if a presenter can display a placeholder
@@ -239,7 +237,7 @@ public class ImagePresenter<T> {
          * @param presenter The presenter requesting permission to display a placeholder
          * @return True iff the presenter can display a placeholder
          */
-        public boolean canSetPlaceholder(ImagePresenter<T> presenter);
+        public boolean canSetPlaceholder(ImagePresenter presenter);
     }
 
     /**
","185         public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator coordinator) {
224     public interface ImagePresenterCoordinator {
232         public boolean canSetImage(ImagePresenter presenter);
240         public boolean canSetPlaceholder(ImagePresenter presenter);
185         public Builder<T> setImagePresenterCoordinator(ImagePresenterCoordinator<T> coordinator) {
223      *
224      * @param <T> The type of the {@link ImagePresenter} objects the implementation will be acting on
226     public interface ImagePresenterCoordinator<T> {
234         public boolean canSetImage(ImagePresenter<T> presenter);
242         public boolean canSetPlaceholder(ImagePresenter<T> presenter);",No
library\src\com\bumptech\glide\presenter\ThumbImagePresenter.java,library\src\com\bumptech\glide\presenter\ThumbImagePresenter.java,a27890fab33e5e12ecef00ef06f6b0daf2bf78a0,7734c982edba8a11d04b1e3d2488b419de685ab8,"Remove generics from ImagePresenterCoordinator

No reason why it can't coordinate presenters for
different types of models","@@ -13,9 +13,9 @@ import android.widget.ImageView;
  * cached), then the thumbnail load is started. If the thumbnail load does not return synchronously, the placeholder
  * image is shown. If the thumbnail load completes before the image load (expected in most cases), the thumbnail is
  * shown until the image load completes. If the image load completes first, the thumbnail will never be shown.
- *
  */
-public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoordinator<T> {
+@SuppressWarnings(""unused"")
+public class ThumbImagePresenter<A, B> implements ImagePresenter.ImagePresenterCoordinator {
 
     /**
      * A builder for a {@link ThumbImagePresenter}. Has a few convenience methods to avoid identical calls on both
@@ -23,17 +23,17 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
      * {@link Builder ThumbImagePresenter.Builder#setThumbPresenterBuilder}, and
      * {@link Builder ThumbImagePresenter.Builder#setImageView} are required.
      *
-     * @param <T> The type of the model that the full and thumb presenters require to load a path and an image for that
-     *           path
+     * @param <A> The type of the model that the full {@link ImagePresenter} requires
+     * @param <B> The type of the model that the thumb {@link ImagePresenter} requires
      */
-    public static class Builder<T> {
-        private ImagePresenter.Builder<T> fullPresenterBuilder;
-        private ImagePresenter.Builder<T> thumbPresenterBuilder;
+    public static class Builder<A, B> {
+        private ImagePresenter.Builder<A> fullPresenterBuilder;
+        private ImagePresenter.Builder<B> thumbPresenterBuilder;
         private ImageView imageView;
         private Drawable placeholderDrawable;
         private int placeholderResourceId;
 
-        public ThumbImagePresenter<T> build(){
+        public ThumbImagePresenter<A, B> build(){
             if (fullPresenterBuilder == null) {
                 throw new IllegalArgumentException(""you must include a builder for the full image presenter"");
             }
@@ -44,7 +44,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
                 throw new IllegalArgumentException(""cannot create presenter without an image view"");
             }
 
-            return new ThumbImagePresenter<T>(this);
+            return new ThumbImagePresenter<A, B>(this);
         }
 
         /**
@@ -54,7 +54,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
          *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
          * @return This builder object
          */
-        public Builder<T> setFullPresenterBuilder(ImagePresenter.Builder<T> builder) {
+        public Builder<A, B> setFullPresenterBuilder(ImagePresenter.Builder<A> builder) {
             this.fullPresenterBuilder = builder;
             return this;
         }
@@ -66,7 +66,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
          *                and {@link ImagePresenter.Builder ImagePresenter.Builder#setImageLoader} must have been called
          * @return This builder object
          */
-        public Builder<T> setThumbPresenterBuilder(ImagePresenter.Builder<T> builder) {
+        public Builder<A, B> setThumbPresenterBuilder(ImagePresenter.Builder<B> builder) {
             this.thumbPresenterBuilder = builder;
             return this;
         }
@@ -74,7 +74,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         /**
          * @see ImagePresenter.Builder ImagePresenter.Builder#setImageView
          */
-        public Builder<T> setImageView(ImageView imageView) {
+        public Builder<A, B> setImageView(ImageView imageView) {
             this.imageView = imageView;
             return this;
         }
@@ -82,7 +82,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         /**
          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderDrawable
          */
-        public Builder<T> setPlaceholderDrawable(Drawable drawable) {
+        public Builder<A, B> setPlaceholderDrawable(Drawable drawable) {
             if (drawable != null && this.placeholderResourceId != 0) {
                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
             }
@@ -94,7 +94,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         /**
          * @see ImagePresenter.Builder ImagePresenter.Builder#setPlaceholderResource
          */
-        public Builder<T> setPlaceholderResource(int resourceId) {
+        public Builder<A, B> setPlaceholderResource(int resourceId) {
             if (resourceId != 0 && placeholderDrawable != null) {
                 throw new IllegalArgumentException(""Can't set both a placeholder drawable and a placeholder resource"");
             }
@@ -104,10 +104,10 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
         }
     }
 
-    private final ImagePresenter<T> fullPresenter;
-    private final ImagePresenter<T> thumbPresenter;
+    private final ImagePresenter<A> fullPresenter;
+    private final ImagePresenter<B> thumbPresenter;
 
-    private ThumbImagePresenter(Builder<T> builder) {
+    private ThumbImagePresenter(Builder<A, B> builder) {
         fullPresenter = builder.fullPresenterBuilder
                 .setImagePresenterCoordinator(this)
                 .setImageView(builder.imageView)
@@ -129,7 +129,7 @@ public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoor
      *
      * @see ImagePresenter#setModel(Object)
      */
-    public void setModels(T fullModel, T thumbModel) {
+    public void setModels(A fullModel, B thumbModel) {
         fullPresenter.setModel(fullModel);
         if (!fullPresenter.isImageSet()) {
             thumbPresenter.setModel(thumbModel);
","17 @SuppressWarnings(""unused"")
18 public class ThumbImagePresenter<A, B> implements ImagePresenter.ImagePresenterCoordinator {
26      * @param <A> The type of the model that the full {@link ImagePresenter} requires
27      * @param <B> The type of the model that the thumb {@link ImagePresenter} requires
29     public static class Builder<A, B> {
30         private ImagePresenter.Builder<A> fullPresenterBuilder;
31         private ImagePresenter.Builder<B> thumbPresenterBuilder;
36         public ThumbImagePresenter<A, B> build(){
47             return new ThumbImagePresenter<A, B>(this);
57         public Builder<A, B> setFullPresenterBuilder(ImagePresenter.Builder<A> builder) {
69         public Builder<A, B> setThumbPresenterBuilder(ImagePresenter.Builder<B> builder) {
77         public Builder<A, B> setImageView(ImageView imageView) {
85         public Builder<A, B> setPlaceholderDrawable(Drawable drawable) {
97         public Builder<A, B> setPlaceholderResource(int resourceId) {
107     private final ImagePresenter<A> fullPresenter;
108     private final ImagePresenter<B> thumbPresenter;
110     private ThumbImagePresenter(Builder<A, B> builder) {
132     public void setModels(A fullModel, B thumbModel) {
16  *
18 public class ThumbImagePresenter<T> implements ImagePresenter.ImagePresenterCoordinator<T> {
26      * @param <T> The type of the model that the full and thumb presenters require to load a path and an image for that
27      *           path
29     public static class Builder<T> {
30         private ImagePresenter.Builder<T> fullPresenterBuilder;
31         private ImagePresenter.Builder<T> thumbPresenterBuilder;
36         public ThumbImagePresenter<T> build(){
47             return new ThumbImagePresenter<T>(this);
57         public Builder<T> setFullPresenterBuilder(ImagePresenter.Builder<T> builder) {
69         public Builder<T> setThumbPresenterBuilder(ImagePresenter.Builder<T> builder) {
77         public Builder<T> setImageView(ImageView imageView) {
85         public Builder<T> setPlaceholderDrawable(Drawable drawable) {
97         public Builder<T> setPlaceholderResource(int resourceId) {
107     private final ImagePresenter<T> fullPresenter;
108     private final ImagePresenter<T> thumbPresenter;
110     private ThumbImagePresenter(Builder<T> builder) {
132     public void setModels(T fullModel, T thumbModel) {",No
library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,library\src\com\bumptech\glide\resize\RecyclableBufferedInputStream.java,823b3dfe54d050bfbd52e1868973ad1ffb394749,a27890fab33e5e12ecef00ef06f6b0daf2bf78a0,Remove misleading constructors from RecycleableBIS,"@@ -71,36 +71,6 @@ public class RecyclableBufferedInputStream extends FilterInputStream {
      */
     protected int pos;
 
-    /**
-     * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer
-     * of 8192 bytes.
-     *
-     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
-     * {@code BufferedInputStream}. All read operations on such a stream will
-     * fail with an IOException.
-     *
-     * @param in the {@code InputStream} the buffer reads from.
-     */
-    public RecyclableBufferedInputStream(InputStream in) {
-        this(in, 8192);
-    }
-
-    /**
-     * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes
-     * of buffer.
-     *
-     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
-     * {@code BufferedInputStream}. All read operations on such a stream will
-     * fail with an IOException.
-     *
-     * @param in the {@code InputStream} the buffer reads from.
-     * @param size the size of buffer in bytes.
-     * @throws IllegalArgumentException if {@code size &lt;= 0}.
-     */
-    public RecyclableBufferedInputStream(InputStream in, int size) {
-        this(in, new byte[size]);
-    }
-
     public RecyclableBufferedInputStream(InputStream in, byte[] buffer) {
         super(in);
         if (buffer == null || buffer.length == 0) {
","74     /**
75      * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer
76      * of 8192 bytes.
77      *
78      * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
79      * {@code BufferedInputStream}. All read operations on such a stream will
80      * fail with an IOException.
81      *
82      * @param in the {@code InputStream} the buffer reads from.
83      */
84     public RecyclableBufferedInputStream(InputStream in) {
85         this(in, 8192);
86     }
87 
88     /**
89      * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes
90      * of buffer.
91      *
92      * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed
93      * {@code BufferedInputStream}. All read operations on such a stream will
94      * fail with an IOException.
95      *
96      * @param in the {@code InputStream} the buffer reads from.
97      * @param size the size of buffer in bytes.
98      * @throws IllegalArgumentException if {@code size &lt;= 0}.
99      */
100     public RecyclableBufferedInputStream(InputStream in, int size) {
101         this(in, new byte[size]);
102     }
103 ",No
library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,9d3c7b20ae60ddca62a1a98e88995bb5606b521a,823b3dfe54d050bfbd52e1868973ad1ffb394749,"Call cb in background in VolleyStreamLoader

This means our code in the cb will run on a
background thread. Though all we do is post to a
thread pool, this change means we don't need to
acquire that lock on the main thread.","@@ -23,30 +23,30 @@ public class VolleyStreamLoader implements StreamLoader {
 
     @Override
     public void loadStream(final StreamReadyCallback cb) {
-        current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url, new Response.ErrorListener() {
+        current = requestQueue.add(new Request<Void>(Request.Method.GET, url, new Response.ErrorListener() {
             @Override
             public void onErrorResponse(VolleyError error) {
                 cb.onException(error);
             }
         }) {
             @Override
-            protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
-                //this may be less than ideal, since we can't downsample the image as it is read,
-                //but we don't have a choice if we want to use Volley
-                return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
+            protected Response<Void> parseNetworkResponse(NetworkResponse response) {
+                //We actually are going to do the parsing in the callback, so we we're going to call it here where it
+                // will be executed on a background thread.
+                cb.onStreamReady(new ByteArrayInputStream(response.data));
+                return Response.success(null, getCacheEntry());
             }
 
             @Override
-            protected void deliverResponse(ByteArrayInputStream response) {
-                cb.onStreamReady(response);
-            }
+            protected void deliverResponse(Void response) { }
         });
     }
 
     @Override
     public void cancel() {
-        if (current != null) {
-            current.cancel();
+        final Request local = current;
+        if (local != null) {
+            local.cancel();
             current = null;
         }
     }
","26         current = requestQueue.add(new Request<Void>(Request.Method.GET, url, new Response.ErrorListener() {
33             protected Response<Void> parseNetworkResponse(NetworkResponse response) {
34                 //We actually are going to do the parsing in the callback, so we we're going to call it here where it
35                 // will be executed on a background thread.
36                 cb.onStreamReady(new ByteArrayInputStream(response.data));
37                 return Response.success(null, getCacheEntry());
41             protected void deliverResponse(Void response) { }
47         final Request local = current;
48         if (local != null) {
49             local.cancel();
26         current = requestQueue.add(new Request<ByteArrayInputStream>(Request.Method.GET, url, new Response.ErrorListener() {
33             protected Response<ByteArrayInputStream> parseNetworkResponse(NetworkResponse response) {
34                 //this may be less than ideal, since we can't downsample the image as it is read,
35                 //but we don't have a choice if we want to use Volley
36                 return Response.success(new ByteArrayInputStream(response.data), getCacheEntry());
40             protected void deliverResponse(ByteArrayInputStream response) {
41                 cb.onStreamReady(response);
42             }
48         if (current != null) {
49             current.cancel();",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,eb30abc2c999b3652823154b74c34a2b3351ce35,9d3c7b20ae60ddca62a1a98e88995bb5606b521a,"Increase Bitmap compression in flickr sample

Increases # of images that will fit into cache","@@ -85,7 +85,9 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         final Glide glide = Glide.get();
         if (!glide.isImageManagerSet()) {
             glide.setImageManager(new ImageManager.Builder(this)
+                    .setBitmapCompressQuality(70)
                     .setDiskCache(diskCache));
+
         }
 
         searching = findViewById(R.id.searching);
","88                     .setBitmapCompressQuality(70)
90 ",No
README.md,README.md,340b387521de3138bfbdf013c53f5a81a737fe5d,eb30abc2c999b3652823154b74c34a2b3351ce35,Updated readme,"@@ -1,37 +1,52 @@
 Glide
 =====
-Glide is an all in one image download and resizing library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
+Glide is a view centric image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap reuse into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
 
-Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
+Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image in a view.
 
 How do I use Glide?
 -------------------
-The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 1.0+ will also be available via a link on the wiki.
+The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 2.0+ will also be available via a link on the wiki.
 
 Simple use cases will look something like this:
 
 ```Java
 
+//For a simple view:
+@Override
+public void onCreate(Bundle savedInstanceState) {
+    ...
+
+    ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
+
+    Glide.load(""http://goo.gl/h8qOq7"").into(imageView);
+}
+
+//For a list:
 @Override
 public View getView(int position, View recycled, ViewGroup container) {
-    final ImageView myImageView;
     if (recycled == null) {
         myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
     } else {
         myImageView = (ImageView) recycled);
     }
 
-    URL myUrl = myUrls.get(position);
+    String url = myUrls.get(position);
 
-    Glide.load(myUrl).into(myImageView).centerCrop().animate(R.anim.fade_in).begin();
+    Glide.load(url)
+        .centerCrop()
+        .placeholder(R.drawable.loading_spinner)
+        .animate(R.anim.fade_in)
+        .into(myImageView);
 
     return myImageView;
 }
+
 ```
 
 Status
 ------
-Glide has been in use at Bump for about six months in two of our Android apps. The API after 1.0 is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!
+Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is in progress and will include a more general and easier to use interface. After version 2.0 the api will be stable and any outdated apis will first be deprecated before being removed. That being said, the 2.0+ api is definitely a work in progress and new functionality will probably be added in intermediate versions. Comments/bugs/questions/pull requests welcome!
 
 Thanks
 ------
","3 Glide is a view centric image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap reuse into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image in a view.
9 The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 2.0+ will also be available via a link on the wiki.
15 //For a simple view:
16 @Override
17 public void onCreate(Bundle savedInstanceState) {
18     ...
19 
20     ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
21 
22     Glide.load(""http://goo.gl/h8qOq7"").into(imageView);
23 }
24 
25 //For a list:
34     String url = myUrls.get(position);
36     Glide.load(url)
37         .centerCrop()
38         .placeholder(R.drawable.loading_spinner)
39         .animate(R.anim.fade_in)
40         .into(myImageView);
44 
49 Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is in progress and will include a more general and easier to use interface. After version 2.0 the api will be stable and any outdated apis will first be deprecated before being removed. That being said, the 2.0+ api is definitely a work in progress and new functionality will probably be added in intermediate versions. Comments/bugs/questions/pull requests welcome!
3 Glide is an all in one image download and resizing library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image.
9 The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 1.0+ will also be available via a link on the wiki.
17     final ImageView myImageView;
24     URL myUrl = myUrls.get(position);
26     Glide.load(myUrl).into(myImageView).centerCrop().animate(R.anim.fade_in).begin();
34 Glide has been in use at Bump for about six months in two of our Android apps. The API after 1.0 is mostly stable though there may be some superficial changes. Comments/bugs/questions/pull requests welcome!",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,340b387521de3138bfbdf013c53f5a81a737fe5d,ImageSetCallback -> ImageReadyCallback,"@@ -15,7 +15,7 @@ import com.bumptech.glide.loader.model.StringLoader;
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageSetCallback;
+import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.loader.Approximate;
 import com.bumptech.glide.resize.loader.CenterCrop;
@@ -485,9 +485,9 @@ public class Glide {
 
             if (animationId != -1) {
                 final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
-                builder.setImageSetCallback(new ImageSetCallback() {
+                builder.setImageReadyCallback(new ImageReadyCallback() {
                     @Override
-                    public void onImageSet(ImageView view, boolean fromCache) {
+                    public void onImageReady(ImageView view, boolean fromCache) {
                         view.clearAnimation();
 
                         if (!fromCache) {
","18 import com.bumptech.glide.presenter.ImageReadyCallback;
488                 builder.setImageReadyCallback(new ImageReadyCallback() {
490                     public void onImageReady(ImageView view, boolean fromCache) {
18 import com.bumptech.glide.presenter.ImageSetCallback;
488                 builder.setImageSetCallback(new ImageSetCallback() {
490                     public void onImageSet(ImageView view, boolean fromCache) {",No
library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,340b387521de3138bfbdf013c53f5a81a737fe5d,ImageSetCallback -> ImageReadyCallback,"@@ -40,7 +40,7 @@ public abstract class BaseImageLoader implements ImageLoader {
     /**
      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
      * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
-     * an image is displayed. See {@link com.bumptech.glide.presenter.ImageSetCallback} instead to make a visual change
+     * an image is displayed. See {@link com.bumptech.glide.presenter.ImageReadyCallback} instead to make a visual change
      * when a load completes.
      *
      * @param id The unique id of the image
","43      * an image is displayed. See {@link com.bumptech.glide.presenter.ImageReadyCallback} instead to make a visual change
43      * an image is displayed. See {@link com.bumptech.glide.presenter.ImageSetCallback} instead to make a visual change",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,340b387521de3138bfbdf013c53f5a81a737fe5d,ImageSetCallback -> ImageReadyCallback,"@@ -50,7 +50,7 @@ public class ImagePresenter<T> {
         private ImageView imageView;
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
-        private ImageSetCallback imageSetCallback;
+        private ImageReadyCallback imageReadyCallback;
         private ImagePresenterCoordinator coordinator;
         private ImageLoader imageLoader;
         private ExceptionHandler<T> exceptionHandler = new ExceptionHandler<T>() {
@@ -170,8 +170,8 @@ public class ImagePresenter<T> {
          * @param cb The callback to call
          * @return This Builder object
          */
-        public Builder<T> setImageSetCallback(ImageSetCallback cb) {
-            this.imageSetCallback = cb;
+        public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {
+            this.imageReadyCallback = cb;
             return this;
         }
 
@@ -206,7 +206,7 @@ public class ImagePresenter<T> {
     private final ModelLoader<T> modelLoader;
     private final ImageLoader imageLoader;
     private final Drawable placeholderDrawable;
-    private final ImageSetCallback imageSetCallback;
+    private final ImageReadyCallback imageReadyCallback;
     private final ImagePresenterCoordinator coordinator;
     private final ExceptionHandler<T> exceptionHandler;
     private final ImageView imageView;
@@ -278,7 +278,7 @@ public class ImagePresenter<T> {
             this.placeholderDrawable = builder.placeholderDrawable;
         }
         this.coordinator = builder.coordinator;
-        this.imageSetCallback = builder.imageSetCallback;
+        this.imageReadyCallback = builder.imageReadyCallback;
         this.exceptionHandler = builder.exceptionHandler;
         this.modelLoader = builder.modelLoader;
         sizeDeterminer = new SizeDeterminer(imageView);
@@ -375,8 +375,8 @@ public class ImagePresenter<T> {
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
 
-                if (imageSetCallback != null)
-                    imageSetCallback.onImageSet(imageView, loadedFromCache);
+                if (imageReadyCallback != null)
+                    imageReadyCallback.onImageReady(imageView, loadedFromCache);
                 imageView.setImageBitmap(image);
                 isImageSet = true;
                 return true;
","53         private ImageReadyCallback imageReadyCallback;
173         public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {
174             this.imageReadyCallback = cb;
209     private final ImageReadyCallback imageReadyCallback;
281         this.imageReadyCallback = builder.imageReadyCallback;
378                 if (imageReadyCallback != null)
379                     imageReadyCallback.onImageReady(imageView, loadedFromCache);
53         private ImageSetCallback imageSetCallback;
173         public Builder<T> setImageSetCallback(ImageSetCallback cb) {
174             this.imageSetCallback = cb;
209     private final ImageSetCallback imageSetCallback;
281         this.imageSetCallback = builder.imageSetCallback;
378                 if (imageSetCallback != null)
379                     imageSetCallback.onImageSet(imageView, loadedFromCache);",No
library\src\com\bumptech\glide\presenter\ImageSetCallback.java,library\src\com\bumptech\glide\presenter\ImageReadyCallback.java,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,340b387521de3138bfbdf013c53f5a81a737fe5d,ImageSetCallback -> ImageReadyCallback,"@@ -7,16 +7,16 @@ package com.bumptech.glide.presenter;
 import android.widget.ImageView;
 
 /**
- * A callback interface used to perform some action when an {@link ImagePresenter} sets an
- * {@link android.widget.ImageView} object's bitmap
+ * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an
+ * {@link android.widget.ImageView}
  */
-public interface ImageSetCallback {
+public interface ImageReadyCallback {
 
     /**
      * The method called when a bitmap is set
      *
      * @param view The view that will display the bitmap
-     * @param fromCache True iff the bitmap load completed without a placeholder being shown.
+     * @param fromCache True iff the load completed without a placeholder being shown.
      */
-    public void onImageSet(ImageView view, boolean fromCache);
+    public void onImageReady(ImageView view, boolean fromCache);
 }
","10  * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an
11  * {@link android.widget.ImageView}
13 public interface ImageReadyCallback {
19      * @param fromCache True iff the load completed without a placeholder being shown.
21     public void onImageReady(ImageView view, boolean fromCache);
10  * A callback interface used to perform some action when an {@link ImagePresenter} sets an
11  * {@link android.widget.ImageView} object's bitmap
13 public interface ImageSetCallback {
19      * @param fromCache True iff the bitmap load completed without a placeholder being shown.
21     public void onImageSet(ImageView view, boolean fromCache);",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,340b387521de3138bfbdf013c53f5a81a737fe5d,ImageSetCallback -> ImageReadyCallback,"@@ -13,7 +13,7 @@ import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageSetCallback;
+import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.resize.loader.CenterCrop;
 
 import java.io.File;
@@ -114,9 +114,9 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                         .setImageView(imageView)
                         .setModelLoader(new FlickrModelLoader(context))
                         .setImageLoader(new CenterCrop(context))
-                        .setImageSetCallback(new ImageSetCallback() {
+                        .setImageReadyCallback(new ImageReadyCallback() {
                             @Override
-                            public void onImageSet(ImageView view, boolean fromCache) {
+                            public void onImageReady(ImageView view, boolean fromCache) {
                                 view.clearAnimation();
 
                                 if (!fromCache) {
","16 import com.bumptech.glide.presenter.ImageReadyCallback;
117                         .setImageReadyCallback(new ImageReadyCallback() {
119                             public void onImageReady(ImageView view, boolean fromCache) {
16 import com.bumptech.glide.presenter.ImageSetCallback;
117                         .setImageSetCallback(new ImageSetCallback() {
119                             public void onImageSet(ImageView view, boolean fromCache) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,a10ff7ac7daea777368d642c5b0bf400000deed4,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,Add an error placeholder,"@@ -346,6 +346,7 @@ public class Glide {
 
         private int animationId = -1;
         private int placeholderId = -1;
+        private int errorId = -1;
         private ResizeOption resizeOption = ResizeOption.APPROXIMATE;
         private ImageLoader imageLoader = null;
 
@@ -427,7 +428,7 @@ public class Glide {
         }
 
         /**
-         * Sets a drawable to display while an image is loading
+         * Sets a resource to display while an image is loading
          *
          * @param resourceId The id of the resource to use as a placeholder
          * @return This Request
@@ -438,6 +439,18 @@ public class Glide {
             return this;
         }
 
+        /**
+         * Sets a resource to display if a load fails
+         *
+         * @param resourceId The id of the resource to use as a placeholder
+         * @return This request
+         */
+        public Request<T> error(int resourceId) {
+            this.errorId = resourceId;
+
+            return this;
+        }
+
         /**
          * Creates an {@link ImagePresenter} or retrieves the existing one and starts loading the image represented by
          * the given model. This must be called on the main thread.
@@ -502,6 +515,11 @@ public class Glide {
                 builder.setPlaceholderResource(placeholderId);
             }
 
+
+            if (errorId != -1) {
+                builder.setErrorResource(errorId);
+            }
+
             return builder.build();
         }
 
@@ -553,6 +571,7 @@ public class Glide {
             public final Class imageLoaderClass;
             public final int animationId;
             public final int placeholderId;
+            public final int errorId;
 
             public Metadata(Request request) {
                 modelClass = request.model.getClass();
@@ -576,6 +595,7 @@ public class Glide {
                 }
                 animationId = request.animationId;
                 placeholderId = request.placeholderId;
+                errorId = request.errorId;
             }
 
             @Override
@@ -590,7 +610,8 @@ public class Glide {
                         modelLoaderClass.equals(other.modelLoaderClass) &&
                         imageLoaderClass.equals(other.imageLoaderClass) &&
                         animationId == other.animationId &&
-                        placeholderId == other.placeholderId;
+                        placeholderId == other.placeholderId &&
+                        errorId == other.errorId;
 
             }
         }
","349         private int errorId = -1;
431          * Sets a resource to display while an image is loading
442         /**
443          * Sets a resource to display if a load fails
444          *
445          * @param resourceId The id of the resource to use as a placeholder
446          * @return This request
447          */
448         public Request<T> error(int resourceId) {
449             this.errorId = resourceId;
450 
451             return this;
452         }
453 
518 
519             if (errorId != -1) {
520                 builder.setErrorResource(errorId);
521             }
522 
574             public final int errorId;
598                 errorId = request.errorId;
613                         placeholderId == other.placeholderId &&
614                         errorId == other.errorId;
430          * Sets a drawable to display while an image is loading
593                         placeholderId == other.placeholderId;",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,a10ff7ac7daea777368d642c5b0bf400000deed4,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,Add an error placeholder,"@@ -4,6 +4,7 @@
 
 package com.bumptech.glide.presenter;
 
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
@@ -33,6 +34,8 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
+    private final Drawable errorDrawable;
+
     /**
      * A builder for an {@link ImagePresenter}.
      *
@@ -65,6 +68,8 @@ public class ImagePresenter<T> {
         };
 
         private ModelLoader<T> modelLoader;
+        private int errorResourceId;
+        private Drawable errorDrawable;
 
         /**
          * Builds an ImagePresenter.
@@ -162,6 +167,38 @@ public class ImagePresenter<T> {
             return this;
         }
 
+        /**
+         * Optional - Sets a resource that will be displayed whenever a load fails. Only call either this method
+         * or {@link #setErrorDrawable(android.graphics.drawable.Drawable)}, not both.
+         *
+         * @param resourceId The id of the resource to show
+         * @return This Builder object
+         */
+        public Builder<T> setErrorResource(int resourceId) {
+            if (resourceId != 0 && errorDrawable != null) {
+                throw new IllegalArgumentException(""Can't set both an error drawable and an error resource"");
+            }
+
+            this.errorResourceId = resourceId;
+            return this;
+        }
+
+        /**
+         * Optional - Sets a drawable that will be displayed whenever a load fails. Only call either this or
+         * {@link #setErrorResource(int)}, not both.
+         *
+         * @param drawable The drawable to show
+         * @return This Builder object
+         */
+        public Builder<T> setErrorDrawable(Drawable drawable) {
+            if (errorResourceId != -1 && drawable != null) {
+                throw new IllegalArgumentException(""Can't set both an error drawable and an error resource"");
+            }
+
+            this.errorDrawable = drawable;
+            return this;
+        }
+
         /**
          * Optional - Sets a callback that will be called after an image is loaded by
          * {@link com.bumptech.glide.loader.image.ImageLoader} and immediately before
@@ -272,11 +309,19 @@ public class ImagePresenter<T> {
     protected ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
+
+        final Resources res = imageView.getResources();
         if (builder.placeholderResourceId != 0) {
-            this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
+            this.placeholderDrawable = res.getDrawable(builder.placeholderResourceId);
         } else {
             this.placeholderDrawable = builder.placeholderDrawable;
         }
+        if (builder.errorResourceId != 0){
+            this.errorDrawable = res.getDrawable(builder.errorResourceId);
+        } else {
+            this.errorDrawable = builder.errorDrawable;
+        }
+
         this.coordinator = builder.coordinator;
         this.imageReadyCallback = builder.imageReadyCallback;
         this.exceptionHandler = builder.exceptionHandler;
@@ -384,8 +429,12 @@ public class ImagePresenter<T> {
 
             @Override
             public void onException(Exception e) {
+                final boolean relevant = loadCount == currentCount;
                 if (exceptionHandler != null) {
-                    exceptionHandler.onException(e, model, loadCount == currentCount);
+                    exceptionHandler.onException(e, model, relevant);
+                }
+                if (relevant && canSetPlaceholder()) {
+                    imageView.setImageDrawable(errorDrawable);
                 }
             }
         });
","7 import android.content.res.Resources;
37     private final Drawable errorDrawable;
38 
71         private int errorResourceId;
72         private Drawable errorDrawable;
170         /**
171          * Optional - Sets a resource that will be displayed whenever a load fails. Only call either this method
172          * or {@link #setErrorDrawable(android.graphics.drawable.Drawable)}, not both.
173          *
174          * @param resourceId The id of the resource to show
175          * @return This Builder object
176          */
177         public Builder<T> setErrorResource(int resourceId) {
178             if (resourceId != 0 && errorDrawable != null) {
179                 throw new IllegalArgumentException(""Can't set both an error drawable and an error resource"");
180             }
181 
182             this.errorResourceId = resourceId;
183             return this;
184         }
185 
186         /**
187          * Optional - Sets a drawable that will be displayed whenever a load fails. Only call either this or
188          * {@link #setErrorResource(int)}, not both.
189          *
190          * @param drawable The drawable to show
191          * @return This Builder object
192          */
193         public Builder<T> setErrorDrawable(Drawable drawable) {
194             if (errorResourceId != -1 && drawable != null) {
195                 throw new IllegalArgumentException(""Can't set both an error drawable and an error resource"");
196             }
197 
198             this.errorDrawable = drawable;
199             return this;
200         }
201 
312 
313         final Resources res = imageView.getResources();
315             this.placeholderDrawable = res.getDrawable(builder.placeholderResourceId);
319         if (builder.errorResourceId != 0){
320             this.errorDrawable = res.getDrawable(builder.errorResourceId);
321         } else {
322             this.errorDrawable = builder.errorDrawable;
323         }
324 
432                 final boolean relevant = loadCount == currentCount;
434                     exceptionHandler.onException(e, model, relevant);
435                 }
436                 if (relevant && canSetPlaceholder()) {
437                     imageView.setImageDrawable(errorDrawable);
276             this.placeholderDrawable = imageView.getResources().getDrawable(builder.placeholderResourceId);
388                     exceptionHandler.onException(e, model, loadCount == currentCount);",No
library\tests\src\com\bumptech\glide\GlideTest.java,library\tests\src\com\bumptech\glide\GlideTest.java,a10ff7ac7daea777368d642c5b0bf400000deed4,a0d8c5119bb1350a0e26a861270f1b372cbcc90e,Add an error placeholder,"@@ -83,6 +83,7 @@ public class GlideTest extends ActivityTestCase {
                 .centerCrop()
                 .animate(android.R.anim.fade_in)
                 .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
+                .error(com.bumptech.glide.tests.R.raw.ic_launcher)
                 .into(imageView);
         ImagePresenter first = getImagePresenterFromView();
 
@@ -90,6 +91,7 @@ public class GlideTest extends ActivityTestCase {
                 .centerCrop()
                 .animate(android.R.anim.fade_in)
                 .placeholder(com.bumptech.glide.tests.R.raw.ic_launcher)
+                .error(com.bumptech.glide.tests.R.raw.ic_launcher)
                 .into(imageView);
         ImagePresenter second = getImagePresenterFromView();
 
@@ -189,7 +191,18 @@ public class GlideTest extends ActivityTestCase {
         Glide.load(file).animate(android.R.anim.fade_in).into(imageView);
         ImagePresenter first = ImagePresenter.getCurrent(imageView);
 
-        Glide.load(file).into(imageView);
+        Glide.load(file).animate(android.R.anim.fade_out).into(imageView);
+        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+
+        assertNotSame(first, second);
+    }
+
+    public void testDifferentErrorIdsReplacesPresenter() {
+        final File file = new File(""fake"");
+        Glide.load(file).error(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
+        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+
+        Glide.load(file).error(android.R.drawable.btn_star).into(imageView);
         ImagePresenter second = ImagePresenter.getCurrent(imageView);
 
         assertNotSame(first, second);
","86                 .error(com.bumptech.glide.tests.R.raw.ic_launcher)
94                 .error(com.bumptech.glide.tests.R.raw.ic_launcher)
194         Glide.load(file).animate(android.R.anim.fade_out).into(imageView);
195         ImagePresenter second = ImagePresenter.getCurrent(imageView);
196 
197         assertNotSame(first, second);
198     }
199 
200     public void testDifferentErrorIdsReplacesPresenter() {
201         final File file = new File(""fake"");
202         Glide.load(file).error(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
203         ImagePresenter first = ImagePresenter.getCurrent(imageView);
204 
205         Glide.load(file).error(android.R.drawable.btn_star).into(imageView);
192         Glide.load(file).into(imageView);",No
library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,d50efbfe3f305040ff0f1880238a1517ab7091c5,a10ff7ac7daea777368d642c5b0bf400000deed4,Allow VolleyModelLoader to set a retry policy,"@@ -1,7 +1,9 @@
 package com.bumptech.glide.loader.model;
 
 import android.content.Context;
+import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.RequestQueue;
+import com.android.volley.RetryPolicy;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.stream.VolleyStreamLoader;
@@ -29,7 +31,7 @@ public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
 
     @Override
     protected StreamLoader buildStreamLoader(T model, int width, int height) {
-        return new VolleyStreamLoader(requestQueue, getUrl(model, width, height));
+        return new VolleyStreamLoader(requestQueue, getUrl(model, width, height), getRetryPolicy());
     }
 
     /**
@@ -41,4 +43,8 @@ public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
      * @return A String url
      */
     protected abstract String getUrl(T model, int width, int height);
+
+    protected RetryPolicy getRetryPolicy() {
+        return new DefaultRetryPolicy();
+    }
 }
","4 import com.android.volley.DefaultRetryPolicy;
6 import com.android.volley.RetryPolicy;
34         return new VolleyStreamLoader(requestQueue, getUrl(model, width, height), getRetryPolicy());
46 
47     protected RetryPolicy getRetryPolicy() {
48         return new DefaultRetryPolicy();
49     }
32         return new VolleyStreamLoader(requestQueue, getUrl(model, width, height));",No
library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,d50efbfe3f305040ff0f1880238a1517ab7091c5,a10ff7ac7daea777368d642c5b0bf400000deed4,Allow VolleyModelLoader to set a retry policy,"@@ -1,9 +1,11 @@
 package com.bumptech.glide.loader.stream;
 
+import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
 import com.android.volley.Response;
+import com.android.volley.RetryPolicy;
 import com.android.volley.VolleyError;
 
 import java.io.ByteArrayInputStream;
@@ -14,40 +16,55 @@ import java.io.ByteArrayInputStream;
 public class VolleyStreamLoader implements StreamLoader {
     private final RequestQueue requestQueue;
     private final String url;
+    private final RetryPolicy retryPolicy;
     private Request current = null;
 
     public VolleyStreamLoader(RequestQueue requestQueue, String url) {
+        this(requestQueue, url, new DefaultRetryPolicy());
+    }
+
+    public VolleyStreamLoader(RequestQueue requestQueue, String url, RetryPolicy retryPolicy) {
         this.requestQueue = requestQueue;
         this.url = url;
+        this.retryPolicy = retryPolicy;
     }
 
     @Override
     public void loadStream(final StreamReadyCallback cb) {
-        current = requestQueue.add(new Request<Void>(Request.Method.GET, url, new Response.ErrorListener() {
+        Request<Void> request = new GlideRequest(url, cb);
+        request.setRetryPolicy(retryPolicy);
+        current = requestQueue.add(request);
+    }
+
+    @Override
+    public void cancel() {
+        final Request local = current;
+        if (local != null) {
+            local.cancel();
+            current = null;
+        }
+    }
+
+    private static class GlideRequest extends Request<Void> {
+        private final StreamReadyCallback cb;
+
+        public GlideRequest(String url, final StreamReadyCallback cb) {
+            super(Method.GET, url, new Response.ErrorListener() {
                 @Override
                 public void onErrorResponse(VolleyError error) {
                     cb.onException(error);
                 }
-        }) {
+            });
+            this.cb = cb;
+        }
+
         @Override
         protected Response<Void> parseNetworkResponse(NetworkResponse response) {
-                //We actually are going to do the parsing in the callback, so we we're going to call it here where it
-                // will be executed on a background thread.
             cb.onStreamReady(new ByteArrayInputStream(response.data));
             return Response.success(null, getCacheEntry());
         }
 
         @Override
         protected void deliverResponse(Void response) { }
-        });
-    }
-
-    @Override
-    public void cancel() {
-        final Request local = current;
-        if (local != null) {
-            local.cancel();
-            current = null;
-        }
     }
 }
","3 import com.android.volley.DefaultRetryPolicy;
8 import com.android.volley.RetryPolicy;
19     private final RetryPolicy retryPolicy;
23         this(requestQueue, url, new DefaultRetryPolicy());
24     }
25 
26     public VolleyStreamLoader(RequestQueue requestQueue, String url, RetryPolicy retryPolicy) {
29         this.retryPolicy = retryPolicy;
34         Request<Void> request = new GlideRequest(url, cb);
35         request.setRetryPolicy(retryPolicy);
36         current = requestQueue.add(request);
47 
48     private static class GlideRequest extends Request<Void> {
49         private final StreamReadyCallback cb;
50 
51         public GlideRequest(String url, final StreamReadyCallback cb) {
52             super(Method.GET, url, new Response.ErrorListener() {
53                 @Override
54                 public void onErrorResponse(VolleyError error) {
55                     cb.onException(error);
56                 }
57             });
58             this.cb = cb;
59         }
60 
61         @Override
62         protected Response<Void> parseNetworkResponse(NetworkResponse response) {
63             cb.onStreamReady(new ByteArrayInputStream(response.data));
64             return Response.success(null, getCacheEntry());
65         }
66 
67         @Override
68         protected void deliverResponse(Void response) { }
69     }
26         current = requestQueue.add(new Request<Void>(Request.Method.GET, url, new Response.ErrorListener() {
27             @Override
28             public void onErrorResponse(VolleyError error) {
29                 cb.onException(error);
30             }
31         }) {
32             @Override
33             protected Response<Void> parseNetworkResponse(NetworkResponse response) {
34                 //We actually are going to do the parsing in the callback, so we we're going to call it here where it
35                 // will be executed on a background thread.
36                 cb.onStreamReady(new ByteArrayInputStream(response.data));
37                 return Response.success(null, getCacheEntry());
38             }
39 
40             @Override
41             protected void deliverResponse(Void response) { }
42         });",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,78790c322a30ac2e62498b79bdc965832bf2342d,d50efbfe3f305040ff0f1880238a1517ab7091c5,Handle views with wrap_content set in Glide,"@@ -8,9 +8,9 @@ import android.widget.ImageView;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
-import com.bumptech.glide.loader.model.ResourceLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
+import com.bumptech.glide.loader.model.ResourceLoader;
 import com.bumptech.glide.loader.model.StringLoader;
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
@@ -18,12 +18,16 @@ import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.loader.Approximate;
+import com.bumptech.glide.resize.loader.AsIs;
 import com.bumptech.glide.resize.loader.CenterCrop;
 import com.bumptech.glide.resize.loader.FitCenter;
 
 import java.io.File;
+import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 
+import static android.view.ViewGroup.LayoutParams;
+
 /**
  * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
  * {@link ImageLoader} and {@link com.android.volley.RequestQueue}. This class provides most of the functionality of
@@ -337,6 +341,7 @@ public class Glide {
             APPROXIMATE,
             CENTER_CROP,
             FIT_CENTER,
+            AS_IS,
         }
 
         private ModelLoaderFactory<T> modelLoaderFactory;
@@ -347,7 +352,7 @@ public class Glide {
         private int animationId = -1;
         private int placeholderId = -1;
         private int errorId = -1;
-        private ResizeOption resizeOption = ResizeOption.APPROXIMATE;
+        private ResizeOption resizeOption = null;
         private ImageLoader imageLoader = null;
 
         public Request(T model) {
@@ -363,8 +368,7 @@ public class Glide {
         }
 
         /**
-         * Resize models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
-         * Replaces any existing resize style
+         * Resize models using {@link CenterCrop}. Replaces any existing resize style
          *
          * @return This Request
          */
@@ -376,8 +380,7 @@ public class Glide {
         }
 
         /**
-         * Resize models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
-         * Replaces any existing resize style
+         * Resize models using {@link FitCenter}. Replaces any existing resize style
          *
          * @return This Request
          */
@@ -389,8 +392,7 @@ public class Glide {
         }
 
         /**
-         * Resize models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
-         * Replaces any existing resize style
+         * Resize models using {@link Approximate}. Replaces any existing resize style
          *
          * @return This Request
          */
@@ -401,6 +403,19 @@ public class Glide {
             return this;
         }
 
+        /**
+         * Load images at their original size using {@link com.bumptech.glide.resize.loader.AsIs}. Replaces any existing
+         * resize style
+         *
+         * @return This Request
+         */
+        public Request<T> asIs() {
+            resizeOption = ResizeOption.AS_IS;
+            imageLoader = null;
+
+            return this;
+        }
+
         /**
          * Set the {@link ImageLoader} to use to load images into memory
          *
@@ -467,6 +482,8 @@ public class Glide {
          * the view's tag for the id {@code R.id.image_presenter_id}.
          */
         private ImagePresenter<T> getImagePresenter(ImageView imageView) {
+            resizeOption = getFinalResizeOption(imageView);
+
             Metadata previous = getMetadataFrom(imageView);
             Metadata current = new Metadata(this);
 
@@ -539,22 +556,57 @@ public class Glide {
             }
         }
 
+        private ResizeOption getFinalResizeOption(ImageView imageView) {
+            ResizeOption result = resizeOption;
+            if (result == null) {
+                //default to Approximate unless view's layout params are set to wrap content, in which case the only
+                //loader that makes sense is AsIs since all the others crop based on the view's size
+                final LayoutParams lp = imageView.getLayoutParams();
+                if (lp != null && (lp.width == LayoutParams.WRAP_CONTENT || lp.height == LayoutParams.WRAP_CONTENT)) {
+                    result = ResizeOption.AS_IS;
+                } else {
+                    result = ResizeOption.APPROXIMATE;
+                }
+            }
+            return result;
+        }
+
         private ImageLoader getImageLoaderFromOptions(Context context) {
-            final ImageLoader result;
+
+            Class<? extends ImageLoader> imageLoaderClass = getImageLoaderClassFor(resizeOption);
+            try {
+                return imageLoaderClass.getConstructor(Context.class).newInstance(context);
+            } catch (InstantiationException e) {
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                e.printStackTrace();
+            } catch (InvocationTargetException e) {
+                e.printStackTrace();
+            } catch (NoSuchMethodException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        private static Class<? extends ImageLoader> getImageLoaderClassFor(ResizeOption resizeOption) {
+            final Class<? extends ImageLoader> imageLoaderClass;
             switch (resizeOption) {
                 case APPROXIMATE:
-                    result = new Approximate(context);
+                    imageLoaderClass = Approximate.class;
                     break;
                 case CENTER_CROP:
-                    result = new CenterCrop(context);
+                    imageLoaderClass = CenterCrop.class;
                     break;
                 case FIT_CENTER:
-                    result = new FitCenter(context);
+                    imageLoaderClass = FitCenter.class;
+                    break;
+                case AS_IS:
+                    imageLoaderClass = AsIs.class;
                     break;
                 default:
                     throw new IllegalArgumentException(""Unknown resize option "" + resizeOption);
             }
-            return result;
+            return imageLoaderClass;
         }
 
         private static Metadata getMetadataFrom(ImageView imageView) {
@@ -579,19 +631,8 @@ public class Glide {
                 if (request.imageLoader != null) {
                     imageLoaderClass = request.imageLoader.getClass();
                 } else {
-                    switch (request.resizeOption) {
-                        case APPROXIMATE:
-                            imageLoaderClass = Approximate.class;
-                            break;
-                        case CENTER_CROP:
-                            imageLoaderClass = CenterCrop.class;
-                            break;
-                        case FIT_CENTER:
-                            imageLoaderClass = FitCenter.class;
-                            break;
-                        default:
-                            throw new IllegalArgumentException(""Unknown resize option "" + request.resizeOption);
-                    }
+                    imageLoaderClass = getImageLoaderClassFor(request.resizeOption);
+
                 }
                 animationId = request.animationId;
                 placeholderId = request.placeholderId;
","13 import com.bumptech.glide.loader.model.ResourceLoader;
21 import com.bumptech.glide.resize.loader.AsIs;
26 import java.lang.reflect.InvocationTargetException;
29 import static android.view.ViewGroup.LayoutParams;
30 
344             AS_IS,
355         private ResizeOption resizeOption = null;
371          * Resize models using {@link CenterCrop}. Replaces any existing resize style
383          * Resize models using {@link FitCenter}. Replaces any existing resize style
395          * Resize models using {@link Approximate}. Replaces any existing resize style
406         /**
407          * Load images at their original size using {@link com.bumptech.glide.resize.loader.AsIs}. Replaces any existing
408          * resize style
409          *
410          * @return This Request
411          */
412         public Request<T> asIs() {
413             resizeOption = ResizeOption.AS_IS;
414             imageLoader = null;
415 
416             return this;
417         }
418 
485             resizeOption = getFinalResizeOption(imageView);
486 
559         private ResizeOption getFinalResizeOption(ImageView imageView) {
560             ResizeOption result = resizeOption;
561             if (result == null) {
562                 //default to Approximate unless view's layout params are set to wrap content, in which case the only
563                 //loader that makes sense is AsIs since all the others crop based on the view's size
564                 final LayoutParams lp = imageView.getLayoutParams();
565                 if (lp != null && (lp.width == LayoutParams.WRAP_CONTENT || lp.height == LayoutParams.WRAP_CONTENT)) {
566                     result = ResizeOption.AS_IS;
567                 } else {
568                     result = ResizeOption.APPROXIMATE;
569                 }
570             }
571             return result;
572         }
573 
575 
576             Class<? extends ImageLoader> imageLoaderClass = getImageLoaderClassFor(resizeOption);
577             try {
578                 return imageLoaderClass.getConstructor(Context.class).newInstance(context);
579             } catch (InstantiationException e) {
580                 e.printStackTrace();
581             } catch (IllegalAccessException e) {
582                 e.printStackTrace();
583             } catch (InvocationTargetException e) {
584                 e.printStackTrace();
585             } catch (NoSuchMethodException e) {
586                 e.printStackTrace();
587             }
588             return null;
589         }
590 
591         private static Class<? extends ImageLoader> getImageLoaderClassFor(ResizeOption resizeOption) {
592             final Class<? extends ImageLoader> imageLoaderClass;
595                     imageLoaderClass = Approximate.class;
598                     imageLoaderClass = CenterCrop.class;
601                     imageLoaderClass = FitCenter.class;
602                     break;
603                 case AS_IS:
604                     imageLoaderClass = AsIs.class;
609             return imageLoaderClass;
634                     imageLoaderClass = getImageLoaderClassFor(request.resizeOption);
635 
11 import com.bumptech.glide.loader.model.ResourceLoader;
350         private ResizeOption resizeOption = ResizeOption.APPROXIMATE;
366          * Resize models using {@link ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
367          * Replaces any existing resize style
379          * Resize models using {@link ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
380          * Replaces any existing resize style
392          * Resize models using {@link ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)}
393          * Replaces any existing resize style
543             final ImageLoader result;
546                     result = new Approximate(context);
549                     result = new CenterCrop(context);
552                     result = new FitCenter(context);
557             return result;
582                     switch (request.resizeOption) {
583                         case APPROXIMATE:
584                             imageLoaderClass = Approximate.class;
585                             break;
586                         case CENTER_CROP:
587                             imageLoaderClass = CenterCrop.class;
588                             break;
589                         case FIT_CENTER:
590                             imageLoaderClass = FitCenter.class;
591                             break;
592                         default:
593                             throw new IllegalArgumentException(""Unknown resize option "" + request.resizeOption);
594                     }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,78790c322a30ac2e62498b79bdc965832bf2342d,d50efbfe3f305040ff0f1880238a1517ab7091c5,Handle views with wrap_content set in Glide,"@@ -526,7 +526,11 @@ public class ImagePresenter<T> {
             handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
             this.cb = null;
             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {
+            //non null layout params and either width and height have been set, or set to wrap content so they
+            //will not be set until we set some content
+            if (layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0)
+                    || (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
+                            layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT))) {
                 cb.onSizeReady(layoutParams.width, layoutParams.height);
             } else if (valid) {
                 cb.onSizeReady(width, height);
","529             //non null layout params and either width and height have been set, or set to wrap content so they
530             //will not be set until we set some content
531             if (layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0)
532                     || (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
533                             layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT))) {
529             if (layoutParams != null && layoutParams.width > 0 && layoutParams.height > 0) {",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,78790c322a30ac2e62498b79bdc965832bf2342d,d50efbfe3f305040ff0f1880238a1517ab7091c5,Handle views with wrap_content set in Glide,"@@ -2,6 +2,7 @@ package com.bumptech.glide.resize.loader;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.view.ViewGroup;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
@@ -41,4 +42,10 @@ public class AsIs extends ImageManagerLoader {
             }
         });
     }
+
+    @Override
+    protected boolean isHandled(int width, int height) {
+        return super.isHandled(width, height)
+                || (width == ViewGroup.LayoutParams.WRAP_CONTENT || height == ViewGroup.LayoutParams.WRAP_CONTENT);
+    }
 }
","5 import android.view.ViewGroup;
45 
46     @Override
47     protected boolean isHandled(int width, int height) {
48         return super.isHandled(width, height)
49                 || (width == ViewGroup.LayoutParams.WRAP_CONTENT || height == ViewGroup.LayoutParams.WRAP_CONTENT);
50     }",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,78790c322a30ac2e62498b79bdc965832bf2342d,d50efbfe3f305040ff0f1880238a1517ab7091c5,Handle views with wrap_content set in Glide,"@@ -24,8 +24,13 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
     public ImageManagerLoader(ImageManager imageManager) {
         this.imageManager = imageManager;
     }
+
     @Override
     protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
+        if (!isHandled(width, height)) {
+            throw new IllegalArgumentException(getClass() + "" cannot handle width="" + width + "" and/or height ="" +
+                    height);
+        }
         loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
     }
 
@@ -69,4 +74,8 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
             acquired = null;
         }
     }
+
+    protected boolean isHandled(int width, int height) {
+        return width >= 0 && height >= 0;
+    }
 }
","27 
30         if (!isHandled(width, height)) {
31             throw new IllegalArgumentException(getClass() + "" cannot handle width="" + width + "" and/or height ="" +
32                     height);
33         }
77 
78     protected boolean isHandled(int width, int height) {
79         return width >= 0 && height >= 0;
80     }",No
library\tests\src\com\bumptech\glide\GlideTest.java,library\tests\src\com\bumptech\glide\GlideTest.java,78790c322a30ac2e62498b79bdc965832bf2342d,d50efbfe3f305040ff0f1880238a1517ab7091c5,Handle views with wrap_content set in Glide,"@@ -98,6 +98,14 @@ public class GlideTest extends ActivityTestCase {
         assertSame(first, second);
     }
 
+    public void testCanHandleWrapContent() {
+        imageView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT));
+        Glide.load(""fake"").into(imageView);
+
+        assertNotNull(ImagePresenter.getCurrent(imageView));
+    }
+
     public void testDifferentModlsReplacesPresenters() {
         Glide.load(""fake"").into(imageView);
 
","101     public void testCanHandleWrapContent() {
102         imageView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
103                 ViewGroup.LayoutParams.WRAP_CONTENT));
104         Glide.load(""fake"").into(imageView);
105 
106         assertNotNull(ImagePresenter.getCurrent(imageView));
107     }
108 ",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,5fd05ac34bfdc21daf6bdc9c7fd15a1ba8237995,78790c322a30ac2e62498b79bdc965832bf2342d,Refactor duplicate code in ImageResizer to classes,"@@ -63,6 +63,65 @@ public class ImageResizer {
         this(null, options);
     }
 
+    private abstract class ImageDownsampler {
+        public Bitmap load(InputStream is, int width, int height) {
+            byte[] bytes = getTempBytes();
+            RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
+            final int[] inDimens = getDimens(bis, width, height);
+
+            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
+            final int sampleSize = getSampleSize(inDimens[0], inDimens[1], width, height);
+
+            final BitmapFactory.Options decodeBitmapOptions = getOptions();
+            decodeBitmapOptions.inSampleSize = sampleSize;
+
+            Bitmap result = decodeStream(bis, decodeBitmapOptions);
+            releaseTempBytes(bytes);
+            return result;
+        }
+
+        protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
+
+        protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
+            return getDimensions(bis);
+        }
+    }
+
+    private final ImageDownsampler atLeastDownsampler = new ImageDownsampler() {
+
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
+            return Math.min(inHeight / outHeight, inWidth / outWidth);
+        }
+    };
+
+    private final ImageDownsampler atMostDownsampler = new ImageDownsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return Math.max(inHeight / outHeight, inWidth / outWidth);
+        }
+    };
+
+    private final ImageDownsampler asIsDownsampler = new ImageDownsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return 0;
+        }
+    };
+
+    private final ImageDownsampler fixedAsIsDownsampler = new ImageDownsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return 0;
+        }
+
+        @Override
+        protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
+            return new int[] { inWidth, inHeight };
+
+        }
+    };
     /**
      * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
      *
@@ -122,21 +181,7 @@ public class ImageResizer {
      * @return A Bitmap containing the image
      */
     public Bitmap loadAtLeast(InputStream is, int width, int height) {
-        byte[] bytes = getTempBytes();
-        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
-        final int[] dimens = getDimensions(bis);
-        final int originalWidth = dimens[0];
-        final int originalHeight = dimens[1];
-
-        // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-        final int sampleSize = Math.min(originalHeight / height, originalWidth / width);
-
-        final BitmapFactory.Options decodeBitmapOptions = getOptions();
-        decodeBitmapOptions.inSampleSize = sampleSize;
-
-        Bitmap result = decodeStream(bis, decodeBitmapOptions);
-        releaseTempBytes(bytes);
-        return result;
+        return atLeastDownsampler.load(is, width, height);
     }
 
     /**
@@ -151,19 +196,7 @@ public class ImageResizer {
      */
     @SuppressWarnings(""unused"")
     public Bitmap loadAtMost(InputStream is, int width, int height) {
-        byte[] bytes = getTempBytes();
-        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
-        final int[] dimens = getDimensions(bis);
-        final int originalWidth = dimens[0];
-        final int originalHeight = dimens[1];
-
-        final int sampleSize = Math.max(originalHeight / height, originalWidth / width);
-        final BitmapFactory.Options decodeBitmapOptions = getOptions();
-        decodeBitmapOptions.inSampleSize = sampleSize;
-
-        Bitmap result = decodeStream(bis, decodeBitmapOptions);
-        releaseTempBytes(bytes);
-        return result;
+        return atMostDownsampler.load(is, width, height);
     }
 
     /**
@@ -173,12 +206,7 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(final InputStream is) {
-        byte[] bytes = getTempBytes();
-        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
-        int[] dimens = getDimensions(bis);
-        Bitmap result = load(bis, getRecycled(dimens));
-        releaseTempBytes(bytes);
-        return result;
+        return asIsDownsampler.load(is, 0, 0);
     }
 
     /**
@@ -193,10 +221,7 @@ public class ImageResizer {
      * @return The loaded image
      */
     public Bitmap loadAsIs(InputStream is, int width, int height) {
-        byte[] bytes = getTempBytes();
-        Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
-        releaseTempBytes(bytes);
-        return result;
+        return fixedAsIsDownsampler.load(is, width, height);
     }
 
     /**
","66     private abstract class ImageDownsampler {
67         public Bitmap load(InputStream is, int width, int height) {
68             byte[] bytes = getTempBytes();
69             RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
70             final int[] inDimens = getDimens(bis, width, height);
71 
72             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
73             final int sampleSize = getSampleSize(inDimens[0], inDimens[1], width, height);
74 
75             final BitmapFactory.Options decodeBitmapOptions = getOptions();
76             decodeBitmapOptions.inSampleSize = sampleSize;
77 
78             Bitmap result = decodeStream(bis, decodeBitmapOptions);
79             releaseTempBytes(bytes);
80             return result;
81         }
82 
83         protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
84 
85         protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
86             return getDimensions(bis);
87         }
88     }
89 
90     private final ImageDownsampler atLeastDownsampler = new ImageDownsampler() {
91 
92         @Override
93         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
94             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
95             return Math.min(inHeight / outHeight, inWidth / outWidth);
96         }
97     };
98 
99     private final ImageDownsampler atMostDownsampler = new ImageDownsampler() {
100         @Override
101         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
102             return Math.max(inHeight / outHeight, inWidth / outWidth);
103         }
104     };
105 
106     private final ImageDownsampler asIsDownsampler = new ImageDownsampler() {
107         @Override
108         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
109             return 0;
110         }
111     };
112 
113     private final ImageDownsampler fixedAsIsDownsampler = new ImageDownsampler() {
114         @Override
115         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
116             return 0;
117         }
118 
119         @Override
120         protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
121             return new int[] { inWidth, inHeight };
122 
123         }
124     };
184         return atLeastDownsampler.load(is, width, height);
199         return atMostDownsampler.load(is, width, height);
209         return asIsDownsampler.load(is, 0, 0);
224         return fixedAsIsDownsampler.load(is, width, height);
125         byte[] bytes = getTempBytes();
126         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
127         final int[] dimens = getDimensions(bis);
128         final int originalWidth = dimens[0];
129         final int originalHeight = dimens[1];
130 
131         // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
132         final int sampleSize = Math.min(originalHeight / height, originalWidth / width);
133 
134         final BitmapFactory.Options decodeBitmapOptions = getOptions();
135         decodeBitmapOptions.inSampleSize = sampleSize;
136 
137         Bitmap result = decodeStream(bis, decodeBitmapOptions);
138         releaseTempBytes(bytes);
139         return result;
154         byte[] bytes = getTempBytes();
155         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
156         final int[] dimens = getDimensions(bis);
157         final int originalWidth = dimens[0];
158         final int originalHeight = dimens[1];
159 
160         final int sampleSize = Math.max(originalHeight / height, originalWidth / width);
161         final BitmapFactory.Options decodeBitmapOptions = getOptions();
162         decodeBitmapOptions.inSampleSize = sampleSize;
163 
164         Bitmap result = decodeStream(bis, decodeBitmapOptions);
165         releaseTempBytes(bytes);
166         return result;
176         byte[] bytes = getTempBytes();
177         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
178         int[] dimens = getDimensions(bis);
179         Bitmap result = load(bis, getRecycled(dimens));
180         releaseTempBytes(bytes);
181         return result;
196         byte[] bytes = getTempBytes();
197         Bitmap result = load(new RecyclableBufferedInputStream(is, bytes), getRecycled(width, height));
198         releaseTempBytes(bytes);
199         return result;",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,53064eb60fad9ea0176a87ac77d841cced27bd29,5fd05ac34bfdc21daf6bdc9c7fd15a1ba8237995,Change default tag to Glide,"@@ -72,8 +72,13 @@ public class ImageResizer {
             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
             final int sampleSize = getSampleSize(inDimens[0], inDimens[1], width, height);
 
-            final BitmapFactory.Options decodeBitmapOptions = getOptions();
+            final BitmapFactory.Options decodeBitmapOptions;
+            if (sampleSize > 1) {
+                decodeBitmapOptions = getOptions();
                 decodeBitmapOptions.inSampleSize = sampleSize;
+            } else {
+                decodeBitmapOptions = getOptions(getRecycled(inDimens));
+            }
 
             Bitmap result = decodeStream(bis, decodeBitmapOptions);
             releaseTempBytes(bytes);
","75             final BitmapFactory.Options decodeBitmapOptions;
76             if (sampleSize > 1) {
77                 decodeBitmapOptions = getOptions();
79             } else {
80                 decodeBitmapOptions = getOptions(getRecycled(inDimens));
81             }
75             final BitmapFactory.Options decodeBitmapOptions = getOptions();",No
library\src\com\bumptech\glide\util\Log.java,library\src\com\bumptech\glide\util\Log.java,53064eb60fad9ea0176a87ac77d841cced27bd29,5fd05ac34bfdc21daf6bdc9c7fd15a1ba8237995,Change default tag to Glide,"@@ -7,7 +7,7 @@ import java.text.SimpleDateFormat;
 import java.util.Date;
 
 public class Log {
-    private static final String TAG = ""BUMP_PHOTOS"";
+    private static final String TAG = ""GLIDE"";
 
     @SuppressLint(""SimpleDateFormat"")
     private static final DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
","10     private static final String TAG = ""GLIDE"";
10     private static final String TAG = ""BUMP_PHOTOS"";",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,11fad2185c246aecb8438f8aff9c200607dd96db,53064eb60fad9ea0176a87ac77d841cced27bd29,Mildly reduce # of posts to bg thread per resize,"@@ -648,8 +648,18 @@ public class ImageManager {
                     });
                 }
 
+                final boolean addedToMemoryCache = putInMemoryCache(key, result);
+                bgHandler.postAtFrontOfQueue(new Runnable() {
+                    @Override
+                    public void run() {
                         bitmapReferenceCounter.initBitmap(result);
-                putInMemoryCache(key, result);
+                        if (addedToMemoryCache) {
+                            bitmapReferenceCounter.acquireBitmap(result);
+                            bitmapReferenceCounter.markPending(result);
+                        }
+                    }
+                });
+
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -670,7 +680,7 @@ public class ImageManager {
     }
 
 
-    private void putInMemoryCache(int key, Bitmap bitmap) {
+    private boolean putInMemoryCache(int key, Bitmap bitmap) {
         final boolean inCache;
         synchronized (memoryCache) {
             inCache = memoryCache.contains(key);
@@ -679,10 +689,7 @@ public class ImageManager {
             }
         }
 
-        if (!inCache) {
-            acquireBitmap(bitmap);
-            bitmapReferenceCounter.markPending(bitmap);
-        }
+        return !inCache;
     }
 
     private static int getKey(String id, int width, int height, ResizeType type){
","651                 final boolean addedToMemoryCache = putInMemoryCache(key, result);
652                 bgHandler.postAtFrontOfQueue(new Runnable() {
653                     @Override
654                     public void run() {
656                         if (addedToMemoryCache) {
657                             bitmapReferenceCounter.acquireBitmap(result);
658                             bitmapReferenceCounter.markPending(result);
659                         }
660                     }
661                 });
662 
683     private boolean putInMemoryCache(int key, Bitmap bitmap) {
692         return !inCache;
652                 putInMemoryCache(key, result);
673     private void putInMemoryCache(int key, Bitmap bitmap) {
682         if (!inCache) {
683             acquireBitmap(bitmap);
684             bitmapReferenceCounter.markPending(bitmap);
685         }",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,878ad09942bf74517a761cc80815038bdbed7b06,11fad2185c246aecb8438f8aff9c200607dd96db,Add retries to flickr search in sample project,"@@ -1,6 +1,7 @@
 package com.bumptech.flickr.api;
 
 import android.content.Context;
+import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
 import com.android.volley.Response;
@@ -94,7 +95,7 @@ public class Api {
     }
 
     public void search(String text, final SearchCallback cb) {
-        requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
+        StringRequest request = new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
             @Override
             public void onResponse(String response) {
                 try {
@@ -116,6 +117,8 @@ public class Api {
             public void onErrorResponse(VolleyError error) {
                 cb.onSearchFailed(error);
             }
-        }));
+        });
+        request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3, DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+        requestQueue.add(request);
     }
 }
","4 import com.android.volley.DefaultRetryPolicy;
98         StringRequest request = new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
120         });
121         request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3, DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
122         requestQueue.add(request);
97         requestQueue.add(new StringRequest(Request.Method.GET, getSearchUrl(text), new Response.Listener<String>() {
119         }));",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\flickr\api\Api.java,ee687a44213cf94c1f4c18d1e38eb57bea182a35,878ad09942bf74517a761cc80815038bdbed7b06,"Cache inefficient Url creation per photo

String.format is rather terrible","@@ -30,7 +30,8 @@ public class Api {
     private static Api API;
     private static final String API_KEY = ""f0e6fbb5fdf1f3842294a1d21f84e8a6"";
     private static final String SIGNED_API_URL = ""http://api.flickr.com/services/rest/?method=%s&format=json&api_key="" + API_KEY;
-    private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
+    //incomplete size independent url for photos that can be cached per photo
+    private static final String CACHEABLE_PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_"";
 
     private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
         put(75, ""s"");
@@ -82,6 +83,10 @@ public class Api {
         return getPhotoUrl(photo, getSizeKey(width, height));
     }
 
+    public static String getCacheableUrl(Photo photo) {
+        return String.format(CACHEABLE_PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
+    }
+
     private static String getUrlForMethod(String method) {
         return String.format(SIGNED_API_URL, method);
     }
@@ -91,7 +96,7 @@ public class Api {
     }
 
     private static String getPhotoUrl(Photo photo, String sizeKey) {
-        return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret, sizeKey);
+        return photo.getPartialUrl() + sizeKey + "".jpg"";
     }
 
     public void search(String text, final SearchCallback cb) {
","33     //incomplete size independent url for photos that can be cached per photo
34     private static final String CACHEABLE_PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_"";
86     public static String getCacheableUrl(Photo photo) {
87         return String.format(CACHEABLE_PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
88     }
89 
99         return photo.getPartialUrl() + sizeKey + "".jpg"";
33     private static final String PHOTO_URL = ""http://farm%s.staticflickr.com/%s/%s_%s_%s.jpg"";
94         return String.format(PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret, sizeKey);",No
samples\flickr\src\com\bumptech\flickr\api\Photo.java,samples\flickr\src\com\bumptech\flickr\api\Photo.java,ee687a44213cf94c1f4c18d1e38eb57bea182a35,878ad09942bf74517a761cc80815038bdbed7b06,"Cache inefficient Url creation per photo

String.format is rather terrible","@@ -17,6 +17,7 @@ public class Photo {
     public final String server;
     public final String farm;
     public final String secret;
+    private String partialUrl = null;
 
     public Photo(JSONObject jsonPhoto) throws JSONException {
         this.id = jsonPhoto.getString(""id"");
@@ -27,4 +28,11 @@ public class Photo {
         this.secret = jsonPhoto.getString(""secret"");
     }
 
+    public String getPartialUrl() {
+        if (partialUrl == null ) {
+            partialUrl = Api.getCacheableUrl(this);
+        }
+        return partialUrl;
+    }
+
 }
","20     private String partialUrl = null;
31     public String getPartialUrl() {
32         if (partialUrl == null ) {
33             partialUrl = Api.getCacheableUrl(this);
34         }
35         return partialUrl;
36     }
37 ",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,ebee47a832ac2e333ed2ff453021810b10d2ea16,ee687a44213cf94c1f4c18d1e38eb57bea182a35,Code cleanup in ImageManager,"@@ -566,7 +566,6 @@ public class ImageManager {
         }
 
         public void cancel() {
-            if (cancelled) return;
             cancelled = true;
 
             bgHandler.removeCallbacks(this);
@@ -577,25 +576,17 @@ public class ImageManager {
 
         @Override
         public void run() {
-            if (cancelled) return;
-
             final String stringKey = String.valueOf(key);
             Bitmap result = null;
             if (useDiskCache) {
-                final InputStream is = diskCache.get(stringKey);
-                if (is != null) {
-                    result = resizer.loadAsIs(is);
-                    if (result == null) {
-                        diskCache.delete(stringKey); //the image must have been corrupted
-                    }
-                }
+                result = getFromDiskCache(stringKey);
             }
 
             if (result == null) {
                 try {
                     resizeWithPool();
                 } catch (Exception e) {
-                    cb.onLoadFailed(e);
+                    handleException(e);
                 }
             } else {
                 finishResize(result, true);
@@ -608,16 +599,19 @@ public class ImageManager {
             future = executor.submit(new Runnable() {
                 @Override
                 public void run() {
-                    if (cancelled) return;
-
                     streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
                         @Override
                         public void onStreamReady(final InputStream is) {
-                            if (cancelled) return;
+                            if (cancelled) {
+                                return;
+                            }
+
+                            //this call back might be called on some other thread,
+                            //we want to do resizing on our thread, especially if we're called
+                            //back on the main thread, so we will resubmit
                             future = executor.submit(new Runnable() {
                                 @Override
                                 public void run() {
-                                    if (cancelled) return;
                                     try {
                                         final Bitmap result = resizeIfNotFound(is);
                                         finishResize(result, false);
@@ -630,7 +624,7 @@ public class ImageManager {
 
                         @Override
                         public void onException(Exception e) {
-                            cb.onLoadFailed(e);
+                            handleException(e);
                         }
                     });
                 }
@@ -640,25 +634,11 @@ public class ImageManager {
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
-                    diskCache.put(String.valueOf(key), new DiskCache.Writer() {
-                        @Override
-                        public void write(OutputStream os) {
-                            result.compress(bitmapCompressFormat, bitmapCompressQuality, os);
-                        }
-                    });
+                    putInDiskCache(String.valueOf(key), result);
                 }
 
-                final boolean addedToMemoryCache = putInMemoryCache(key, result);
-                bgHandler.postAtFrontOfQueue(new Runnable() {
-                    @Override
-                    public void run() {
                 bitmapReferenceCounter.initBitmap(result);
-                        if (addedToMemoryCache) {
-                            bitmapReferenceCounter.acquireBitmap(result);
-                            bitmapReferenceCounter.markPending(result);
-                        }
-                    }
-                });
+                putInMemoryCache(key, result);
 
                 mainHandler.post(new Runnable() {
                     @Override
@@ -667,20 +647,40 @@ public class ImageManager {
                     }
                 });
             } else {
-                mainHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        cb.onLoadFailed(null);
+                handleException(null);
             }
-                });
         }
+
+        private void handleException(Exception e) {
+            cb.onLoadFailed(e);
         }
 
         protected abstract Bitmap resizeIfNotFound(InputStream is) throws IOException;
     }
 
+    private Bitmap getFromDiskCache(String key) {
+        Bitmap result = null;
+        final InputStream is = diskCache.get(key);
+        if (is != null) {
+            result = resizer.loadAsIs(is);
+            if (result == null) {
+                diskCache.delete(key); //the image must have been corrupted
+            }
+        }
+        return result;
+    }
+
+    private void putInDiskCache(String key, final Bitmap bitmap) {
+        diskCache.put(key, new DiskCache.Writer() {
+            @Override
+            public void write(OutputStream os) {
+                bitmap.compress(bitmapCompressFormat, bitmapCompressQuality, os);
+            }
+        });
+
+    }
 
-    private boolean putInMemoryCache(int key, Bitmap bitmap) {
+    private void putInMemoryCache(int key, final Bitmap bitmap) {
         final boolean inCache;
         synchronized (memoryCache) {
             inCache = memoryCache.contains(key);
@@ -689,7 +689,8 @@ public class ImageManager {
             }
         }
 
-        return !inCache;
+        bitmapReferenceCounter.acquireBitmap(bitmap);
+        bitmapReferenceCounter.markPending(bitmap);
     }
 
     private static int getKey(String id, int width, int height, ResizeType type){
","582                 result = getFromDiskCache(stringKey);
589                     handleException(e);
605                             if (cancelled) {
606                                 return;
607                             }
608 
609                             //this call back might be called on some other thread,
610                             //we want to do resizing on our thread, especially if we're called
611                             //back on the main thread, so we will resubmit
627                             handleException(e);
637                     putInDiskCache(String.valueOf(key), result);
641                 putInMemoryCache(key, result);
650                 handleException(null);
653 
654         private void handleException(Exception e) {
655             cb.onLoadFailed(e);
661     private Bitmap getFromDiskCache(String key) {
662         Bitmap result = null;
663         final InputStream is = diskCache.get(key);
664         if (is != null) {
665             result = resizer.loadAsIs(is);
666             if (result == null) {
667                 diskCache.delete(key); //the image must have been corrupted
668             }
669         }
670         return result;
671     }
673     private void putInDiskCache(String key, final Bitmap bitmap) {
674         diskCache.put(key, new DiskCache.Writer() {
675             @Override
676             public void write(OutputStream os) {
677                 bitmap.compress(bitmapCompressFormat, bitmapCompressQuality, os);
678             }
679         });
680 
681     }
682 
683     private void putInMemoryCache(int key, final Bitmap bitmap) {
692         bitmapReferenceCounter.acquireBitmap(bitmap);
693         bitmapReferenceCounter.markPending(bitmap);
569             if (cancelled) return;
580             if (cancelled) return;
581 
585                 final InputStream is = diskCache.get(stringKey);
586                 if (is != null) {
587                     result = resizer.loadAsIs(is);
588                     if (result == null) {
589                         diskCache.delete(stringKey); //the image must have been corrupted
590                     }
591                 }
598                     cb.onLoadFailed(e);
611                     if (cancelled) return;
612 
616                             if (cancelled) return;
620                                     if (cancelled) return;
633                             cb.onLoadFailed(e);
643                     diskCache.put(String.valueOf(key), new DiskCache.Writer() {
644                         @Override
645                         public void write(OutputStream os) {
646                             result.compress(bitmapCompressFormat, bitmapCompressQuality, os);
647                         }
648                     });
651                 final boolean addedToMemoryCache = putInMemoryCache(key, result);
652                 bgHandler.postAtFrontOfQueue(new Runnable() {
653                     @Override
654                     public void run() {
656                         if (addedToMemoryCache) {
657                             bitmapReferenceCounter.acquireBitmap(result);
658                             bitmapReferenceCounter.markPending(result);
659                         }
660                     }
661                 });
670                 mainHandler.post(new Runnable() {
671                     @Override
672                     public void run() {
673                         cb.onLoadFailed(null);
675                 });
683     private boolean putInMemoryCache(int key, Bitmap bitmap) {
692         return !inCache;",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,933f43576bda8138f85ec83fc93c5659dad35d82,ebee47a832ac2e333ed2ff453021810b10d2ea16,Revert to using String keys for caching,"@@ -358,7 +358,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImage(String id, final StreamLoader streamLoader, final LoadedCallback cb){
-        final int key = getKey(id, -1, -1, ResizeType.AS_IS);
+        final String key = getKey(id, -1, -1, ResizeType.AS_IS);
         return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
@@ -379,7 +379,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImageExact(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final int key = getKey(id, width, height, ResizeType.AS_IS);
+        final String key = getKey(id, width, height, ResizeType.AS_IS);
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
@@ -400,7 +400,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object getImageApproximate(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
+        final String key = getKey(id, width, height, ResizeType.APPROXIMATE);
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
@@ -422,7 +422,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object centerCrop(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
+        final String key = getKey(id, width, height, ResizeType.CENTER_CROP);
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
@@ -444,7 +444,7 @@ public class ImageManager {
      * @return A token tracking this request
      */
     public Object fitCenter(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb){
-        final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
+        final String key = getKey(id, width, height, ResizeType.FIT_CENTER);
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
@@ -524,11 +524,11 @@ public class ImageManager {
         bgHandler.getLooper().quit();
     }
 
-    private Object runJob(int key, LoadedCallback cb, ImageManagerJob job) {
+    private Object runJob(String key, LoadedCallback cb, ImageManagerJob job) {
         return runJob(key, cb, true, job);
     }
 
-    private Object runJob(int key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
+    private Object runJob(String key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
         if (shutdown) return null;
 
         if (!returnFromCache(key, cb)) {
@@ -537,7 +537,7 @@ public class ImageManager {
         return job;
     }
 
-    private boolean returnFromCache(int key, LoadedCallback cb) {
+    private boolean returnFromCache(String key, LoadedCallback cb) {
         Bitmap inCache = memoryCache.get(key);
         boolean found = inCache != null;
         if (found) {
@@ -548,7 +548,7 @@ public class ImageManager {
 
     private abstract class ImageManagerJob implements Runnable {
         private final StreamLoader streamLoader;
-        private int key;
+        private String key;
         private LoadedCallback cb;
         private boolean useDiskCache;
         private Future future = null;
@@ -558,7 +558,7 @@ public class ImageManager {
             this.streamLoader = streamLoader;
         }
 
-        public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
+        public void execute(String key, LoadedCallback cb, boolean useDiskCache) {
             this.key = key;
             this.cb = cb;
             this.useDiskCache = useDiskCache;
@@ -576,10 +576,9 @@ public class ImageManager {
 
         @Override
         public void run() {
-            final String stringKey = String.valueOf(key);
             Bitmap result = null;
             if (useDiskCache) {
-                result = getFromDiskCache(stringKey);
+                result = getFromDiskCache(key);
             }
 
             if (result == null) {
@@ -634,7 +633,7 @@ public class ImageManager {
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
                 if (useDiskCache && !isInDiskCache) {
-                    putInDiskCache(String.valueOf(key), result);
+                    putInDiskCache(key, result);
                 }
 
                 bitmapReferenceCounter.initBitmap(result);
@@ -680,7 +679,7 @@ public class ImageManager {
 
     }
 
-    private void putInMemoryCache(int key, final Bitmap bitmap) {
+    private void putInMemoryCache(String key, final Bitmap bitmap) {
         final boolean inCache;
         synchronized (memoryCache) {
             inCache = memoryCache.contains(key);
@@ -693,7 +692,7 @@ public class ImageManager {
         bitmapReferenceCounter.markPending(bitmap);
     }
 
-    private static int getKey(String id, int width, int height, ResizeType type){
-        return Util.hash(id.hashCode(), width, height, type.hashCode());
+    private static String getKey(String id, int width, int height, ResizeType type){
+        return String.valueOf(Util.hash(id.hashCode(), width, height, type.hashCode()));
     }
 }
","361         final String key = getKey(id, -1, -1, ResizeType.AS_IS);
382         final String key = getKey(id, width, height, ResizeType.AS_IS);
403         final String key = getKey(id, width, height, ResizeType.APPROXIMATE);
425         final String key = getKey(id, width, height, ResizeType.CENTER_CROP);
447         final String key = getKey(id, width, height, ResizeType.FIT_CENTER);
527     private Object runJob(String key, LoadedCallback cb, ImageManagerJob job) {
531     private Object runJob(String key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
540     private boolean returnFromCache(String key, LoadedCallback cb) {
551         private String key;
561         public void execute(String key, LoadedCallback cb, boolean useDiskCache) {
581                 result = getFromDiskCache(key);
636                     putInDiskCache(key, result);
682     private void putInMemoryCache(String key, final Bitmap bitmap) {
695     private static String getKey(String id, int width, int height, ResizeType type){
696         return String.valueOf(Util.hash(id.hashCode(), width, height, type.hashCode()));
361         final int key = getKey(id, -1, -1, ResizeType.AS_IS);
382         final int key = getKey(id, width, height, ResizeType.AS_IS);
403         final int key = getKey(id, width, height, ResizeType.APPROXIMATE);
425         final int key = getKey(id, width, height, ResizeType.CENTER_CROP);
447         final int key = getKey(id, width, height, ResizeType.FIT_CENTER);
527     private Object runJob(int key, LoadedCallback cb, ImageManagerJob job) {
531     private Object runJob(int key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
540     private boolean returnFromCache(int key, LoadedCallback cb) {
551         private int key;
561         public void execute(int key, LoadedCallback cb, boolean useDiskCache) {
579             final String stringKey = String.valueOf(key);
582                 result = getFromDiskCache(stringKey);
637                     putInDiskCache(String.valueOf(key), result);
683     private void putInMemoryCache(int key, final Bitmap bitmap) {
696     private static int getKey(String id, int width, int height, ResizeType type){
697         return Util.hash(id.hashCode(), width, height, type.hashCode());",No
library\src\com\bumptech\glide\resize\cache\LruPhotoCache.java,library\src\com\bumptech\glide\resize\cache\LruPhotoCache.java,933f43576bda8138f85ec83fc93c5659dad35d82,ebee47a832ac2e333ed2ff453021810b10d2ea16,Revert to using String keys for caching,"@@ -13,13 +13,13 @@ import android.support.v4.util.LruCache;
  * @see android.support.v4.util.LruCache
  */
 public class LruPhotoCache implements MemoryCache {
-    private final LruCache<Integer, Bitmap> lruCache;
+    private final LruCache<String, Bitmap> lruCache;
     private ImageRemovedListener imageRemovedListener;
 
     public LruPhotoCache(int maxSize) {
-        lruCache = new LruCache<Integer, Bitmap>(maxSize) {
+        lruCache = new LruCache<String, Bitmap>(maxSize) {
             @Override
-            protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
+            protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
                 super.entryRemoved(evicted, key, oldValue, newValue);
                 if (imageRemovedListener != null) {
                     imageRemovedListener.onImageRemoved(oldValue);
@@ -27,24 +27,24 @@ public class LruPhotoCache implements MemoryCache {
             }
 
             @Override
-            protected int sizeOf(Integer key, Bitmap value) {
+            protected int sizeOf(String key, Bitmap value) {
                 //get the size, getByteCount() is API 12+...
                 return value.getHeight() * value.getRowBytes();
             }
         };
     }
 
-    public boolean contains(Integer key) {
-        return get(key) != null;
+    public boolean contains(String key) {
+        return lruCache.get(key) != null;
     }
 
     @Override
-    public Bitmap get(Integer key) {
+    public Bitmap get(String key) {
         return lruCache.get(key);
     }
 
     @Override
-    public Bitmap put(Integer key, Bitmap bitmap) {
+    public Bitmap put(String key, Bitmap bitmap) {
         return lruCache.put(key, bitmap);
     }
 
","16     private final LruCache<String, Bitmap> lruCache;
20         lruCache = new LruCache<String, Bitmap>(maxSize) {
22             protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
30             protected int sizeOf(String key, Bitmap value) {
37     public boolean contains(String key) {
38         return lruCache.get(key) != null;
42     public Bitmap get(String key) {
47     public Bitmap put(String key, Bitmap bitmap) {
16     private final LruCache<Integer, Bitmap> lruCache;
20         lruCache = new LruCache<Integer, Bitmap>(maxSize) {
22             protected void entryRemoved(boolean evicted, Integer key, Bitmap oldValue, Bitmap newValue) {
30             protected int sizeOf(Integer key, Bitmap value) {
37     public boolean contains(Integer key) {
38         return get(key) != null;
42     public Bitmap get(Integer key) {
47     public Bitmap put(Integer key, Bitmap bitmap) {",No
library\src\com\bumptech\glide\resize\cache\MemoryCache.java,library\src\com\bumptech\glide\resize\cache\MemoryCache.java,933f43576bda8138f85ec83fc93c5659dad35d82,ebee47a832ac2e333ed2ff453021810b10d2ea16,Revert to using String keys for caching,"@@ -18,14 +18,14 @@ public interface MemoryCache {
      * @param key The key
      * @return true iff the key has a non null value in the cache
      */
-    public boolean contains(Integer key);
+    public boolean contains(String key);
 
     /**
      * Get a value from the cache
      * @param key The key
      * @return The bitmap at key or null if the key is not present
      */
-    public Bitmap get(Integer key);
+    public Bitmap get(String key);
 
     /**
      * Add bitmap to the cache with the given key
@@ -33,7 +33,7 @@ public interface MemoryCache {
      * @param bitmap The bitmap to store
      * @return The old value of key (null if key is not in map)
      */
-    public Bitmap put(Integer key, Bitmap bitmap);
+    public Bitmap put(String key, Bitmap bitmap);
 
     /**
      * Set the listener to be called when a bitmap is removed from the cache
","21     public boolean contains(String key);
28     public Bitmap get(String key);
36     public Bitmap put(String key, Bitmap bitmap);
21     public boolean contains(Integer key);
28     public Bitmap get(Integer key);
36     public Bitmap put(Integer key, Bitmap bitmap);",No
library\src\com\bumptech\glide\resize\cache\MemoryCacheAdapter.java,library\src\com\bumptech\glide\resize\cache\MemoryCacheAdapter.java,933f43576bda8138f85ec83fc93c5659dad35d82,ebee47a832ac2e333ed2ff453021810b10d2ea16,Revert to using String keys for caching,"@@ -3,18 +3,19 @@ package com.bumptech.glide.resize.cache;
 import android.graphics.Bitmap;
 
 public class MemoryCacheAdapter implements MemoryCache {
+
     @Override
-    public boolean contains(Integer key) {
+    public boolean contains(String key) {
         return false;
     }
 
     @Override
-    public Bitmap get(Integer key) {
+    public Bitmap get(String key) {
         return null;
     }
 
     @Override
-    public Bitmap put(Integer key, Bitmap bitmap) {
+    public Bitmap put(String key, Bitmap bitmap) {
         return null;
     }
 
","6 
8     public boolean contains(String key) {
13     public Bitmap get(String key) {
18     public Bitmap put(String key, Bitmap bitmap) {
7     public boolean contains(Integer key) {
12     public Bitmap get(Integer key) {
17     public Bitmap put(Integer key, Bitmap bitmap) {",No
library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,library\src\com\bumptech\glide\loader\stream\VolleyStreamLoader.java,fdb5f853e615ab46a4f3dea3a46bfca09c75f27a,933f43576bda8138f85ec83fc93c5659dad35d82,Fix a warning in VolleyStreamLoader,"@@ -19,6 +19,7 @@ public class VolleyStreamLoader implements StreamLoader {
     private final RetryPolicy retryPolicy;
     private Request current = null;
 
+    @SuppressWarnings(""unused"")
     public VolleyStreamLoader(RequestQueue requestQueue, String url) {
         this(requestQueue, url, new DefaultRetryPolicy());
     }
","22     @SuppressWarnings(""unused"")",No
Makefile,Makefile,5c440624273f5f284cc464cbc7d39cc68a68825a,fdb5f853e615ab46a4f3dea3a46bfca09c75f27a,Compile volley as a jar and not a library project,"@@ -1,5 +1,8 @@
 setup:
 	git submodule init
 	git submodule update
-	echo android.library=true >> library/volley/project.properties
+	cd library/volley && ant jar
+	cp library/volley/bin/volley.jar library/libs
+
+update-ant: setup
 	android update project --path .. --library glide/library
","4 	cd library/volley && ant jar
5 	cp library/volley/bin/volley.jar library/libs
6 
7 update-ant: setup
4 	echo android.library=true >> library/volley/project.properties",No
library\build.gradle,library\build.gradle,5c440624273f5f284cc464cbc7d39cc68a68825a,fdb5f853e615ab46a4f3dea3a46bfca09c75f27a,Compile volley as a jar and not a library project,"@@ -16,10 +16,9 @@ repositories {
 dependencies {
     compile files('libs/disklrucache-2.0.2.jar')
     compile 'com.android.support:support-v4:13.0.+'
-    compile project('volley')
+    compile files('libs/volley.jar')
 }
 
-
 android {
     compileSdkVersion 17
     buildToolsVersion = 17
","19     compile files('libs/volley.jar')
19     compile project('volley')
22 ",No
library\project.properties,library\project.properties,5c440624273f5f284cc464cbc7d39cc68a68825a,fdb5f853e615ab46a4f3dea3a46bfca09c75f27a,Compile volley as a jar and not a library project,"@@ -13,4 +13,3 @@
 android.library=true
 # Project target.
 target=android-16
-android.library.reference.1=volley
",16 android.library.reference.1=volley,No
library\tests\project.properties,library\tests\project.properties,5c440624273f5f284cc464cbc7d39cc68a68825a,fdb5f853e615ab46a4f3dea3a46bfca09c75f27a,Compile volley as a jar and not a library project,"@@ -12,4 +12,4 @@
 
 # Project target.
 target=android-16
-android.library.reference.1=../../library
+
","15 
15 android.library.reference.1=../../library",No
,library\src\com\bumptech\glide\resize\Downsampler.java,c27229a159bfc992874609270ab8b57981fef339,5c440624273f5f284cc464cbc7d39cc68a68825a,Refactor downsampler and transformation out of IR,"@@ -0,0 +1,156 @@
+package com.bumptech.glide.resize;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+
+import java.io.IOException;
+
+/**
+ * A base class with methods for loading and decoding images from InputStreams.
+ */
+public abstract class Downsampler {
+    private final String id = getClass().toString();
+
+    /**
+     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
+     * will be greater than or equal to the given width and height.
+     *
+     */
+    public static Downsampler AT_LEAST = new Downsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return Math.min(inHeight / outHeight, inWidth / outWidth);
+        }
+    };
+
+    /**
+     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
+     * will be less than or equal to the given width and height.
+     *
+     */
+    public static Downsampler AT_MOST = new Downsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return Math.max(inHeight / outHeight, inWidth / outWidth);
+        }
+    };
+
+
+    /**
+     * Load the image at its original size
+     *
+     */
+    public static Downsampler NONE = new Downsampler() {
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return 0;
+        }
+    };
+
+    private static final int MARK_POSITION = 1024 * 1024; //1mb
+
+    /**
+     * Load the image for the given InputStream. If a recycled Bitmap whose dimensions exactly match those of the image
+     * for the given InputStream is available, the operation is much less expensive in terms of memory.
+     *
+     * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
+     * given InputStream is provided.
+     *
+     * @param bis An InputStream to the data for the image
+     * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
+     * @param pool A pool of recycled bitmaps
+     * @param outWidth The width the final image should be close to
+     * @param outHeight The height the final image should be close to
+     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
+     */
+    public Bitmap downsample(RecyclableBufferedInputStream bis, BitmapFactory.Options options, BitmapPool pool, int outWidth, int outHeight) {
+        final int[] inDimens = getDimensions(bis, options);
+        final int inWidth = inDimens[0];
+        final int inHeight = inDimens[1];
+
+        final int sampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);
+
+        //sample sizes <= 1 do nothing
+        if (sampleSize > 1) {
+            options.inSampleSize = sampleSize;
+        } else {
+            setInBitmap(options, pool.get(inWidth, inHeight));
+        }
+
+        return decodeStream(bis, options);
+    }
+
+    /**
+     * Get some id that uniquely identifies the downsample for use as part of a cache key
+     * @return A unique String
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Determine the amount of downsampling to use for a load given the dimensions of the image to be downsampled and
+     * the dimensions of the view/target the image will be displayed in.
+     *
+     * @see BitmapFactory.Options#inSampleSize
+     *
+     * @param inWidth The width of the image to be downsampled
+     * @param inHeight The height of the image to be downsampled
+     * @param outWidth The width of the view/target the image will be displayed in
+     * @param outHeight The height of the view/target the imag will be displayed in
+     * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
+     */
+    protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
+
+    /**
+     * A method for getting the dimensions of an image from the given InputStream
+     *
+     * @param bis The InputStream representing the image
+     * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
+     * @return an array containing the dimensions of the image in the form {width, height}
+     */
+    public int[] getDimensions(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {
+        options.inJustDecodeBounds = true;
+        decodeStream(bis, options);
+        options.inJustDecodeBounds = false;
+        return new int[] { options.outWidth, options.outHeight };
+    }
+
+
+    private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {
+         if (options.inJustDecodeBounds) {
+             bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
+                         //something large enough to minimize the possibility of not being able to fit
+                         //enough of the header in the buffer to get the image size so that we don't fail
+                         //to load images. The BufferedInputStream will create a new buffer of 2x the
+                         //original size each time we use up the buffer space without passing the mark so
+                         //this is a maximum bound on the buffer size, not a default. Most of the time we
+                         //won't go past our pre-allocated 16kb
+         }
+
+        final Bitmap result = BitmapFactory.decodeStream(bis, null, options);
+
+        try {
+            if (options.inJustDecodeBounds) {
+                bis.reset();
+                bis.clearMark();
+            } else {
+                bis.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return result;
+    }
+
+    @TargetApi(11)
+    private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
+        if (Build.VERSION.SDK_INT >= 11) {
+            options.inBitmap = recycled;
+        }
+    }
+}
","1 package com.bumptech.glide.resize;
2 
3 import android.annotation.TargetApi;
4 import android.graphics.Bitmap;
5 import android.graphics.BitmapFactory;
6 import android.os.Build;
7 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
8 
9 import java.io.IOException;
10 
11 /**
12  * A base class with methods for loading and decoding images from InputStreams.
13  */
14 public abstract class Downsampler {
15     private final String id = getClass().toString();
16 
17     /**
18      * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
19      * will be greater than or equal to the given width and height.
20      *
21      */
22     public static Downsampler AT_LEAST = new Downsampler() {
23         @Override
24         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
25             return Math.min(inHeight / outHeight, inWidth / outWidth);
26         }
27     };
28 
29     /**
30      * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image
31      * will be less than or equal to the given width and height.
32      *
33      */
34     public static Downsampler AT_MOST = new Downsampler() {
35         @Override
36         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
37             return Math.max(inHeight / outHeight, inWidth / outWidth);
38         }
39     };
40 
41 
42     /**
43      * Load the image at its original size
44      *
45      */
46     public static Downsampler NONE = new Downsampler() {
47         @Override
48         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
49             return 0;
50         }
51     };
52 
53     private static final int MARK_POSITION = 1024 * 1024; //1mb
54 
55     /**
56      * Load the image for the given InputStream. If a recycled Bitmap whose dimensions exactly match those of the image
57      * for the given InputStream is available, the operation is much less expensive in terms of memory.
58      *
59      * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
60      * given InputStream is provided.
61      *
62      * @param bis An InputStream to the data for the image
63      * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
64      * @param pool A pool of recycled bitmaps
65      * @param outWidth The width the final image should be close to
66      * @param outHeight The height the final image should be close to
67      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
68      */
69     public Bitmap downsample(RecyclableBufferedInputStream bis, BitmapFactory.Options options, BitmapPool pool, int outWidth, int outHeight) {
70         final int[] inDimens = getDimensions(bis, options);
71         final int inWidth = inDimens[0];
72         final int inHeight = inDimens[1];
73 
74         final int sampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);
75 
76         //sample sizes <= 1 do nothing
77         if (sampleSize > 1) {
78             options.inSampleSize = sampleSize;
79         } else {
80             setInBitmap(options, pool.get(inWidth, inHeight));
81         }
82 
83         return decodeStream(bis, options);
84     }
85 
86     /**
87      * Get some id that uniquely identifies the downsample for use as part of a cache key
88      * @return A unique String
89      */
90     public String getId() {
91         return id;
92     }
93 
94     /**
95      * Determine the amount of downsampling to use for a load given the dimensions of the image to be downsampled and
96      * the dimensions of the view/target the image will be displayed in.
97      *
98      * @see BitmapFactory.Options#inSampleSize
99      *
100      * @param inWidth The width of the image to be downsampled
101      * @param inHeight The height of the image to be downsampled
102      * @param outWidth The width of the view/target the image will be displayed in
103      * @param outHeight The height of the view/target the imag will be displayed in
104      * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
105      */
106     protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
107 
108     /**
109      * A method for getting the dimensions of an image from the given InputStream
110      *
111      * @param bis The InputStream representing the image
112      * @param options The options to pass to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect, android.graphics.BitmapFactory.Options)}
113      * @return an array containing the dimensions of the image in the form {width, height}
114      */
115     public int[] getDimensions(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {
116         options.inJustDecodeBounds = true;
117         decodeStream(bis, options);
118         options.inJustDecodeBounds = false;
119         return new int[] { options.outWidth, options.outHeight };
120     }
121 
122 
123     private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {
124          if (options.inJustDecodeBounds) {
125              bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
126                          //something large enough to minimize the possibility of not being able to fit
127                          //enough of the header in the buffer to get the image size so that we don't fail
128                          //to load images. The BufferedInputStream will create a new buffer of 2x the
129                          //original size each time we use up the buffer space without passing the mark so
130                          //this is a maximum bound on the buffer size, not a default. Most of the time we
131                          //won't go past our pre-allocated 16kb
132          }
133 
134         final Bitmap result = BitmapFactory.decodeStream(bis, null, options);
135 
136         try {
137             if (options.inJustDecodeBounds) {
138                 bis.reset();
139                 bis.clearMark();
140             } else {
141                 bis.close();
142             }
143         } catch (IOException e) {
144             e.printStackTrace();
145         }
146 
147         return result;
148     }
149 
150     @TargetApi(11)
151     private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
152         if (Build.VERSION.SDK_INT >= 11) {
153             options.inBitmap = recycled;
154         }
155     }
156 }",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,c27229a159bfc992874609270ab8b57981fef339,5c440624273f5f284cc464cbc7d39cc68a68825a,Refactor downsampler and transformation out of IR,"@@ -362,28 +362,7 @@ public class ImageManager {
         return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
-                return resizer.loadAsIs(is);
-            }
-        });
-    }
-
-    /**
-     * Loads the image assuming its width and height are exactly those given.
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The width of the image on disk
-     * @param height The height of the image on disk
-     * @param cb The callback called when the load completes
-     * @return A token tracking this request
-     */
-    public Object getImageExact(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final String key = getKey(id, width, height, ResizeType.AS_IS);
-        return runJob(key, cb, new ImageManagerJob(streamLoader) {
-            @Override
-            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
-                return resizer.loadAsIs(is, width, height);
+                return resizer.load(is);
             }
         });
     }
@@ -404,7 +383,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
-                return resizer.loadAtLeast(is, width, height);
+                return resizer.load(is, width, height);
             }
         });
     }
@@ -426,7 +405,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
-                return resizer.centerCrop(is, width, height);
+                return resizer.load(is, width, height, Transformation.CENTER_CROP);
             }
         });
     }
@@ -448,7 +427,7 @@ public class ImageManager {
         return runJob(key, cb, new ImageManagerJob(streamLoader) {
             @Override
             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
-                return resizer.fitInSpace(is, width, height);
+                return resizer.load(is, width, height, Transformation.FIT_CENTER);
             }
         });
     }
@@ -661,7 +640,7 @@ public class ImageManager {
         Bitmap result = null;
         final InputStream is = diskCache.get(key);
         if (is != null) {
-            result = resizer.loadAsIs(is);
+            result = resizer.load(is);
             if (result == null) {
                 diskCache.delete(key); //the image must have been corrupted
             }
","365                 return resizer.load(is);
386                 return resizer.load(is, width, height);
408                 return resizer.load(is, width, height, Transformation.CENTER_CROP);
430                 return resizer.load(is, width, height, Transformation.FIT_CENTER);
643             result = resizer.load(is);
365                 return resizer.loadAsIs(is);
366             }
367         });
368     }
369 
370     /**
371      * Loads the image assuming its width and height are exactly those given.
372      *
373      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
374      *           is not required to do so
375      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
376      * @param width The width of the image on disk
377      * @param height The height of the image on disk
378      * @param cb The callback called when the load completes
379      * @return A token tracking this request
380      */
381     public Object getImageExact(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
382         final String key = getKey(id, width, height, ResizeType.AS_IS);
383         return runJob(key, cb, new ImageManagerJob(streamLoader) {
384             @Override
385             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
386                 return resizer.loadAsIs(is, width, height);
407                 return resizer.loadAtLeast(is, width, height);
429                 return resizer.centerCrop(is, width, height);
451                 return resizer.fitInSpace(is, width, height);
664             result = resizer.loadAsIs(is);",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\ImageResizer.java,c27229a159bfc992874609270ab8b57981fef339,5c440624273f5f284cc464cbc7d39cc68a68825a,Refactor downsampler and transformation out of IR,"@@ -25,7 +25,6 @@ import java.util.Queue;
  */
 public class ImageResizer {
     private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
-    private static final int MARK_POSITION = 1024 * 1024; //1mb
     private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;
     private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
     private final BitmapPool bitmapPool;
@@ -63,70 +62,6 @@ public class ImageResizer {
         this(null, options);
     }
 
-    private abstract class ImageDownsampler {
-        public Bitmap load(InputStream is, int width, int height) {
-            byte[] bytes = getTempBytes();
-            RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
-            final int[] inDimens = getDimens(bis, width, height);
-
-            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-            final int sampleSize = getSampleSize(inDimens[0], inDimens[1], width, height);
-
-            final BitmapFactory.Options decodeBitmapOptions;
-            if (sampleSize > 1) {
-                decodeBitmapOptions = getOptions();
-                decodeBitmapOptions.inSampleSize = sampleSize;
-            } else {
-                decodeBitmapOptions = getOptions(getRecycled(inDimens));
-            }
-
-            Bitmap result = decodeStream(bis, decodeBitmapOptions);
-            releaseTempBytes(bytes);
-            return result;
-        }
-
-        protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
-
-        protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
-            return getDimensions(bis);
-        }
-    }
-
-    private final ImageDownsampler atLeastDownsampler = new ImageDownsampler() {
-
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
-            return Math.min(inHeight / outHeight, inWidth / outWidth);
-        }
-    };
-
-    private final ImageDownsampler atMostDownsampler = new ImageDownsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return Math.max(inHeight / outHeight, inWidth / outWidth);
-        }
-    };
-
-    private final ImageDownsampler asIsDownsampler = new ImageDownsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return 0;
-        }
-    };
-
-    private final ImageDownsampler fixedAsIsDownsampler = new ImageDownsampler() {
-        @Override
-        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
-            return 0;
-        }
-
-        @Override
-        protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
-            return new int[] { inWidth, inHeight };
-
-        }
-    };
     /**
      * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
      *
@@ -146,166 +81,46 @@ public class ImageResizer {
         }
     }
 
-    /**
-     * Scale the image so that either the width of the image matches the given width and the height of the image is
-     * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
-     *
-     * Does not maintain the image's aspect ratio
-     *
-     * @param is The InputStream for the image
-     * @param width The minimum width of the image
-     * @param height The minimum height of the image
-     * @return The resized image
-     */
-    public Bitmap centerCrop(InputStream is, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is, width, height);
-        return centerCrop(getRecycled(width, height), streamed, width, height);
+    public Bitmap load(InputStream is) {
+        return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
     }
 
-    /**
-     * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
-     * will be equal to the given dimension and the other will be less than the given dimension
-     *
-     * @param is The InputStream for the image
-     * @param width The maximum width of the image
-     * @param height The maximum height of the image
-     * @return The resized image
-     */
-    public Bitmap fitInSpace(InputStream is, int width, int height) {
-        final Bitmap streamed = loadAtLeast(is, width > height ? 1 : width, height > width ? 1 : height);
-        return fitInSpace(streamed, width, height);
+    public Bitmap load(InputStream is, int outWidth, int outHeight) {
+        return load(is, outWidth, outHeight, Transformation.NONE);
     }
 
-    /**
-     * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
-     * greater than or equal to the given width and height.
-     *
-     * @param is An inputStream for the image
-     * @param width The minimum width of the returned Bitmap
-     * @param height The minimum height of the returned Bitmap
-     * @return A Bitmap containing the image
-     */
-    public Bitmap loadAtLeast(InputStream is, int width, int height) {
-        return atLeastDownsampler.load(is, width, height);
+    public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
+        return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
     }
 
-    /**
-     * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
-     * less than or equal to the given width and height. Unlike {@link #fitInSpace(android.graphics.Bitmap, int, int)},
-     * one or both dimensions may be less than the given dimensions.
-     *
-     * @param is An InputStream for the image.
-     * @param width The maximum width
-     * @param height The maximum height
-     * @return A bitmap containing the image
-     */
-    @SuppressWarnings(""unused"")
-    public Bitmap loadAtMost(InputStream is, int width, int height) {
-        return atMostDownsampler.load(is, width, height);
-    }
+    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
+        byte[] tempBytesForBis = getTempBytes();
+        byte[] tempBytesForOptions = getTempBytes();
 
-    /**
-     * Load the image at its original size
-     *
-     * @param is The InputStream for the image
-     * @return The loaded image
-     */
-    public Bitmap loadAsIs(final InputStream is) {
-        return asIsDownsampler.load(is, 0, 0);
-    }
+        BitmapFactory.Options options = getOptions();
+        options.inTempStorage = tempBytesForOptions;
 
-    /**
-     * Load the image at its original size
-     *
-     * This is somewhat more efficient than {@link #loadAsIs(java.io.InputStream)} because it does not need to read
-     * the image header to determine the image's width and height. Instead, it assumes the given width and height
-     *
-     * @param is The InputStream for the image
-     * @param width The width of the image represented by the InputStream
-     * @param height The height of the image represented by the InputStream
-     * @return The loaded image
-     */
-    public Bitmap loadAsIs(InputStream is, int width, int height) {
-        return fixedAsIsDownsampler.load(is, width, height);
-    }
+        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);
 
-    /**
-     * A potentially expensive operation to load the image for the given InputStream. If a recycled Bitmap whose
-     * dimensions exactly match those of the image for the given InputStream is available, the operation is much less
-     * expensive in terms of memory.
-     *
-     * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
-     * given InputStream is provided.
-     *
-     * @param is The InputStream representing the image data
-     * @param recycle A Bitmap we can load the image into, or null
-     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
-     */
-    private Bitmap load(RecyclableBufferedInputStream is, Bitmap recycle){
-        final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
-        return decodeStream(is, decodeBitmapOptions);
-    }
+        final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
+        final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);
 
-    /**
-     * A method for getting the dimensions of an image from the given InputStream
-     *
-     * @param is The InputStream representing the image
-     * @return an array containing the dimensions of the image in the form {width, height}
-     */
-    private int[] getDimensions(RecyclableBufferedInputStream is) {
-        final BitmapFactory.Options decodeBoundsOptions = getOptions();
-        decodeBoundsOptions.inJustDecodeBounds = true;
-        decodeStream(is, decodeBoundsOptions);
-        return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
-    }
-
-    private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {
-        decodeBitmapOptions.inTempStorage = getTempBytes();
-
-        if (decodeBitmapOptions.inJustDecodeBounds) {
-            bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
-                                     //something large enough to minimize the possibility of not being able to fit
-                                     //enough of the header in the buffer to get the image size so that we don't fail
-                                     //to load images. The BufferedInputStream will create a new buffer of 2x the
-                                     //original size each time we use up the buffer space without passing the mark so
-                                     //this is a maximum bound on the buffer size, not a default. Most of the time we
-                                     //won't go past our pre-allocated 16kb
-        }
-        final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
-        try {
-            if (decodeBitmapOptions.inJustDecodeBounds) {
-                bis.reset();
-                bis.clearMark();
-            } else {
-                bis.close();
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            releaseTempBytes(decodeBitmapOptions.inTempStorage);
+        if (initial != result) {
+            bitmapPool.put(initial);
         }
 
+        releaseTempBytes(tempBytesForBis);
+        releaseTempBytes(tempBytesForOptions);
+
         return result;
     }
 
     private BitmapFactory.Options getOptions() {
-        return getOptions(null);
-    }
-
-    private BitmapFactory.Options getOptions(Bitmap recycle) {
         BitmapFactory.Options result = new BitmapFactory.Options();
-        copyOptions(defaultOptions, result, recycle);
+        copyOptions(defaultOptions, result);
         return result;
     }
 
-    private Bitmap getRecycled(int[] dimens) {
-        return getRecycled(dimens[0], dimens[1]);
-    }
-
-    private Bitmap getRecycled(int width, int height) {
-        return bitmapPool.get(width, height);
-    }
-
     private byte[] getTempBytes() {
         byte[] result;
         synchronized (tempQueue) {
@@ -324,9 +139,9 @@ public class ImageResizer {
         }
     }
 
-    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
+    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
         if (Build.VERSION.SDK_INT >= 11) {
-            copyOptionsHoneycomb(from, to, recycled);
+            copyOptionsHoneycomb(from, to);
         } else if (Build.VERSION.SDK_INT >= 10) {
             copyOptionsGingerbreadMr1(from, to);
         } else {
@@ -335,10 +150,9 @@ public class ImageResizer {
     }
 
     @TargetApi(11)
-    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
+    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
         copyOptionsGingerbreadMr1(from, to);
         to.inMutable = from.inMutable;
-        to.inBitmap = recycled;
     }
 
     @TargetApi(10)
","84     public Bitmap load(InputStream is) {
85         return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
88     public Bitmap load(InputStream is, int outWidth, int outHeight) {
89         return load(is, outWidth, outHeight, Transformation.NONE);
92     public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
93         return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
96     public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
97         byte[] tempBytesForBis = getTempBytes();
98         byte[] tempBytesForOptions = getTempBytes();
99 
100         BitmapFactory.Options options = getOptions();
101         options.inTempStorage = tempBytesForOptions;
102 
103         RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);
104 
105         final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
106         final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);
107 
108         if (initial != result) {
109             bitmapPool.put(initial);
112         releaseTempBytes(tempBytesForBis);
113         releaseTempBytes(tempBytesForOptions);
120         copyOptions(defaultOptions, result);
142     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
144             copyOptionsHoneycomb(from, to);
153     private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
28     private static final int MARK_POSITION = 1024 * 1024; //1mb
66     private abstract class ImageDownsampler {
67         public Bitmap load(InputStream is, int width, int height) {
68             byte[] bytes = getTempBytes();
69             RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytes);
70             final int[] inDimens = getDimens(bis, width, height);
71 
72             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
73             final int sampleSize = getSampleSize(inDimens[0], inDimens[1], width, height);
74 
75             final BitmapFactory.Options decodeBitmapOptions;
76             if (sampleSize > 1) {
77                 decodeBitmapOptions = getOptions();
78                 decodeBitmapOptions.inSampleSize = sampleSize;
79             } else {
80                 decodeBitmapOptions = getOptions(getRecycled(inDimens));
81             }
82 
83             Bitmap result = decodeStream(bis, decodeBitmapOptions);
84             releaseTempBytes(bytes);
85             return result;
86         }
87 
88         protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);
89 
90         protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
91             return getDimensions(bis);
92         }
93     }
94 
95     private final ImageDownsampler atLeastDownsampler = new ImageDownsampler() {
96 
97         @Override
98         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
99             // inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings
100             return Math.min(inHeight / outHeight, inWidth / outWidth);
101         }
102     };
103 
104     private final ImageDownsampler atMostDownsampler = new ImageDownsampler() {
105         @Override
106         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
107             return Math.max(inHeight / outHeight, inWidth / outWidth);
108         }
109     };
110 
111     private final ImageDownsampler asIsDownsampler = new ImageDownsampler() {
112         @Override
113         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
114             return 0;
115         }
116     };
117 
118     private final ImageDownsampler fixedAsIsDownsampler = new ImageDownsampler() {
119         @Override
120         protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
121             return 0;
122         }
123 
124         @Override
125         protected int[] getDimens(RecyclableBufferedInputStream bis, int inWidth, int inHeight) {
126             return new int[] { inWidth, inHeight };
127 
128         }
129     };
149     /**
150      * Scale the image so that either the width of the image matches the given width and the height of the image is
151      * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
152      *
153      * Does not maintain the image's aspect ratio
154      *
155      * @param is The InputStream for the image
156      * @param width The minimum width of the image
157      * @param height The minimum height of the image
158      * @return The resized image
159      */
160     public Bitmap centerCrop(InputStream is, int width, int height) {
161         final Bitmap streamed = loadAtLeast(is, width, height);
162         return centerCrop(getRecycled(width, height), streamed, width, height);
165     /**
166      * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
167      * will be equal to the given dimension and the other will be less than the given dimension
168      *
169      * @param is The InputStream for the image
170      * @param width The maximum width of the image
171      * @param height The maximum height of the image
172      * @return The resized image
173      */
174     public Bitmap fitInSpace(InputStream is, int width, int height) {
175         final Bitmap streamed = loadAtLeast(is, width > height ? 1 : width, height > width ? 1 : height);
176         return fitInSpace(streamed, width, height);
179     /**
180      * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
181      * greater than or equal to the given width and height.
182      *
183      * @param is An inputStream for the image
184      * @param width The minimum width of the returned Bitmap
185      * @param height The minimum height of the returned Bitmap
186      * @return A Bitmap containing the image
187      */
188     public Bitmap loadAtLeast(InputStream is, int width, int height) {
189         return atLeastDownsampler.load(is, width, height);
192     /**
193      * Scale the image uniformly (maintaining the image's aspect ratio) so that the dimensions of the image will be
194      * less than or equal to the given width and height. Unlike {@link #fitInSpace(android.graphics.Bitmap, int, int)},
195      * one or both dimensions may be less than the given dimensions.
196      *
197      * @param is An InputStream for the image.
198      * @param width The maximum width
199      * @param height The maximum height
200      * @return A bitmap containing the image
201      */
202     @SuppressWarnings(""unused"")
203     public Bitmap loadAtMost(InputStream is, int width, int height) {
204         return atMostDownsampler.load(is, width, height);
207     /**
208      * Load the image at its original size
209      *
210      * @param is The InputStream for the image
211      * @return The loaded image
212      */
213     public Bitmap loadAsIs(final InputStream is) {
214         return asIsDownsampler.load(is, 0, 0);
215     }
216 
217     /**
218      * Load the image at its original size
219      *
220      * This is somewhat more efficient than {@link #loadAsIs(java.io.InputStream)} because it does not need to read
221      * the image header to determine the image's width and height. Instead, it assumes the given width and height
222      *
223      * @param is The InputStream for the image
224      * @param width The width of the image represented by the InputStream
225      * @param height The height of the image represented by the InputStream
226      * @return The loaded image
227      */
228     public Bitmap loadAsIs(InputStream is, int width, int height) {
229         return fixedAsIsDownsampler.load(is, width, height);
230     }
231 
232     /**
233      * A potentially expensive operation to load the image for the given InputStream. If a recycled Bitmap whose
234      * dimensions exactly match those of the image for the given InputStream is available, the operation is much less
235      * expensive in terms of memory.
236      *
237      * Note - this method will throw an exception of a Bitmap with dimensions not matching those of the image for the
238      * given InputStream is provided.
239      *
240      * @param is The InputStream representing the image data
241      * @param recycle A Bitmap we can load the image into, or null
242      * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null
243      */
244     private Bitmap load(RecyclableBufferedInputStream is, Bitmap recycle){
245         final BitmapFactory.Options decodeBitmapOptions = getOptions(recycle);
246         return decodeStream(is, decodeBitmapOptions);
247     }
248 
249     /**
250      * A method for getting the dimensions of an image from the given InputStream
251      *
252      * @param is The InputStream representing the image
253      * @return an array containing the dimensions of the image in the form {width, height}
254      */
255     private int[] getDimensions(RecyclableBufferedInputStream is) {
256         final BitmapFactory.Options decodeBoundsOptions = getOptions();
257         decodeBoundsOptions.inJustDecodeBounds = true;
258         decodeStream(is, decodeBoundsOptions);
259         return new int[] { decodeBoundsOptions.outWidth, decodeBoundsOptions.outHeight };
260     }
261 
262     private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options decodeBitmapOptions) {
263         decodeBitmapOptions.inTempStorage = getTempBytes();
264 
265         if (decodeBitmapOptions.inJustDecodeBounds) {
266             bis.mark(MARK_POSITION); //this is large, but jpeg headers are not size bounded so we need
267                                      //something large enough to minimize the possibility of not being able to fit
268                                      //enough of the header in the buffer to get the image size so that we don't fail
269                                      //to load images. The BufferedInputStream will create a new buffer of 2x the
270                                      //original size each time we use up the buffer space without passing the mark so
271                                      //this is a maximum bound on the buffer size, not a default. Most of the time we
272                                      //won't go past our pre-allocated 16kb
273         }
274         final Bitmap result = BitmapFactory.decodeStream(bis, null, decodeBitmapOptions);
275         try {
276             if (decodeBitmapOptions.inJustDecodeBounds) {
277                 bis.reset();
278                 bis.clearMark();
279             } else {
280                 bis.close();
281             }
282         } catch (IOException e) {
283             e.printStackTrace();
284         } finally {
285             releaseTempBytes(decodeBitmapOptions.inTempStorage);
286         }
292         return getOptions(null);
293     }
294 
295     private BitmapFactory.Options getOptions(Bitmap recycle) {
297         copyOptions(defaultOptions, result, recycle);
301     private Bitmap getRecycled(int[] dimens) {
302         return getRecycled(dimens[0], dimens[1]);
303     }
304 
305     private Bitmap getRecycled(int width, int height) {
306         return bitmapPool.get(width, height);
307     }
308 
327     private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
329             copyOptionsHoneycomb(from, to, recycled);
338     private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to, Bitmap recycled) {
341         to.inBitmap = recycled;",No
,library\src\com\bumptech\glide\resize\Transformation.java,c27229a159bfc992874609270ab8b57981fef339,5c440624273f5f284cc464cbc7d39cc68a68825a,Refactor downsampler and transformation out of IR,"@@ -0,0 +1,68 @@
+package com.bumptech.glide.resize;
+
+import android.graphics.Bitmap;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+
+/**
+ * A class for performing an arbitrary transformation on a bitmap
+ */
+public abstract class Transformation {
+    private final String id = getClass().toString();
+
+    /**
+     * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
+     * will be equal to the given dimension and the other will be less than the given dimension
+     */
+    public static Transformation CENTER_CROP = new Transformation() {
+        @Override
+        public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
+            return ImageResizer.centerCrop(pool.get(outWidth, outHeight), bitmap, outWidth, outHeight);
+        }
+    };
+
+    /**
+     * Scale the image so that either the width of the image matches the given width and the height of the image is
+     * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
+     *
+     * Does not maintain the image's aspect ratio
+     */
+    public static Transformation FIT_CENTER = new Transformation() {
+        @Override
+        public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
+            return ImageResizer.fitInSpace(bitmap, outWidth, outHeight);
+        }
+    };
+
+    /**
+     * A noop Transformation that simply returns the given bitmap
+     */
+    public static Transformation NONE = new Transformation() {
+        @Override
+        public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
+            return bitmap;
+        }
+    };
+
+    /**
+     * Transform the given bitmap. It is also acceptable to simply return the given bitmap if no transformation is
+     * required.
+     *
+     * @param bitmap The bitmap to transform
+     * @param pool A bitmap pool to obtain reused bitmaps from and release unneeded bitmaps to. It is always safe
+     *             to attempt to retrieve bitmaps. However, any bitmaps released to the pool must not be referenced
+     *             elsewhere or returned.
+     * @param outWidth The width of the view or target the bitmap will be displayed in
+     * @param outHeight The height of the view or target the bitmap will be displayed in
+     * @return The transformed bitmap
+     */
+    public abstract Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight);
+
+    /**
+     * A method to get a unique identifier for this particular transformation that can be used as part of a cache key
+     *
+     * @return A string that uniquely identifies this transformation from other transformations
+     */
+    public String getId() {
+        return id;
+    }
+}
","1 package com.bumptech.glide.resize;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
5 
6 /**
7  * A class for performing an arbitrary transformation on a bitmap
8  */
9 public abstract class Transformation {
10     private final String id = getClass().toString();
11 
12     /**
13      * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
14      * will be equal to the given dimension and the other will be less than the given dimension
15      */
16     public static Transformation CENTER_CROP = new Transformation() {
17         @Override
18         public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
19             return ImageResizer.centerCrop(pool.get(outWidth, outHeight), bitmap, outWidth, outHeight);
20         }
21     };
22 
23     /**
24      * Scale the image so that either the width of the image matches the given width and the height of the image is
25      * greater than the given height or vice versa, and then crop the larger dimension to match the given dimension.
26      *
27      * Does not maintain the image's aspect ratio
28      */
29     public static Transformation FIT_CENTER = new Transformation() {
30         @Override
31         public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
32             return ImageResizer.fitInSpace(bitmap, outWidth, outHeight);
33         }
34     };
35 
36     /**
37      * A noop Transformation that simply returns the given bitmap
38      */
39     public static Transformation NONE = new Transformation() {
40         @Override
41         public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
42             return bitmap;
43         }
44     };
45 
46     /**
47      * Transform the given bitmap. It is also acceptable to simply return the given bitmap if no transformation is
48      * required.
49      *
50      * @param bitmap The bitmap to transform
51      * @param pool A bitmap pool to obtain reused bitmaps from and release unneeded bitmaps to. It is always safe
52      *             to attempt to retrieve bitmaps. However, any bitmaps released to the pool must not be referenced
53      *             elsewhere or returned.
54      * @param outWidth The width of the view or target the bitmap will be displayed in
55      * @param outHeight The height of the view or target the bitmap will be displayed in
56      * @return The transformed bitmap
57      */
58     public abstract Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight);
59 
60     /**
61      * A method to get a unique identifier for this particular transformation that can be used as part of a cache key
62      *
63      * @return A string that uniquely identifies this transformation from other transformations
64      */
65     public String getId() {
66         return id;
67     }
68 }",No
library\src\com\bumptech\glide\resize\loader\Exact.java,,c27229a159bfc992874609270ab8b57981fef339,5c440624273f5f284cc464cbc7d39cc68a68825a,Refactor downsampler and transformation out of IR,"@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.loader;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.LoadedCallback;
-
-/**
- * Load an image at its original dimensions.
- *
- * <p>
- *     This class is almost identical to {@link AsIs} except that it assumes the image size is identical to the given
- *     dimensions. This assumption means we don't first need to read the image header to obtain the dimensions.
- * </p>
- *
- * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
- */
-@SuppressWarnings(""unused"")
-public class Exact extends ImageManagerLoader {
-
-    public Exact(Context context) {
-        super(context);
-    }
-
-    public Exact(ImageManager imageManager) {
-        super(imageManager);
-    }
-
-    @Override
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageExact(id, streamLoader, width, height, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onException(e);
-            }
-        });
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.loader;
6 
7 import android.content.Context;
8 import android.graphics.Bitmap;
9 import com.bumptech.glide.loader.stream.StreamLoader;
10 import com.bumptech.glide.resize.ImageManager;
11 import com.bumptech.glide.resize.LoadedCallback;
12 
13 /**
14  * Load an image at its original dimensions.
15  *
16  * <p>
17  *     This class is almost identical to {@link AsIs} except that it assumes the image size is identical to the given
18  *     dimensions. This assumption means we don't first need to read the image header to obtain the dimensions.
19  * </p>
20  *
21  * @see ImageManager#getImageExact(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
22  */
23 @SuppressWarnings(""unused"")
24 public class Exact extends ImageManagerLoader {
25 
26     public Exact(Context context) {
27         super(context);
28     }
29 
30     public Exact(ImageManager imageManager) {
31         super(imageManager);
32     }
33 
34     @Override
35     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
36         return imageManager.getImageExact(id, streamLoader, width, height, new LoadedCallback() {
37             @Override
38             public void onLoadCompleted(Bitmap loaded) {
39                 cb.onImageReady(loaded);
40             }
41 
42             @Override
43             public void onLoadFailed(Exception e) {
44                 cb.onException(e);
45             }
46         });
47     }
48 }",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -30,7 +30,6 @@ import com.bumptech.glide.util.Log;
 import com.bumptech.glide.util.Util;
 
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -69,13 +68,6 @@ public class ImageManager {
     private final DiskCache diskCache;
     private final Bitmap.CompressFormat bitmapCompressFormat;
 
-    private enum ResizeType {
-        CENTER_CROP,
-        FIT_CENTER,
-        APPROXIMATE,
-        AS_IS
-    }
-
     /**
      * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
      * This is a conservative estimate that has been safe for 2.2+ devices consistently. It is probably rather small
@@ -348,88 +340,16 @@ public class ImageManager {
         });
     }
 
-    /**
-     * Loads the image at its original dimensions.
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param cb The callback called when the load completes
-     * @return A token tracking this request
-     */
-    public Object getImage(String id, final StreamLoader streamLoader, final LoadedCallback cb){
-        final String key = getKey(id, -1, -1, ResizeType.AS_IS);
-        return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
-            @Override
-            protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
-                return resizer.load(is);
-            }
-        });
-    }
-
-    /**
-     * Loads the image to nearly the given width and height maintaining the original proportions.
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The desired width in pixels
-     * @param height The desired height of the slice
-     * @param cb The callback called when the task finishes
-     * @return A token tracking this request
-     */
-    public Object getImageApproximate(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final String key = getKey(id, width, height, ResizeType.APPROXIMATE);
-        return runJob(key, cb, new ImageManagerJob(streamLoader) {
-            @Override
-            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
-                return resizer.load(is, width, height);
-            }
-        });
-    }
-
-    /**
-     * Loads the image, resizes it to be exactly width pixels wide keeping proportions,
-     * and then returns a section from the center of image exactly height pixels tall.
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The desired width in pixels
-     * @param height The desired height of the slice
-     * @param cb The callback called when the task finishes
-     * @return A token tracking this request
-     */
-    public Object centerCrop(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
-        final String key = getKey(id, width, height, ResizeType.CENTER_CROP);
-        return runJob(key, cb, new ImageManagerJob(streamLoader) {
-            @Override
-            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
-                return resizer.load(is, width, height, Transformation.CENTER_CROP);
-            }
-        });
-    }
+    public Object getImage(String id, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
+        if (shutdown) return null;
+        final String key = getKey(id, downsampler, transformation, width, height);
 
-    /**
-     * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
-     * an area of width*height.
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The width of the space
-     * @param height The height of the space
-     * @param cb The callback called when the task finishes
-     * @return A token tracking this request
-     */
-    public Object fitCenter(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb){
-        final String key = getKey(id, width, height, ResizeType.FIT_CENTER);
-        return runJob(key, cb, new ImageManagerJob(streamLoader) {
-            @Override
-            protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
-                return resizer.load(is, width, height, Transformation.FIT_CENTER);
+        ImageManagerJob job = null;
+        if (!returnFromCache(key, cb)) {
+            job = new ImageManagerJob();
+            job.execute(key, streamLoader, width, height, downsampler, transformation, cb);
         }
-        });
+        return job;
     }
 
     /**
@@ -503,19 +423,6 @@ public class ImageManager {
         bgHandler.getLooper().quit();
     }
 
-    private Object runJob(String key, LoadedCallback cb, ImageManagerJob job) {
-        return runJob(key, cb, true, job);
-    }
-
-    private Object runJob(String key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
-        if (shutdown) return null;
-
-        if (!returnFromCache(key, cb)) {
-            job.execute(key, cb, useDiskCache);
-        }
-        return job;
-    }
-
     private boolean returnFromCache(String key, LoadedCallback cb) {
         Bitmap inCache = memoryCache.get(key);
         boolean found = inCache != null;
@@ -525,28 +432,30 @@ public class ImageManager {
         return found;
     }
 
-    private abstract class ImageManagerJob implements Runnable {
-        private final StreamLoader streamLoader;
+    private class ImageManagerJob implements Runnable {
+        private StreamLoader streamLoader;
         private String key;
         private LoadedCallback cb;
-        private boolean useDiskCache;
         private Future future = null;
         private volatile boolean cancelled = false;
+        private Transformation transformation;
+        private Downsampler downsampler;
+        private int width;
+        private int height;
 
-        public ImageManagerJob(StreamLoader streamLoader) {
-            this.streamLoader = streamLoader;
-        }
-
-        public void execute(String key, LoadedCallback cb, boolean useDiskCache) {
+        public void execute(String key, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
             this.key = key;
             this.cb = cb;
-            this.useDiskCache = useDiskCache;
+            this.width = width;
+            this.height = height;
+            this.streamLoader = streamLoader;
+            this.downsampler = downsampler;
+            this.transformation = transformation;
             bgHandler.post(this);
         }
 
         public void cancel() {
             cancelled = true;
-
             bgHandler.removeCallbacks(this);
             if (future != null) {
                 future.cancel(false);
@@ -555,13 +464,12 @@ public class ImageManager {
 
         @Override
         public void run() {
-            Bitmap result = null;
-            if (useDiskCache) {
-                result = getFromDiskCache(key);
-            }
+            Bitmap result = getFromDiskCache(key);
 
             if (result == null) {
                 try {
+                    //in almost every case exception will be because of race after calling shutdown. Not much we can do
+                    //either way
                     resizeWithPool();
                 } catch (Exception e) {
                     handleException(e);
@@ -571,8 +479,6 @@ public class ImageManager {
             }
         }
 
-        //in almost every case exception will be because of race after calling shutdown. Not much we can do
-        //either way
         private void resizeWithPool() throws RejectedExecutionException {
             future = executor.submit(new Runnable() {
                 @Override
@@ -611,7 +517,7 @@ public class ImageManager {
 
         private void finishResize(final Bitmap result, boolean isInDiskCache) {
             if (result != null) {
-                if (useDiskCache && !isInDiskCache) {
+                if (!isInDiskCache) {
                     putInDiskCache(key, result);
                 }
 
@@ -633,7 +539,9 @@ public class ImageManager {
             cb.onLoadFailed(e);
         }
 
-        protected abstract Bitmap resizeIfNotFound(InputStream is) throws IOException;
+        private Bitmap resizeIfNotFound(InputStream is) throws IOException {
+            return resizer.load(is, width, height, downsampler, transformation);
+        }
     }
 
     private Bitmap getFromDiskCache(String key) {
@@ -671,7 +579,8 @@ public class ImageManager {
         bitmapReferenceCounter.markPending(bitmap);
     }
 
-    private static String getKey(String id, int width, int height, ResizeType type){
-        return String.valueOf(Util.hash(id.hashCode(), width, height, type.hashCode()));
+    private static String getKey(String id, Downsampler downsampler, Transformation transformation, int width, int height) {
+        return String.valueOf(Util.hash(id.hashCode(), downsampler.getId().hashCode(),
+                transformation.getId().hashCode(), width, height));
     }
 }
","343     public Object getImage(String id, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
344         if (shutdown) return null;
345         final String key = getKey(id, downsampler, transformation, width, height);
347         ImageManagerJob job = null;
348         if (!returnFromCache(key, cb)) {
349             job = new ImageManagerJob();
350             job.execute(key, streamLoader, width, height, downsampler, transformation, cb);
352         return job;
435     private class ImageManagerJob implements Runnable {
436         private StreamLoader streamLoader;
441         private Transformation transformation;
442         private Downsampler downsampler;
443         private int width;
444         private int height;
446         public void execute(String key, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
449             this.width = width;
450             this.height = height;
451             this.streamLoader = streamLoader;
452             this.downsampler = downsampler;
453             this.transformation = transformation;
467             Bitmap result = getFromDiskCache(key);
471                     //in almost every case exception will be because of race after calling shutdown. Not much we can do
472                     //either way
520                 if (!isInDiskCache) {
542         private Bitmap resizeIfNotFound(InputStream is) throws IOException {
543             return resizer.load(is, width, height, downsampler, transformation);
544         }
582     private static String getKey(String id, Downsampler downsampler, Transformation transformation, int width, int height) {
583         return String.valueOf(Util.hash(id.hashCode(), downsampler.getId().hashCode(),
584                 transformation.getId().hashCode(), width, height));
33 import java.io.FileNotFoundException;
72     private enum ResizeType {
73         CENTER_CROP,
74         FIT_CENTER,
75         APPROXIMATE,
76         AS_IS
77     }
78 
351     /**
352      * Loads the image at its original dimensions.
353      *
354      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
355      *           is not required to do so
356      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
357      * @param cb The callback called when the load completes
358      * @return A token tracking this request
359      */
360     public Object getImage(String id, final StreamLoader streamLoader, final LoadedCallback cb){
361         final String key = getKey(id, -1, -1, ResizeType.AS_IS);
362         return runJob(key, cb, false, new ImageManagerJob(streamLoader) {
363             @Override
364             protected Bitmap resizeIfNotFound(InputStream is) throws IOException {
365                 return resizer.load(is);
366             }
367         });
368     }
370     /**
371      * Loads the image to nearly the given width and height maintaining the original proportions.
372      *
373      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
374      *           is not required to do so
375      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
376      * @param width The desired width in pixels
377      * @param height The desired height of the slice
378      * @param cb The callback called when the task finishes
379      * @return A token tracking this request
380      */
381     public Object getImageApproximate(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
382         final String key = getKey(id, width, height, ResizeType.APPROXIMATE);
383         return runJob(key, cb, new ImageManagerJob(streamLoader) {
384             @Override
385             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
386                 return resizer.load(is, width, height);
388         });
389     }
390 
391     /**
392      * Loads the image, resizes it to be exactly width pixels wide keeping proportions,
393      * and then returns a section from the center of image exactly height pixels tall.
394      *
395      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
396      *           is not required to do so
397      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
398      * @param width The desired width in pixels
399      * @param height The desired height of the slice
400      * @param cb The callback called when the task finishes
401      * @return A token tracking this request
402      */
403     public Object centerCrop(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb) {
404         final String key = getKey(id, width, height, ResizeType.CENTER_CROP);
405         return runJob(key, cb, new ImageManagerJob(streamLoader) {
406             @Override
407             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException {
408                 return resizer.load(is, width, height, Transformation.CENTER_CROP);
409             }
410         });
411     }
412 
413     /**
414      * Loads the image for the given id and resizes it, maintaining the original proportions, so that the image fills
415      * an area of width*height.
416      *
417      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
418      *           is not required to do so
419      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
420      * @param width The width of the space
421      * @param height The height of the space
422      * @param cb The callback called when the task finishes
423      * @return A token tracking this request
424      */
425     public Object fitCenter(String id, StreamLoader streamLoader, final int width, final int height, final LoadedCallback cb){
426         final String key = getKey(id, width, height, ResizeType.FIT_CENTER);
427         return runJob(key, cb, new ImageManagerJob(streamLoader) {
428             @Override
429             protected Bitmap resizeIfNotFound(InputStream is) throws FileNotFoundException{
430                 return resizer.load(is, width, height, Transformation.FIT_CENTER);
431             }
432         });
506     private Object runJob(String key, LoadedCallback cb, ImageManagerJob job) {
507         return runJob(key, cb, true, job);
508     }
509 
510     private Object runJob(String key, LoadedCallback cb, boolean useDiskCache, ImageManagerJob job) {
511         if (shutdown) return null;
512 
513         if (!returnFromCache(key, cb)) {
514             job.execute(key, cb, useDiskCache);
515         }
516         return job;
517     }
518 
528     private abstract class ImageManagerJob implements Runnable {
529         private final StreamLoader streamLoader;
532         private boolean useDiskCache;
536         public ImageManagerJob(StreamLoader streamLoader) {
537             this.streamLoader = streamLoader;
538         }
539 
540         public void execute(String key, LoadedCallback cb, boolean useDiskCache) {
543             this.useDiskCache = useDiskCache;
549 
558             Bitmap result = null;
559             if (useDiskCache) {
560                 result = getFromDiskCache(key);
561             }
574         //in almost every case exception will be because of race after calling shutdown. Not much we can do
575         //either way
614                 if (useDiskCache && !isInDiskCache) {
636         protected abstract Bitmap resizeIfNotFound(InputStream is) throws IOException;
674     private static String getKey(String id, int width, int height, ResizeType type){
675         return String.valueOf(Util.hash(id.hashCode(), width, height, type.hashCode()));",No
library\src\com\bumptech\glide\resize\loader\Approximate.java,library\src\com\bumptech\glide\resize\loader\Approximate.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -7,8 +7,10 @@ package com.bumptech.glide.resize.loader;
 import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.Transformation;
 
 /**
  * Load an image at roughly the width and height of the view that will display it, maintaining its original aspect ratio
@@ -25,25 +27,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 public class Approximate extends ImageManagerLoader {
 
     public Approximate(Context context) {
-        super(context);
+        super(context, Downsampler.AT_LEAST, Transformation.NONE);
     }
 
     public Approximate(ImageManager imageManager) {
-        super(imageManager);
-    }
-
-    @Override
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImageApproximate(id, streamLoader, width, height, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onException(e);
-            }
-        });
+        super(imageManager, Downsampler.AT_LEAST, Transformation.NONE);
     }
 }
","10 import com.bumptech.glide.resize.Downsampler;
13 import com.bumptech.glide.resize.Transformation;
30         super(context, Downsampler.AT_LEAST, Transformation.NONE);
34         super(imageManager, Downsampler.AT_LEAST, Transformation.NONE);
28         super(context);
32         super(imageManager);
33     }
34 
35     @Override
36     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
37         return imageManager.getImageApproximate(id, streamLoader, width, height, new LoadedCallback() {
38             @Override
39             public void onLoadCompleted(Bitmap loaded) {
40                 cb.onImageReady(loaded);
41             }
42 
43             @Override
44             public void onLoadFailed(Exception e) {
45                 cb.onException(e);
46             }
47         });",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,library\src\com\bumptech\glide\resize\loader\AsIs.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -1,11 +1,8 @@
 package com.bumptech.glide.resize.loader;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.view.ViewGroup;
-import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.Transformation;
 
 /**
  * Load an image at its original dimensions.
@@ -21,31 +18,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 public class AsIs extends ImageManagerLoader {
 
     public AsIs(Context context) {
-        super(context);
+        super(context, Transformation.CENTER_CROP);
     }
 
     public AsIs(ImageManager imageManager) {
-        super(imageManager);
-    }
-
-    @Override
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImage(id, streamLoader, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onException(e);
-            }
-        });
-    }
-
-    @Override
-    protected boolean isHandled(int width, int height) {
-        return super.isHandled(width, height)
-                || (width == ViewGroup.LayoutParams.WRAP_CONTENT || height == ViewGroup.LayoutParams.WRAP_CONTENT);
+        super(imageManager, Transformation.CENTER_CROP);
     }
 }
","5 import com.bumptech.glide.resize.Transformation;
21         super(context, Transformation.CENTER_CROP);
25         super(imageManager, Transformation.CENTER_CROP);
4 import android.graphics.Bitmap;
5 import android.view.ViewGroup;
6 import com.bumptech.glide.loader.stream.StreamLoader;
8 import com.bumptech.glide.resize.LoadedCallback;
24         super(context);
28         super(imageManager);
29     }
30 
31     @Override
32     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
33         return imageManager.getImage(id, streamLoader, new LoadedCallback() {
34             @Override
35             public void onLoadCompleted(Bitmap loaded) {
36                 cb.onImageReady(loaded);
37             }
38 
39             @Override
40             public void onLoadFailed(Exception e) {
41                 cb.onException(e);
42             }
43         });
44     }
45 
46     @Override
47     protected boolean isHandled(int width, int height) {
48         return super.isHandled(width, height)
49                 || (width == ViewGroup.LayoutParams.WRAP_CONTENT || height == ViewGroup.LayoutParams.WRAP_CONTENT);",No
library\src\com\bumptech\glide\resize\loader\CenterCrop.java,library\src\com\bumptech\glide\resize\loader\CenterCrop.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -9,6 +9,7 @@ import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.Transformation;
 
 /**
  * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
@@ -19,25 +20,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 public class CenterCrop extends ImageManagerLoader {
 
     public CenterCrop(Context context) {
-        super(context);
+        super(context, Transformation.CENTER_CROP);
     }
 
     public CenterCrop(ImageManager imageManager) {
-        super(imageManager);
-    }
-
-    @Override
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.centerCrop(id, streamLoader, width, height, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onException(e);
-            }
-        });
+        super(imageManager, Transformation.CENTER_CROP);
     }
 }
","12 import com.bumptech.glide.resize.Transformation;
23         super(context, Transformation.CENTER_CROP);
27         super(imageManager, Transformation.CENTER_CROP);
22         super(context);
26         super(imageManager);
27     }
28 
29     @Override
30     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
31         return imageManager.centerCrop(id, streamLoader, width, height, new LoadedCallback() {
32             @Override
33             public void onLoadCompleted(Bitmap loaded) {
34                 cb.onImageReady(loaded);
35             }
36 
37             @Override
38             public void onLoadFailed(Exception e) {
39                 cb.onException(e);
40             }
41         });",No
library\src\com\bumptech\glide\resize\loader\FitCenter.java,library\src\com\bumptech\glide\resize\loader\FitCenter.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -7,8 +7,10 @@ package com.bumptech.glide.resize.loader;
 import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.Transformation;
 
 /**
  * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
@@ -20,25 +22,10 @@ import com.bumptech.glide.resize.LoadedCallback;
 public class FitCenter extends ImageManagerLoader {
 
     public FitCenter(Context context) {
-        super(context);
+        super(context, Transformation.FIT_CENTER);
     }
 
     public FitCenter(ImageManager imageManager) {
-        super(imageManager);
-    }
-
-    @Override
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.fitCenter(id, streamLoader, width, height, new LoadedCallback() {
-            @Override
-            public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
-            }
-
-            @Override
-            public void onLoadFailed(Exception e) {
-                cb.onException(e);
-            }
-        });
+        super(imageManager, Transformation.FIT_CENTER);
     }
 }
","10 import com.bumptech.glide.resize.Downsampler;
13 import com.bumptech.glide.resize.Transformation;
25         super(context, Transformation.FIT_CENTER);
29         super(imageManager, Transformation.FIT_CENTER);
23         super(context);
27         super(imageManager);
28     }
29 
30     @Override
31     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
32         return imageManager.fitCenter(id, streamLoader, width, height, new LoadedCallback() {
33             @Override
34             public void onLoadCompleted(Bitmap loaded) {
35                 cb.onImageReady(loaded);
36             }
37 
38             @Override
39             public void onLoadFailed(Exception e) {
40                 cb.onException(e);
41             }
42         });",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -5,24 +5,41 @@ import android.graphics.Bitmap;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.loader.image.BaseImageLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.Transformation;
+
+import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
 /**
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
  * purposes.
  */
-public abstract class ImageManagerLoader extends BaseImageLoader {
+public class ImageManagerLoader extends BaseImageLoader {
 
     protected final ImageManager imageManager;
+    private final Transformation transformation;
+    private final Downsampler downsampler;
     private Bitmap acquired;
     private Object loadToken;
 
-    public ImageManagerLoader(Context context) {
-        this(Glide.get().getImageManager(context));
+    public ImageManagerLoader(Context context, Transformation transformation) {
+        this(context, Downsampler.AT_LEAST, transformation);
+    }
+
+    public ImageManagerLoader(Context context, Downsampler downsampler, Transformation transformation) {
+        this(Glide.get().getImageManager(context), downsampler, transformation);
     }
 
-    public ImageManagerLoader(ImageManager imageManager) {
+    public ImageManagerLoader(ImageManager imageManager, Transformation transformation) {
+        this(imageManager, Downsampler.AT_LEAST, transformation);
+    }
+
+    public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler, Transformation transformation) {
         this.imageManager = imageManager;
+        this.downsampler = downsampler;
+        this.transformation = transformation;
     }
 
     @Override
@@ -46,7 +63,19 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
      *
      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
      */
-    protected abstract Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
+    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
+        return imageManager.getImage(id, streamLoader, width, height, downsampler, transformation, new LoadedCallback() {
+            @Override
+            public void onLoadCompleted(Bitmap loaded) {
+                cb.onImageReady(loaded);
+            }
+
+            @Override
+            public void onLoadFailed(Exception e) {
+                cb.onException(e);
+            }
+        });
+    }
 
     @Override
     protected void onImageReady(String id, Bitmap image, boolean isUsed) {
@@ -76,6 +105,7 @@ public abstract class ImageManagerLoader extends BaseImageLoader {
     }
 
     protected boolean isHandled(int width, int height) {
-        return width >= 0 && height >= 0;
+        return width >= 0 && height >= 0 ||
+                (downsampler == Downsampler.NONE && width == WRAP_CONTENT && height == WRAP_CONTENT);
     }
 }
","8 import com.bumptech.glide.resize.Downsampler;
10 import com.bumptech.glide.resize.LoadedCallback;
11 import com.bumptech.glide.resize.Transformation;
12 
13 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
19 public class ImageManagerLoader extends BaseImageLoader {
22     private final Transformation transformation;
23     private final Downsampler downsampler;
27     public ImageManagerLoader(Context context, Transformation transformation) {
28         this(context, Downsampler.AT_LEAST, transformation);
31     public ImageManagerLoader(Context context, Downsampler downsampler, Transformation transformation) {
32         this(Glide.get().getImageManager(context), downsampler, transformation);
33     }
34 
35     public ImageManagerLoader(ImageManager imageManager, Transformation transformation) {
36         this(imageManager, Downsampler.AT_LEAST, transformation);
37     }
38 
39     public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler, Transformation transformation) {
41         this.downsampler = downsampler;
42         this.transformation = transformation;
66     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
67         return imageManager.getImage(id, streamLoader, width, height, downsampler, transformation, new LoadedCallback() {
68             @Override
69             public void onLoadCompleted(Bitmap loaded) {
70                 cb.onImageReady(loaded);
71             }
72 
73             @Override
74             public void onLoadFailed(Exception e) {
75                 cb.onException(e);
76             }
77         });
78     }
108         return width >= 0 && height >= 0 ||
109                 (downsampler == Downsampler.NONE && width == WRAP_CONTENT && height == WRAP_CONTENT);
14 public abstract class ImageManagerLoader extends BaseImageLoader {
20     public ImageManagerLoader(Context context) {
21         this(Glide.get().getImageManager(context));
24     public ImageManagerLoader(ImageManager imageManager) {
49     protected abstract Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
79         return width >= 0 && height >= 0;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,2381ce1d267b4d9591e0603ae641ba93d6b1342d,c27229a159bfc992874609270ab8b57981fef339,Use downsampler/transformation in ImageManager,"@@ -14,7 +14,13 @@ import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
+<<<<<<< HEAD
+import com.bumptech.glide.resize.Downsampler;
+import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.resize.loader.CenterCrop;
+=======
+import com.bumptech.glide.resize.loader.ImageManagerLoader;
+>>>>>>> 765fdbe... Should have been in go to just image manager loader
 
 import java.io.File;
 import java.util.ArrayList;
","17 <<<<<<< HEAD
18 import com.bumptech.glide.resize.Downsampler;
19 import com.bumptech.glide.resize.Transformation;
21 =======
22 import com.bumptech.glide.resize.loader.ImageManagerLoader;
23 >>>>>>> 765fdbe... Should have been in go to just image manager loader",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,ef34a5bc088fc6c07a986e674e88dd306e793fbe,2381ce1d267b4d9591e0603ae641ba93d6b1342d,use downsampler/transformation in Glide,"@@ -2,6 +2,7 @@ package com.bumptech.glide;
 
 import android.content.Context;
 import android.net.Uri;
+import android.view.ViewGroup;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.widget.ImageView;
@@ -16,17 +17,18 @@ import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
+import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
+import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.resize.loader.Approximate;
-import com.bumptech.glide.resize.loader.AsIs;
 import com.bumptech.glide.resize.loader.CenterCrop;
 import com.bumptech.glide.resize.loader.FitCenter;
+import com.bumptech.glide.resize.loader.ImageManagerLoader;
 
 import java.io.File;
-import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 
-import static android.view.ViewGroup.LayoutParams;
+import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
 /**
  * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
@@ -336,7 +338,6 @@ public class Glide {
      */
     @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
-
         private enum ResizeOption {
             APPROXIMATE,
             CENTER_CROP,
@@ -352,8 +353,8 @@ public class Glide {
         private int animationId = -1;
         private int placeholderId = -1;
         private int errorId = -1;
-        private ResizeOption resizeOption = null;
-        private ImageLoader imageLoader = null;
+        private Transformation transformation = Transformation.NONE;
+        private Downsampler downsampler = null;
 
         public Request(T model) {
             this.model = model;
@@ -373,8 +374,8 @@ public class Glide {
          * @return This Request
          */
         public Request<T> centerCrop() {
-            resizeOption = ResizeOption.CENTER_CROP;
-            imageLoader = null;
+            transformation = Transformation.CENTER_CROP;
+            downsampler = Downsampler.AT_LEAST;
 
             return this;
         }
@@ -385,46 +386,47 @@ public class Glide {
          * @return This Request
          */
         public Request<T> fitCenter() {
-            resizeOption = ResizeOption.FIT_CENTER;
-            imageLoader = null;
+            transformation = Transformation.FIT_CENTER;
+            downsampler = Downsampler.AT_LEAST;
 
             return this;
         }
 
         /**
-         * Resize models using {@link Approximate}. Replaces any existing resize style
+         * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}. Replaces any existing resize style
          *
          * @return This Request
          */
         public Request<T> approximate() {
-            resizeOption = ResizeOption.APPROXIMATE;
-            imageLoader = null;
+            transformation = Transformation.NONE;
+            downsampler = Downsampler.AT_LEAST;
 
             return this;
         }
 
         /**
-         * Load images at their original size using {@link com.bumptech.glide.resize.loader.AsIs}. Replaces any existing
+         * Load images at their original size using {@link Downsampler#NONE}. Replaces any existing
          * resize style
          *
          * @return This Request
          */
         public Request<T> asIs() {
-            resizeOption = ResizeOption.AS_IS;
-            imageLoader = null;
+            transformation = Transformation.NONE;
+            downsampler = Downsampler.NONE;
 
             return this;
         }
 
         /**
-         * Set the {@link ImageLoader} to use to load images into memory
+         * Set an arbitrary transformation to apply after an image has been loaded into memory.  Replaces any existing
+         * resize style
          *
-         * @param imageLoader The {@link ImageLoader} to use
+         * @param transformation The transformation to use
          * @return This Request
          */
-        public Request<T> resizeWith(ImageLoader imageLoader) {
-            this.imageLoader = imageLoader;
-            resizeOption = null;
+        public Request<T> transform(Transformation transformation) {
+            this.transformation = transformation;
+            downsampler = Downsampler.AT_LEAST;
 
             return this;
         }
@@ -482,7 +484,7 @@ public class Glide {
          * the view's tag for the id {@code R.id.image_presenter_id}.
          */
         private ImagePresenter<T> getImagePresenter(ImageView imageView) {
-            resizeOption = getFinalResizeOption(imageView);
+            downsampler = getFinalDownsampler(imageView);
 
             Metadata previous = getMetadataFrom(imageView);
             Metadata current = new Metadata(this);
@@ -505,13 +507,12 @@ public class Glide {
         private ImagePresenter<T> buildImagePresenter(ImageView imageView) {
             final Context context = imageView.getContext();
 
-            imageLoader = getFinalImageLoader(context);
             modelLoader = getFinalModelLoader(context);
 
             ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
                     .setImageView(imageView)
                     .setModelLoader(modelLoader)
-                    .setImageLoader(imageLoader);
+                    .setImageLoader(new ImageManagerLoader(context, downsampler, transformation));
 
             if (animationId != -1) {
                 final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
@@ -548,67 +549,19 @@ public class Glide {
             }
         }
 
-        private ImageLoader getFinalImageLoader(Context context) {
-            if (imageLoader == null) {
-                return getImageLoaderFromOptions(context);
-            } else {
-                return imageLoader;
-            }
-        }
-
-        private ResizeOption getFinalResizeOption(ImageView imageView) {
-            ResizeOption result = resizeOption;
+        private Downsampler getFinalDownsampler(ImageView imageView) {
+            Downsampler result = downsampler;
             if (result == null) {
-                //default to Approximate unless view's layout params are set to wrap content, in which case the only
-                //loader that makes sense is AsIs since all the others crop based on the view's size
-                final LayoutParams lp = imageView.getLayoutParams();
-                if (lp != null && (lp.width == LayoutParams.WRAP_CONTENT || lp.height == LayoutParams.WRAP_CONTENT)) {
-                    result = ResizeOption.AS_IS;
+                ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+                if (layoutParams.width == WRAP_CONTENT && layoutParams.height == WRAP_CONTENT) {
+                    result = Downsampler.NONE;
                 } else {
-                    result = ResizeOption.APPROXIMATE;
+                    result = Downsampler.AT_LEAST;
                 }
             }
             return result;
         }
 
-        private ImageLoader getImageLoaderFromOptions(Context context) {
-
-            Class<? extends ImageLoader> imageLoaderClass = getImageLoaderClassFor(resizeOption);
-            try {
-                return imageLoaderClass.getConstructor(Context.class).newInstance(context);
-            } catch (InstantiationException e) {
-                e.printStackTrace();
-            } catch (IllegalAccessException e) {
-                e.printStackTrace();
-            } catch (InvocationTargetException e) {
-                e.printStackTrace();
-            } catch (NoSuchMethodException e) {
-                e.printStackTrace();
-            }
-            return null;
-        }
-
-        private static Class<? extends ImageLoader> getImageLoaderClassFor(ResizeOption resizeOption) {
-            final Class<? extends ImageLoader> imageLoaderClass;
-            switch (resizeOption) {
-                case APPROXIMATE:
-                    imageLoaderClass = Approximate.class;
-                    break;
-                case CENTER_CROP:
-                    imageLoaderClass = CenterCrop.class;
-                    break;
-                case FIT_CENTER:
-                    imageLoaderClass = FitCenter.class;
-                    break;
-                case AS_IS:
-                    imageLoaderClass = AsIs.class;
-                    break;
-                default:
-                    throw new IllegalArgumentException(""Unknown resize option "" + resizeOption);
-            }
-            return imageLoaderClass;
-        }
-
         private static Metadata getMetadataFrom(ImageView imageView) {
             return (Metadata) imageView.getTag(R.id.glide_metadata);
         }
@@ -620,20 +573,17 @@ public class Glide {
         private static class Metadata {
             public final Class modelClass;
             public final Class modelLoaderClass;
-            public final Class imageLoaderClass;
             public final int animationId;
             public final int placeholderId;
             public final int errorId;
+            private final String downsamplerId;
+            private final String transformationId;
 
             public Metadata(Request request) {
                 modelClass = request.model.getClass();
                 modelLoaderClass = request.modelLoaderClass;
-                if (request.imageLoader != null) {
-                    imageLoaderClass = request.imageLoader.getClass();
-                } else {
-                    imageLoaderClass = getImageLoaderClassFor(request.resizeOption);
-
-                }
+                downsamplerId = request.downsampler.getId();
+                transformationId = request.transformation.getId();
                 animationId = request.animationId;
                 placeholderId = request.placeholderId;
                 errorId = request.errorId;
@@ -649,7 +599,8 @@ public class Glide {
 
                 return modelClass.equals(other.modelClass) &&
                         modelLoaderClass.equals(other.modelLoaderClass) &&
-                        imageLoaderClass.equals(other.imageLoaderClass) &&
+                        downsamplerId.equals(other.downsamplerId) &&
+                        transformationId.equals(other.transformationId) &&
                         animationId == other.animationId &&
                         placeholderId == other.placeholderId &&
                         errorId == other.errorId;
","5 import android.view.ViewGroup;
20 import com.bumptech.glide.resize.Downsampler;
22 import com.bumptech.glide.resize.Transformation;
26 import com.bumptech.glide.resize.loader.ImageManagerLoader;
31 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
356         private Transformation transformation = Transformation.NONE;
357         private Downsampler downsampler = null;
377             transformation = Transformation.CENTER_CROP;
378             downsampler = Downsampler.AT_LEAST;
389             transformation = Transformation.FIT_CENTER;
390             downsampler = Downsampler.AT_LEAST;
396          * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}. Replaces any existing resize style
401             transformation = Transformation.NONE;
402             downsampler = Downsampler.AT_LEAST;
408          * Load images at their original size using {@link Downsampler#NONE}. Replaces any existing
414             transformation = Transformation.NONE;
415             downsampler = Downsampler.NONE;
421          * Set an arbitrary transformation to apply after an image has been loaded into memory.  Replaces any existing
422          * resize style
424          * @param transformation The transformation to use
427         public Request<T> transform(Transformation transformation) {
428             this.transformation = transformation;
429             downsampler = Downsampler.AT_LEAST;
487             downsampler = getFinalDownsampler(imageView);
515                     .setImageLoader(new ImageManagerLoader(context, downsampler, transformation));
552         private Downsampler getFinalDownsampler(ImageView imageView) {
553             Downsampler result = downsampler;
555                 ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
556                 if (layoutParams.width == WRAP_CONTENT && layoutParams.height == WRAP_CONTENT) {
557                     result = Downsampler.NONE;
559                     result = Downsampler.AT_LEAST;
579             private final String downsamplerId;
580             private final String transformationId;
585                 downsamplerId = request.downsampler.getId();
586                 transformationId = request.transformation.getId();
602                         downsamplerId.equals(other.downsamplerId) &&
603                         transformationId.equals(other.transformationId) &&
21 import com.bumptech.glide.resize.loader.AsIs;
26 import java.lang.reflect.InvocationTargetException;
29 import static android.view.ViewGroup.LayoutParams;
339 
355         private ResizeOption resizeOption = null;
356         private ImageLoader imageLoader = null;
376             resizeOption = ResizeOption.CENTER_CROP;
377             imageLoader = null;
388             resizeOption = ResizeOption.FIT_CENTER;
389             imageLoader = null;
395          * Resize models using {@link Approximate}. Replaces any existing resize style
400             resizeOption = ResizeOption.APPROXIMATE;
401             imageLoader = null;
407          * Load images at their original size using {@link com.bumptech.glide.resize.loader.AsIs}. Replaces any existing
413             resizeOption = ResizeOption.AS_IS;
414             imageLoader = null;
420          * Set the {@link ImageLoader} to use to load images into memory
422          * @param imageLoader The {@link ImageLoader} to use
425         public Request<T> resizeWith(ImageLoader imageLoader) {
426             this.imageLoader = imageLoader;
427             resizeOption = null;
485             resizeOption = getFinalResizeOption(imageView);
508             imageLoader = getFinalImageLoader(context);
514                     .setImageLoader(imageLoader);
551         private ImageLoader getFinalImageLoader(Context context) {
552             if (imageLoader == null) {
553                 return getImageLoaderFromOptions(context);
554             } else {
555                 return imageLoader;
556             }
557         }
558 
559         private ResizeOption getFinalResizeOption(ImageView imageView) {
560             ResizeOption result = resizeOption;
562                 //default to Approximate unless view's layout params are set to wrap content, in which case the only
563                 //loader that makes sense is AsIs since all the others crop based on the view's size
564                 final LayoutParams lp = imageView.getLayoutParams();
565                 if (lp != null && (lp.width == LayoutParams.WRAP_CONTENT || lp.height == LayoutParams.WRAP_CONTENT)) {
566                     result = ResizeOption.AS_IS;
568                     result = ResizeOption.APPROXIMATE;
574         private ImageLoader getImageLoaderFromOptions(Context context) {
575 
576             Class<? extends ImageLoader> imageLoaderClass = getImageLoaderClassFor(resizeOption);
577             try {
578                 return imageLoaderClass.getConstructor(Context.class).newInstance(context);
579             } catch (InstantiationException e) {
580                 e.printStackTrace();
581             } catch (IllegalAccessException e) {
582                 e.printStackTrace();
583             } catch (InvocationTargetException e) {
584                 e.printStackTrace();
585             } catch (NoSuchMethodException e) {
586                 e.printStackTrace();
587             }
588             return null;
589         }
590 
591         private static Class<? extends ImageLoader> getImageLoaderClassFor(ResizeOption resizeOption) {
592             final Class<? extends ImageLoader> imageLoaderClass;
593             switch (resizeOption) {
594                 case APPROXIMATE:
595                     imageLoaderClass = Approximate.class;
596                     break;
597                 case CENTER_CROP:
598                     imageLoaderClass = CenterCrop.class;
599                     break;
600                 case FIT_CENTER:
601                     imageLoaderClass = FitCenter.class;
602                     break;
603                 case AS_IS:
604                     imageLoaderClass = AsIs.class;
605                     break;
606                 default:
607                     throw new IllegalArgumentException(""Unknown resize option "" + resizeOption);
608             }
609             return imageLoaderClass;
610         }
611 
623             public final Class imageLoaderClass;
631                 if (request.imageLoader != null) {
632                     imageLoaderClass = request.imageLoader.getClass();
633                 } else {
634                     imageLoaderClass = getImageLoaderClassFor(request.resizeOption);
635 
636                 }
652                         imageLoaderClass.equals(other.imageLoaderClass) &&",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -15,14 +15,14 @@ import com.bumptech.glide.loader.model.ResourceLoader;
 import com.bumptech.glide.loader.model.StringLoader;
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.model.UrlLoader;
+import com.bumptech.glide.loader.transformation.CenterCrop;
+import com.bumptech.glide.loader.transformation.FitCenter;
+import com.bumptech.glide.loader.transformation.TransformationLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.Transformation;
-import com.bumptech.glide.resize.loader.Approximate;
-import com.bumptech.glide.resize.loader.CenterCrop;
-import com.bumptech.glide.resize.loader.FitCenter;
 import com.bumptech.glide.resize.loader.ImageManagerLoader;
 
 import java.io.File;
@@ -338,6 +338,7 @@ public class Glide {
      */
     @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
+
         private enum ResizeOption {
             APPROXIMATE,
             CENTER_CROP,
@@ -353,8 +354,9 @@ public class Glide {
         private int animationId = -1;
         private int placeholderId = -1;
         private int errorId = -1;
-        private Transformation transformation = Transformation.NONE;
+        private Transformation transformation = null;
         private Downsampler downsampler = null;
+        private TransformationLoader<T> transformationLoader = null;
 
         public Request(T model) {
             this.model = model;
@@ -376,6 +378,7 @@ public class Glide {
         public Request<T> centerCrop() {
             transformation = Transformation.CENTER_CROP;
             downsampler = Downsampler.AT_LEAST;
+            transformationLoader = null;
 
             return this;
         }
@@ -388,6 +391,7 @@ public class Glide {
         public Request<T> fitCenter() {
             transformation = Transformation.FIT_CENTER;
             downsampler = Downsampler.AT_LEAST;
+            transformationLoader = null;
 
             return this;
         }
@@ -400,6 +404,7 @@ public class Glide {
         public Request<T> approximate() {
             transformation = Transformation.NONE;
             downsampler = Downsampler.AT_LEAST;
+            transformationLoader = null;
 
             return this;
         }
@@ -413,6 +418,7 @@ public class Glide {
         public Request<T> asIs() {
             transformation = Transformation.NONE;
             downsampler = Downsampler.NONE;
+            transformationLoader = null;
 
             return this;
         }
@@ -424,9 +430,18 @@ public class Glide {
          * @param transformation The transformation to use
          * @return This Request
          */
-        public Request<T> transform(Transformation transformation) {
+        public Request<T> transform(final Transformation transformation) {
             this.transformation = transformation;
             downsampler = Downsampler.AT_LEAST;
+            transformationLoader = null;
+
+            return this;
+        }
+
+        public Request<T> transform(TransformationLoader<T> transformationLoader) {
+            this.transformationLoader = transformationLoader;
+            transformation = null;
+            downsampler = Downsampler.AT_LEAST;
 
             return this;
         }
@@ -508,11 +523,13 @@ public class Glide {
             final Context context = imageView.getContext();
 
             modelLoader = getFinalModelLoader(context);
+            transformationLoader = getFinalTransformationLoader();
 
             ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
                     .setImageView(imageView)
                     .setModelLoader(modelLoader)
-                    .setImageLoader(new ImageManagerLoader(context, downsampler, transformation));
+                    .setImageLoader(new ImageManagerLoader(context, downsampler))
+                    .setTransformationLoader(transformationLoader);
 
             if (animationId != -1) {
                 final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
@@ -533,7 +550,6 @@ public class Glide {
                 builder.setPlaceholderResource(placeholderId);
             }
 
-
             if (errorId != -1) {
                 builder.setErrorResource(errorId);
             }
@@ -549,6 +565,27 @@ public class Glide {
             }
         }
 
+        private TransformationLoader<T> getFinalTransformationLoader() {
+            if (transformationLoader != null) {
+                return transformationLoader;
+            } else {
+                return new TransformationLoader<T>() {
+                    @Override
+                    public Transformation getTransformation(T model) {
+                        return transformation;
+                    }
+                };
+            }
+        }
+
+        private String getFinalTransformationId() {
+            if (transformationLoader != null) {
+                return transformationLoader.getClass().toString();
+            } else {
+                return transformation.getId();
+            }
+        }
+
         private Downsampler getFinalDownsampler(ImageView imageView) {
             Downsampler result = downsampler;
             if (result == null) {
@@ -562,6 +599,7 @@ public class Glide {
             return result;
         }
 
+
         private static Metadata getMetadataFrom(ImageView imageView) {
             return (Metadata) imageView.getTag(R.id.glide_metadata);
         }
@@ -583,7 +621,7 @@ public class Glide {
                 modelClass = request.model.getClass();
                 modelLoaderClass = request.modelLoaderClass;
                 downsamplerId = request.downsampler.getId();
-                transformationId = request.transformation.getId();
+                transformationId = request.getFinalTransformationId();
                 animationId = request.animationId;
                 placeholderId = request.placeholderId;
                 errorId = request.errorId;
","18 import com.bumptech.glide.loader.transformation.CenterCrop;
19 import com.bumptech.glide.loader.transformation.FitCenter;
20 import com.bumptech.glide.loader.transformation.TransformationLoader;
341 
357         private Transformation transformation = null;
359         private TransformationLoader<T> transformationLoader = null;
381             transformationLoader = null;
394             transformationLoader = null;
407             transformationLoader = null;
421             transformationLoader = null;
433         public Request<T> transform(final Transformation transformation) {
436             transformationLoader = null;
437 
438             return this;
439         }
440 
441         public Request<T> transform(TransformationLoader<T> transformationLoader) {
442             this.transformationLoader = transformationLoader;
443             transformation = null;
444             downsampler = Downsampler.AT_LEAST;
526             transformationLoader = getFinalTransformationLoader();
531                     .setImageLoader(new ImageManagerLoader(context, downsampler))
532                     .setTransformationLoader(transformationLoader);
568         private TransformationLoader<T> getFinalTransformationLoader() {
569             if (transformationLoader != null) {
570                 return transformationLoader;
571             } else {
572                 return new TransformationLoader<T>() {
573                     @Override
574                     public Transformation getTransformation(T model) {
575                         return transformation;
576                     }
577                 };
578             }
579         }
580 
581         private String getFinalTransformationId() {
582             if (transformationLoader != null) {
583                 return transformationLoader.getClass().toString();
584             } else {
585                 return transformation.getId();
586             }
587         }
588 
602 
624                 transformationId = request.getFinalTransformationId();
23 import com.bumptech.glide.resize.loader.Approximate;
24 import com.bumptech.glide.resize.loader.CenterCrop;
25 import com.bumptech.glide.resize.loader.FitCenter;
356         private Transformation transformation = Transformation.NONE;
427         public Request<T> transform(Transformation transformation) {
515                     .setImageLoader(new ImageManagerLoader(context, downsampler, transformation));
536 
586                 transformationId = request.transformation.getId();",No
library\src\com\bumptech\glide\loader\image\BaseImageLoader.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,95 +0,0 @@
-package com.bumptech.glide.loader.image;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
-
-import java.lang.ref.WeakReference;
-
-
-/**
- * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
- * subclasses with a weak reference to the calling {@link com.bumptech.glide.presenter.ImagePresenter}.
- */
-public abstract class BaseImageLoader implements ImageLoader {
-    @Override
-    public final Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
-        doFetchImage(id, streamLoader, width, height, new InternalImageReadyCallback(cb, id));
-        return cb;
-    }
-
-    @Override
-    public void clear() { }
-
-    /**
-     * The method where subclasses should actually begin any long running load for the given path and model. It is
-     * safe to strongly reference the given callback since that callback only weakly references the object that created
-     * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
-     * image is ready.
-     *
-     * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The width of the view where the image will be displayed
-     * @param height The height of the view where the image will be displayed
-     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
-     */
-    protected abstract void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
-
-    /**
-     * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
-     * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
-     * an image is displayed. See {@link com.bumptech.glide.presenter.ImageReadyCallback} instead to make a visual change
-     * when a load completes.
-     *
-     * @param id The unique id of the image
-     * @param image The loaded image
-     * @param isUsed True iff the requesting object is going to display the image
-     */
-    protected void onImageReady(String id, Bitmap image, boolean isUsed) { }
-
-    /**
-     * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
-     * Should be used to cleanup or update any data related to the failed load.
-     *
-     * @param e The exception that caused the failure, or null
-     * @param id The unique id of the image
-     * @return True iff this image loader has handled the exception and the cb should not be notified.
-     */
-    @SuppressWarnings(""unused"")
-    protected boolean onImageLoadFailed(Exception e, String id) {
-        return false;
-    }
-
-    protected class InternalImageReadyCallback implements ImageReadyCallback {
-        private final WeakReference<ImageReadyCallback> cbRef;
-        private final String id;
-
-        public InternalImageReadyCallback(ImageReadyCallback cb, String id) {
-            this.cbRef = new WeakReference<ImageReadyCallback>(cb);
-            this.id = id;
-        }
-
-        @Override
-        public final boolean onImageReady(Bitmap image) {
-            final ImageReadyCallback cb = cbRef.get();
-            boolean result = false;
-            if (cb != null) {
-                result = cb.onImageReady(image);
-                BaseImageLoader.this.onImageReady(id, image, result);
-            }
-            return result;
-        }
-
-        @Override
-        public void onException(Exception e) {
-            final ImageReadyCallback cb = cbRef.get();
-            if (cb != null) {
-                if (!BaseImageLoader.this.onImageLoadFailed(e, id)) {
-                    cb.onException(e);
-                }
-            }
-        }
-    }
-}
","1 package com.bumptech.glide.loader.image;
2 
3 import android.graphics.Bitmap;
4 import com.bumptech.glide.loader.stream.StreamLoader;
5 
6 import java.lang.ref.WeakReference;
7 
8 
9 /**
10  * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing
11  * subclasses with a weak reference to the calling {@link com.bumptech.glide.presenter.ImagePresenter}.
12  */
13 public abstract class BaseImageLoader implements ImageLoader {
14     @Override
15     public final Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
16         doFetchImage(id, streamLoader, width, height, new InternalImageReadyCallback(cb, id));
17         return cb;
18     }
19 
20     @Override
21     public void clear() { }
22 
23     /**
24      * The method where subclasses should actually begin any long running load for the given path and model. It is
25      * safe to strongly reference the given callback since that callback only weakly references the object that created
26      * it. Once a load completes or fails the given callback should be called to signal to the calling object that the
27      * image is ready.
28      *
29      * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback)
30      *
31      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
32      *           is not required to do so
33      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
34      * @param width The width of the view where the image will be displayed
35      * @param height The height of the view where the image will be displayed
36      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
37      */
38     protected abstract void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
39 
40     /**
41      * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be
42      * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how
43      * an image is displayed. See {@link com.bumptech.glide.presenter.ImageReadyCallback} instead to make a visual change
44      * when a load completes.
45      *
46      * @param id The unique id of the image
47      * @param image The loaded image
48      * @param isUsed True iff the requesting object is going to display the image
49      */
50     protected void onImageReady(String id, Bitmap image, boolean isUsed) { }
51 
52     /**
53      * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap.
54      * Should be used to cleanup or update any data related to the failed load.
55      *
56      * @param e The exception that caused the failure, or null
57      * @param id The unique id of the image
58      * @return True iff this image loader has handled the exception and the cb should not be notified.
59      */
60     @SuppressWarnings(""unused"")
61     protected boolean onImageLoadFailed(Exception e, String id) {
62         return false;
63     }
64 
65     protected class InternalImageReadyCallback implements ImageReadyCallback {
66         private final WeakReference<ImageReadyCallback> cbRef;
67         private final String id;
68 
69         public InternalImageReadyCallback(ImageReadyCallback cb, String id) {
70             this.cbRef = new WeakReference<ImageReadyCallback>(cb);
71             this.id = id;
72         }
73 
74         @Override
75         public final boolean onImageReady(Bitmap image) {
76             final ImageReadyCallback cb = cbRef.get();
77             boolean result = false;
78             if (cb != null) {
79                 result = cb.onImageReady(image);
80                 BaseImageLoader.this.onImageReady(id, image, result);
81             }
82             return result;
83         }
84 
85         @Override
86         public void onException(Exception e) {
87             final ImageReadyCallback cb = cbRef.get();
88             if (cb != null) {
89                 if (!BaseImageLoader.this.onImageLoadFailed(e, id)) {
90                     cb.onException(e);
91                 }
92             }
93         }
94     }
95 }",No
library\src\com\bumptech\glide\loader\image\ImageLoader.java,library\src\com\bumptech\glide\loader\image\ImageLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -2,6 +2,7 @@ package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.resize.Transformation;
 
 /**
  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a bitmap for a given id and
@@ -44,7 +45,7 @@ public interface ImageLoader {
      *
      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
      */
-    public Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);
+    public Object fetchImage(String id, StreamLoader streamLoader, Transformation transformation, int width, int height, ImageReadyCallback cb);
 
     /**
      * Called when the current image load does not need to continue and any corresponding cleanup to save cpu
","5 import com.bumptech.glide.resize.Transformation;
48     public Object fetchImage(String id, StreamLoader streamLoader, Transformation transformation, int width, int height, ImageReadyCallback cb);
47     public Object fetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb);",No
library\src\com\bumptech\glide\loader\model\BaseModelLoader.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,29 +0,0 @@
-package com.bumptech.glide.loader.model;
-
-import com.bumptech.glide.loader.stream.StreamLoader;
-
-/**
- * A base class that handles canceling any existing {@link StreamLoader} when
- * cleared
- *
- * @param <T> The type of model for this loader
- */
-public abstract class BaseModelLoader<T> implements ModelLoader<T> {
-    private StreamLoader current;
-
-    @Override
-    public final StreamLoader getStreamLoader(T model, int width, int height) {
-        current = buildStreamLoader(model, width, height);
-        return current;
-    }
-
-    protected abstract StreamLoader buildStreamLoader(T model, int width, int height);
-
-    @Override
-    public void clear() {
-        if (current != null) {
-            current.cancel();
-            current = null;
-        }
-    }
-}
","1 package com.bumptech.glide.loader.model;
2 
3 import com.bumptech.glide.loader.stream.StreamLoader;
4 
5 /**
6  * A base class that handles canceling any existing {@link StreamLoader} when
7  * cleared
8  *
9  * @param <T> The type of model for this loader
10  */
11 public abstract class BaseModelLoader<T> implements ModelLoader<T> {
12     private StreamLoader current;
13 
14     @Override
15     public final StreamLoader getStreamLoader(T model, int width, int height) {
16         current = buildStreamLoader(model, width, height);
17         return current;
18     }
19 
20     protected abstract StreamLoader buildStreamLoader(T model, int width, int height);
21 
22     @Override
23     public void clear() {
24         if (current != null) {
25             current.cancel();
26             current = null;
27         }
28     }
29 }",No
library\src\com\bumptech\glide\loader\model\FileLoader.java,library\src\com\bumptech\glide\loader\model\FileLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -27,7 +27,4 @@ public class FileLoader implements ModelLoader<File> {
         //canonical is better, but also slower
         return model.getAbsolutePath();
     }
-
-    @Override
-    public void clear() { }
 }
","30 
31     @Override
32     public void clear() { }",No
library\src\com\bumptech\glide\loader\model\ModelLoader.java,library\src\com\bumptech\glide\loader\model\ModelLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -43,10 +43,4 @@ public interface ModelLoader<T> {
      * it does not have to.
      */
     public String getId(T model);
-
-    /**
-     * A method that allows the ModelLoader to cleanup any old or inprocess {@link StreamLoader}. Primarily oriented
-     * at allowing the model loader to call {@link com.bumptech.glide.loader.stream.StreamLoader#cancel()};
-     */
-    public void clear();
 }
","46 
47     /**
48      * A method that allows the ModelLoader to cleanup any old or inprocess {@link StreamLoader}. Primarily oriented
49      * at allowing the model loader to call {@link com.bumptech.glide.loader.stream.StreamLoader#cancel()};
50      */
51     public void clear();",No
library\src\com\bumptech\glide\loader\model\ResourceLoader.java,library\src\com\bumptech\glide\loader\model\ResourceLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -26,7 +26,4 @@ public class ResourceLoader implements ModelLoader<Integer> {
     public String getId(Integer model) {
         return model.toString();
     }
-
-    @Override
-    public void clear() { }
 }
","29 
30     @Override
31     public void clear() { }",No
library\src\com\bumptech\glide\loader\model\StringLoader.java,library\src\com\bumptech\glide\loader\model\StringLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -10,7 +10,7 @@ import java.io.File;
  * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
  * {@link android.content.ContentResolver#openInputStream(android.net.Uri)}.
  */
-public class StringLoader extends BaseModelLoader<String> {
+public class StringLoader implements ModelLoader<String> {
 
     private final ModelLoader<Uri> uriLoader;
 
@@ -28,7 +28,7 @@ public class StringLoader extends BaseModelLoader<String> {
     }
 
     @Override
-    protected StreamLoader buildStreamLoader(final String model, final int width, final int height) {
+    public StreamLoader getStreamLoader(final String model, final int width, final int height) {
         Uri uri = Uri.parse(model);
 
         final String scheme = uri.getScheme();
","13 public class StringLoader implements ModelLoader<String> {
31     public StreamLoader getStreamLoader(final String model, final int width, final int height) {
13 public class StringLoader extends BaseModelLoader<String> {
31     protected StreamLoader buildStreamLoader(final String model, final int width, final int height) {",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -13,7 +13,7 @@ import java.net.URL;
  * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
  * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamLoader(android.net.Uri, int, int)}.
  */
-public class UriLoader extends BaseModelLoader<Uri> {
+public class UriLoader implements ModelLoader<Uri> {
     private final Context context;
     private final ModelLoader<URL> urlLoader;
 
@@ -32,7 +32,7 @@ public class UriLoader extends BaseModelLoader<Uri> {
     }
 
     @Override
-    protected StreamLoader buildStreamLoader(Uri model, int width, int height) {
+    public StreamLoader getStreamLoader(Uri model, int width, int height) {
         final String scheme = model.getScheme();
 
         StreamLoader result = null;
@@ -58,12 +58,6 @@ public class UriLoader extends BaseModelLoader<Uri> {
         return model.toString();
     }
 
-    @Override
-    public void clear() {
-        super.clear();
-        urlLoader.clear();
-    }
-
     private boolean isLocalUri(String scheme) {
         return ContentResolver.SCHEME_FILE.equals(scheme)
                 || ContentResolver.SCHEME_CONTENT.equals(scheme)
","16 public class UriLoader implements ModelLoader<Uri> {
35     public StreamLoader getStreamLoader(Uri model, int width, int height) {
16 public class UriLoader extends BaseModelLoader<Uri> {
35     protected StreamLoader buildStreamLoader(Uri model, int width, int height) {
61     @Override
62     public void clear() {
63         super.clear();
64         urlLoader.clear();
65     }
66 ",No
library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,library\src\com\bumptech\glide\loader\model\VolleyModelLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -12,7 +12,7 @@ import com.bumptech.glide.loader.stream.VolleyStreamLoader;
  * A base ModelLoader for using Volley to fetch an image from a model that
  * can readily be converted into a url
  */
-public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
+public abstract class VolleyModelLoader<T> implements ModelLoader<T> {
     private final RequestQueue requestQueue;
 
     /**
@@ -30,7 +30,7 @@ public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
     }
 
     @Override
-    protected StreamLoader buildStreamLoader(T model, int width, int height) {
+    public StreamLoader getStreamLoader(T model, int width, int height) {
         return new VolleyStreamLoader(requestQueue, getUrl(model, width, height), getRetryPolicy());
     }
 
","15 public abstract class VolleyModelLoader<T> implements ModelLoader<T> {
33     public StreamLoader getStreamLoader(T model, int width, int height) {
15 public abstract class VolleyModelLoader<T> extends BaseModelLoader<T> {
33     protected StreamLoader buildStreamLoader(T model, int width, int height) {",No
,library\src\com\bumptech\glide\loader\transformation\CenterCrop.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -0,0 +1,15 @@
+package com.bumptech.glide.loader.transformation;
+
+import com.bumptech.glide.resize.Transformation;
+
+/**
+ * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
+ *
+ * @param <T> The type of the model. Can be any type since the {@link Transformation is model/type agnostic}.
+ */
+public class CenterCrop<T> implements TransformationLoader<T>{
+    @Override
+    public Transformation getTransformation(T model) {
+        return Transformation.CENTER_CROP;
+    }
+}
","1 package com.bumptech.glide.loader.transformation;
2 
3 import com.bumptech.glide.resize.Transformation;
4 
5 /**
6  * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
7  *
8  * @param <T> The type of the model. Can be any type since the {@link Transformation is model/type agnostic}.
9  */
10 public class CenterCrop<T> implements TransformationLoader<T>{
11     @Override
12     public Transformation getTransformation(T model) {
13         return Transformation.CENTER_CROP;
14     }
15 }",No
,library\src\com\bumptech\glide\loader\transformation\FitCenter.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -0,0 +1,16 @@
+package com.bumptech.glide.loader.transformation;
+
+import com.bumptech.glide.resize.Transformation;
+
+/**
+ * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
+ * of the image is smaller than or equal to the other given dimension.
+ *
+ * @param <T> The type of the model. Can be any type since the {@link Transformation is model/type agnostic}.
+ */
+public class FitCenter<T> implements TransformationLoader<T> {
+    @Override
+    public Transformation getTransformation(T model) {
+        return Transformation.FIT_CENTER;
+    }
+}
","1 package com.bumptech.glide.loader.transformation;
2 
3 import com.bumptech.glide.resize.Transformation;
4 
5 /**
6  * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
7  * of the image is smaller than or equal to the other given dimension.
8  *
9  * @param <T> The type of the model. Can be any type since the {@link Transformation is model/type agnostic}.
10  */
11 public class FitCenter<T> implements TransformationLoader<T> {
12     @Override
13     public Transformation getTransformation(T model) {
14         return Transformation.FIT_CENTER;
15     }
16 }",No
,library\src\com\bumptech\glide\loader\transformation\None.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -0,0 +1,15 @@
+package com.bumptech.glide.loader.transformation;
+
+import com.bumptech.glide.resize.Transformation;
+
+/**
+ * A loader that will always return a noop {@link Transformation} that does not change a bitmap.
+ *
+ * @param <T> The model type, can be anything since the {@link Transformation} is type agnostic
+ */
+public class None<T> implements TransformationLoader<T> {
+    @Override
+    public Transformation getTransformation(T model) {
+        return Transformation.NONE;
+    }
+}
","1 package com.bumptech.glide.loader.transformation;
2 
3 import com.bumptech.glide.resize.Transformation;
4 
5 /**
6  * A loader that will always return a noop {@link Transformation} that does not change a bitmap.
7  *
8  * @param <T> The model type, can be anything since the {@link Transformation} is type agnostic
9  */
10 public class None<T> implements TransformationLoader<T> {
11     @Override
12     public Transformation getTransformation(T model) {
13         return Transformation.NONE;
14     }
15 }",No
,library\src\com\bumptech\glide\loader\transformation\TransformationLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -0,0 +1,19 @@
+package com.bumptech.glide.loader.transformation;
+
+import com.bumptech.glide.resize.Transformation;
+
+/**
+ * A class for loading a {@link Transformation} for a particular model. This allows things like rotating the image based
+ * on its exif data
+ *
+ * @param <T> The type of the model to be loaded
+ */
+public interface TransformationLoader<T> {
+    /**
+     * Get the {@link Transformation} for the model
+     *
+     * @param model The model
+     * @return A new or static (if the transformation is type/model agnostic) {@link Transformation}
+     */
+    public Transformation getTransformation(T model);
+}
","1 package com.bumptech.glide.loader.transformation;
2 
3 import com.bumptech.glide.resize.Transformation;
4 
5 /**
6  * A class for loading a {@link Transformation} for a particular model. This allows things like rotating the image based
7  * on its exif data
8  *
9  * @param <T> The type of the model to be loaded
10  */
11 public interface TransformationLoader<T> {
12     /**
13      * Get the {@link Transformation} for the model
14      *
15      * @param model The model
16      * @return A new or static (if the transformation is type/model agnostic) {@link Transformation}
17      */
18     public Transformation getTransformation(T model);
19 }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -17,6 +17,9 @@ import com.bumptech.glide.R;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
+import com.bumptech.glide.loader.transformation.None;
+import com.bumptech.glide.loader.transformation.TransformationLoader;
+import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.util.Log;
 
 import java.lang.ref.WeakReference;
@@ -34,7 +37,6 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
-    private final Drawable errorDrawable;
 
     /**
      * A builder for an {@link ImagePresenter}.
@@ -70,6 +72,7 @@ public class ImagePresenter<T> {
         private ModelLoader<T> modelLoader;
         private int errorResourceId;
         private Drawable errorDrawable;
+        private TransformationLoader<T> transformationLoader;
 
         /**
          * Builds an ImagePresenter.
@@ -95,6 +98,10 @@ public class ImagePresenter<T> {
                 throw new IllegalArgumentException(""cannot create presenter without a model loader"");
             }
 
+            if (transformationLoader == null) {
+                transformationLoader = new None<T>();
+            }
+
             return new ImagePresenter<T>(this);
         }
 
@@ -235,6 +242,11 @@ public class ImagePresenter<T> {
             this.exceptionHandler = exceptionHandler;
             return this;
         }
+
+        public Builder<T> setTransformationLoader(TransformationLoader<T> transformationLoader) {
+            this.transformationLoader = transformationLoader;
+            return this;
+        }
     }
 
     @SuppressWarnings(""all"")
@@ -242,6 +254,8 @@ public class ImagePresenter<T> {
 
     private final ModelLoader<T> modelLoader;
     private final ImageLoader imageLoader;
+    private final TransformationLoader<T> transformationLoader;
+
     private final Drawable placeholderDrawable;
     private final ImageReadyCallback imageReadyCallback;
     private final ImagePresenterCoordinator coordinator;
@@ -254,6 +268,7 @@ public class ImagePresenter<T> {
     private boolean isImageSet = false;
     private boolean loadedFromCache = false;
     private final SizeDeterminer sizeDeterminer;
+    private final Drawable errorDrawable;
 
     /**
      * An interface used to coordinate multiple {@link ImagePresenter} objects acting on the same view
@@ -309,6 +324,7 @@ public class ImagePresenter<T> {
     protected ImagePresenter(Builder<T> builder) {
         this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
+        this.transformationLoader = builder.transformationLoader;
 
         final Resources res = imageView.getResources();
         if (builder.placeholderResourceId != 0) {
@@ -405,17 +421,16 @@ public class ImagePresenter<T> {
         resetPlaceHolder();
         currentModel = null;
         isImageSet = false;
-        modelLoader.clear();
         imageLoader.clear();
     }
 
     private void fetchImage(final T model, int width, int height, final int loadCount) {
-        modelLoader.clear();
         imageLoader.clear();
-        final StreamLoader streamLoader = modelLoader.getStreamLoader(model, width, height);
         final String id = modelLoader.getId(model);
+        final StreamLoader sl = modelLoader.getStreamLoader(model, width, height);
+        final Transformation t = transformationLoader.getTransformation(model);
 
-        imageToken = imageLoader.fetchImage(id, streamLoader, width, height, new ImageLoader.ImageReadyCallback() {
+        imageToken = imageLoader.fetchImage(id, sl, t, width, height, new ImageLoader.ImageReadyCallback() {
             @Override
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
","20 import com.bumptech.glide.loader.transformation.None;
21 import com.bumptech.glide.loader.transformation.TransformationLoader;
22 import com.bumptech.glide.resize.Transformation;
75         private TransformationLoader<T> transformationLoader;
101             if (transformationLoader == null) {
102                 transformationLoader = new None<T>();
103             }
104 
245 
246         public Builder<T> setTransformationLoader(TransformationLoader<T> transformationLoader) {
247             this.transformationLoader = transformationLoader;
248             return this;
249         }
257     private final TransformationLoader<T> transformationLoader;
258 
271     private final Drawable errorDrawable;
327         this.transformationLoader = builder.transformationLoader;
430         final StreamLoader sl = modelLoader.getStreamLoader(model, width, height);
431         final Transformation t = transformationLoader.getTransformation(model);
433         imageToken = imageLoader.fetchImage(id, sl, t, width, height, new ImageLoader.ImageReadyCallback() {
37     private final Drawable errorDrawable;
408         modelLoader.clear();
413         modelLoader.clear();
415         final StreamLoader streamLoader = modelLoader.getStreamLoader(model, width, height);
418         imageToken = imageLoader.fetchImage(id, streamLoader, width, height, new ImageLoader.ImageReadyCallback() {",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -340,14 +340,15 @@ public class ImageManager {
         });
     }
 
-    public Object getImage(String id, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
+    public Object getImage(String id, StreamLoader streamLoader, Transformation transformation, Downsampler downsampler, int width, int height, LoadedCallback cb) {
         if (shutdown) return null;
-        final String key = getKey(id, downsampler, transformation, width, height);
+
+        final String key = getKey(id, transformation.getId(), downsampler, width, height);
 
         ImageManagerJob job = null;
         if (!returnFromCache(key, cb)) {
             job = new ImageManagerJob();
-            job.execute(key, streamLoader, width, height, downsampler, transformation, cb);
+            job.execute(key, streamLoader, transformation, downsampler, width, height, cb);
         }
         return job;
     }
@@ -432,25 +433,25 @@ public class ImageManager {
         return found;
     }
 
-    private class ImageManagerJob implements Runnable {
-        private StreamLoader streamLoader;
-        private String key;
+    private class ImageManagerJob<T> implements Runnable {
         private LoadedCallback cb;
         private Future future = null;
         private volatile boolean cancelled = false;
-        private Transformation transformation;
         private Downsampler downsampler;
         private int width;
         private int height;
+        private String key;
+        private StreamLoader streamLoader = null;
+        private Transformation transformation;
 
-        public void execute(String key, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
+        public void execute(String key, StreamLoader streamLoader, Transformation transformation, Downsampler downsampler, int width, int height, LoadedCallback cb) {
             this.key = key;
+            this.streamLoader = streamLoader;
+            this.transformation = transformation;
             this.cb = cb;
             this.width = width;
             this.height = height;
-            this.streamLoader = streamLoader;
             this.downsampler = downsampler;
-            this.transformation = transformation;
             bgHandler.post(this);
         }
 
@@ -460,6 +461,9 @@ public class ImageManager {
             if (future != null) {
                 future.cancel(false);
             }
+            if (streamLoader != null) {
+                streamLoader.cancel();
+            }
         }
 
         @Override
@@ -579,8 +583,8 @@ public class ImageManager {
         bitmapReferenceCounter.markPending(bitmap);
     }
 
-    private static String getKey(String id, Downsampler downsampler, Transformation transformation, int width, int height) {
+    private static String getKey(String id, String transformationId, Downsampler downsampler, int width, int height) {
         return String.valueOf(Util.hash(id.hashCode(), downsampler.getId().hashCode(),
-                transformation.getId().hashCode(), width, height));
+                transformationId.hashCode(), width, height));
     }
 }
","343     public Object getImage(String id, StreamLoader streamLoader, Transformation transformation, Downsampler downsampler, int width, int height, LoadedCallback cb) {
345 
346         final String key = getKey(id, transformation.getId(), downsampler, width, height);
351             job.execute(key, streamLoader, transformation, downsampler, width, height, cb);
436     private class ImageManagerJob<T> implements Runnable {
443         private String key;
444         private StreamLoader streamLoader = null;
445         private Transformation transformation;
447         public void execute(String key, StreamLoader streamLoader, Transformation transformation, Downsampler downsampler, int width, int height, LoadedCallback cb) {
449             this.streamLoader = streamLoader;
450             this.transformation = transformation;
464             if (streamLoader != null) {
465                 streamLoader.cancel();
466             }
586     private static String getKey(String id, String transformationId, Downsampler downsampler, int width, int height) {
588                 transformationId.hashCode(), width, height));
343     public Object getImage(String id, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
345         final String key = getKey(id, downsampler, transformation, width, height);
350             job.execute(key, streamLoader, width, height, downsampler, transformation, cb);
435     private class ImageManagerJob implements Runnable {
436         private StreamLoader streamLoader;
437         private String key;
441         private Transformation transformation;
446         public void execute(String key, StreamLoader streamLoader, int width, int height, Downsampler downsampler, Transformation transformation, LoadedCallback cb) {
451             this.streamLoader = streamLoader;
453             this.transformation = transformation;
582     private static String getKey(String id, Downsampler downsampler, Transformation transformation, int width, int height) {
584                 transformation.getId().hashCode(), width, height));",No
library\src\com\bumptech\glide\resize\loader\Approximate.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.loader;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.Downsampler;
-import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.LoadedCallback;
-import com.bumptech.glide.resize.Transformation;
-
-/**
- * Load an image at roughly the width and height of the view that will display it, maintaining its original aspect ratio
- *
- * <p>
- * Should be used when the image is larger than the view that will display it and you don't want to alter the original
- * aspect ratio. Can save a substantial amount of memory depending on the size discrepancy between the view and the
- * image.
- * </p>
- *
- * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
- */
-@SuppressWarnings(""unused"")
-public class Approximate extends ImageManagerLoader {
-
-    public Approximate(Context context) {
-        super(context, Downsampler.AT_LEAST, Transformation.NONE);
-    }
-
-    public Approximate(ImageManager imageManager) {
-        super(imageManager, Downsampler.AT_LEAST, Transformation.NONE);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.loader;
6 
7 import android.content.Context;
8 import android.graphics.Bitmap;
9 import com.bumptech.glide.loader.stream.StreamLoader;
10 import com.bumptech.glide.resize.Downsampler;
11 import com.bumptech.glide.resize.ImageManager;
12 import com.bumptech.glide.resize.LoadedCallback;
13 import com.bumptech.glide.resize.Transformation;
14 
15 /**
16  * Load an image at roughly the width and height of the view that will display it, maintaining its original aspect ratio
17  *
18  * <p>
19  * Should be used when the image is larger than the view that will display it and you don't want to alter the original
20  * aspect ratio. Can save a substantial amount of memory depending on the size discrepancy between the view and the
21  * image.
22  * </p>
23  *
24  * @see ImageManager#getImageApproximate(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
25  */
26 @SuppressWarnings(""unused"")
27 public class Approximate extends ImageManagerLoader {
28 
29     public Approximate(Context context) {
30         super(context, Downsampler.AT_LEAST, Transformation.NONE);
31     }
32 
33     public Approximate(ImageManager imageManager) {
34         super(imageManager, Downsampler.AT_LEAST, Transformation.NONE);
35     }
36 }",No
library\src\com\bumptech\glide\resize\loader\AsIs.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,27 +0,0 @@
-package com.bumptech.glide.resize.loader;
-
-import android.content.Context;
-import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.Transformation;
-
-/**
- * Load an image at its original dimensions.
- *
- * <p> Should be used when an image is exactly the same size as the view that will display it
- * or you want to use some external process (like the view) to do the resizing for you. This class is usually less
- * efficient than other implementations if the image is not exactly the size of the view
- * </p>
- *
- * @see ImageManager#getImage(String, com.bumptech.glide.loader.stream.StreamLoader, com.bumptech.glide.resize.LoadedCallback)
- */
-@SuppressWarnings(""unused"")
-public class AsIs extends ImageManagerLoader {
-
-    public AsIs(Context context) {
-        super(context, Transformation.CENTER_CROP);
-    }
-
-    public AsIs(ImageManager imageManager) {
-        super(imageManager, Transformation.CENTER_CROP);
-    }
-}
","1 package com.bumptech.glide.resize.loader;
2 
3 import android.content.Context;
4 import com.bumptech.glide.resize.ImageManager;
5 import com.bumptech.glide.resize.Transformation;
6 
7 /**
8  * Load an image at its original dimensions.
9  *
10  * <p> Should be used when an image is exactly the same size as the view that will display it
11  * or you want to use some external process (like the view) to do the resizing for you. This class is usually less
12  * efficient than other implementations if the image is not exactly the size of the view
13  * </p>
14  *
15  * @see ImageManager#getImage(String, com.bumptech.glide.loader.stream.StreamLoader, com.bumptech.glide.resize.LoadedCallback)
16  */
17 @SuppressWarnings(""unused"")
18 public class AsIs extends ImageManagerLoader {
19 
20     public AsIs(Context context) {
21         super(context, Transformation.CENTER_CROP);
22     }
23 
24     public AsIs(ImageManager imageManager) {
25         super(imageManager, Transformation.CENTER_CROP);
26     }
27 }",No
library\src\com\bumptech\glide\resize\loader\CenterCrop.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.loader;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.LoadedCallback;
-import com.bumptech.glide.resize.Transformation;
-
-/**
- * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
- *
- * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
- */
-@SuppressWarnings(""unused"")
-public class CenterCrop extends ImageManagerLoader {
-
-    public CenterCrop(Context context) {
-        super(context, Transformation.CENTER_CROP);
-    }
-
-    public CenterCrop(ImageManager imageManager) {
-        super(imageManager, Transformation.CENTER_CROP);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.loader;
6 
7 import android.content.Context;
8 import android.graphics.Bitmap;
9 import com.bumptech.glide.loader.stream.StreamLoader;
10 import com.bumptech.glide.resize.ImageManager;
11 import com.bumptech.glide.resize.LoadedCallback;
12 import com.bumptech.glide.resize.Transformation;
13 
14 /**
15  * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
16  *
17  * @see ImageManager#centerCrop(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
18  */
19 @SuppressWarnings(""unused"")
20 public class CenterCrop extends ImageManagerLoader {
21 
22     public CenterCrop(Context context) {
23         super(context, Transformation.CENTER_CROP);
24     }
25 
26     public CenterCrop(ImageManager imageManager) {
27         super(imageManager, Transformation.CENTER_CROP);
28     }
29 }",No
library\src\com\bumptech\glide\resize\loader\FitCenter.java,,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.loader;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.Downsampler;
-import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.LoadedCallback;
-import com.bumptech.glide.resize.Transformation;
-
-/**
- * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
- * of the image is smaller than or equal to the other given dimension.
- *
- * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
- */
-@SuppressWarnings(""Unused"")
-public class FitCenter extends ImageManagerLoader {
-
-    public FitCenter(Context context) {
-        super(context, Transformation.FIT_CENTER);
-    }
-
-    public FitCenter(ImageManager imageManager) {
-        super(imageManager, Transformation.FIT_CENTER);
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.loader;
6 
7 import android.content.Context;
8 import android.graphics.Bitmap;
9 import com.bumptech.glide.loader.stream.StreamLoader;
10 import com.bumptech.glide.resize.Downsampler;
11 import com.bumptech.glide.resize.ImageManager;
12 import com.bumptech.glide.resize.LoadedCallback;
13 import com.bumptech.glide.resize.Transformation;
14 
15 /**
16  * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
17  * of the image is smaller than or equal to the other given dimension.
18  *
19  * @see ImageManager#fitCenter(String, com.bumptech.glide.loader.stream.StreamLoader, int, int, com.bumptech.glide.resize.LoadedCallback)
20  */
21 @SuppressWarnings(""Unused"")
22 public class FitCenter extends ImageManagerLoader {
23 
24     public FitCenter(Context context) {
25         super(context, Transformation.FIT_CENTER);
26     }
27 
28     public FitCenter(ImageManager imageManager) {
29         super(imageManager, Transformation.FIT_CENTER);
30     }
31 }",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -3,7 +3,7 @@ package com.bumptech.glide.resize.loader;
 import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.loader.image.BaseImageLoader;
+import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
@@ -16,58 +16,41 @@ import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
  * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling
  * purposes.
  */
-public class ImageManagerLoader extends BaseImageLoader {
+public class ImageManagerLoader implements ImageLoader {
 
     protected final ImageManager imageManager;
-    private final Transformation transformation;
     private final Downsampler downsampler;
     private Bitmap acquired;
     private Object loadToken;
 
-    public ImageManagerLoader(Context context, Transformation transformation) {
-        this(context, Downsampler.AT_LEAST, transformation);
+    public ImageManagerLoader(Context context) {
+        this(context, Downsampler.AT_LEAST);
     }
 
-    public ImageManagerLoader(Context context, Downsampler downsampler, Transformation transformation) {
-        this(Glide.get().getImageManager(context), downsampler, transformation);
+    public ImageManagerLoader(ImageManager imageManager) {
+        this(imageManager, Downsampler.AT_LEAST);
     }
 
-    public ImageManagerLoader(ImageManager imageManager, Transformation transformation) {
-        this(imageManager, Downsampler.AT_LEAST, transformation);
+    public ImageManagerLoader(Context context, Downsampler downsampler) {
+        this(Glide.get().getImageManager(context), downsampler);
     }
 
-    public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler, Transformation transformation) {
+    public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler) {
         this.imageManager = imageManager;
         this.downsampler = downsampler;
-        this.transformation = transformation;
     }
 
     @Override
-    protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
+    public Object fetchImage(String id, StreamLoader streamLoader, Transformation transformation, int width, int height, final ImageReadyCallback cb) {
         if (!isHandled(width, height)) {
             throw new IllegalArgumentException(getClass() + "" cannot handle width="" + width + "" and/or height ="" +
                     height);
         }
-        loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
-    }
+        loadToken = imageManager.getImage(id, streamLoader, transformation, downsampler, width, height, new LoadedCallback() {
 
-    /**
-     * An abstract method to make a specific resize call to the {@link ImageManager}
-     *
-     * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
-     *           is not required to do so
-     * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
-     * @param width The width of the view where the image will be displayed
-     * @param height The height of the view where the image will be displayed
-     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
-     *
-     * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
-     */
-    protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
-        return imageManager.getImage(id, streamLoader, width, height, downsampler, transformation, new LoadedCallback() {
             @Override
             public void onLoadCompleted(Bitmap loaded) {
-                cb.onImageReady(loaded);
+                onImageReady(loaded, cb.onImageReady(loaded));
             }
 
             @Override
@@ -75,10 +58,10 @@ public class ImageManagerLoader extends BaseImageLoader {
                 cb.onException(e);
             }
         });
+        return loadToken;
     }
 
-    @Override
-    protected void onImageReady(String id, Bitmap image, boolean isUsed) {
+    protected void onImageReady(Bitmap image, boolean isUsed) {
         if (isUsed) {
             releaseAcquired();
             imageManager.acquireBitmap(image);
","6 import com.bumptech.glide.loader.image.ImageLoader;
19 public class ImageManagerLoader implements ImageLoader {
26     public ImageManagerLoader(Context context) {
27         this(context, Downsampler.AT_LEAST);
30     public ImageManagerLoader(ImageManager imageManager) {
31         this(imageManager, Downsampler.AT_LEAST);
34     public ImageManagerLoader(Context context, Downsampler downsampler) {
35         this(Glide.get().getImageManager(context), downsampler);
38     public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler) {
44     public Object fetchImage(String id, StreamLoader streamLoader, Transformation transformation, int width, int height, final ImageReadyCallback cb) {
49         loadToken = imageManager.getImage(id, streamLoader, transformation, downsampler, width, height, new LoadedCallback() {
53                 onImageReady(loaded, cb.onImageReady(loaded));
61         return loadToken;
64     protected void onImageReady(Bitmap image, boolean isUsed) {
6 import com.bumptech.glide.loader.image.BaseImageLoader;
19 public class ImageManagerLoader extends BaseImageLoader {
22     private final Transformation transformation;
27     public ImageManagerLoader(Context context, Transformation transformation) {
28         this(context, Downsampler.AT_LEAST, transformation);
31     public ImageManagerLoader(Context context, Downsampler downsampler, Transformation transformation) {
32         this(Glide.get().getImageManager(context), downsampler, transformation);
35     public ImageManagerLoader(ImageManager imageManager, Transformation transformation) {
36         this(imageManager, Downsampler.AT_LEAST, transformation);
39     public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler, Transformation transformation) {
42         this.transformation = transformation;
46     protected final void doFetchImage(String id, StreamLoader streamLoader, int width, int height, ImageReadyCallback cb) {
51         loadToken = loadFromImageManager(id, streamLoader, width, height, cb);
52     }
54     /**
55      * An abstract method to make a specific resize call to the {@link ImageManager}
56      *
57      * @param id A string id that uniquely identifies the image to be loaded. It may include the width and height, but
58      *           is not required to do so
59      * @param streamLoader The {@link StreamLoader} that will be used to load the image if it is not cached
60      * @param width The width of the view where the image will be displayed
61      * @param height The height of the view where the image will be displayed
62      * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails
63      *
64      * @return A reference to the fetch that must be retained by the calling object as long as the fetch is relevant
65      */
66     protected Object loadFromImageManager(String id, StreamLoader streamLoader, int width, int height, final ImageReadyCallback cb) {
67         return imageManager.getImage(id, streamLoader, width, height, downsampler, transformation, new LoadedCallback() {
70                 cb.onImageReady(loaded);
80     @Override
81     protected void onImageReady(String id, Bitmap image, boolean isUsed) {",No
library\tests\src\com\bumptech\glide\GlideTest.java,library\tests\src\com\bumptech\glide\GlideTest.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -45,7 +45,7 @@ public class GlideTest extends ActivityTestCase {
     }
 
     private ImagePresenter getImagePresenterFromView() {
-        return (ImagePresenter) imageView.getTag(R.id.image_presenter_id);
+        return (ImagePresenter) imageView.getTag();
     }
 
     public void testFileDefaultLoader() {
@@ -103,15 +103,15 @@ public class GlideTest extends ActivityTestCase {
                 ViewGroup.LayoutParams.WRAP_CONTENT));
         Glide.load(""fake"").into(imageView);
 
-        assertNotNull(ImagePresenter.getCurrent(imageView));
+        assertNotNull(getImagePresenterFromView());
     }
 
     public void testDifferentModlsReplacesPresenters() {
         Glide.load(""fake"").into(imageView);
 
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
         Glide.load(4).into(imageView);
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
@@ -122,7 +122,7 @@ public class GlideTest extends ActivityTestCase {
             public StreamLoader getStreamLoader(Object model, int width, int height) {
                 return new StreamLoader() {
                     @Override
-                    public void loadStream(StreamReadyCallback cb) {
+                    public void loadStream(Object t, StreamReadyCallback cb) {
                     }
 
                     @Override
@@ -136,19 +136,16 @@ public class GlideTest extends ActivityTestCase {
                 return String.valueOf(model.hashCode());
             }
 
-            @Override
-            public void clear() {
-            }
         }).load(new Object()).into(imageView);
 
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
 
         Glide.using(new ModelLoader<Object>() {
             @Override
             public StreamLoader getStreamLoader(Object model, int width, int height) {
                 return new StreamLoader() {
                     @Override
-                    public void loadStream(StreamReadyCallback cb) {
+                    public void loadStream(Object object, StreamReadyCallback cb) {
                     }
 
                     @Override
@@ -162,12 +159,9 @@ public class GlideTest extends ActivityTestCase {
                 return String.valueOf(model.hashCode());
             }
 
-            @Override
-            public void clear() {
-            }
         }).load(new Object()).into(imageView);
 
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
@@ -175,10 +169,10 @@ public class GlideTest extends ActivityTestCase {
     public void testDifferentImageLoadersReplacesPresenter() {
         final File file = new File(""fake"");
         Glide.load(file).centerCrop().into(imageView);
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
 
         Glide.load(file).into(imageView);
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
@@ -186,10 +180,10 @@ public class GlideTest extends ActivityTestCase {
     public void testDifferentPlaceholdersReplacesPresenter() {
         final File file = new File(""fake"");
         Glide.load(file).placeholder(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
 
         Glide.load(file).into(imageView);
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
@@ -197,10 +191,10 @@ public class GlideTest extends ActivityTestCase {
     public void testDifferentAnimationsReplacesPresenter() {
         final File file = new File(""fake"");
         Glide.load(file).animate(android.R.anim.fade_in).into(imageView);
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
 
         Glide.load(file).animate(android.R.anim.fade_out).into(imageView);
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
@@ -208,10 +202,10 @@ public class GlideTest extends ActivityTestCase {
     public void testDifferentErrorIdsReplacesPresenter() {
         final File file = new File(""fake"");
         Glide.load(file).error(com.bumptech.glide.tests.R.raw.ic_launcher).into(imageView);
-        ImagePresenter first = ImagePresenter.getCurrent(imageView);
+        ImagePresenter first = getImagePresenterFromView();
 
         Glide.load(file).error(android.R.drawable.btn_star).into(imageView);
-        ImagePresenter second = ImagePresenter.getCurrent(imageView);
+        ImagePresenter second = getImagePresenterFromView();
 
         assertNotSame(first, second);
     }
","48         return (ImagePresenter) imageView.getTag();
106         assertNotNull(getImagePresenterFromView());
112         ImagePresenter first = getImagePresenterFromView();
114         ImagePresenter second = getImagePresenterFromView();
125                     public void loadStream(Object t, StreamReadyCallback cb) {
141         ImagePresenter first = getImagePresenterFromView();
148                     public void loadStream(Object object, StreamReadyCallback cb) {
164         ImagePresenter second = getImagePresenterFromView();
172         ImagePresenter first = getImagePresenterFromView();
175         ImagePresenter second = getImagePresenterFromView();
183         ImagePresenter first = getImagePresenterFromView();
186         ImagePresenter second = getImagePresenterFromView();
194         ImagePresenter first = getImagePresenterFromView();
197         ImagePresenter second = getImagePresenterFromView();
205         ImagePresenter first = getImagePresenterFromView();
208         ImagePresenter second = getImagePresenterFromView();
48         return (ImagePresenter) imageView.getTag(R.id.image_presenter_id);
106         assertNotNull(ImagePresenter.getCurrent(imageView));
112         ImagePresenter first = ImagePresenter.getCurrent(imageView);
114         ImagePresenter second = ImagePresenter.getCurrent(imageView);
125                     public void loadStream(StreamReadyCallback cb) {
139             @Override
140             public void clear() {
141             }
144         ImagePresenter first = ImagePresenter.getCurrent(imageView);
151                     public void loadStream(StreamReadyCallback cb) {
165             @Override
166             public void clear() {
167             }
170         ImagePresenter second = ImagePresenter.getCurrent(imageView);
178         ImagePresenter first = ImagePresenter.getCurrent(imageView);
181         ImagePresenter second = ImagePresenter.getCurrent(imageView);
189         ImagePresenter first = ImagePresenter.getCurrent(imageView);
192         ImagePresenter second = ImagePresenter.getCurrent(imageView);
200         ImagePresenter first = ImagePresenter.getCurrent(imageView);
203         ImagePresenter second = ImagePresenter.getCurrent(imageView);
211         ImagePresenter first = ImagePresenter.getCurrent(imageView);
214         ImagePresenter second = ImagePresenter.getCurrent(imageView);",No
library\tests\src\com\bumptech\glide\loader\StringLoaderTest.java,library\tests\src\com\bumptech\glide\loader\StringLoaderTest.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -39,9 +39,6 @@ public class StringLoaderTest extends AndroidTestCase {
                 return null;
             }
 
-            @Override
-            public void clear() {
-            }
         };
 
         stringLoader = new StringLoader(uriLoader);
","42             @Override
43             public void clear() {
44             }",No
library\tests\src\com\bumptech\glide\loader\UriLoaderTest.java,library\tests\src\com\bumptech\glide\loader\UriLoaderTest.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -29,7 +29,7 @@ public class UriLoaderTest extends AndroidTestCase {
         urlLoader = new StreamLoader() {
 
             @Override
-            public void loadStream(StreamReadyCallback cb) {
+            public void loadStream(Object t, StreamReadyCallback cb) {
             }
 
             @Override
@@ -46,10 +46,6 @@ public class UriLoaderTest extends AndroidTestCase {
             public String getId(URL model) {
                 return null;
             }
-
-            @Override
-            public void clear() {
-            }
         });
     }
 
","32             public void loadStream(Object t, StreamReadyCallback cb) {
32             public void loadStream(StreamReadyCallback cb) {
49 
50             @Override
51             public void clear() {
52             }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,c572847b4cf003bcd5070b5d0499342ac6827450,ef34a5bc088fc6c07a986e674e88dd306e793fbe,"Allow arbitrary transformations

Also passes loaders all the way to image manager
to decrease # of objects created for images
in the memory or disk cache.","@@ -12,15 +12,10 @@ import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
-<<<<<<< HEAD
-import com.bumptech.glide.resize.Downsampler;
-import com.bumptech.glide.resize.Transformation;
-import com.bumptech.glide.resize.loader.CenterCrop;
-=======
-import com.bumptech.glide.resize.loader.ImageManagerLoader;
->>>>>>> 765fdbe... Should have been in go to just image manager loader
+import com.bumptech.glide.resize.loader.Approximate;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -119,7 +114,8 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
                         .setModelLoader(new FlickrModelLoader(context))
-                        .setImageLoader(new CenterCrop(context))
+                        .setImageLoader(new Approximate<Photo>(context))
+                        .setTransformationLoader(new CenterCrop<Photo>())
                         .setImageReadyCallback(new ImageReadyCallback() {
                             @Override
                             public void onImageReady(ImageView view, boolean fromCache) {
","15 import com.bumptech.glide.loader.transformation.CenterCrop;
18 import com.bumptech.glide.resize.loader.Approximate;
117                         .setImageLoader(new Approximate<Photo>(context))
118                         .setTransformationLoader(new CenterCrop<Photo>())
17 <<<<<<< HEAD
18 import com.bumptech.glide.resize.Downsampler;
19 import com.bumptech.glide.resize.Transformation;
20 import com.bumptech.glide.resize.loader.CenterCrop;
21 =======
22 import com.bumptech.glide.resize.loader.ImageManagerLoader;
23 >>>>>>> 765fdbe... Should have been in go to just image manager loader
122                         .setImageLoader(new CenterCrop(context))",No
library\res\values\ids.xml,,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -1,5 +0,0 @@
-<?xml version=""1.0"" encoding=""utf-8""?>
-<resources>
-  <item type=""id"" name=""image_presenter_id"" />
-  <item type=""id"" name=""glide_metadata"" />
-</resources>
\ No newline at end of file
","1 <?xml version=""1.0"" encoding=""utf-8""?>
2 <resources>
3   <item type=""id"" name=""image_presenter_id"" />
4   <item type=""id"" name=""glide_metadata"" />
5 </resources>",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -20,6 +20,8 @@ import com.bumptech.glide.loader.transformation.FitCenter;
 import com.bumptech.glide.loader.transformation.TransformationLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
+import com.bumptech.glide.presenter.target.ImageViewTarget;
+import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.Transformation;
@@ -27,8 +29,8 @@ import com.bumptech.glide.resize.loader.ImageManagerLoader;
 
 import java.io.File;
 import java.net.URL;
-
-import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 /**
  * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
@@ -44,6 +46,7 @@ public class Glide {
     private static final Glide GLIDE = new Glide();
     private ImageManager imageManager = null;
     private RequestQueue requestQueue = null;
+    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();
 
     /**
      * Get the singleton.
@@ -321,7 +324,7 @@ public class Glide {
     public static class ModelRequest<T> {
         private final ModelLoader<T> modelLoader;
 
-        public ModelRequest(ModelLoader<T> modelLoader) {
+        private ModelRequest(ModelLoader<T> modelLoader) {
             this.modelLoader = modelLoader;
         }
 
@@ -339,6 +342,9 @@ public class Glide {
     @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
 
+        private Context context;
+        private Target target;
+
         private enum ResizeOption {
             APPROXIMATE,
             CENTER_CROP,
@@ -358,13 +364,13 @@ public class Glide {
         private Downsampler downsampler = null;
         private TransformationLoader<T> transformationLoader = null;
 
-        public Request(T model) {
+        private Request(T model) {
             this.model = model;
             this.modelLoaderFactory = getFactory(model);
             this.modelLoaderClass = modelLoaderFactory.loaderClass();
         }
 
-        public Request(T model, ModelLoader<T> modelLoader) {
+        private Request(T model, ModelLoader<T> modelLoader) {
             this.model = model;
             this.modelLoader = modelLoader;
             this.modelLoaderClass = modelLoader.getClass();
@@ -490,7 +496,27 @@ public class Glide {
          * @see ImagePresenter#setModel(Object)
          */
         public void into(ImageView imageView) {
-            ImagePresenter<T> imagePresenter = getImagePresenter(imageView);
+            //make an effort to support wrap content layout params. This will still blow
+            //up if transformation doesn't handle wrap content, but its a start
+            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
+            if (layoutParams != null &&
+                    (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
+                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {
+                downsampler = Downsampler.NONE;
+            }
+
+            finish(imageView.getContext(), new ImageViewTarget(imageView));
+        }
+
+        public ContextRequest into(Target target) {
+            return new ContextRequest(this, target);
+        }
+
+        private void finish(Context context, Target target) {
+            this.context = context;
+            this.target = target;
+
+            ImagePresenter<T> imagePresenter = getImagePresenter(target);
             imagePresenter.setModel(model);
         }
 
@@ -498,50 +524,45 @@ public class Glide {
          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
          * the view's tag for the id {@code R.id.image_presenter_id}.
          */
-        private ImagePresenter<T> getImagePresenter(ImageView imageView) {
-            downsampler = getFinalDownsampler(imageView);
-
-            Metadata previous = getMetadataFrom(imageView);
+        @SuppressWarnings(""unchecked"")
+        private ImagePresenter<T> getImagePresenter(Target target) {
+            Metadata previous = GLIDE.metadataTracker.get(target);
             Metadata current = new Metadata(this);
 
-            ImagePresenter<T> result = ImagePresenter.getCurrent(imageView);
+            ImagePresenter<T> result = target.getImagePresenter();
 
             if (!current.equals(previous)) {
                 if (result != null) {
                     result.clear();
                 }
 
-                result = buildImagePresenter(imageView);
+                result = buildImagePresenter(target);
+                target.setImagePresenter(result);
 
-                setMetadata(imageView, current);
+                GLIDE.metadataTracker.put(target, current);
             }
 
             return result;
         }
 
-        private ImagePresenter<T> buildImagePresenter(ImageView imageView) {
-            final Context context = imageView.getContext();
-
+        private ImagePresenter<T> buildImagePresenter(Target target) {
             modelLoader = getFinalModelLoader(context);
             transformationLoader = getFinalTransformationLoader();
 
             ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
-                    .setImageView(imageView)
+                    .setTarget(target, context)
                     .setModelLoader(modelLoader)
                     .setImageLoader(new ImageManagerLoader(context, downsampler))
                     .setTransformationLoader(transformationLoader);
 
             if (animationId != -1) {
-                final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
+                final Animation animation = AnimationUtils.loadAnimation(context, animationId);
                 builder.setImageReadyCallback(new ImageReadyCallback() {
                     @Override
-                    public void onImageReady(ImageView view, boolean fromCache) {
-                        view.clearAnimation();
-
+                    public void onImageReady(Target target, boolean fromCache) {
                         if (!fromCache) {
-                            view.startAnimation(animation);
+                            target.startAnimation(animation);
                         }
-
                     }
                 });
             }
@@ -585,27 +606,20 @@ public class Glide {
                 return transformation.getId();
             }
         }
-
-        private Downsampler getFinalDownsampler(ImageView imageView) {
-            Downsampler result = downsampler;
-            if (result == null) {
-                ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
-                if (layoutParams.width == WRAP_CONTENT && layoutParams.height == WRAP_CONTENT) {
-                    result = Downsampler.NONE;
-                } else {
-                    result = Downsampler.AT_LEAST;
-                }
-            }
-            return result;
     }
 
+    public static class ContextRequest {
+        private final Request request;
+        private final Target target;
 
-        private static Metadata getMetadataFrom(ImageView imageView) {
-            return (Metadata) imageView.getTag(R.id.glide_metadata);
+        private ContextRequest(Request request, Target target) {
+            this.request = request;
+            this.target = target;
         }
 
-        private static void setMetadata(ImageView imageView, Metadata metadata) {
-            imageView.setTag(R.id.glide_metadata, metadata);
+        public void with(Context context) {
+            request.finish(context, target);
+        }
     }
 
     private static class Metadata {
@@ -614,6 +628,7 @@ public class Glide {
         public final int animationId;
         public final int placeholderId;
         public final int errorId;
+
         private final String downsamplerId;
         private final String transformationId;
 
@@ -645,6 +660,4 @@ public class Glide {
 
         }
     }
-
-    }
 }
","23 import com.bumptech.glide.presenter.target.ImageViewTarget;
24 import com.bumptech.glide.presenter.target.Target;
32 import java.util.Map;
33 import java.util.WeakHashMap;
49     private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();
327         private ModelRequest(ModelLoader<T> modelLoader) {
345         private Context context;
346         private Target target;
347 
367         private Request(T model) {
373         private Request(T model, ModelLoader<T> modelLoader) {
499             //make an effort to support wrap content layout params. This will still blow
500             //up if transformation doesn't handle wrap content, but its a start
501             final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
502             if (layoutParams != null &&
503                     (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
504                     layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {
505                 downsampler = Downsampler.NONE;
506             }
507 
508             finish(imageView.getContext(), new ImageViewTarget(imageView));
509         }
510 
511         public ContextRequest into(Target target) {
512             return new ContextRequest(this, target);
513         }
514 
515         private void finish(Context context, Target target) {
516             this.context = context;
517             this.target = target;
518 
519             ImagePresenter<T> imagePresenter = getImagePresenter(target);
527         @SuppressWarnings(""unchecked"")
528         private ImagePresenter<T> getImagePresenter(Target target) {
529             Metadata previous = GLIDE.metadataTracker.get(target);
532             ImagePresenter<T> result = target.getImagePresenter();
539                 result = buildImagePresenter(target);
540                 target.setImagePresenter(result);
542                 GLIDE.metadataTracker.put(target, current);
548         private ImagePresenter<T> buildImagePresenter(Target target) {
553                     .setTarget(target, context)
559                 final Animation animation = AnimationUtils.loadAnimation(context, animationId);
562                     public void onImageReady(Target target, boolean fromCache) {
564                             target.startAnimation(animation);
611     public static class ContextRequest {
612         private final Request request;
613         private final Target target;
615         private ContextRequest(Request request, Target target) {
616             this.request = request;
617             this.target = target;
620         public void with(Context context) {
621             request.finish(context, target);
622         }
631 
30 
31 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
324         public ModelRequest(ModelLoader<T> modelLoader) {
361         public Request(T model) {
367         public Request(T model, ModelLoader<T> modelLoader) {
493             ImagePresenter<T> imagePresenter = getImagePresenter(imageView);
501         private ImagePresenter<T> getImagePresenter(ImageView imageView) {
502             downsampler = getFinalDownsampler(imageView);
503 
504             Metadata previous = getMetadataFrom(imageView);
507             ImagePresenter<T> result = ImagePresenter.getCurrent(imageView);
514                 result = buildImagePresenter(imageView);
516                 setMetadata(imageView, current);
522         private ImagePresenter<T> buildImagePresenter(ImageView imageView) {
523             final Context context = imageView.getContext();
524 
529                     .setImageView(imageView)
535                 final Animation animation = AnimationUtils.loadAnimation(imageView.getContext(), animationId);
538                     public void onImageReady(ImageView view, boolean fromCache) {
539                         view.clearAnimation();
540 
542                             view.startAnimation(animation);
544 
588 
589         private Downsampler getFinalDownsampler(ImageView imageView) {
590             Downsampler result = downsampler;
591             if (result == null) {
592                 ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
593                 if (layoutParams.width == WRAP_CONTENT && layoutParams.height == WRAP_CONTENT) {
594                     result = Downsampler.NONE;
595                 } else {
596                     result = Downsampler.AT_LEAST;
597                 }
598             }
599             return result;
603         private static Metadata getMetadataFrom(ImageView imageView) {
604             return (Metadata) imageView.getTag(R.id.glide_metadata);
607         private static void setMetadata(ImageView imageView, Metadata metadata) {
608             imageView.setTag(R.id.glide_metadata, metadata);
648 
649     }",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -4,26 +4,21 @@
 
 package com.bumptech.glide.presenter;
 
+import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import com.bumptech.glide.R;
 import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.transformation.None;
 import com.bumptech.glide.loader.transformation.TransformationLoader;
+import com.bumptech.glide.presenter.target.ImageViewTarget;
+import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.util.Log;
 
-import java.lang.ref.WeakReference;
-
 /**
  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
  * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
@@ -37,7 +32,6 @@ import java.lang.ref.WeakReference;
  */
 public class ImagePresenter<T> {
 
-
     /**
      * A builder for an {@link ImagePresenter}.
      *
@@ -52,12 +46,12 @@ public class ImagePresenter<T> {
      */
     @SuppressWarnings(""unused"")
     public static class Builder<T> {
-        private ImageView imageView;
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
         private ImageReadyCallback imageReadyCallback;
         private ImagePresenterCoordinator coordinator;
         private ImageLoader imageLoader;
+        private Context context;
         private ExceptionHandler<T> exceptionHandler = new ExceptionHandler<T>() {
             @Override
             public void onException(Exception e, T model, boolean isCurrent) {
@@ -73,6 +67,7 @@ public class ImagePresenter<T> {
         private int errorResourceId;
         private Drawable errorDrawable;
         private TransformationLoader<T> transformationLoader;
+        private Target target;
 
         /**
          * Builds an ImagePresenter.
@@ -80,16 +75,14 @@ public class ImagePresenter<T> {
          * <p>
          *     Note - If an ImagePresenter has already been set for this view, it will be silently replaced and will not
          *     be cleared which could lead to undefined behavior. It is most efficient to set an ImagePresenter once and
-         *     then retrieve it for each subsequent load. If you need to replace an ImagePresenter you can do so by
-         *     setting the tag at <code>R.id.image_presenter_id</code> to null with
-         *     {@link View#setTag(int, Object)}
+         *     then retrieve it for each subsequent load.
          * </p>
          *
          * @return A new ImagePresenter
          */
         public ImagePresenter<T> build(){
-            if (imageView == null) {
-                throw new IllegalArgumentException(""cannot create presenter without an image view"");
+            if (target == null) {
+                throw new IllegalArgumentException(""cannot create presenter without a target"");
             }
             if (imageLoader == null) {
                 throw new IllegalArgumentException(""cannot create presenter without an image loader"");
@@ -111,8 +104,17 @@ public class ImagePresenter<T> {
          * @param imageView The {@link android.widget.ImageView} to wrap
          * @return This Builder object
          */
-        public Builder<T> setImageView(ImageView imageView) {
-            this.imageView = imageView;
+        public Builder<T> setImageView(final ImageView imageView) {
+            this.target = new ImageViewTarget(imageView);
+            this.context = imageView.getContext();
+
+            return this;
+        }
+
+        public Builder<T> setTarget(Target target, Context context) {
+            this.target = target;
+            this.context = context;
+
             return this;
         }
 
@@ -252,6 +254,8 @@ public class ImagePresenter<T> {
     @SuppressWarnings(""all"")
     private Object imageToken; //this is just a reference we may need to keep, otherwise unused
 
+    private final Target target;
+
     private final ModelLoader<T> modelLoader;
     private final ImageLoader imageLoader;
     private final TransformationLoader<T> transformationLoader;
@@ -260,14 +264,12 @@ public class ImagePresenter<T> {
     private final ImageReadyCallback imageReadyCallback;
     private final ImagePresenterCoordinator coordinator;
     private final ExceptionHandler<T> exceptionHandler;
-    private final ImageView imageView;
 
     private T currentModel;
     private int currentCount;
 
     private boolean isImageSet = false;
     private boolean loadedFromCache = false;
-    private final SizeDeterminer sizeDeterminer;
     private final Drawable errorDrawable;
 
     /**
@@ -308,25 +310,11 @@ public class ImagePresenter<T> {
         public void onException(Exception e, T model, boolean isCurrent);
     }
 
-    /**
-     * Retrieves the current ImagePresenter for the given view using {@link android.widget.ImageView#getTag()} and
-     * <code>R.id.image_presenter_id</code>
-     *
-     * @param imageView The view to get the ImagePresenter for
-     * @param <T> The type of model being displayed in the ImageView
-     * @return The current ImagePresenter, or null if one does not exist
-     */
-    @SuppressWarnings(""unchecked"")
-    public static <T> ImagePresenter<T> getCurrent(View imageView) {
-        return (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
-    }
-
     protected ImagePresenter(Builder<T> builder) {
-        this.imageView = builder.imageView;
         this.imageLoader = builder.imageLoader;
         this.transformationLoader = builder.transformationLoader;
 
-        final Resources res = imageView.getResources();
+        final Resources res = builder.context.getResources();
         if (builder.placeholderResourceId != 0) {
             this.placeholderDrawable = res.getDrawable(builder.placeholderResourceId);
         } else {
@@ -342,23 +330,7 @@ public class ImagePresenter<T> {
         this.imageReadyCallback = builder.imageReadyCallback;
         this.exceptionHandler = builder.exceptionHandler;
         this.modelLoader = builder.modelLoader;
-        sizeDeterminer = new SizeDeterminer(imageView);
-
-        imageView.setTag(R.id.image_presenter_id, this);
-    }
-
-    /**
-     * A method to get the wrapped {@link android.widget.ImageView}.
-     *
-     * <p>
-     *     Note - Setting any image or drawable on the view
-     * directly may be overridden at any point by the wrapping presenter.
-     * </p>
-     *
-     * @return The {@link android.widget.ImageView} this {@link ImagePresenter} object wraps
-     */
-    public ImageView getImageView() {
-        return imageView;
+        this.target = builder.target;
     }
 
     /**
@@ -384,7 +356,7 @@ public class ImagePresenter<T> {
             currentModel = model;
             isImageSet = false;
 
-            sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
+            target.getSize(new Target.SizeReadyCallback() {
                 @Override
                 public void onSizeReady(int width, int height) {
                     fetchImage(model, width, height, loadCount);
@@ -407,7 +379,7 @@ public class ImagePresenter<T> {
     public void resetPlaceHolder() {
         if (!canSetPlaceholder()) return;
 
-        imageView.setImageDrawable(placeholderDrawable);
+        target.setPlaceholder(placeholderDrawable);
     }
 
     /**
@@ -436,8 +408,8 @@ public class ImagePresenter<T> {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
 
                 if (imageReadyCallback != null)
-                    imageReadyCallback.onImageReady(imageView, loadedFromCache);
-                imageView.setImageBitmap(image);
+                    imageReadyCallback.onImageReady(target, loadedFromCache);
+                target.onImageReady(image);
                 isImageSet = true;
                 return true;
             }
@@ -449,7 +421,7 @@ public class ImagePresenter<T> {
                     exceptionHandler.onException(e, model, relevant);
                 }
                 if (relevant && canSetPlaceholder()) {
-                    imageView.setImageDrawable(errorDrawable);
+                    target.setPlaceholder(errorDrawable);
                 }
             }
         });
@@ -473,104 +445,4 @@ public class ImagePresenter<T> {
     private boolean canSetPlaceholder() {
         return coordinator == null || coordinator.canSetPlaceholder(this);
     }
-
-    private static class SizeDeterminer {
-        private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
-        private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
-
-        private final View view;
-        private int width = 0;
-        private int height = 0;
-        private boolean valid = false;
-        private SizeReadyCallback cb = null;
-        private Handler handler = new Handler();
-        private final Runnable getDimens = new Runnable() {
-            @Override
-            public void run() {
-                if (cb == null) return;
-
-                ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-                if (layoutParams.width > 0 && layoutParams.height > 0) {
-                    cb.onSizeReady(layoutParams.width, layoutParams.height);
-                } else if (view.getWidth() > 0 && view.getHeight() > 0) {
-                    valid = true;
-                    width = view.getWidth();
-                    height = view.getHeight();
-                    cb.onSizeReady(width, height);
-                }
-                cb = null;
-            }
-        };
-
-        private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
-            private final WeakReference<SizeDeterminer> sizeDeterminerRef;
-            private final Handler handler;
-
-            public SizeObserver(SizeDeterminer sizeDeterminer, Handler handler) {
-                this.sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
-                this.handler = handler;
-            }
-
-            @Override
-            public void onGlobalLayout() {
-                if (sizeDeterminerRef.get() != null) {
-                    handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
-                    handler.postAtTime(new Runnable() {
-                        @Override
-                        public void run() {
-                            final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
-                            if (sizeDeterminer != null) {
-                                sizeDeterminer.maybeInvalidate();
-                            }
-                        }
-                    }, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
-                }
-            }
-        }
-
-        public interface SizeReadyCallback {
-            public void onSizeReady(int width, int height);
-        }
-
-        public SizeDeterminer(View view) {
-            this.view = view;
-            view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this, handler));
-        }
-
-        public void getSize(SizeReadyCallback cb) {
-            handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
-            this.cb = null;
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            //non null layout params and either width and height have been set, or set to wrap content so they
-            //will not be set until we set some content
-            if (layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0)
-                    || (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
-                            layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT))) {
-                cb.onSizeReady(layoutParams.width, layoutParams.height);
-            } else if (valid) {
-                cb.onSizeReady(width, height);
-            } else {
-                this.cb = cb;
-                handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis()
-                        + PENDING_SIZE_CHANGE_DELAY);
-            }
-        }
-
-        private void maybeInvalidate() {
-            ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-            if (layoutParams.width <= 0 || layoutParams.height <= 0) {
-                if (view.getWidth() >= 0 && view.getHeight() >= 0) {
-                    width = view.getWidth();
-                    height = view.getHeight();
-                    valid = true;
-                    if (cb != null) {
-                        cb.onSizeReady(width, height);
-                        cb = null;
-                    }
-                } else {
-                    valid = false;
-                }
-            }
-        }
-    }
 }
","7 import android.content.Context;
17 import com.bumptech.glide.presenter.target.ImageViewTarget;
18 import com.bumptech.glide.presenter.target.Target;
54         private Context context;
70         private Target target;
78          *     then retrieve it for each subsequent load.
84             if (target == null) {
85                 throw new IllegalArgumentException(""cannot create presenter without a target"");
107         public Builder<T> setImageView(final ImageView imageView) {
108             this.target = new ImageViewTarget(imageView);
109             this.context = imageView.getContext();
110 
111             return this;
112         }
113 
114         public Builder<T> setTarget(Target target, Context context) {
115             this.target = target;
116             this.context = context;
117 
257     private final Target target;
258 
317         final Resources res = builder.context.getResources();
333         this.target = builder.target;
359             target.getSize(new Target.SizeReadyCallback() {
382         target.setPlaceholder(placeholderDrawable);
411                     imageReadyCallback.onImageReady(target, loadedFromCache);
412                 target.onImageReady(image);
424                     target.setPlaceholder(errorDrawable);
10 import android.os.Handler;
11 import android.os.SystemClock;
12 import android.view.View;
13 import android.view.ViewGroup;
14 import android.view.ViewTreeObserver;
16 import com.bumptech.glide.R;
25 import java.lang.ref.WeakReference;
26 
40 
55         private ImageView imageView;
83          *     then retrieve it for each subsequent load. If you need to replace an ImagePresenter you can do so by
84          *     setting the tag at <code>R.id.image_presenter_id</code> to null with
85          *     {@link View#setTag(int, Object)}
91             if (imageView == null) {
92                 throw new IllegalArgumentException(""cannot create presenter without an image view"");
114         public Builder<T> setImageView(ImageView imageView) {
115             this.imageView = imageView;
263     private final ImageView imageView;
270     private final SizeDeterminer sizeDeterminer;
311     /**
312      * Retrieves the current ImagePresenter for the given view using {@link android.widget.ImageView#getTag()} and
313      * <code>R.id.image_presenter_id</code>
314      *
315      * @param imageView The view to get the ImagePresenter for
316      * @param <T> The type of model being displayed in the ImageView
317      * @return The current ImagePresenter, or null if one does not exist
318      */
319     @SuppressWarnings(""unchecked"")
320     public static <T> ImagePresenter<T> getCurrent(View imageView) {
321         return (ImagePresenter<T>) imageView.getTag(R.id.image_presenter_id);
322     }
323 
325         this.imageView = builder.imageView;
329         final Resources res = imageView.getResources();
345         sizeDeterminer = new SizeDeterminer(imageView);
346 
347         imageView.setTag(R.id.image_presenter_id, this);
348     }
349 
350     /**
351      * A method to get the wrapped {@link android.widget.ImageView}.
352      *
353      * <p>
354      *     Note - Setting any image or drawable on the view
355      * directly may be overridden at any point by the wrapping presenter.
356      * </p>
357      *
358      * @return The {@link android.widget.ImageView} this {@link ImagePresenter} object wraps
359      */
360     public ImageView getImageView() {
361         return imageView;
387             sizeDeterminer.getSize(new SizeDeterminer.SizeReadyCallback() {
410         imageView.setImageDrawable(placeholderDrawable);
439                     imageReadyCallback.onImageReady(imageView, loadedFromCache);
440                 imageView.setImageBitmap(image);
452                     imageView.setImageDrawable(errorDrawable);
476 
477     private static class SizeDeterminer {
478         private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
479         private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
480 
481         private final View view;
482         private int width = 0;
483         private int height = 0;
484         private boolean valid = false;
485         private SizeReadyCallback cb = null;
486         private Handler handler = new Handler();
487         private final Runnable getDimens = new Runnable() {
488             @Override
489             public void run() {
490                 if (cb == null) return;
491 
492                 ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
493                 if (layoutParams.width > 0 && layoutParams.height > 0) {
494                     cb.onSizeReady(layoutParams.width, layoutParams.height);
495                 } else if (view.getWidth() > 0 && view.getHeight() > 0) {
496                     valid = true;
497                     width = view.getWidth();
498                     height = view.getHeight();
499                     cb.onSizeReady(width, height);
500                 }
501                 cb = null;
502             }
503         };
504 
505         private static class SizeObserver implements ViewTreeObserver.OnGlobalLayoutListener {
506             private final WeakReference<SizeDeterminer> sizeDeterminerRef;
507             private final Handler handler;
508 
509             public SizeObserver(SizeDeterminer sizeDeterminer, Handler handler) {
510                 this.sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
511                 this.handler = handler;
512             }
513 
514             @Override
515             public void onGlobalLayout() {
516                 if (sizeDeterminerRef.get() != null) {
517                     handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
518                     handler.postAtTime(new Runnable() {
519                         @Override
520                         public void run() {
521                             final SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
522                             if (sizeDeterminer != null) {
523                                 sizeDeterminer.maybeInvalidate();
524                             }
525                         }
526                     }, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis() + PENDING_SIZE_CHANGE_DELAY);
527                 }
528             }
529         }
530 
531         public interface SizeReadyCallback {
532             public void onSizeReady(int width, int height);
533         }
534 
535         public SizeDeterminer(View view) {
536             this.view = view;
537             view.getViewTreeObserver().addOnGlobalLayoutListener(new SizeObserver(this, handler));
538         }
539 
540         public void getSize(SizeReadyCallback cb) {
541             handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
542             this.cb = null;
543             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
544             //non null layout params and either width and height have been set, or set to wrap content so they
545             //will not be set until we set some content
546             if (layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0)
547                     || (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
548                             layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT))) {
549                 cb.onSizeReady(layoutParams.width, layoutParams.height);
550             } else if (valid) {
551                 cb.onSizeReady(width, height);
552             } else {
553                 this.cb = cb;
554                 handler.postAtTime(getDimens, PENDING_SIZE_CHANGE_TOKEN, SystemClock.uptimeMillis()
555                         + PENDING_SIZE_CHANGE_DELAY);
556             }
557         }
558 
559         private void maybeInvalidate() {
560             ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
561             if (layoutParams.width <= 0 || layoutParams.height <= 0) {
562                 if (view.getWidth() >= 0 && view.getHeight() >= 0) {
563                     width = view.getWidth();
564                     height = view.getHeight();
565                     valid = true;
566                     if (cb != null) {
567                         cb.onSizeReady(width, height);
568                         cb = null;
569                     }
570                 } else {
571                     valid = false;
572                 }
573             }
574         }
575     }",No
library\src\com\bumptech\glide\presenter\ImageReadyCallback.java,library\src\com\bumptech\glide\presenter\ImageReadyCallback.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -4,7 +4,7 @@
 
 package com.bumptech.glide.presenter;
 
-import android.widget.ImageView;
+import com.bumptech.glide.presenter.target.Target;
 
 /**
  * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an
@@ -15,8 +15,8 @@ public interface ImageReadyCallback {
     /**
      * The method called when a bitmap is set
      *
-     * @param view The view that will display the bitmap
+     * @param target The target that will display the bitmap
      * @param fromCache True iff the load completed without a placeholder being shown.
      */
-    public void onImageReady(ImageView view, boolean fromCache);
+    public void onImageReady(Target target, boolean fromCache);
 }
","7 import com.bumptech.glide.presenter.target.Target;
18      * @param target The target that will display the bitmap
21     public void onImageReady(Target target, boolean fromCache);
7 import android.widget.ImageView;
18      * @param view The view that will display the bitmap
21     public void onImageReady(ImageView view, boolean fromCache);",No
library\src\com\bumptech\glide\presenter\ThumbImagePresenter.java,library\src\com\bumptech\glide\presenter\ThumbImagePresenter.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -136,15 +136,6 @@ public class ThumbImagePresenter<A, B> implements ImagePresenter.ImagePresenterC
         }
     }
 
-    /**
-     * Get the {@link android.widget.ImageView} this object is acting on
-     *
-     * @see ImagePresenter#getImageView()
-     */
-    public ImageView getImageView() {
-        return fullPresenter.getImageView();
-    }
-
     /**
      * Calls the corresponding method on both image presenters
      *
","139     /**
140      * Get the {@link android.widget.ImageView} this object is acting on
141      *
142      * @see ImagePresenter#getImageView()
143      */
144     public ImageView getImageView() {
145         return fullPresenter.getImageView();
146     }
147 ",No
,library\src\com\bumptech\glide\presenter\target\ImageViewTarget.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -0,0 +1,136 @@
+package com.bumptech.glide.presenter.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.view.View;
+import android.view.animation.Animation;
+import android.widget.ImageView;
+import com.bumptech.glide.presenter.ImagePresenter;
+
+import static android.view.ViewGroup.LayoutParams;
+
+/**
+ * A target wrapping an ImageView that makes use of {@link ImageView#setTag(Object)} to store and retrieve
+ * ImagePresenters. Also obtains the runtime dimensions of the ImageView.
+ */
+public class ImageViewTarget implements Target {
+    private final ImageView imageView;
+    private final SizeDeterminer sizeDeterminer;
+
+    public ImageViewTarget(ImageView imageView) {
+        this.imageView = imageView;
+        this.sizeDeterminer = new SizeDeterminer(imageView);
+    }
+
+    @Override
+    public void onImageReady(Bitmap bitmap) {
+        imageView.setImageBitmap(bitmap);
+    }
+
+    @Override
+    public void setPlaceholder(Drawable placeholder) {
+        imageView.setImageDrawable(placeholder);
+    }
+
+    @Override
+    public void getSize(SizeReadyCallback cb) {
+        sizeDeterminer.getSize(cb);
+    }
+
+    @Override
+    public void startAnimation(Animation animation) {
+        imageView.clearAnimation();
+
+        imageView.startAnimation(animation);
+    }
+
+    /**
+     * TODO: use {@link View#setTag(int, Object)} when we can do so and still create
+     * a jar
+     */
+    @Override
+    public void setImagePresenter(ImagePresenter imagePresenter) {
+        imageView.setTag(imagePresenter);
+    }
+
+    @Override
+    public ImagePresenter getImagePresenter() {
+        Object tag = imageView.getTag();
+        ImagePresenter result = null;
+        if (tag instanceof ImagePresenter) {
+            result = (ImagePresenter) tag;
+        }
+        return result;
+    }
+
+    @Override
+    public int hashCode() {
+        return imageView.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        } else if (!(o instanceof ImageViewTarget)) {
+            return false;
+        }
+        ImageViewTarget other = (ImageViewTarget) o;
+        return imageView.equals(other.imageView);
+    }
+
+    private static class SizeDeterminer {
+        private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
+        private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
+
+        private final View view;
+        private int[] dimens = new int[2];
+        private boolean valid = false;
+        private SizeReadyCallback cb = null;
+        private Handler handler = new Handler();
+        private final Runnable getDimens = new Runnable() {
+            @Override
+            public void run() {
+                if (cb == null) return;
+
+                LayoutParams layoutParams = view.getLayoutParams();
+                if (layoutParams.width > 0 && layoutParams.height > 0) {
+                    cb.onSizeReady(layoutParams.width, layoutParams.height);
+                } else if (view.getWidth() > 0 && view.getHeight() > 0) {
+                    valid = true;
+                    dimens[0] = view.getWidth();
+                    dimens[1] = view.getHeight();
+                    cb.onSizeReady(dimens[0], dimens[1]);
+                }
+                cb = null;
+            }
+        };
+
+        public SizeDeterminer(View view) {
+            this.view = view;
+        }
+
+        public void getSize(SizeReadyCallback cb) {
+            handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
+            this.cb = null;
+            LayoutParams layoutParams = view.getLayoutParams();
+            //non null layout params and either width and height have been set, or set to wrap content so they
+            //will not be set until we set some content
+            if (isHandled(layoutParams)) {
+                cb.onSizeReady(layoutParams.width, layoutParams.height);
+            } else if (valid) {
+                cb.onSizeReady(dimens[0], dimens[1]);
+            } else {
+                this.cb = cb;
+                handler.postDelayed(getDimens, PENDING_SIZE_CHANGE_DELAY);
+            }
+        }
+
+        private boolean isHandled(LayoutParams layoutParams) {
+            return layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0) ||
+                    (layoutParams.width == LayoutParams.WRAP_CONTENT || layoutParams.height == LayoutParams.WRAP_CONTENT));
+        }
+
+    }
+}
","1 package com.bumptech.glide.presenter.target;
2 
3 import android.graphics.Bitmap;
4 import android.graphics.drawable.Drawable;
5 import android.os.Handler;
6 import android.view.View;
7 import android.view.animation.Animation;
8 import android.widget.ImageView;
9 import com.bumptech.glide.presenter.ImagePresenter;
10 
11 import static android.view.ViewGroup.LayoutParams;
12 
13 /**
14  * A target wrapping an ImageView that makes use of {@link ImageView#setTag(Object)} to store and retrieve
15  * ImagePresenters. Also obtains the runtime dimensions of the ImageView.
16  */
17 public class ImageViewTarget implements Target {
18     private final ImageView imageView;
19     private final SizeDeterminer sizeDeterminer;
20 
21     public ImageViewTarget(ImageView imageView) {
22         this.imageView = imageView;
23         this.sizeDeterminer = new SizeDeterminer(imageView);
24     }
25 
26     @Override
27     public void onImageReady(Bitmap bitmap) {
28         imageView.setImageBitmap(bitmap);
29     }
30 
31     @Override
32     public void setPlaceholder(Drawable placeholder) {
33         imageView.setImageDrawable(placeholder);
34     }
35 
36     @Override
37     public void getSize(SizeReadyCallback cb) {
38         sizeDeterminer.getSize(cb);
39     }
40 
41     @Override
42     public void startAnimation(Animation animation) {
43         imageView.clearAnimation();
44 
45         imageView.startAnimation(animation);
46     }
47 
48     /**
49      * TODO: use {@link View#setTag(int, Object)} when we can do so and still create
50      * a jar
51      */
52     @Override
53     public void setImagePresenter(ImagePresenter imagePresenter) {
54         imageView.setTag(imagePresenter);
55     }
56 
57     @Override
58     public ImagePresenter getImagePresenter() {
59         Object tag = imageView.getTag();
60         ImagePresenter result = null;
61         if (tag instanceof ImagePresenter) {
62             result = (ImagePresenter) tag;
63         }
64         return result;
65     }
66 
67     @Override
68     public int hashCode() {
69         return imageView.hashCode();
70     }
71 
72     @Override
73     public boolean equals(Object o) {
74         if (o == null) {
75             return false;
76         } else if (!(o instanceof ImageViewTarget)) {
77             return false;
78         }
79         ImageViewTarget other = (ImageViewTarget) o;
80         return imageView.equals(other.imageView);
81     }
82 
83     private static class SizeDeterminer {
84         private static final String PENDING_SIZE_CHANGE_TOKEN = ""pending_load"";
85         private static final int PENDING_SIZE_CHANGE_DELAY = 100; //60 fps = 1000/60 = 16.67 ms
86 
87         private final View view;
88         private int[] dimens = new int[2];
89         private boolean valid = false;
90         private SizeReadyCallback cb = null;
91         private Handler handler = new Handler();
92         private final Runnable getDimens = new Runnable() {
93             @Override
94             public void run() {
95                 if (cb == null) return;
96 
97                 LayoutParams layoutParams = view.getLayoutParams();
98                 if (layoutParams.width > 0 && layoutParams.height > 0) {
99                     cb.onSizeReady(layoutParams.width, layoutParams.height);
100                 } else if (view.getWidth() > 0 && view.getHeight() > 0) {
101                     valid = true;
102                     dimens[0] = view.getWidth();
103                     dimens[1] = view.getHeight();
104                     cb.onSizeReady(dimens[0], dimens[1]);
105                 }
106                 cb = null;
107             }
108         };
109 
110         public SizeDeterminer(View view) {
111             this.view = view;
112         }
113 
114         public void getSize(SizeReadyCallback cb) {
115             handler.removeCallbacksAndMessages(PENDING_SIZE_CHANGE_TOKEN);
116             this.cb = null;
117             LayoutParams layoutParams = view.getLayoutParams();
118             //non null layout params and either width and height have been set, or set to wrap content so they
119             //will not be set until we set some content
120             if (isHandled(layoutParams)) {
121                 cb.onSizeReady(layoutParams.width, layoutParams.height);
122             } else if (valid) {
123                 cb.onSizeReady(dimens[0], dimens[1]);
124             } else {
125                 this.cb = cb;
126                 handler.postDelayed(getDimens, PENDING_SIZE_CHANGE_DELAY);
127             }
128         }
129 
130         private boolean isHandled(LayoutParams layoutParams) {
131             return layoutParams != null && ((layoutParams.width > 0 && layoutParams.height > 0) ||
132                     (layoutParams.width == LayoutParams.WRAP_CONTENT || layoutParams.height == LayoutParams.WRAP_CONTENT));
133         }
134 
135     }
136 }",No
,library\src\com\bumptech\glide\presenter\target\SimpleTarget.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -0,0 +1,47 @@
+package com.bumptech.glide.presenter.target;
+
+import android.graphics.drawable.Drawable;
+import android.view.animation.Animation;
+import com.bumptech.glide.presenter.ImagePresenter;
+
+/**
+ * A simpler interface for targets with default (usually noop) implementations of non essential methods.
+ */
+public abstract class SimpleTarget implements Target {
+    private ImagePresenter imagePresenter;
+
+    @Override
+    public void setPlaceholder(Drawable placeholder) { }
+
+    @Override
+    public void startAnimation(Animation animation) { }
+
+    @Override
+    public void setImagePresenter(ImagePresenter imagePresenter) {
+        this.imagePresenter = imagePresenter;
+    }
+
+    @Override
+    public ImagePresenter getImagePresenter() {
+        return imagePresenter;
+    }
+
+    /**
+     * A default implementation that calls {@link SizeReadyCallback#onSizeReady(int, int)} synchronously with
+     * {@link #getSize(com.bumptech.glide.presenter.target.Target.SizeReadyCallback)}.
+     *
+     * @param cb The callback that must be called when the size of the target has been determined
+     */
+    @Override
+    public void getSize(SizeReadyCallback cb) {
+        final int[] size = getSize();
+        cb.onSizeReady(size[0], size[1]);
+    }
+
+    /**
+     * Synchronously return the dimensions of this target as [width, height]
+     *
+     * @return The dimensions of this target
+     */
+    protected abstract int[] getSize();
+}
","1 package com.bumptech.glide.presenter.target;
2 
3 import android.graphics.drawable.Drawable;
4 import android.view.animation.Animation;
5 import com.bumptech.glide.presenter.ImagePresenter;
6 
7 /**
8  * A simpler interface for targets with default (usually noop) implementations of non essential methods.
9  */
10 public abstract class SimpleTarget implements Target {
11     private ImagePresenter imagePresenter;
12 
13     @Override
14     public void setPlaceholder(Drawable placeholder) { }
15 
16     @Override
17     public void startAnimation(Animation animation) { }
18 
19     @Override
20     public void setImagePresenter(ImagePresenter imagePresenter) {
21         this.imagePresenter = imagePresenter;
22     }
23 
24     @Override
25     public ImagePresenter getImagePresenter() {
26         return imagePresenter;
27     }
28 
29     /**
30      * A default implementation that calls {@link SizeReadyCallback#onSizeReady(int, int)} synchronously with
31      * {@link #getSize(com.bumptech.glide.presenter.target.Target.SizeReadyCallback)}.
32      *
33      * @param cb The callback that must be called when the size of the target has been determined
34      */
35     @Override
36     public void getSize(SizeReadyCallback cb) {
37         final int[] size = getSize();
38         cb.onSizeReady(size[0], size[1]);
39     }
40 
41     /**
42      * Synchronously return the dimensions of this target as [width, height]
43      *
44      * @return The dimensions of this target
45      */
46     protected abstract int[] getSize();
47 }",No
,library\src\com\bumptech\glide\presenter\target\Target.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -0,0 +1,64 @@
+package com.bumptech.glide.presenter.target;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.view.animation.Animation;
+import com.bumptech.glide.presenter.ImagePresenter;
+
+/**
+ * An interface that Glide can load an image into
+ */
+public interface Target {
+
+    /**
+     * A callback that must be called when the target has determined its size. For fixed size targets it can
+     * be called synchronously.
+     */
+    public interface SizeReadyCallback {
+        public void onSizeReady(int width, int height);
+    }
+
+    /**
+     * The method that will be called when the image load has finished
+     * @param bitmap The loaded image
+     */
+    public void onImageReady(Bitmap bitmap);
+
+    /**
+     * A method that can optionally be implemented to set any placeholder that might have been passed to Glide to
+     * display either while an image is loading or after the load has failed.
+     *
+     * @param placeholder The drawable to display
+     */
+    public void setPlaceholder(Drawable placeholder);
+
+    /**
+     * A method to retrieve the size of this target
+     * @param cb The callback that must be called when the size of the target has been determined
+     */
+    public void getSize(SizeReadyCallback cb);
+
+    /**
+     * A method that can be optionally implemented to start any animation that might have been passed to Glide for this
+     * target.
+     *
+     * @param animation The animation to display
+     */
+    public void startAnimation(Animation animation);
+
+    /**
+     * A method that is used to keep a reference to the ImagePresenter. Increases the efficiency of loads if it is
+     * possible that this target object will be used more than once.
+     *
+     * @param imagePresenter The ImagePresenter to store
+     */
+    public void setImagePresenter(ImagePresenter imagePresenter);
+
+    /**
+     * A method for retrieving any current ImagePresenter. Increases the efficiency of loads if it is possible that this
+     * target object will be used more than once.
+     *
+     * @return The current ImagePresenter or null
+     */
+    public ImagePresenter getImagePresenter();
+}
","1 package com.bumptech.glide.presenter.target;
2 
3 import android.graphics.Bitmap;
4 import android.graphics.drawable.Drawable;
5 import android.view.animation.Animation;
6 import com.bumptech.glide.presenter.ImagePresenter;
7 
8 /**
9  * An interface that Glide can load an image into
10  */
11 public interface Target {
12 
13     /**
14      * A callback that must be called when the target has determined its size. For fixed size targets it can
15      * be called synchronously.
16      */
17     public interface SizeReadyCallback {
18         public void onSizeReady(int width, int height);
19     }
20 
21     /**
22      * The method that will be called when the image load has finished
23      * @param bitmap The loaded image
24      */
25     public void onImageReady(Bitmap bitmap);
26 
27     /**
28      * A method that can optionally be implemented to set any placeholder that might have been passed to Glide to
29      * display either while an image is loading or after the load has failed.
30      *
31      * @param placeholder The drawable to display
32      */
33     public void setPlaceholder(Drawable placeholder);
34 
35     /**
36      * A method to retrieve the size of this target
37      * @param cb The callback that must be called when the size of the target has been determined
38      */
39     public void getSize(SizeReadyCallback cb);
40 
41     /**
42      * A method that can be optionally implemented to start any animation that might have been passed to Glide for this
43      * target.
44      *
45      * @param animation The animation to display
46      */
47     public void startAnimation(Animation animation);
48 
49     /**
50      * A method that is used to keep a reference to the ImagePresenter. Increases the efficiency of loads if it is
51      * possible that this target object will be used more than once.
52      *
53      * @param imagePresenter The ImagePresenter to store
54      */
55     public void setImagePresenter(ImagePresenter imagePresenter);
56 
57     /**
58      * A method for retrieving any current ImagePresenter. Increases the efficiency of loads if it is possible that this
59      * target object will be used more than once.
60      *
61      * @return The current ImagePresenter or null
62      */
63     public ImagePresenter getImagePresenter();
64 }",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,c572847b4cf003bcd5070b5d0499342ac6827450,"Allow glide to load images into arbitrary targets

Removes global layout listener for views because
of performance issues.","@@ -15,7 +15,8 @@ import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
-import com.bumptech.glide.resize.loader.Approximate;
+import com.bumptech.glide.presenter.target.Target;
+import com.bumptech.glide.resize.loader.ImageManagerLoader;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -114,22 +115,21 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
                         .setModelLoader(new FlickrModelLoader(context))
-                        .setImageLoader(new Approximate<Photo>(context))
+                        .setImageLoader(new ImageManagerLoader(context))
                         .setTransformationLoader(new CenterCrop<Photo>())
                         .setImageReadyCallback(new ImageReadyCallback() {
                             @Override
-                            public void onImageReady(ImageView view, boolean fromCache) {
-                                view.clearAnimation();
-
+                            public void onImageReady(Target target, boolean fromCache) {
                                 if (!fromCache) {
-                                    view.startAnimation(fadeIn);
+                                    target.startAnimation(fadeIn);
                                 }
                             }
                         })
                         .build();
                 view = imageView;
+                view.setTag(imagePresenter);
             } else {
-                imagePresenter = ImagePresenter.getCurrent(view);
+                imagePresenter = (ImagePresenter<Photo>) view.getTag();
             }
 
             imagePresenter.setModel(current);
","18 import com.bumptech.glide.presenter.target.Target;
19 import com.bumptech.glide.resize.loader.ImageManagerLoader;
118                         .setImageLoader(new ImageManagerLoader(context))
122                             public void onImageReady(Target target, boolean fromCache) {
124                                     target.startAnimation(fadeIn);
130                 view.setTag(imagePresenter);
132                 imagePresenter = (ImagePresenter<Photo>) view.getTag();
18 import com.bumptech.glide.resize.loader.Approximate;
117                         .setImageLoader(new Approximate<Photo>(context))
121                             public void onImageReady(ImageView view, boolean fromCache) {
122                                 view.clearAnimation();
123 
125                                     view.startAnimation(fadeIn);
132                 imagePresenter = ImagePresenter.getCurrent(view);",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,8c85210b51c162129bab92531c090bf2b77b3355,33943be3ddf092ffb670ac0b51c884f9f39ee0b0,Add default downsampler and transformations,"@@ -360,8 +360,8 @@ public class Glide {
         private int animationId = -1;
         private int placeholderId = -1;
         private int errorId = -1;
-        private Transformation transformation = null;
-        private Downsampler downsampler = null;
+        private Transformation transformation = Transformation.NONE;
+        private Downsampler downsampler = Downsampler.AT_LEAST;
         private TransformationLoader<T> transformationLoader = null;
 
         private Request(T model) {
","363         private Transformation transformation = Transformation.NONE;
364         private Downsampler downsampler = Downsampler.AT_LEAST;
363         private Transformation transformation = null;
364         private Downsampler downsampler = null;",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,a967562c5c0d2f31bb79e344240f2e0e0ee37721,8c85210b51c162129bab92531c090bf2b77b3355,Don't post to bg thread for bitmap ref counting,"@@ -18,7 +18,7 @@ import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
-import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
+import com.bumptech.glide.resize.bitmap_recycle.SerialBitmapReferenceCounter;
 import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
@@ -315,7 +315,7 @@ public class ImageManager {
                 if (bitmapPool == null) {
                     bitmapPool = new LruBitmapPool(getSafeMemoryCacheSize(context));
                 }
-                bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool);
+                bitmapReferenceCounter = new SerialBitmapReferenceCounter(bitmapPool);
             }
         }
     }
@@ -360,13 +360,8 @@ public class ImageManager {
      * @param b The rejected Bitmap
      */
     public void rejectBitmap(final Bitmap b) {
-        bgHandler.post(new Runnable() {
-            @Override
-            public void run() {
         bitmapReferenceCounter.rejectBitmap(b);
     }
-        });
-    }
 
     /**
      * Notify the ImageManager that a Bitmap it loaded is going to be used and increment the reference counter for that
@@ -377,13 +372,8 @@ public class ImageManager {
      * @param b The acquired Bitmap
      */
     public void acquireBitmap(final Bitmap b) {
-        bgHandler.post(new Runnable() {
-            @Override
-            public void run() {
         bitmapReferenceCounter.acquireBitmap(b);
     }
-        });
-    }
 
     /**
      * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
@@ -394,13 +384,8 @@ public class ImageManager {
      * @param b The releasedBitmap
      */
     public void releaseBitmap(final Bitmap b) {
-        bgHandler.post(new Runnable() {
-            @Override
-            public void run() {
         bitmapReferenceCounter.releaseBitmap(b);
     }
-        });
-    }
 
     /**
      * Cancel the task represented by the given token. If token is null this call will be ignored.
@@ -525,12 +510,11 @@ public class ImageManager {
                     putInDiskCache(key, result);
                 }
 
-                bitmapReferenceCounter.initBitmap(result);
-                putInMemoryCache(key, result);
-
                 mainHandler.post(new Runnable() {
                     @Override
                     public void run() {
+                        bitmapReferenceCounter.initBitmap(result);
+                        putInMemoryCache(key, result);
                         cb.onLoadCompleted(result);
                     }
                 });
@@ -572,12 +556,10 @@ public class ImageManager {
 
     private void putInMemoryCache(String key, final Bitmap bitmap) {
         final boolean inCache;
-        synchronized (memoryCache) {
         inCache = memoryCache.contains(key);
         if (!inCache) {
             memoryCache.put(key, bitmap);
         }
-        }
 
         bitmapReferenceCounter.acquireBitmap(bitmap);
         bitmapReferenceCounter.markPending(bitmap);
","21 import com.bumptech.glide.resize.bitmap_recycle.SerialBitmapReferenceCounter;
318                 bitmapReferenceCounter = new SerialBitmapReferenceCounter(bitmapPool);
516                         bitmapReferenceCounter.initBitmap(result);
517                         putInMemoryCache(key, result);
21 import com.bumptech.glide.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;
318                 bitmapReferenceCounter = new ConcurrentBitmapReferenceCounter(bitmapPool);
363         bgHandler.post(new Runnable() {
364             @Override
365             public void run() {
368         });
369     }
380         bgHandler.post(new Runnable() {
381             @Override
382             public void run() {
385         });
386     }
397         bgHandler.post(new Runnable() {
398             @Override
399             public void run() {
402         });
403     }
528                 bitmapReferenceCounter.initBitmap(result);
529                 putInMemoryCache(key, result);
530 
575         synchronized (memoryCache) {
580         }",No
library\src\com\bumptech\glide\resize\bitmap_recycle\ConcurrentBitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\SerialBitmapReferenceCounter.java,a967562c5c0d2f31bb79e344240f2e0e0ee37721,8c85210b51c162129bab92531c090bf2b77b3355,Don't post to bg thread for bitmap ref counting,"@@ -2,13 +2,14 @@ package com.bumptech.glide.resize.bitmap_recycle;
 
 import android.graphics.Bitmap;
 
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
 
-public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter {
+public class SerialBitmapReferenceCounter implements BitmapReferenceCounter {
 
     private static class InnerTrackerPool {
-        private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
+        private LinkedList<InnerTracker> pool = new LinkedList<InnerTracker>();
 
         public InnerTracker get() {
             InnerTracker result = pool.poll();
@@ -25,20 +26,16 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
     }
 
     private static class InnerTracker {
-        private volatile int refs = 0;
-        private volatile boolean pending = false;
+        private int refs = 0;
+        private boolean pending = false;
 
         public void acquire() {
             pending = false;
-            synchronized (this) {
             refs++;
         }
-        }
 
         public boolean release() {
-            synchronized (this) {
             refs--;
-            }
 
             return refs == 0 && !pending;
         }
@@ -53,32 +50,30 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
         }
     }
 
-    private final ConcurrentHashMap<Integer, InnerTracker> counter;
+    private final Map<Bitmap, InnerTracker> counter = new HashMap<Bitmap, InnerTracker>();
     private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
-    public ConcurrentBitmapReferenceCounter(BitmapPool target) {
+    public SerialBitmapReferenceCounter(BitmapPool target) {
         this.target = target;
-        counter = new ConcurrentHashMap<Integer, InnerTracker>();
     }
 
     @Override
     public void initBitmap(Bitmap toInit) {
-        final InnerTracker ifAbsent = pool.get();
-        final InnerTracker old = counter.putIfAbsent(toInit.hashCode(), ifAbsent);
-        if (old != null) {
-            pool.release(ifAbsent);
+        final InnerTracker tracker = counter.get(toInit);
+        if (tracker == null) {
+            counter.put(toInit, pool.get());
         }
     }
 
     @Override
     public void acquireBitmap(Bitmap bitmap) {
-        get(bitmap).acquire();
+        counter.get(bitmap).acquire();
     }
 
     @Override
     public void releaseBitmap(Bitmap bitmap) {
-        final InnerTracker tracker = get(bitmap);
+        final InnerTracker tracker = counter.get(bitmap);
         if (tracker.release()) {
             recycle(tracker, bitmap);
         }
@@ -86,7 +81,7 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
 
     @Override
     public void rejectBitmap(Bitmap bitmap) {
-        final InnerTracker tracker = get(bitmap);
+        final InnerTracker tracker = counter.get(bitmap);
         if (tracker.reject()) {
             recycle(tracker, bitmap);
         }
@@ -94,17 +89,12 @@ public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter
 
     @Override
     public void markPending(Bitmap bitmap) {
-        get(bitmap).markPending();
-    }
-
-    private InnerTracker get(Bitmap bitmap) {
-        return counter.get(bitmap.hashCode());
+        counter.get(bitmap).markPending();
     }
 
     private void recycle(InnerTracker tracker, Bitmap bitmap) {
-        if (!target.put(bitmap)) {
-            counter.remove(bitmap.hashCode());
+        target.put(bitmap);
+        counter.remove(bitmap);
         pool.release(tracker);
     }
 }
-}
","5 import java.util.HashMap;
6 import java.util.LinkedList;
7 import java.util.Map;
9 public class SerialBitmapReferenceCounter implements BitmapReferenceCounter {
12         private LinkedList<InnerTracker> pool = new LinkedList<InnerTracker>();
29         private int refs = 0;
30         private boolean pending = false;
53     private final Map<Bitmap, InnerTracker> counter = new HashMap<Bitmap, InnerTracker>();
57     public SerialBitmapReferenceCounter(BitmapPool target) {
63         final InnerTracker tracker = counter.get(toInit);
64         if (tracker == null) {
65             counter.put(toInit, pool.get());
71         counter.get(bitmap).acquire();
76         final InnerTracker tracker = counter.get(bitmap);
84         final InnerTracker tracker = counter.get(bitmap);
92         counter.get(bitmap).markPending();
96         target.put(bitmap);
97         counter.remove(bitmap);
5 import java.util.concurrent.ConcurrentHashMap;
6 import java.util.concurrent.ConcurrentLinkedQueue;
8 public class ConcurrentBitmapReferenceCounter implements BitmapReferenceCounter {
11         private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();
28         private volatile int refs = 0;
29         private volatile boolean pending = false;
33             synchronized (this) {
36         }
39             synchronized (this) {
41             }
56     private final ConcurrentHashMap<Integer, InnerTracker> counter;
60     public ConcurrentBitmapReferenceCounter(BitmapPool target) {
62         counter = new ConcurrentHashMap<Integer, InnerTracker>();
67         final InnerTracker ifAbsent = pool.get();
68         final InnerTracker old = counter.putIfAbsent(toInit.hashCode(), ifAbsent);
69         if (old != null) {
70             pool.release(ifAbsent);
76         get(bitmap).acquire();
81         final InnerTracker tracker = get(bitmap);
89         final InnerTracker tracker = get(bitmap);
97         get(bitmap).markPending();
98     }
99 
100     private InnerTracker get(Bitmap bitmap) {
101         return counter.get(bitmap.hashCode());
105         if (!target.put(bitmap)) {
106             counter.remove(bitmap.hashCode());
110 }",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,673466805f2e69b6d8567604732435058696daca,a967562c5c0d2f31bb79e344240f2e0e0ee37721,Fix exception when disk cache dir is null,"@@ -299,15 +299,19 @@ public class ImageManager {
             }
 
             if (diskCache == null) {
+                File cacheDir = getPhotoCacheDir(context);
+                if (cacheDir != null) {
                     try {
-                    diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
+                        diskCache = DiskLruCacheWrapper.get(cacheDir, DEFAULT_DISK_CACHE_SIZE);
                     } catch (IOException e) {
                         //this is probably a corrupt or full sd card, so default to not using a disk cache
                         e.printStackTrace();
-                    diskCache = new DiskCacheAdapter();
                     }
                 }
 
+                diskCache = new DiskCacheAdapter();
+            }
+
             if (!recycleBitmaps) {
                 bitmapPool = new BitmapPoolAdapter();
                 bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
","302                 File cacheDir = getPhotoCacheDir(context);
303                 if (cacheDir != null) {
305                         diskCache = DiskLruCacheWrapper.get(cacheDir, DEFAULT_DISK_CACHE_SIZE);
312                 diskCache = new DiskCacheAdapter();
313             }
314 
303                     diskCache = DiskLruCacheWrapper.get(getPhotoCacheDir(context), DEFAULT_DISK_CACHE_SIZE);
307                     diskCache = new DiskCacheAdapter();",No
library\src\com\bumptech\glide\resize\bitmap_recycle\LruBitmapPool.java,library\src\com\bumptech\glide\resize\bitmap_recycle\LruBitmapPool.java,20941f417deaebeb0eef02727d4c7c7945f423f2,673466805f2e69b6d8567604732435058696daca,"Dramatically reduce cpu usage of lru bitmap pool

No longer need to iterate over linked list to
find individual entries","@@ -5,14 +5,10 @@ import android.util.SparseArray;
 import com.bumptech.glide.util.Log;
 
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 
 public class LruBitmapPool implements BitmapPool {
-    private final SparseArray<ArrayList<Bitmap>> pool = new SparseArray<ArrayList<Bitmap>>();
-    //Typically there should only be a handful of keys (often 1 or 2) so
-    //iterating over this list should be fast
-    private final LinkedList<Integer> keys = new LinkedList<Integer>();
+    private final GroupedBitmapLinkedMap pool = new GroupedBitmapLinkedMap();
 
     private final int maxSize;
     private int currentSize = 0;
@@ -26,70 +22,153 @@ public class LruBitmapPool implements BitmapPool {
         final int key = getKey(bitmap);
         final int size = getSize(bitmap);
 
-        ArrayList<Bitmap> bitmaps = pool.get(key);
-        if (bitmaps == null) {
-            bitmaps = new ArrayList<Bitmap>();
-            pool.put(key, bitmaps);
-        } else {
-            removeKey(key);
-        }
-        keys.addFirst(key);
+        pool.put(key, bitmap);
         currentSize += size;
-
-        bitmaps.add(bitmap);
-
-        maybeEvict();
+        evict();
 
         return true;
     }
 
-    private void maybeEvict() {
+    private void evict() {
         while (currentSize > maxSize) {
-            final Integer key = keys.getLast();
-            List<Bitmap> toRemove = pool.get(key);
-            while (toRemove.size() > 0 && currentSize > maxSize) {
-                Bitmap removed = toRemove.remove(toRemove.size()-1);
-                currentSize -= getSize(removed);
-            }
-            if (toRemove.size() == 0) {
-                removeKey(key);
-            }
+            currentSize -= getSize(pool.removeLast());
         }
     }
 
     @Override
     public synchronized Bitmap get(int width, int height) {
-        final int key = getKey(width, height);
-        final ArrayList<Bitmap> list = pool.get(key);
-        final Bitmap result;
-        if (list != null && list.size() > 0) {
-            result = list.remove(list.size()-1); //most efficient to remove from the end of an ArrayList
+        final int sizeKey = getKey(width, height);
+        final Bitmap result = pool.get(sizeKey);
+        if (result == null) {
+            Log.d(""LBP: missing bitmap for width="" + width + "" height="" + height);
+        } else {
             currentSize -= getSize(result);
-            removeKey(key);
-            if (list.size() > 0) {
-                keys.addFirst(key);
         }
+
+        return result;
+    }
+
+    private static int getKey(Bitmap bitmap) {
+        return getKey(bitmap.getWidth(), bitmap.getHeight());
+    }
+
+    private static int getKey(int width, int height) {
+        return width >= height ? width * width + width + height : width + height * height;
+   }
+
+    private static int getSize(Bitmap bitmap) {
+        return bitmap.getHeight() * bitmap.getWidth();
+    }
+
+    /**
+     * Similar to {@link java.util.LinkedHashMap} when access ordered except that it is access ordered on groups
+     * of bitmaps rather than individual objects. The idea is to be able to find the LRU bitmap size, rather than the
+     * LRU bitmap object. We can then remove bitmaps from the least recently used size of bitmap when we need to
+     * reduce our cache size.
+     *
+     * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if no bitmaps
+     * of that size are present. We do not count addition or removal of bitmaps as an access.
+     */
+    private static class GroupedBitmapLinkedMap {
+        private final SparseArray<LinkedEntry> keyToEntry = new SparseArray<LinkedEntry>();
+        private final LinkedEntry head = new LinkedEntry();
+
+        public void put(int key, Bitmap bitmap) {
+            LinkedEntry entry = keyToEntry.get(key);
+            if (entry == null) {
+                entry = new LinkedEntry(key);
+                makeTail(entry);
+                keyToEntry.put(key, entry);
+            }
+            entry.add(bitmap);
+        }
+
+        public Bitmap get(int key) {
+            LinkedEntry entry = keyToEntry.get(key);
+            if (entry == null) {
+                entry = new LinkedEntry(key);
+                keyToEntry.put(key, entry);
+            }
+            makeHead(entry);
+
+            return entry.removeLast();
+        }
+
+        public Bitmap removeLast() {
+            LinkedEntry last = head.prev;
+
+            while (last != head) {
+                Bitmap removed = last.removeLast();
+                if (removed != null) {
+                    return removed;
                 } else {
-            Log.d(""LBP: missing bitmap for width="" + width + "" height="" + height);
-            result = null;
+                    //we will clean up empty lru entries since they are likely to have been one off or unusual sizes
+                    //and are not likely to be requested again so the gc thrash should be minimal. Doing so will speed
+                    //up our removeLast operation in the future and prevent our linked list from growing to arbitrarily
+                    //large sizes
+                    removeEntry(last);
+                    keyToEntry.remove(last.key);
                 }
-        return result;
+
+                last = last.prev;
             }
 
-    //keys.remove(int) -> remove index int, not object int :(
-    private void removeKey(Integer key) {
-        keys.remove(key);
+            return null;
         }
 
-    private int getKey(Bitmap bitmap) {
-        return getKey(bitmap.getWidth(), bitmap.getHeight());
+        private void makeHead(LinkedEntry entry) {
+            removeEntry(entry);
+            entry.prev = head;
+            entry.next = head.next;
+            updateEntry(entry);
         }
 
-    private int getKey(int width, int height) {
-        return width >= height ? width * width + width + height : width + height * height;
+        private void makeTail(LinkedEntry entry) {
+            removeEntry(entry);
+            entry.prev = head.prev;
+            entry.next = head;
+            updateEntry(entry);
         }
 
-    private int getSize(Bitmap bitmap) {
-        return bitmap.getHeight() * bitmap.getRowBytes();
+        //after updating entry's next and prev, set
+        //those entry's prev and next (respectively) to rentry
+        private static void updateEntry(LinkedEntry entry) {
+            entry.next.prev = entry;
+            entry.prev.next = entry;
+        }
+
+        private static void removeEntry(LinkedEntry entry) {
+            entry.prev.next = entry.next;
+            entry.next.prev = entry.prev;
+        }
+
+        private static class LinkedEntry {
+            private List<Bitmap> value;
+            private final int key;
+            LinkedEntry next;
+            LinkedEntry prev;
+
+            //head only
+            public LinkedEntry() {
+                this(-1);
+            }
+
+            public LinkedEntry(int key) {
+                next = prev = this;
+                this.key = key;
+            }
+
+            public Bitmap removeLast() {
+                final int valueSize = value != null ? value.size() : 0;
+                return valueSize > 0 ? value.remove(valueSize-1) : null;
+            }
+
+            public void add(Bitmap bitmap) {
+                if (value == null) {
+                    value = new ArrayList<Bitmap>();
+                }
+                value.add(bitmap);
+            }
+        }
     }
 }
","11     private final GroupedBitmapLinkedMap pool = new GroupedBitmapLinkedMap();
25         pool.put(key, bitmap);
27         evict();
32     private void evict() {
34             currentSize -= getSize(pool.removeLast());
40         final int sizeKey = getKey(width, height);
41         final Bitmap result = pool.get(sizeKey);
42         if (result == null) {
44         } else {
45             currentSize -= getSize(result);
47 
51     private static int getKey(Bitmap bitmap) {
55     private static int getKey(int width, int height) {
59     private static int getSize(Bitmap bitmap) {
60         return bitmap.getHeight() * bitmap.getWidth();
61     }
62 
63     /**
64      * Similar to {@link java.util.LinkedHashMap} when access ordered except that it is access ordered on groups
65      * of bitmaps rather than individual objects. The idea is to be able to find the LRU bitmap size, rather than the
66      * LRU bitmap object. We can then remove bitmaps from the least recently used size of bitmap when we need to
67      * reduce our cache size.
68      *
69      * For the purposes of the LRU, we count gets for a particular size of bitmap as an access, even if no bitmaps
70      * of that size are present. We do not count addition or removal of bitmaps as an access.
71      */
72     private static class GroupedBitmapLinkedMap {
73         private final SparseArray<LinkedEntry> keyToEntry = new SparseArray<LinkedEntry>();
74         private final LinkedEntry head = new LinkedEntry();
75 
76         public void put(int key, Bitmap bitmap) {
77             LinkedEntry entry = keyToEntry.get(key);
78             if (entry == null) {
79                 entry = new LinkedEntry(key);
80                 makeTail(entry);
81                 keyToEntry.put(key, entry);
82             }
83             entry.add(bitmap);
84         }
85 
86         public Bitmap get(int key) {
87             LinkedEntry entry = keyToEntry.get(key);
88             if (entry == null) {
89                 entry = new LinkedEntry(key);
90                 keyToEntry.put(key, entry);
91             }
92             makeHead(entry);
93 
94             return entry.removeLast();
95         }
96 
97         public Bitmap removeLast() {
98             LinkedEntry last = head.prev;
99 
100             while (last != head) {
101                 Bitmap removed = last.removeLast();
102                 if (removed != null) {
103                     return removed;
104                 } else {
105                     //we will clean up empty lru entries since they are likely to have been one off or unusual sizes
106                     //and are not likely to be requested again so the gc thrash should be minimal. Doing so will speed
107                     //up our removeLast operation in the future and prevent our linked list from growing to arbitrarily
108                     //large sizes
109                     removeEntry(last);
110                     keyToEntry.remove(last.key);
111                 }
112 
113                 last = last.prev;
114             }
115 
116             return null;
117         }
118 
119         private void makeHead(LinkedEntry entry) {
120             removeEntry(entry);
121             entry.prev = head;
122             entry.next = head.next;
123             updateEntry(entry);
124         }
125 
126         private void makeTail(LinkedEntry entry) {
127             removeEntry(entry);
128             entry.prev = head.prev;
129             entry.next = head;
130             updateEntry(entry);
131         }
132 
133         //after updating entry's next and prev, set
134         //those entry's prev and next (respectively) to rentry
135         private static void updateEntry(LinkedEntry entry) {
136             entry.next.prev = entry;
137             entry.prev.next = entry;
138         }
139 
140         private static void removeEntry(LinkedEntry entry) {
141             entry.prev.next = entry.next;
142             entry.next.prev = entry.prev;
143         }
144 
145         private static class LinkedEntry {
146             private List<Bitmap> value;
147             private final int key;
148             LinkedEntry next;
149             LinkedEntry prev;
150 
151             //head only
152             public LinkedEntry() {
153                 this(-1);
154             }
155 
156             public LinkedEntry(int key) {
157                 next = prev = this;
158                 this.key = key;
159             }
160 
161             public Bitmap removeLast() {
162                 final int valueSize = value != null ? value.size() : 0;
163                 return valueSize > 0 ? value.remove(valueSize-1) : null;
164             }
165 
166             public void add(Bitmap bitmap) {
167                 if (value == null) {
168                     value = new ArrayList<Bitmap>();
169                 }
170                 value.add(bitmap);
171             }
172         }
8 import java.util.LinkedList;
12     private final SparseArray<ArrayList<Bitmap>> pool = new SparseArray<ArrayList<Bitmap>>();
13     //Typically there should only be a handful of keys (often 1 or 2) so
14     //iterating over this list should be fast
15     private final LinkedList<Integer> keys = new LinkedList<Integer>();
29         ArrayList<Bitmap> bitmaps = pool.get(key);
30         if (bitmaps == null) {
31             bitmaps = new ArrayList<Bitmap>();
32             pool.put(key, bitmaps);
33         } else {
34             removeKey(key);
35         }
36         keys.addFirst(key);
38 
39         bitmaps.add(bitmap);
40 
41         maybeEvict();
46     private void maybeEvict() {
48             final Integer key = keys.getLast();
49             List<Bitmap> toRemove = pool.get(key);
50             while (toRemove.size() > 0 && currentSize > maxSize) {
51                 Bitmap removed = toRemove.remove(toRemove.size()-1);
52                 currentSize -= getSize(removed);
53             }
54             if (toRemove.size() == 0) {
55                 removeKey(key);
56             }
62         final int key = getKey(width, height);
63         final ArrayList<Bitmap> list = pool.get(key);
64         final Bitmap result;
65         if (list != null && list.size() > 0) {
66             result = list.remove(list.size()-1); //most efficient to remove from the end of an ArrayList
67             currentSize -= getSize(result);
68             removeKey(key);
69             if (list.size() > 0) {
70                 keys.addFirst(key);
71             }
72         } else {
74             result = null;
79     //keys.remove(int) -> remove index int, not object int :(
80     private void removeKey(Integer key) {
81         keys.remove(key);
82     }
83 
84     private int getKey(Bitmap bitmap) {
88     private int getKey(int width, int height) {
92     private int getSize(Bitmap bitmap) {
93         return bitmap.getHeight() * bitmap.getRowBytes();",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,50997b0bbbc9ff198b3ef2baaf9dc78e95c1f795,20941f417deaebeb0eef02727d4c7c7945f423f2,Always call handleException rather than cb,"@@ -493,7 +493,7 @@ public class ImageManager {
                                         final Bitmap result = resizeIfNotFound(is);
                                         finishResize(result, false);
                                     } catch (Exception e) {
-                                        cb.onLoadFailed(e);
+                                        handleException(e);
                                     }
                                 }
                             });
","496                                         handleException(e);
496                                         cb.onLoadFailed(e);",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,0d133b4ecd1827f539e7a35b1cc8b2ea065c7b17,50997b0bbbc9ff198b3ef2baaf9dc78e95c1f795,Reduce priority of image manager bg thread,"@@ -104,7 +104,6 @@ public class ImageManager {
     public static File getPhotoCacheDir(Context context, String cacheName) {
         File cacheDir = null;
 
-
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
                 !isExternalStorageRemovable()) {
             //seems like this can still be null even if the above are true
@@ -325,7 +324,7 @@ public class ImageManager {
     }
 
     private ImageManager(Builder builder) {
-        HandlerThread bgThread = new HandlerThread(""bg_thread"");
+        HandlerThread bgThread = new HandlerThread(""bg_thread"", android.os.Process.THREAD_PRIORITY_BACKGROUND);
         bgThread.start();
         bgHandler = new Handler(bgThread.getLooper());
         executor = builder.resizeService;
","327         HandlerThread bgThread = new HandlerThread(""bg_thread"", android.os.Process.THREAD_PRIORITY_BACKGROUND);
107 
328         HandlerThread bgThread = new HandlerThread(""bg_thread"");",No
library\libs\android-support-v4.jar,library\libs\android-support-v4.jar,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,0d133b4ecd1827f539e7a35b1cc8b2ea065c7b17,"Add our own version of an lru memory cache

Allows us to remove our dependency on the
android support libs.","Binary files a/library/libs/android-support-v4.jar and /dev/null differ
",,No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,0d133b4ecd1827f539e7a35b1cc8b2ea065c7b17,"Add our own version of an lru memory cache

Allows us to remove our dependency on the
android support libs.","@@ -23,7 +23,7 @@ import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
-import com.bumptech.glide.resize.cache.LruPhotoCache;
+import com.bumptech.glide.resize.cache.LruMemoryCache;
 import com.bumptech.glide.resize.cache.MemoryCache;
 import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
 import com.bumptech.glide.util.Log;
@@ -294,7 +294,7 @@ public class ImageManager {
             }
 
             if (memoryCache == null) {
-                memoryCache = new LruPhotoCache(getSafeMemoryCacheSize(context));
+                memoryCache = new LruMemoryCache(getSafeMemoryCacheSize(context));
             }
 
             if (diskCache == null) {
","26 import com.bumptech.glide.resize.cache.LruMemoryCache;
297                 memoryCache = new LruMemoryCache(getSafeMemoryCacheSize(context));
26 import com.bumptech.glide.resize.cache.LruPhotoCache;
297                 memoryCache = new LruPhotoCache(getSafeMemoryCacheSize(context));",No
,library\src\com\bumptech\glide\resize\cache\LruMemoryCache.java,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,0d133b4ecd1827f539e7a35b1cc8b2ea065c7b17,"Add our own version of an lru memory cache

Allows us to remove our dependency on the
android support libs.","@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
+ */
+
+package com.bumptech.glide.resize.cache;
+
+import android.graphics.Bitmap;
+
+import java.util.LinkedHashMap;
+
+/**
+ */
+public class LruMemoryCache implements MemoryCache {
+    private final LinkedHashMap<String, Bitmap> cache = new LinkedHashMap<String, Bitmap>(15, 0.75f, true);
+    private final int maxSize;
+    private ImageRemovedListener imageRemovedListener;
+    private int currentSize = 0;
+
+    private static int getSize(Bitmap bitmap) {
+        return bitmap.getHeight() * bitmap.getRowBytes();
+    }
+
+    public LruMemoryCache(int size) {
+        this.maxSize = size;
+    }
+
+    @Override
+    public boolean contains(String key) {
+        return cache.get(key) != null;
+    }
+
+    @Override
+    public Bitmap get(String key) {
+        return cache.get(key);
+    }
+
+    @Override
+    public Bitmap put(String key, Bitmap bitmap) {
+        currentSize += getSize(bitmap);
+        final Bitmap result = cache.put(key, bitmap);
+        evict();
+        return result;
+    }
+
+    @Override
+    public void setImageRemovedListener(ImageRemovedListener listener) {
+        this.imageRemovedListener = listener;
+    }
+
+    private void evict() {
+        LinkedHashMap.Entry<String, Bitmap> last;
+        while (currentSize > maxSize) {
+            last = cache.entrySet().iterator().next();
+            final Bitmap toRemove = last.getValue();
+            currentSize -= getSize(toRemove);
+            cache.remove(last.getKey());
+
+            if (imageRemovedListener != null) {
+                imageRemovedListener.onImageRemoved(toRemove);
+            }
+        }
+    }
+}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.cache;
6 
7 import android.graphics.Bitmap;
8 
9 import java.util.LinkedHashMap;
10 
11 /**
12  */
13 public class LruMemoryCache implements MemoryCache {
14     private final LinkedHashMap<String, Bitmap> cache = new LinkedHashMap<String, Bitmap>(15, 0.75f, true);
15     private final int maxSize;
16     private ImageRemovedListener imageRemovedListener;
17     private int currentSize = 0;
18 
19     private static int getSize(Bitmap bitmap) {
20         return bitmap.getHeight() * bitmap.getRowBytes();
21     }
22 
23     public LruMemoryCache(int size) {
24         this.maxSize = size;
25     }
26 
27     @Override
28     public boolean contains(String key) {
29         return cache.get(key) != null;
30     }
31 
32     @Override
33     public Bitmap get(String key) {
34         return cache.get(key);
35     }
36 
37     @Override
38     public Bitmap put(String key, Bitmap bitmap) {
39         currentSize += getSize(bitmap);
40         final Bitmap result = cache.put(key, bitmap);
41         evict();
42         return result;
43     }
44 
45     @Override
46     public void setImageRemovedListener(ImageRemovedListener listener) {
47         this.imageRemovedListener = listener;
48     }
49 
50     private void evict() {
51         LinkedHashMap.Entry<String, Bitmap> last;
52         while (currentSize > maxSize) {
53             last = cache.entrySet().iterator().next();
54             final Bitmap toRemove = last.getValue();
55             currentSize -= getSize(toRemove);
56             cache.remove(last.getKey());
57 
58             if (imageRemovedListener != null) {
59                 imageRemovedListener.onImageRemoved(toRemove);
60             }
61         }
62     }
63 }",No
library\src\com\bumptech\glide\resize\cache\LruPhotoCache.java,,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,0d133b4ecd1827f539e7a35b1cc8b2ea065c7b17,"Add our own version of an lru memory cache

Allows us to remove our dependency on the
android support libs.","@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.resize.cache;
-
-import android.graphics.Bitmap;
-import android.support.v4.util.LruCache;
-
-/**
- * A thin wrapper around the LruCache provided in the Android support libraries.
- *
- * @see android.support.v4.util.LruCache
- */
-public class LruPhotoCache implements MemoryCache {
-    private final LruCache<String, Bitmap> lruCache;
-    private ImageRemovedListener imageRemovedListener;
-
-    public LruPhotoCache(int maxSize) {
-        lruCache = new LruCache<String, Bitmap>(maxSize) {
-            @Override
-            protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
-                super.entryRemoved(evicted, key, oldValue, newValue);
-                if (imageRemovedListener != null) {
-                    imageRemovedListener.onImageRemoved(oldValue);
-                }
-            }
-
-            @Override
-            protected int sizeOf(String key, Bitmap value) {
-                //get the size, getByteCount() is API 12+...
-                return value.getHeight() * value.getRowBytes();
-            }
-        };
-    }
-
-    public boolean contains(String key) {
-        return lruCache.get(key) != null;
-    }
-
-    @Override
-    public Bitmap get(String key) {
-        return lruCache.get(key);
-    }
-
-    @Override
-    public Bitmap put(String key, Bitmap bitmap) {
-        return lruCache.put(key, bitmap);
-    }
-
-    @Override
-    public void setImageRemovedListener(ImageRemovedListener listener) {
-        this.imageRemovedListener = listener;
-    }
-}
","1 /*
2  * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
3  */
4 
5 package com.bumptech.glide.resize.cache;
6 
7 import android.graphics.Bitmap;
8 import android.support.v4.util.LruCache;
9 
10 /**
11  * A thin wrapper around the LruCache provided in the Android support libraries.
12  *
13  * @see android.support.v4.util.LruCache
14  */
15 public class LruPhotoCache implements MemoryCache {
16     private final LruCache<String, Bitmap> lruCache;
17     private ImageRemovedListener imageRemovedListener;
18 
19     public LruPhotoCache(int maxSize) {
20         lruCache = new LruCache<String, Bitmap>(maxSize) {
21             @Override
22             protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
23                 super.entryRemoved(evicted, key, oldValue, newValue);
24                 if (imageRemovedListener != null) {
25                     imageRemovedListener.onImageRemoved(oldValue);
26                 }
27             }
28 
29             @Override
30             protected int sizeOf(String key, Bitmap value) {
31                 //get the size, getByteCount() is API 12+...
32                 return value.getHeight() * value.getRowBytes();
33             }
34         };
35     }
36 
37     public boolean contains(String key) {
38         return lruCache.get(key) != null;
39     }
40 
41     @Override
42     public Bitmap get(String key) {
43         return lruCache.get(key);
44     }
45 
46     @Override
47     public Bitmap put(String key, Bitmap bitmap) {
48         return lruCache.put(key, bitmap);
49     }
50 
51     @Override
52     public void setImageRemovedListener(ImageRemovedListener listener) {
53         this.imageRemovedListener = listener;
54     }
55 }",No
Makefile,Makefile,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,"Add rules to build glide as a .jar

Makes glide not a library project by default,
although all that is really needed to use it
as a library project is to just add
android.library=true to project.properties again","@@ -1,8 +1,10 @@
-setup:
+jar:
 	git submodule init
 	git submodule update
 	cd library/volley && ant jar
 	cp library/volley/bin/volley.jar library/libs
+	cd library && ant jar
+
+glide-minus-volley:
+	cd library && ant glide-minus-volley
 
-update-ant: setup
-	android update project --path .. --library glide/library
","1 jar:
6 	cd library && ant jar
7 
8 glide-minus-volley:
9 	cd library && ant glide-minus-volley
1 setup:
7 update-ant: setup
8 	android update project --path .. --library glide/library",No
library\build.xml,library\build.xml,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,"Add rules to build glide as a .jar

Makes glide not a library project by default,
although all that is really needed to use it
as a library project is to just add
android.library=true to project.properties again","@@ -1,5 +1,5 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
-<project name=""photos"" default=""help"">
+<project name=""glide"" default=""help"">
 
   <!-- The local.properties file is created and updated by the 'android' tool.
        It contains the path to the SDK. It should *NOT* be checked into
","2 <project name=""glide"" default=""help"">
2 <project name=""photos"" default=""help"">",No
,library\custom_rules.xml,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,"Add rules to build glide as a .jar

Makes glide not a library project by default,
although all that is really needed to use it
as a library project is to just add
android.library=true to project.properties again","@@ -0,0 +1,15 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project name=""glide-rules"" default=""help"">
+    <target name=""jar"" depends=""-compile"">
+        <jar destfile=""bin/glide.jar""
+            basedir=""bin/classes"" >
+            <zipgroupfileset dir=""libs"" includes=""*.jar"" />
+        </jar>
+    </target>
+    <target name=""glide-minus-volley"" depends=""-compile"">
+        <jar destfile=""bin/glide-minus-volley.jar""
+            basedir=""bin/classes"" >
+            <zipgroupfileset dir=""libs"" includes=""disklrucache*.jar"" />
+        </jar>
+    </target>
+</project>
","1 <?xml version=""1.0"" encoding=""UTF-8""?>
2 <project name=""glide-rules"" default=""help"">
3     <target name=""jar"" depends=""-compile"">
4         <jar destfile=""bin/glide.jar""
5             basedir=""bin/classes"" >
6             <zipgroupfileset dir=""libs"" includes=""*.jar"" />
7         </jar>
8     </target>
9     <target name=""glide-minus-volley"" depends=""-compile"">
10         <jar destfile=""bin/glide-minus-volley.jar""
11             basedir=""bin/classes"" >
12             <zipgroupfileset dir=""libs"" includes=""disklrucache*.jar"" />
13         </jar>
14     </target>
15 </project>",Yes
library\project.properties,library\project.properties,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,76c7bc1d3db2e9f8b855ad7dc0d856358cb0a443,"Add rules to build glide as a .jar

Makes glide not a library project by default,
although all that is really needed to use it
as a library project is to just add
android.library=true to project.properties again","@@ -10,6 +10,8 @@
 # To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
-android.library=true
 # Project target.
 target=android-16
+
+# https://code.google.com/p/android/issues/detail?id=40487
+renderscript.opt.level=O0
","15 
16 # https://code.google.com/p/android/issues/detail?id=40487
17 renderscript.opt.level=O0
13 android.library=true",No
library\src\com\bumptech\glide\loader\model\UriLoader.java,library\src\com\bumptech\glide\loader\model\UriLoader.java,6cfecdb66e30d45f72516a13efb0d8243a68febc,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,update docs,"@@ -11,7 +11,7 @@ import java.net.URL;
 
 /**
  * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
- * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamLoader(android.net.Uri, int, int)}.
+ * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
  */
 public class UriLoader implements ModelLoader<Uri> {
     private final Context context;
","14  * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
14  * 'file' schemes. Unsupported schemes will throw an exception in {@link #buildStreamLoader(android.net.Uri, int, int)}.",No
library\src\com\bumptech\glide\loader\stream\StreamLoader.java,library\src\com\bumptech\glide\loader\stream\StreamLoader.java,6cfecdb66e30d45f72516a13efb0d8243a68febc,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,update docs,"@@ -3,7 +3,7 @@ package com.bumptech.glide.loader.stream;
 import java.io.InputStream;
 
 /**
- * An interface for lazily and asynchronously opening an input stream that can be used to load an image.
+ * A base class for lazily and asynchronously opening an input stream that can be used to load an image.
  * A new instance is created per image load by {@link com.bumptech.glide.loader.model.ModelLoader}. loadStream
  * may or may not be called for any given load depending on whether or not the corresponding image is cached. Cancel
  * also may or may not be called.
","6  * A base class for lazily and asynchronously opening an input stream that can be used to load an image.
6  * An interface for lazily and asynchronously opening an input stream that can be used to load an image.",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,6cfecdb66e30d45f72516a13efb0d8243a68febc,4e9cdbf5b540b9c16c6102e2db286d1aff19cedc,update docs,"@@ -20,9 +20,10 @@ import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.util.Log;
 
 /**
- * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
- * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
- * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load a bitmap from a given
+ * Wraps an {@link Target} to display arbitrary Bitmaps and provides a framework for fetching and
+ * loading bitmaps correctly when targest are being recycled. Uses {@link ModelLoader} to between a
+ * model {@link StreamLoader} for a given model, a {@link StreamLoader} to download or otherwise obtain an
+ * {@link java.io.InputStream} for a given model, and  an {@link ImageLoader} to load a bitmap from a given
  * {@link java.io.InputStream}. This class also determines the width and height of the wrapped
  * {@link android.widget.ImageView} at runtime and passes that information to the provided {@link ModelLoader} and
  * {@link ImageLoader}.
@@ -73,9 +74,8 @@ public class ImagePresenter<T> {
          * Builds an ImagePresenter.
          *
          * <p>
-         *     Note - If an ImagePresenter has already been set for this view, it will be silently replaced and will not
-         *     be cleared which could lead to undefined behavior. It is most efficient to set an ImagePresenter once and
-         *     then retrieve it for each subsequent load.
+         *     Note - this ImagePresenter will not be retained by default. Consider
+         *     {@link android.view.View#setTag(Object)}, or the view holder pattern.
          * </p>
          *
          * @return A new ImagePresenter
@@ -99,18 +99,27 @@ public class ImagePresenter<T> {
         }
 
         /**
-         * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
+         * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps.
+         * Alternatively you can instead set a more general target for an object other than an ImageView using
+         * {@link #setTarget(com.bumptech.glide.presenter.target.Target, android.content.Context)}.
          *
          * @param imageView The {@link android.widget.ImageView} to wrap
          * @return This Builder object
          */
         public Builder<T> setImageView(final ImageView imageView) {
-            this.target = new ImageViewTarget(imageView);
-            this.context = imageView.getContext();
+            setTarget(new ImageViewTarget(imageView), imageView.getContext());
 
             return this;
         }
 
+        /**
+         * Required - Sets the {@link Target} the presenter will use to display any loaded bitmaps. If you are loading
+         * bitmaps into an {@link ImageView}, you can instead use {@link #setImageView(android.widget.ImageView)}.
+         *
+         * @param target The {@link Target} to wrap
+         * @param context A context that can be held for the duration of the load
+         * @return This builder object
+         */
         public Builder<T> setTarget(Target target, Context context) {
             this.target = target;
             this.context = context;
@@ -223,7 +232,9 @@ public class ImagePresenter<T> {
 
         /**
          * Optional - Sets a coordinator that can allow or prevent placeholders or bitmaps from being set in otherwise
-         * valid loads. See {@link com.bumptech.glide.presenter.ThumbImagePresenter}.
+         * valid loads.
+         *
+         * @see com.bumptech.glide.presenter.ThumbImagePresenter
          *
          * @param coordinator The coordinator to set
          * @return This Builder object
@@ -235,7 +246,8 @@ public class ImagePresenter<T> {
 
         /**
          * Optional - Sets a handler that will be notified if any path or image load causes an exception.
-         * See {@link com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler}.
+         *
+         * @see com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler
          *
          * @param exceptionHandler The exception handler to set
          * @return This builder object
@@ -245,6 +257,15 @@ public class ImagePresenter<T> {
             return this;
         }
 
+        /**
+         * Optional - Sets a transformation loader to use to obtain a transformation to apply to images on a per
+         * model basis.
+         *
+         * @see Transformation
+         *
+         * @param transformationLoader A {@link TransformationLoader} for this model type
+         * @return This builder object
+         */
         public Builder<T> setTransformationLoader(TransformationLoader<T> transformationLoader) {
             this.transformationLoader = transformationLoader;
             return this;
@@ -341,8 +362,8 @@ public class ImagePresenter<T> {
      *
      * <p>
      *     Note - A load will not begin before the ImagePresenter has determined the width and height of the wrapped
-     * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until
-     * then the current load is stored. Subsequent calls will replace the stored load
+     * view, which can't happen until that view has been made visible and undergone layout for the first time. Until
+     * then the current load is stored. Subsequent calls will replace the stored load.
      * </p>
      *
      * @param model The model containing the information required to load a path and/or bitmap
","23  * Wraps an {@link Target} to display arbitrary Bitmaps and provides a framework for fetching and
24  * loading bitmaps correctly when targest are being recycled. Uses {@link ModelLoader} to between a
25  * model {@link StreamLoader} for a given model, a {@link StreamLoader} to download or otherwise obtain an
26  * {@link java.io.InputStream} for a given model, and  an {@link ImageLoader} to load a bitmap from a given
77          *     Note - this ImagePresenter will not be retained by default. Consider
78          *     {@link android.view.View#setTag(Object)}, or the view holder pattern.
102          * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps.
103          * Alternatively you can instead set a more general target for an object other than an ImageView using
104          * {@link #setTarget(com.bumptech.glide.presenter.target.Target, android.content.Context)}.
110             setTarget(new ImageViewTarget(imageView), imageView.getContext());
115         /**
116          * Required - Sets the {@link Target} the presenter will use to display any loaded bitmaps. If you are loading
117          * bitmaps into an {@link ImageView}, you can instead use {@link #setImageView(android.widget.ImageView)}.
118          *
119          * @param target The {@link Target} to wrap
120          * @param context A context that can be held for the duration of the load
121          * @return This builder object
122          */
235          * valid loads.
236          *
237          * @see com.bumptech.glide.presenter.ThumbImagePresenter
249          *
250          * @see com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler
260         /**
261          * Optional - Sets a transformation loader to use to obtain a transformation to apply to images on a per
262          * model basis.
263          *
264          * @see Transformation
265          *
266          * @param transformationLoader A {@link TransformationLoader} for this model type
267          * @return This builder object
268          */
365      * view, which can't happen until that view has been made visible and undergone layout for the first time. Until
366      * then the current load is stored. Subsequent calls will replace the stored load.
23  * Wraps an {@link android.widget.ImageView} to display arbitrary Bitmaps and provides a framework for fetching and
24  * loading bitmaps correctly when views are being recycled. Uses {@link ModelLoader} to download convert between a
25  * model and an {@link java.io.InputStream} for a given model and {@link ImageLoader} to load a bitmap from a given
76          *     Note - If an ImagePresenter has already been set for this view, it will be silently replaced and will not
77          *     be cleared which could lead to undefined behavior. It is most efficient to set an ImagePresenter once and
78          *     then retrieve it for each subsequent load.
102          * Required - Sets the {@link android.widget.ImageView} the presenter will use to display any loaded bitmaps
108             this.target = new ImageViewTarget(imageView);
109             this.context = imageView.getContext();
226          * valid loads. See {@link com.bumptech.glide.presenter.ThumbImagePresenter}.
238          * See {@link com.bumptech.glide.presenter.ImagePresenter.ExceptionHandler}.
344      * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until
345      * then the current load is stored. Subsequent calls will replace the stored load",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,02ddf36100d8b90b0ada2ef1dc67cb0ce6f73530,6cfecdb66e30d45f72516a13efb0d8243a68febc,Add a cancel method to glide,"@@ -231,6 +231,30 @@ public class Glide {
         return new Request<Integer>(resourceId);
     }
 
+    /**
+     * @see #cancel(com.bumptech.glide.presenter.target.Target)
+     */
+    public static boolean cancel(ImageView imageView) {
+        return cancel(new ImageViewTarget(imageView));
+    }
+
+    /**
+     * Cancel any pending loads Glide may have for the target. After the load is cancelled Glide will not load
+     * a placeholder or bitmap into the target so it is safe to do so yourself until you start another load.
+     *
+     * @param target The Target to cancel loads for
+     * @return True iff Glide had ever been asked to load an image for this view
+     */
+    public static boolean cancel(Target target) {
+        ImagePresenter current = target.getImagePresenter();
+        final boolean cancelled = current != null;
+        if (cancelled) {
+            current.clear();
+        }
+
+        return cancelled;
+    }
+
     private interface ModelLoaderFactory<T> {
         public ModelLoader<T> build(Context context);
         public Class<? extends ModelLoader<T>> loaderClass();
","234     /**
235      * @see #cancel(com.bumptech.glide.presenter.target.Target)
236      */
237     public static boolean cancel(ImageView imageView) {
238         return cancel(new ImageViewTarget(imageView));
239     }
240 
241     /**
242      * Cancel any pending loads Glide may have for the target. After the load is cancelled Glide will not load
243      * a placeholder or bitmap into the target so it is safe to do so yourself until you start another load.
244      *
245      * @param target The Target to cancel loads for
246      * @return True iff Glide had ever been asked to load an image for this view
247      */
248     public static boolean cancel(Target target) {
249         ImagePresenter current = target.getImagePresenter();
250         final boolean cancelled = current != null;
251         if (cancelled) {
252             current.clear();
253         }
254 
255         return cancelled;
256     }
257 ",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,75172f25fc3a44af74e164f18449e45db68ac485,02ddf36100d8b90b0ada2ef1dc67cb0ce6f73530,Throw if key glide request arguments are null,"@@ -389,12 +389,24 @@ public class Glide {
         private TransformationLoader<T> transformationLoader = null;
 
         private Request(T model) {
+            if (model == null ) {
+                throw new IllegalArgumentException(""Model can't be null"");
+            }
             this.model = model;
             this.modelLoaderFactory = getFactory(model);
+            if (modelLoaderFactory == null ) {
+                throw new IllegalArgumentException(""Missing ModelLoader factory for model = "" + model);
+            }
             this.modelLoaderClass = modelLoaderFactory.loaderClass();
         }
 
         private Request(T model, ModelLoader<T> modelLoader) {
+            if (model == null ) {
+                throw new IllegalArgumentException(""Model can't be null"");
+            }
+            if (modelLoader == null) {
+                throw new IllegalArgumentException(""ModelLoader can't be null"");
+            }
             this.model = model;
             this.modelLoader = modelLoader;
             this.modelLoaderClass = modelLoader.getClass();
","392             if (model == null ) {
393                 throw new IllegalArgumentException(""Model can't be null"");
394             }
397             if (modelLoaderFactory == null ) {
398                 throw new IllegalArgumentException(""Missing ModelLoader factory for model = "" + model);
399             }
404             if (model == null ) {
405                 throw new IllegalArgumentException(""Model can't be null"");
406             }
407             if (modelLoader == null) {
408                 throw new IllegalArgumentException(""ModelLoader can't be null"");
409             }",No
library\src\com\bumptech\glide\resize\bitmap_recycle\SerialBitmapReferenceCounter.java,library\src\com\bumptech\glide\resize\bitmap_recycle\SerialBitmapReferenceCounter.java,e9bb38b983ede3ce22220af5de3ba803c50248c8,75172f25fc3a44af74e164f18449e45db68ac485,Fix a memory leak when bitmaps not released,"@@ -5,6 +5,7 @@ import android.graphics.Bitmap;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
+import java.util.WeakHashMap;
 
 public class SerialBitmapReferenceCounter implements BitmapReferenceCounter {
 
@@ -50,7 +51,7 @@ public class SerialBitmapReferenceCounter implements BitmapReferenceCounter {
         }
     }
 
-    private final Map<Bitmap, InnerTracker> counter = new HashMap<Bitmap, InnerTracker>();
+    private final Map<Bitmap, InnerTracker> counter = new WeakHashMap<Bitmap, InnerTracker>();
     private final BitmapPool target;
     private final InnerTrackerPool pool = new InnerTrackerPool();
 
","8 import java.util.WeakHashMap;
54     private final Map<Bitmap, InnerTracker> counter = new WeakHashMap<Bitmap, InnerTracker>();
53     private final Map<Bitmap, InnerTracker> counter = new HashMap<Bitmap, InnerTracker>();",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,2cdcb477b627fa4940dc4f05d5a45f88a9e2b0d0,e9bb38b983ede3ce22220af5de3ba803c50248c8,Call ImageLoader exception handler on main thread,"@@ -526,9 +526,14 @@ public class ImageManager {
             }
         }
 
-        private void handleException(Exception e) {
+        private void handleException(final Exception e) {
+            mainHandler.post(new Runnable() {
+                @Override
+                public void run() {
                     cb.onLoadFailed(e);
                 }
+            });
+        }
 
         private Bitmap resizeIfNotFound(InputStream is) throws IOException {
             return resizer.load(is, width, height, downsampler, transformation);
","529         private void handleException(final Exception e) {
530             mainHandler.post(new Runnable() {
531                 @Override
532                 public void run() {
535             });
536         }
529         private void handleException(Exception e) {",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,f6d25a2c66f49cdb1c3fece268729238a4c28bae,2cdcb477b627fa4940dc4f05d5a45f88a9e2b0d0,Don't set a null error drawable,"@@ -441,7 +441,7 @@ public class ImagePresenter<T> {
                 if (exceptionHandler != null) {
                     exceptionHandler.onException(e, model, relevant);
                 }
-                if (relevant && canSetPlaceholder()) {
+                if (relevant && canSetPlaceholder() && errorDrawable != null) {
                     target.setPlaceholder(errorDrawable);
                 }
             }
","444                 if (relevant && canSetPlaceholder() && errorDrawable != null) {
444                 if (relevant && canSetPlaceholder()) {",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,f6418a526d759708d849aea7dcdec5396cad0206,f6d25a2c66f49cdb1c3fece268729238a4c28bae,Move ImageManagerLoader out of its own package,"@@ -25,7 +25,7 @@ import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.Transformation;
-import com.bumptech.glide.resize.loader.ImageManagerLoader;
+import com.bumptech.glide.loader.image.ImageManagerLoader;
 
 import java.io.File;
 import java.net.URL;
","28 import com.bumptech.glide.loader.image.ImageManagerLoader;
28 import com.bumptech.glide.resize.loader.ImageManagerLoader;",No
library\src\com\bumptech\glide\resize\loader\ImageManagerLoader.java,library\src\com\bumptech\glide\loader\image\ImageManagerLoader.java,f6418a526d759708d849aea7dcdec5396cad0206,f6d25a2c66f49cdb1c3fece268729238a4c28bae,Move ImageManagerLoader out of its own package,"@@ -1,14 +1,13 @@
-package com.bumptech.glide.resize.loader;
+package com.bumptech.glide.loader.image;
 
 import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.loader.image.ImageLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.resize.Downsampler;
+import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
-import com.bumptech.glide.resize.Transformation;
 
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
","1 package com.bumptech.glide.loader.image;
8 import com.bumptech.glide.resize.Transformation;
1 package com.bumptech.glide.resize.loader;
6 import com.bumptech.glide.loader.image.ImageLoader;
11 import com.bumptech.glide.resize.Transformation;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,f6418a526d759708d849aea7dcdec5396cad0206,f6d25a2c66f49cdb1c3fece268729238a4c28bae,Move ImageManagerLoader out of its own package,"@@ -16,7 +16,7 @@ import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.Target;
-import com.bumptech.glide.resize.loader.ImageManagerLoader;
+import com.bumptech.glide.loader.image.ImageManagerLoader;
 
 import java.io.File;
 import java.util.ArrayList;
","19 import com.bumptech.glide.loader.image.ImageManagerLoader;
19 import com.bumptech.glide.resize.loader.ImageManagerLoader;",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -9,6 +9,7 @@ import android.widget.ImageView;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.loader.image.ImageLoader;
+import com.bumptech.glide.loader.image.ImageManagerLoader;
 import com.bumptech.glide.loader.model.FileLoader;
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.model.ResourceLoader;
@@ -22,10 +23,9 @@ import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.ImageViewTarget;
 import com.bumptech.glide.presenter.target.Target;
-import com.bumptech.glide.resize.Downsampler;
 import com.bumptech.glide.resize.ImageManager;
-import com.bumptech.glide.resize.Transformation;
-import com.bumptech.glide.loader.image.ImageManagerLoader;
+import com.bumptech.glide.resize.load.Downsampler;
+import com.bumptech.glide.resize.load.Transformation;
 
 import java.io.File;
 import java.net.URL;
","12 import com.bumptech.glide.loader.image.ImageManagerLoader;
27 import com.bumptech.glide.resize.load.Downsampler;
28 import com.bumptech.glide.resize.load.Transformation;
25 import com.bumptech.glide.resize.Downsampler;
27 import com.bumptech.glide.resize.Transformation;
28 import com.bumptech.glide.loader.image.ImageManagerLoader;",No
library\src\com\bumptech\glide\loader\image\ImageLoader.java,library\src\com\bumptech\glide\loader\image\ImageLoader.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -2,7 +2,7 @@ package com.bumptech.glide.loader.image;
 
 import android.graphics.Bitmap;
 import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 
 /**
  * An interface used by {@link com.bumptech.glide.presenter.ImagePresenter} to fetch a bitmap for a given id and
","5 import com.bumptech.glide.resize.load.Transformation;
5 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\loader\image\ImageManagerLoader.java,library\src\com\bumptech\glide\loader\image\ImageManagerLoader.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -4,10 +4,10 @@ import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.loader.stream.StreamLoader;
-import com.bumptech.glide.resize.Downsampler;
-import com.bumptech.glide.resize.Transformation;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.LoadedCallback;
+import com.bumptech.glide.resize.load.Downsampler;
+import com.bumptech.glide.resize.load.Transformation;
 
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
","9 import com.bumptech.glide.resize.load.Downsampler;
10 import com.bumptech.glide.resize.load.Transformation;
7 import com.bumptech.glide.resize.Downsampler;
8 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\loader\transformation\CenterCrop.java,library\src\com\bumptech\glide\loader\transformation\CenterCrop.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,6 +1,6 @@
 package com.bumptech.glide.loader.transformation;
 
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 
 /**
  * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
","3 import com.bumptech.glide.resize.load.Transformation;
3 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\loader\transformation\FitCenter.java,library\src\com\bumptech\glide\loader\transformation\FitCenter.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,6 +1,6 @@
 package com.bumptech.glide.loader.transformation;
 
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 
 /**
  * Load the image so that one dimension of the image exactly matches one of the given dimensions and the other dimension
","3 import com.bumptech.glide.resize.load.Transformation;
3 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\loader\transformation\None.java,library\src\com\bumptech\glide\loader\transformation\None.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,6 +1,6 @@
 package com.bumptech.glide.loader.transformation;
 
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 
 /**
  * A loader that will always return a noop {@link Transformation} that does not change a bitmap.
","3 import com.bumptech.glide.resize.load.Transformation;
3 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\loader\transformation\TransformationLoader.java,library\src\com\bumptech\glide\loader\transformation\TransformationLoader.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,6 +1,6 @@
 package com.bumptech.glide.loader.transformation;
 
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 
 /**
  * A class for loading a {@link Transformation} for a particular model. This allows things like rotating the image based
","3 import com.bumptech.glide.resize.load.Transformation;
3 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\presenter\ImagePresenter.java,library\src\com\bumptech\glide\presenter\ImagePresenter.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -16,7 +16,7 @@ import com.bumptech.glide.loader.transformation.None;
 import com.bumptech.glide.loader.transformation.TransformationLoader;
 import com.bumptech.glide.presenter.target.ImageViewTarget;
 import com.bumptech.glide.presenter.target.Target;
-import com.bumptech.glide.resize.Transformation;
+import com.bumptech.glide.resize.load.Transformation;
 import com.bumptech.glide.util.Log;
 
 /**
","19 import com.bumptech.glide.resize.load.Transformation;
19 import com.bumptech.glide.resize.Transformation;",No
library\src\com\bumptech\glide\resize\ImageManager.java,library\src\com\bumptech\glide\resize\ImageManager.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -26,6 +26,9 @@ import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
 import com.bumptech.glide.resize.cache.LruMemoryCache;
 import com.bumptech.glide.resize.cache.MemoryCache;
 import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
+import com.bumptech.glide.resize.load.Downsampler;
+import com.bumptech.glide.resize.load.ImageResizer;
+import com.bumptech.glide.resize.load.Transformation;
 import com.bumptech.glide.util.Log;
 import com.bumptech.glide.util.Util;
 
","29 import com.bumptech.glide.resize.load.Downsampler;
30 import com.bumptech.glide.resize.load.ImageResizer;
31 import com.bumptech.glide.resize.load.Transformation;",No
library\src\com\bumptech\glide\resize\Downsampler.java,library\src\com\bumptech\glide\resize\load\Downsampler.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,9 +1,10 @@
-package com.bumptech.glide.resize;
+package com.bumptech.glide.resize.load;
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import com.bumptech.glide.resize.RecyclableBufferedInputStream;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 
 import java.io.IOException;
","1 package com.bumptech.glide.resize.load;
7 import com.bumptech.glide.resize.RecyclableBufferedInputStream;
1 package com.bumptech.glide.resize;",No
library\src\com\bumptech\glide\resize\ImageResizer.java,library\src\com\bumptech\glide\resize\load\ImageResizer.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
  */
-package com.bumptech.glide.resize;
+package com.bumptech.glide.resize.load;
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
@@ -11,6 +11,7 @@ import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.media.ExifInterface;
 import android.os.Build;
+import com.bumptech.glide.resize.RecyclableBufferedInputStream;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.util.Log;
","4 package com.bumptech.glide.resize.load;
14 import com.bumptech.glide.resize.RecyclableBufferedInputStream;
4 package com.bumptech.glide.resize;",No
library\src\com\bumptech\glide\resize\Transformation.java,library\src\com\bumptech\glide\resize\load\Transformation.java,98f8035b44e9c120e25d663c9ec21eee0773645e,f6418a526d759708d849aea7dcdec5396cad0206,Move ImageResizer et al to their own package,"@@ -1,4 +1,4 @@
-package com.bumptech.glide.resize;
+package com.bumptech.glide.resize.load;
 
 import android.graphics.Bitmap;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
","1 package com.bumptech.glide.resize.load;
1 package com.bumptech.glide.resize;",No
library\AndroidManifest.xml,library\AndroidManifest.xml,64186e3971a8f9ec14a8da2bec752e8182a2057a,98f8035b44e9c120e25d663c9ec21eee0773645e,Bump targetSdkVersion,"@@ -3,6 +3,6 @@
           package=""com.bumptech.glide""
           android:versionCode=""1""
           android:versionName=""1.0"">
-  <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />
+  <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""18"" />
   <application />
 </manifest>
","6   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""18"" />
6   <uses-sdk android:minSdkVersion=""8"" android:targetSdkVersion=""16"" />",No
library\src\com\bumptech\glide\Glide.java,library\src\com\bumptech\glide\Glide.java,8cfe9c42b3163489b7add832dbacd19f529f5fa2,64186e3971a8f9ec14a8da2bec752e8182a2057a,Javadoc fixes and updates,"@@ -148,7 +148,7 @@ public class Glide {
     }
 
     /**
-     * Set the {@link ModelLoader} for this view.
+     * Set the {@link ModelLoader} and therefore the model type to use for a new load.
      *
      * <p>
      *     Note - You can use this method to set a {@link ModelLoader} for models that don't have a default
@@ -160,7 +160,7 @@ public class Glide {
      *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to
      *     supply a custom {@link ModelLoader} here to do so, even if a default exists. Fetching a smaller image
      *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to
-     *     download an image using the width and the height of the view, consider passing in a subclass of
+     *     download an image using the width and the height of the target, consider passing in a subclass of
      *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}.
      * </p>
      *
@@ -177,7 +177,7 @@ public class Glide {
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
      * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}
-     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
      */
     public static Request<String> load(String string) {
         return new Request<String>(string);
@@ -189,7 +189,7 @@ public class Glide {
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
      * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}
-     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
      */
     public static Request<Uri> load(Uri uri) {
         return new Request<Uri>(uri);
@@ -201,7 +201,7 @@ public class Glide {
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
      * @param url The URL representing the image.
-     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
      */
     public static Request<URL> load(URL url) {
         return new Request<URL>(url);
@@ -213,7 +213,7 @@ public class Glide {
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
      * @param file The File containing the image
-     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
      */
     public static Request<File> load(File file) {
         return new Request<File>(file);
@@ -225,7 +225,7 @@ public class Glide {
      * @see #using(com.bumptech.glide.loader.model.ModelLoader)
      *
      * @param resourceId the id of the resource containing the image
-     * @return A {@link Request} to set options for the load and ultimately the view to load the model into
+     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
      */
     public static Request<Integer> load(Integer resourceId) {
         return new Request<Integer>(resourceId);
@@ -243,7 +243,7 @@ public class Glide {
      * a placeholder or bitmap into the target so it is safe to do so yourself until you start another load.
      *
      * @param target The Target to cancel loads for
-     * @return True iff Glide had ever been asked to load an image for this view
+     * @return True iff Glide had ever been asked to load an image for this target
      */
     public static boolean cancel(Target target) {
         ImagePresenter current = target.getImagePresenter();
@@ -359,9 +359,9 @@ public class Glide {
 
     /**
      * Sets a variety of type independent options including resizing, animations, and placeholders. Responsible
-     * for building or retrieving an ImagePresenter for the given view and passing the ImagePresenter the given model.
+     * for building or retrieving an ImagePresenter for the given target and passing the ImagePresenter the given model.
      *
-     * @param <T> The type of model that will be loaded into the view
+     * @param <T> The type of model that will be loaded into the target
      */
     @SuppressWarnings(""unused"") //public api
     public static class Request<T> {
@@ -489,7 +489,7 @@ public class Glide {
         }
 
         /**
-         * Sets an animation to run on the wrapped view when an image load finishes. Will only be run if the image
+         * Sets an animation to run on the wrapped target when an image load finishes. Will only be run if the image
          * was loaded asynchronously (ie was not in the memory cache)
          *
          * @param animationId The resource id of the animation to run
@@ -557,8 +557,8 @@ public class Glide {
         }
 
         /**
-         * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
-         * the view's tag for the id {@code R.id.image_presenter_id}.
+         * Creates the new {@link ImagePresenter} if one does not currently exist for the current target and sets it as
+         * the target's ImagePresenter via {@link Target#setImagePresenter(com.bumptech.glide.presenter.ImagePresenter)}
          */
         @SuppressWarnings(""unchecked"")
         private ImagePresenter<T> getImagePresenter(Target target) {
","151      * Set the {@link ModelLoader} and therefore the model type to use for a new load.
163      *     download an image using the width and the height of the target, consider passing in a subclass of
180      * @return A {@link Request} to set options for the load and ultimately the target to load the model into
192      * @return A {@link Request} to set options for the load and ultimately the target to load the model into
204      * @return A {@link Request} to set options for the load and ultimately the target to load the model into
216      * @return A {@link Request} to set options for the load and ultimately the target to load the model into
228      * @return A {@link Request} to set options for the load and ultimately the target to load the model into
246      * @return True iff Glide had ever been asked to load an image for this target
362      * for building or retrieving an ImagePresenter for the given target and passing the ImagePresenter the given model.
364      * @param <T> The type of model that will be loaded into the target
492          * Sets an animation to run on the wrapped target when an image load finishes. Will only be run if the image
560          * Creates the new {@link ImagePresenter} if one does not currently exist for the current target and sets it as
561          * the target's ImagePresenter via {@link Target#setImagePresenter(com.bumptech.glide.presenter.ImagePresenter)}
151      * Set the {@link ModelLoader} for this view.
163      *     download an image using the width and the height of the view, consider passing in a subclass of
180      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
192      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
204      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
216      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
228      * @return A {@link Request} to set options for the load and ultimately the view to load the model into
246      * @return True iff Glide had ever been asked to load an image for this view
362      * for building or retrieving an ImagePresenter for the given view and passing the ImagePresenter the given model.
364      * @param <T> The type of model that will be loaded into the view
492          * Sets an animation to run on the wrapped view when an image load finishes. Will only be run if the image
560          * Creates the new {@link ImagePresenter} if one does not currently exist for the current view and sets it as
561          * the view's tag for the id {@code R.id.image_presenter_id}.",No
library\src\com\bumptech\glide\presenter\target\SimpleTarget.java,library\src\com\bumptech\glide\presenter\target\SimpleTarget.java,8cfe9c42b3163489b7add832dbacd19f529f5fa2,64186e3971a8f9ec14a8da2bec752e8182a2057a,Javadoc fixes and updates,"@@ -27,8 +27,8 @@ public abstract class SimpleTarget implements Target {
     }
 
     /**
-     * A default implementation that calls {@link SizeReadyCallback#onSizeReady(int, int)} synchronously with
-     * {@link #getSize(com.bumptech.glide.presenter.target.Target.SizeReadyCallback)}.
+     * A default implementation that calls {@link com.bumptech.glide.presenter.target.Target.SizeReadyCallback}
+     * synchronously with {@link #getSize()}
      *
      * @param cb The callback that must be called when the size of the target has been determined
      */
","30      * A default implementation that calls {@link com.bumptech.glide.presenter.target.Target.SizeReadyCallback}
31      * synchronously with {@link #getSize()}
30      * A default implementation that calls {@link SizeReadyCallback#onSizeReady(int, int)} synchronously with
31      * {@link #getSize(com.bumptech.glide.presenter.target.Target.SizeReadyCallback)}.",No
samples\flickr\AndroidManifest.xml,samples\flickr\AndroidManifest.xml,8735c904abc7184052abcaf057f02290e2fd91db,8cfe9c42b3163489b7add832dbacd19f529f5fa2,Code cleanup in sample project,"@@ -3,6 +3,11 @@
   package=""com.bumptech.flickr""
   android:versionCode=""1""
   android:versionName=""1.0"">
+
+  <uses-permission android:name=""android.permission.INTERNET"" />
+  <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
+  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
+
   <application android:label=""@string/app_name"" android:icon=""@drawable/ic_launcher""
     android:hardwareAccelerated=""true""
     android:theme=""@style/Theme.Sherlock"">
@@ -16,9 +21,7 @@
             <category android:name=""android.intent.category.LAUNCHER"" />
         </intent-filter>
       </activity>
+
   </application>
 
-  <uses-permission android:name=""android.permission.INTERNET"" />
-  <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
-  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
 </manifest>
","6 
7   <uses-permission android:name=""android.permission.INTERNET"" />
8   <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
9   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
10 
24 
21   <uses-permission android:name=""android.permission.INTERNET"" />
22   <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
23   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,8735c904abc7184052abcaf057f02290e2fd91db,8cfe9c42b3163489b7add832dbacd19f529f5fa2,Code cleanup in sample project,"@@ -1,6 +1,6 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <resources>
-    <string name=""app_name"">MyActivity</string>
+    <string name=""app_name"">Glide Demo</string>
     <string name=""search"">Search</string>
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
   <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>
","3     <string name=""app_name"">Glide Demo</string>
3     <string name=""app_name"">MyActivity</string>",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,8735c904abc7184052abcaf057f02290e2fd91db,8cfe9c42b3163489b7add832dbacd19f529f5fa2,Code cleanup in sample project,"@@ -12,13 +12,12 @@ import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
 import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.loader.image.ImageManagerLoader;
 import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.Target;
-import com.bumptech.glide.loader.image.ImageManagerLoader;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -30,18 +29,15 @@ import java.util.List;
  * To change this template use File | Settings | File Templates.
  */
 public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
-    private static final String CACHE_PATH_KEY = ""cache_path"";
     private static final String IMAGE_SIZE_KEY = ""image_size"";
 
     private PhotoAdapter adapter;
     private List<Photo> currentPhotos;
-    private File cacheDir;
     private int photoSize;
 
-    public static FlickrPhotoGrid newInstance(File cacheDir, int size) {
+    public static FlickrPhotoGrid newInstance(int size) {
         FlickrPhotoGrid photoGrid = new FlickrPhotoGrid();
         Bundle args = new Bundle();
-        args.putString(CACHE_PATH_KEY, cacheDir.getAbsolutePath());
         args.putInt(IMAGE_SIZE_KEY, size);
         photoGrid.setArguments(args);
         return photoGrid;
@@ -50,7 +46,6 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         Bundle args = getArguments();
-        cacheDir = new File(args.getString(CACHE_PATH_KEY));
         photoSize = args.getInt(IMAGE_SIZE_KEY);
 
         final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
@@ -111,6 +106,9 @@ public class FlickrPhotoGrid extends SherlockFragment implements PhotoViewer {
                 params.height = photoSize;
 
                 final Context context = getActivity();
+
+                //this is an example of how one might use ImagePresenter directly, there is no particular reason
+                //why ImagePresenter is used here and not in FlickrPhotoList otherwise.
                 final Animation fadeIn = AnimationUtils.loadAnimation(context, R.anim.fade_in);
                 imagePresenter = new ImagePresenter.Builder<Photo>()
                         .setImageView(imageView)
","15 import com.bumptech.glide.loader.image.ImageManagerLoader;
38     public static FlickrPhotoGrid newInstance(int size) {
109 
110                 //this is an example of how one might use ImagePresenter directly, there is no particular reason
111                 //why ImagePresenter is used here and not in FlickrPhotoList otherwise.
19 import com.bumptech.glide.loader.image.ImageManagerLoader;
21 import java.io.File;
33     private static final String CACHE_PATH_KEY = ""cache_path"";
38     private File cacheDir;
41     public static FlickrPhotoGrid newInstance(File cacheDir, int size) {
44         args.putString(CACHE_PATH_KEY, cacheDir.getAbsolutePath());
53         cacheDir = new File(args.getString(CACHE_PATH_KEY));",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,8735c904abc7184052abcaf057f02290e2fd91db,8cfe9c42b3163489b7add832dbacd19f529f5fa2,Code cleanup in sample project,"@@ -33,12 +33,13 @@ import java.util.Map;
 import java.util.Set;
 
 public class FlickrSearchActivity extends SherlockFragmentActivity {
+    private static final String CACHE_NAME = ""flickr_cache"";
+
     private int searchCount = 0;
     private EditText searchText;
     private View searching;
     private TextView searchTerm;
     private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
-    private File cacheDir;
     private List<Photo> currentPhotos = new ArrayList<Photo>();
     private View searchLoading;
 
@@ -62,17 +63,22 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
         } else {
             PhotoViewer photoViewer = (PhotoViewer) fragment;
             photoViewer.onPhotosUpdated(currentPhotos);
+            if (!photoViewers.contains(photoViewer)) {
                 photoViewers.add(photoViewer);
             }
         }
+    }
 
     /** Called when the activity is first created. */
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.flickr_search_activity);
-        String cacheName = ""flickr_cache"";
-        cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
+
+
+        final Glide glide = Glide.get();
+        if (!glide.isImageManagerSet()) {
+            File cacheDir = ImageManager.getPhotoCacheDir(this, CACHE_NAME);
 
             DiskCache diskCache;
             try {
@@ -82,12 +88,9 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
                 diskCache = new DiskCacheAdapter();
             }
 
-        final Glide glide = Glide.get();
-        if (!glide.isImageManagerSet()) {
             glide.setImageManager(new ImageManager.Builder(this)
                     .setBitmapCompressQuality(70)
                     .setDiskCache(diskCache));
-
         }
 
         searching = findViewById(R.id.searching);
@@ -220,11 +223,11 @@ public class FlickrSearchActivity extends SherlockFragmentActivity {
             Page page = Page.values()[position];
             if (page == Page.SMALL) {
                 int pageSize = getPageSize(R.dimen.small_photo_side);
-                return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
+                return FlickrPhotoGrid.newInstance(pageSize);
 
             } else if (page == Page.MEDIUM) {
                 int pageSize = getPageSize(R.dimen.medium_photo_side);
-                return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
+                return FlickrPhotoGrid.newInstance(pageSize);
             } else if (page == Page.LIST) {
                 return FlickrPhotoList.newInstance();
             } else {
","36     private static final String CACHE_NAME = ""flickr_cache"";
37 
66             if (!photoViewers.contains(photoViewer)) {
70     }
77 
78 
79         final Glide glide = Glide.get();
80         if (!glide.isImageManagerSet()) {
81             File cacheDir = ImageManager.getPhotoCacheDir(this, CACHE_NAME);
226                 return FlickrPhotoGrid.newInstance(pageSize);
230                 return FlickrPhotoGrid.newInstance(pageSize);
41     private File cacheDir;
74         String cacheName = ""flickr_cache"";
75         cacheDir = ImageManager.getPhotoCacheDir(this, cacheName);
85         final Glide glide = Glide.get();
86         if (!glide.isImageManagerSet()) {
90 
223                 return FlickrPhotoGrid.newInstance(cacheDir, pageSize);
227                 return FlickrPhotoGrid.newInstance(cacheDir, pageSize);",No
.gitignore,.gitignore,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -8,7 +8,10 @@ library/local.properties
 *.swp
 proguard-project.txt
 samples/flickr/.idea/*
-samples/flickr/gen/**/*
-samples/flickr/out/**/*
+samples/flickr/gen
+samples/flickr/out
+samples/flickr/bin
 samples/flickr/local.properties
+*.keystore
 **/.idea/*
+
","11 samples/flickr/gen
12 samples/flickr/out
13 samples/flickr/bin
15 *.keystore
17 
11 samples/flickr/gen/**/*
12 samples/flickr/out/**/*",No
samples\flickr\AndroidManifest.xml,samples\flickr\AndroidManifest.xml,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,12 +1,12 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <manifest xmlns:android=""http://schemas.android.com/apk/res/android""
-  package=""com.bumptech.flickr""
+  package=""com.bumptech.glide.samples.flickr""
   android:versionCode=""1""
   android:versionName=""1.0"">
 
   <uses-permission android:name=""android.permission.INTERNET"" />
   <uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" />
-  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />
+  <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""18"" />
 
   <application android:label=""@string/app_name"" android:icon=""@drawable/ic_launcher""
     android:hardwareAccelerated=""true""
","3   package=""com.bumptech.glide.samples.flickr""
9   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""18"" />
3   package=""com.bumptech.flickr""
9   <uses-sdk android:minSdkVersion=""9"" android:targetSdkVersion=""16"" />",No
samples\flickr\ant.properties,samples\flickr\ant.properties,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -14,4 +14,6 @@
 #  'key.store' for the location of your keystore and
 #  'key.alias' for the name of the key to use.
 # The password will be asked during the build when you use the 'release' target.
+key.store=glide-release-key.keystore
+key.alias=flickr
 
","17 key.store=glide-release-key.keystore
18 key.alias=flickr",No
samples\flickr\build.xml,samples\flickr\build.xml,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,5 +1,5 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
-<project name=""flickr"" default=""help"">
+<project name=""glide-flickr-demo"" default=""help"">
 
     <!-- The local.properties file is created and updated by the 'android' tool.
          It contains the path to the SDK. It should *NOT* be checked into
","2 <project name=""glide-flickr-demo"" default=""help"">
2 <project name=""flickr"" default=""help"">",No
samples\flickr\libs\android-support-v4.jar,samples\flickr\libs\android-support-v4.jar,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","Binary files a/samples/flickr/libs/android-support-v4.jar and /dev/null differ
",,No
samples\flickr\project.properties,samples\flickr\project.properties,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -11,7 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
-android.library.reference.1=../../library
-android.library.reference.2=ActionBarSherlock/library
-android.library.reference.3=volley/
+target=android-18
+android.library.reference.1=ActionBarSherlock/library
","14 target=android-18
15 android.library.reference.1=ActionBarSherlock/library
14 target=android-16
15 android.library.reference.1=../../library
16 android.library.reference.2=ActionBarSherlock/library
17 android.library.reference.3=volley/",No
samples\flickr\res\values\strings.xml,samples\flickr\res\values\strings.xml,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,6 +1,6 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <resources>
-    <string name=""app_name"">Glide Demo</string>
+    <string name=""app_name"">Glide Flickr Demo</string>
     <string name=""search"">Search</string>
     <string name=""searching_for"">Searching for \""%s\"" on Flickr</string>
   <string name=""search_failed"">Search for \""%s\"" failed, check your network connection and try again</string>
","3     <string name=""app_name"">Glide Flickr Demo</string>
3     <string name=""app_name"">Glide Demo</string>",No
samples\flickr\src\com\bumptech\flickr\FlickrModelLoader.java,samples\flickr\src\com\bumptech\glide\samples\flickr\FlickrModelLoader.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,8 +1,8 @@
-package com.bumptech.flickr;
+package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-import com.bumptech.flickr.api.Api;
-import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.samples.flickr.api.Api;
+import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.loader.model.VolleyModelLoader;
 
 /**
","1 package com.bumptech.glide.samples.flickr;
4 import com.bumptech.glide.samples.flickr.api.Api;
5 import com.bumptech.glide.samples.flickr.api.Photo;
1 package com.bumptech.flickr;
4 import com.bumptech.flickr.api.Api;
5 import com.bumptech.flickr.api.Photo;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoGrid.java,samples\flickr\src\com\bumptech\glide\samples\flickr\FlickrPhotoGrid.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,4 +1,4 @@
-package com.bumptech.flickr;
+package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
 import android.os.Bundle;
@@ -11,7 +11,7 @@ import android.widget.BaseAdapter;
 import android.widget.GridView;
 import android.widget.ImageView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.loader.image.ImageManagerLoader;
 import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
","1 package com.bumptech.glide.samples.flickr;
14 import com.bumptech.glide.samples.flickr.api.Photo;
1 package com.bumptech.flickr;
14 import com.bumptech.flickr.api.Photo;",No
samples\flickr\src\com\bumptech\flickr\FlickrPhotoList.java,samples\flickr\src\com\bumptech\glide\samples\flickr\FlickrPhotoList.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,4 +1,4 @@
-package com.bumptech.flickr;
+package com.bumptech.glide.samples.flickr;
 
 import android.os.Bundle;
 import android.view.LayoutInflater;
@@ -9,8 +9,8 @@ import android.widget.ImageView;
 import android.widget.ListView;
 import android.widget.TextView;
 import com.actionbarsherlock.app.SherlockFragment;
-import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.samples.flickr.api.Photo;
 
 import java.util.ArrayList;
 import java.util.List;
","1 package com.bumptech.glide.samples.flickr;
13 import com.bumptech.glide.samples.flickr.api.Photo;
1 package com.bumptech.flickr;
12 import com.bumptech.flickr.api.Photo;",No
samples\flickr\src\com\bumptech\flickr\FlickrSearchActivity.java,samples\flickr\src\com\bumptech\glide\samples\flickr\FlickrSearchActivity.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,4 +1,4 @@
-package com.bumptech.flickr;
+package com.bumptech.glide.samples.flickr;
 
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
@@ -14,13 +14,13 @@ import android.widget.EditText;
 import android.widget.TextView;
 import com.actionbarsherlock.app.ActionBar;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
-import com.bumptech.flickr.api.Api;
-import com.bumptech.flickr.api.Photo;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.cache.DiskCache;
 import com.bumptech.glide.resize.cache.DiskCacheAdapter;
 import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.samples.flickr.api.Api;
+import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.Log;
 
 import java.io.File;
","1 package com.bumptech.glide.samples.flickr;
22 import com.bumptech.glide.samples.flickr.api.Api;
23 import com.bumptech.glide.samples.flickr.api.Photo;
1 package com.bumptech.flickr;
17 import com.bumptech.flickr.api.Api;
18 import com.bumptech.flickr.api.Photo;",No
samples\flickr\src\com\bumptech\flickr\PhotoViewer.java,samples\flickr\src\com\bumptech\glide\samples\flickr\PhotoViewer.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,6 +1,6 @@
-package com.bumptech.flickr;
+package com.bumptech.glide.samples.flickr;
 
-import com.bumptech.flickr.api.Photo;
+import com.bumptech.glide.samples.flickr.api.Photo;
 
 import java.util.List;
 
","1 package com.bumptech.glide.samples.flickr;
3 import com.bumptech.glide.samples.flickr.api.Photo;
1 package com.bumptech.flickr;
3 import com.bumptech.flickr.api.Photo;",No
samples\flickr\src\com\bumptech\flickr\api\Api.java,samples\flickr\src\com\bumptech\glide\samples\flickr\api\Api.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,4 +1,4 @@
-package com.bumptech.flickr.api;
+package com.bumptech.glide.samples.flickr.api;
 
 import android.content.Context;
 import com.android.volley.DefaultRetryPolicy;
","1 package com.bumptech.glide.samples.flickr.api;
1 package com.bumptech.flickr.api;",No
samples\flickr\src\com\bumptech\flickr\api\Photo.java,samples\flickr\src\com\bumptech\glide\samples\flickr\api\Photo.java,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,8735c904abc7184052abcaf057f02290e2fd91db,"Prepare sample project for release

Mostly updating package from com.bumptech.flickr
to com.bumptech.glide.samples.flickr. Also
removes support jar in favor of one included with
ActionBarSherlock to avoid a dependency issue.","@@ -1,4 +1,4 @@
-package com.bumptech.flickr.api;
+package com.bumptech.glide.samples.flickr.api;
 
 import org.json.JSONException;
 import org.json.JSONObject;
","1 package com.bumptech.glide.samples.flickr.api;
1 package com.bumptech.flickr.api;",No
README.md,README.md,acf9eccb5d393700e1171f8ce4024ba1f9fd48b5,8a6ea1bf4139db19d1a7e99b39ff0cfea2d83b48,Readme updates for recent changes and +author,"@@ -1,12 +1,12 @@
 Glide
 =====
-Glide is a view centric image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap reuse into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
+Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. By default, Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
 
-Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image in a view.
+Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image.
 
 How do I use Glide?
 -------------------
-The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 2.0+ will also be available via a link on the wiki.
+You can download a .jar from GitHub's release page for the Glide project. The wiki also has tutorials on a variety of topics and the javadocs for version 2.0+ will also be available via a link there as well.
 
 Simple use cases will look something like this:
 
@@ -46,9 +46,13 @@ public View getView(int position, View recycled, ViewGroup container) {
 
 Status
 ------
-Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is in progress and will include a more general and easier to use interface. After version 2.0 the api will be stable and any outdated apis will first be deprecated before being removed. That being said, the 2.0+ api is definitely a work in progress and new functionality will probably be added in intermediate versions. Comments/bugs/questions/pull requests welcome!
+Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is the first public release with a stable api. Comments/bugs/questions/pull requests welcome!
 
 Thanks
 ------
-Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide.
-Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)
+Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide, and also to Square and [Picasso](https://github.com/square/picasso) for Glide's high level api.
+Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/).
+
+Author
+------
+Sam Judd - <sam.a.judd@gmail.com> @samajudd
","3 Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. By default, Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
5 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image.
9 You can download a .jar from GitHub's release page for the Glide project. The wiki also has tutorials on a variety of topics and the javadocs for version 2.0+ will also be available via a link there as well.
49 Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is the first public release with a stable api. Comments/bugs/questions/pull requests welcome!
53 Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide, and also to Square and [Picasso](https://github.com/square/picasso) for Glide's high level api.
54 Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/).
55 
56 Author
57 ------
58 Sam Judd - <sam.a.judd@gmail.com> @samajudd
3 Glide is a view centric image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap reuse into one simple and easy to use interface. Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android.
5 Glide works best for long lists or grids where every item contains an image or images, but it's also effective for almost any case where you need to fetch, resize, and display a remote image in a view.
9 The GitHub project wiki has tutorials on a variety of topics, including basic usage and adding Glide to a project. The javadocs for version 2.0+ will also be available via a link on the wiki.
49 Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is in progress and will include a more general and easier to use interface. After version 2.0 the api will be stable and any outdated apis will first be deprecated before being removed. That being said, the 2.0+ api is definitely a work in progress and new functionality will probably be added in intermediate versions. Comments/bugs/questions/pull requests welcome!
53 Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide.
54 Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)",No
